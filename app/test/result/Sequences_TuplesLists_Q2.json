{"result": [{"answers": [{"content": "Update: For Python 3, check Ben's answer Update 2023: I wrote this answer more than ten years ago and there are better answers now. You should be using python 3 and the answer above. Original answer: To attach a message to the current exception and re-raise it:\n(the outer try/except is just to show the effect) For python 2.x where x>=6: This will also do the right thing if err is derived from ValueError. For example UnicodeDecodeError. Note that you can add whatever you like to err. For example err.problematic_array=[1,2,3]. Edit: @Ducan points in a comment the above does not work with python 3 since .message is not a member of ValueError. Instead you could use this (valid python 2.6 or later or 3.x): Edit2: Depending on what the purpose is, you can also opt for adding the extra information under your own variable name. For both python2 and python3:", "id": 9157277, "owner_tier": 0.9, "score": 0.3658536585094851}, {"content": "I tried this compact version of @RobinL, and worked as well:", "id": 70380633, "owner_tier": 0.3, "score": 0.016260162574525745}, {"content": "PEP 678 \u2013 Enriching Exceptions with Notes was accepted and landed in Python 3.11. New APIs allow users to attach custom message(s) to existing errors. This is useful for adding additional context when an error is encountered. Using the add_note method is suitable for answering the original question: It would render like this: Modifying the args attribute, which is used by BaseException.__str__ to render an exception, is the only way. You could either extend the args: Which will render as: Or you could replace the args[0], which is a little more complicated but produces a cleaner result. This will render the same way as the Python 3.11+ exception __notes__ do:", "id": 75549200, "owner_tier": 0.9, "score": 0.0704607045799458}, {"content": "Raising same error, with prepending custom text message in front.\n(edit -  sorry, actually same as https://stackoverflow.com/a/65494175/15229310 , why there is like 10 (upvoted) 'solutions' that simply don't answer question as posted?)", "id": 75146373, "owner_tier": 0.3, "score": 0.013550135474254743}, {"content": "This only works with Python 3.  You can modify the exception's original arguments and add your own arguments. An exception remembers the args it was created with.  I presume this is so that you can modify the exception. In the function reraise we prepend the exception's original arguments with any new arguments that we want (like a message).  Finally we re-raise the exception while preserving the trace-back history.", "id": 62662138, "owner_tier": 0.5, "score": 0.06504065037940379}, {"content": "Try below: Output:", "id": 65494175, "owner_tier": 0.1, "score": 0.027100270975609755}, {"content": "If you're lucky enough to only support python 3.x, this really becomes a thing of beauty :) We can chain the exceptions using raise from. In this case, the exception your caller would catch has the line number of the place where we raise our exception. Notice the bottom exception only has the stacktrace from where we raised our exception. Your caller could still get the original exception by accessing the __cause__ attribute of the exception they catch. Or you can use with_traceback. Using this form, the exception your caller would catch has the traceback from where the original error occurred. Notice the bottom exception has the line where we performed the invalid division as well as the line where we reraise the exception.", "id": 29442282, "owner_tier": 0.5, "score": 0.9999999999728997}, {"content": "None of the above solutions did exactly what I wanted, which was to add some information to the first part of the error message i.e. I wanted my users to see my custom message first. This worked for me:", "id": 60185186, "owner_tier": 0.5, "score": 0.02168021677506775}, {"content": "Either raise the new exception with your error message using or within the place where you want to raise it OR attach (replace) error message into current exception using 'from' (Python 3.x supported only):", "id": 49380379, "owner_tier": 0.5, "score": 0.027100270975609755}, {"content": "It seems all the answers are adding info to e.args[0], thereby altering the existing error message.  Is there a downside to extending the args tuple instead?  I think the possible upside is, you can leave the original error message alone for cases where parsing that string is needed; and you could add multiple elements to the tuple if your custom error handling produced several messages or error codes, for cases where the traceback would be parsed programmatically (like via a system monitoring tool). or Can you see a downside to this approach?", "id": 17030625, "owner_tier": 0.7, "score": 0.054200541978319784}, {"content": "Python 3 built-in exceptions have the strerror field:", "id": 45960221, "owner_tier": 0.3, "score": 0.02168021677506775}, {"content": "This is the function I use to modify the exception message in Python 2.7 and 3.x while preserving the original traceback. It requires six", "id": 38772267, "owner_tier": 0.5, "score": 0.029810298075880756}, {"content": "prints:", "id": 9157254, "owner_tier": 0.9, "score": 0.03794037937669376}, {"content": "The current answer did not work good for me, if the exception is not re-caught the appended message is not shown. But doing like below both keeps the trace and shows the appended message regardless if the exception is re-caught or not. ( I used Python 2.7, have not tried it in Python 3 )", "id": 31155263, "owner_tier": 0.5, "score": 0.02168021677506775}, {"content": "This code template should allow you to raise an exception with a custom message.", "id": 10997792, "owner_tier": 0.5, "score": 0.040650406476964766}, {"content": "if you want to custom the error type, a simple thing you can do is to define an error class based on ValueError.", "id": 9157273, "owner_tier": 0.1, "score": -2.7100270838008917e-11}], "link": "https://stackoverflow.com/questions/9157210/how-do-i-raise-the-same-exception-with-a-custom-message-in-python", "question": {"content": "I have this try block in my code: Strictly speaking, I am actually raising another ValueError, not the ValueError thrown by do_something...(), which is referred to as err in this case. How do I attach a custom message to err? I try the following code but fails due to err, a ValueError instance, not being callable:", "id": 9157210, "title": "How do I raise the same Exception with a custom message in Python?", "traffic_rate": 52}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "exception", "message"]}, {"answers": [{"content": "With PEP 678 (Python 3.11) adding notes to exceptions is natively supported: Rendered as: I was hopping it could replace Steve Howard solution, Unfortunately, it does not give user any control on how to format the final exception (e.g. can't add a note before the exception like: 'Error in fn: {original_exc}') If you want more control on the traceback, you can use https://github.com/google/etils: Or:", "id": 71605371, "owner_tier": 0.5, "score": 0.14963503645985402}, {"content": "I use in my codes: output:", "id": 73295409, "owner_tier": 0.1, "score": 0.018248175145985403}, {"content": "Here's what I use for personal projects (I'm sure there's ample reason not to do this in production code): The code (1) intercepts the error; (2) creates a copy of the error's .args property, which is a tuple that is assumed to include an error message at index 0, achieved using a list comprehension; (3) appends a line break and a custom message to the error message; (4) appends any additional items of .args to the copy using\nunpacking; (5) converts the copy to a tuple; and finally (6) replaces .args with the amended copy. Most of these operations are to circumvent the immutability of the .args tuple.", "id": 71818728, "owner_tier": 0.1, "score": 0.029197080255474454}, {"content": "This is my implementation, to use it as a context manager and optionally add extra message to exception: Usage: This would resolve in such traceback:", "id": 68848804, "owner_tier": 0.1, "score": 0.0255474452189781}, {"content": "In case you came here searching for a solution for Python 3 the manual  says: When raising a new exception (rather than using a bare raise to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using from with raise: Example: Which looks like this in the end: Turning a totally nondescript TypeError into a nice message with hints towards a solution without messing up the original Exception.", "id": 46091127, "owner_tier": 0.5, "score": 0.9999999999635036}, {"content": "One handy approach that I used is to use class attribute as storage for details, as class attribute is accessible both from class object and class instance:  Then in your code: And when catching an error:", "id": 12370499, "owner_tier": 0.5, "score": 0.0547445255109489}, {"content": "I'd do it like this so changing its type in foo() won't require also changing it in bar(). Update 1 Here's a slight modification that preserves the original traceback: Update 2 For Python 3.x, the code in my first update is syntactically incorrect plus the idea of having a message attribute on BaseException was retracted in a change to PEP 352 on 2012-05-16 (my first update was posted on 2012-03-12). So currently, in Python 3.5.2 anyway, you'd need to do something along these lines to preserve the traceback and not hardcode the type of exception in function bar(). Also note that there will be the line: in the traceback messages displayed. Update 3 A commenter asked if there was a way that would work in both Python 2 and 3. Although the answer might seem to be \"No\" due to the syntax differences, there is a way around that by using a helper function like reraise() in the six add-on module. So, if you'd rather not use the library for some reason, below is a simplified standalone version. Note too, that since the exception is reraised within the reraise() function, that will appear in whatever traceback is raised, but the final result is what you want.", "id": 6062799, "owner_tier": 0.9, "score": 0.6021897809854014}, {"content": "I don't like all the given answers so far. They are still too verbose imho. In either code and message output. All i want to have is the stacktrace pointing to the source exception, no exception stuff in between, so no creation of new exceptions, just re-raising the original with all the relevant stack frame states in it, that led there. Steve Howard gave a nice answer which i want to extend, no, reduce ... to python 3 only. The only new thing is the parameter expansion/unpacking which makes it small and easy enough for me to use.  Try it: This will give you: A simple pretty-print could be something like", "id": 58270258, "owner_tier": 0.1, "score": 0.08759124083941605}, {"content": "Assuming you don't want to or can't modify foo(), you can do this:  This is indeed the only solution here that solves the problem in Python 3 without an ugly and confusing \"During handling of the above exception, another exception occurred\" message. In case the re-raising line should be added to the stack trace, writing raise e instead of raise will do the trick.", "id": 6062677, "owner_tier": 0.5, "score": 0.17518248171532846}, {"content": "I will provide a snippet of code that I use often whenever I want to add extra info to an exception.  I works both in Python 2.7 and 3.6.   The code above results in the following output:    I know this deviates a little from the example provided in the question, but nevertheless I hope someone finds it useful. ", "id": 42359068, "owner_tier": 0.9, "score": 0.0401459853649635}, {"content": "Unlike previous answers, this works in the face of exceptions with really bad __str__.\nIt does modify the type however, in order to factor out unhelpful __str__ implementations. I'd still like to find an additional improvement that doesn't modify the type. The original traceback and type (name) are preserved.", "id": 20532167, "owner_tier": 0.9, "score": 0.0328467152919708}, {"content": "You can define your own exception that inherits from another and create it's own constructor to set value. For example:", "id": 6062657, "owner_tier": 0.3, "score": 0.0328467152919708}, {"content": "Maybe", "id": 6062653, "owner_tier": 0.9, "score": -3.649635014315799e-11}], "link": "https://stackoverflow.com/questions/6062576/adding-information-to-an-exception", "question": {"content": "I want to achieve something like this: But what I get is: Any clues as to how to achieve this? How to do it both in Python 2 and 3?", "id": 6062576, "title": "Adding information to an exception?", "traffic_rate": 32}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "exception"]}, {"answers": [{"content": "The error handling, written in C, uses type checking for the special case of a tuple, before other type-checking and exception handling, so that multiple types of exceptions may be caught.  At least one Python core developer advocates using exception handling for control flow. Adding lists as an additional type to check would work against this strategy. It appears that expanding this to allow for sets or lists has not been specifically addressed by the core development team, though I will gladly reference it if it can be found. There has been a discussion on the Python mailing list that speculates quite a lot (another answer here quotes one response at length).  After performing the below analysis, and in the context of the mailing list discussion, I think the reasoning is obvious. I do not suggest proposing to add other containers. Catching the tuple of exceptions does work: outputs: But catching the list of exceptions does not work: prints: This demonstrates that we are doing type checking for the special case of a tuple. It would certainly make the code slower to add another type to check for, and the core developers have been saying that it's a good thing to use exception handling for control flow in Python for a while now.  An analysis of the source agrees with this above conclusion. This is not an issue for Python's grammar or parsing. It will accept any expression. Thus any expression that results in an Exception or tuple of Exceptions should be legal. If we disassemble a function that does this in Python 3, we see that it looks to match an exception with a comparison operation.  Which outputs: This leads us inside the Python interpreter. The CPython control flow first checks for if the value is a tuple. If so, \nit iterates through the tuple using tuple specific code - looking for the value to be a Exception: Adding another type would require more internal control flow, slowing down control flow inside of the Python interpreter. Tuples are lightweight arrays of pointers. So are lists, but they may be allocated extra space so that you may quickly add to them (up to the point they need to get larger). In Python 3.7.3 on Linux: Sets take up even more space because they are hash tables. They have both a hash of the object they contain as well as a pointer to that which they point to. This is for the CPython core development team to debate and decide.  But my conclusion is that slowing down control flow in Python by checking for other types even at the C level would work against the strategy of using exception handling for control flow in Python modules.  After reasoning through the above, I would not propose that they add this.", "id": 35852234, "owner_tier": 0.9, "score": 0.99999999875}, {"content": "@BrenBarn Thanks for your link to the discussion at https://mail.python.org/pipermail/python-list/2012-January/619107.html I think the best and clearest response comes from Steven D'Aprano's reply at https://mail.python.org/pipermail/python-list/2012-January/619120.html I copied the content below for easy read. Steven's reply: Simplicity. If you also allow lists, then why not allow arbitrary sequences? What \nabout iterators, do you allow them? That could be awkward, because \niterators can only be run through once. Dictionaries are also iterable, \nso once you allow arbitrary iterables, you get dicts. The whole thing \nbecomes a mess. Better to keep it simple and only allow a single \ncanonical collection type, and in Python, that type is tuple, not list. Tuples are that canonical collection type because they have a number of \ndesirable properties: Tuples are small and memory efficient, using the smallest amount of\nmemory needed to hold their items. Lists typically carry a block of\nspare memory, to make insertions fast. Consequently the Python virtual machine can create them rapidly and\nefficiently. Tuples are immutable, so you don't have to worry about passing one to a\nfunction and having the function modify it behind your back. Tuples are ordered, for the times where that matters. Since the typical use-case is to iterate over the items in fixed order,\nthere's no need to pay the extra expense for a dict or set. Tuples are simple to write: in general you only need commas between\nitems. Sometimes, to avoid ambiguity or change the precedence of\ncalculation, you also need round brackets (parentheses for Americans).\nExcept clauses are one of those times. Frozensets and sets are ruled out for historical reasons: they didn't\nexist until Python 2.3. Besides, which would you rather write? (\"abc\", \"def\")\n  frozenset([abc\", \"def\"]) Sets and lists are ruled out because they are mutable, both require\nmuch more memory, and sets have a heavier computational burden. The latter makes more sense semantically to me -- \"catch all exception\n  types in a list\" as opposed to \"catch this single thing composed of\n  three exception types\". Then you are labouring under a misunderstanding. You're not catching a \ntuple, because tuples are never thrown. You're catching any of the \nexceptions that are contained in that tuple. Both lists and tuples are single things in themselves. Both lists and \ntuples are containers: A list is a single thing that contains other things.  A tuple is a single thing that contains other things.", "id": 36236179, "owner_tier": 0.5, "score": -1.2499999924031613e-09}], "link": "https://stackoverflow.com/questions/35851782/why-does-handling-multiple-exceptions-require-a-tuple-but-not-a-list", "question": {"content": "Consider the following example: The tuple is the correct way to handle multiple exception types. Using a list for the multiple exception types causes neither to be handled. I am wondering why Python syntax requires a tuple for multiple exception types.  The docs say that it uses a tuple, so perhaps it is just \"never was implemented using a list instead of a tuple.\" It seems reasonable to me that a list could also be used in this situation, conceptually at least. Is there any reason why Python uses a tuple instead of a list for this situation?", "id": 35851782, "title": "Why does handling multiple exceptions require a tuple, but not a list?", "traffic_rate": 5}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "python-2.7", "exception", "error-handling"]}, {"answers": [{"content": "The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works The short version is that += actually does two things, one right after the other: In this case, step 1 works because you\u2019re allowed to add stuff to lists (they\u2019re mutable), but step 2 fails because you can\u2019t put stuff into tuples after creating them (tuples are immutable).  In a real program, I would suggest you don't do a try-except clause, because tup[0].extend([4,5,6]) does the exact same thing.", "id": 39872951, "owner_tier": 0.3, "score": -2.8571428397786543e-10}, {"content": "Yes it's expected.  A tuple cannot be changed. A tuple, like a list, is a structure that points to other objects. It doesn't care about what those objects are. They could be strings, numbers, tuples, lists, or other objects. So doing anything to one of the objects contained in the tuple, including appending to that object if it's a list, isn't relevant to the semantics of the tuple. (Imagine if you wrote a class that had methods on it that cause its internal state to change. You wouldn't expect it to be impossible to call those methods on an object based on where it's stored). Or another example: Two mutable lists referenced by a list and by a tuple. Should I be able to do the last line (answer: yes). If you think the answer's no, why not? Should t change the semantics of l3 (answer: no). If you want an immutable object of sequential structures, it should be tuples all the way down. This example uses the infix operator: Many operations have an \u201cin-place\u201d version. The following functions\n  provide a more primitive access to in-place operators than the usual\n  syntax does; for example, the statement x += y is equivalent to x =\n  operator.iadd(x, y). Another way to put it is to say that z =\n  operator.iadd(x, y) is equivalent to the compound statement z = x; z\n  += y. https://docs.python.org/2/library/operator.html So this: is equivalent to this: The __iadd__ line succeeds, and modifies the first list. So the list has been changed. The __iadd__ call returns the mutated list.  The second line tries to assign the list back to the tuple, and this fails. So, at the end of the program, the list has been extended but the second part of the += operation failed. For the specifics, see this question.", "id": 29747287, "owner_tier": 0.9, "score": 0.9999999997142857}, {"content": "Tuples cannot be changed directly, correct. Yet, you may change a tuple's element by reference. Like:", "id": 29747543, "owner_tier": 0.5, "score": 0.114285714}, {"content": "Well I guess tup[0] += (4, 5, 6) is translated to: tup[0].__iadd__((4,5,6)) is executed normally changing the list in the first element. But the assignment fails since tuples are immutables.", "id": 29747466, "owner_tier": 0.5, "score": 0.2857142854285714}], "link": "https://stackoverflow.com/questions/29747224/append-to-a-list-defined-in-a-tuple-is-it-a-bug", "question": {"content": "So I have this code: which generates this error: While this code: prints this: Is this behavior expected? I realize this is not a very common use case. However, while the error is expected, I did not expect the list change. ", "id": 29747224, "title": "Append to a list defined in a tuple - is it a bug?", "traffic_rate": 6}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "list", "tuples"]}, {"answers": [{"content": "If tuples are immutable, why is it possible to change a list within a tuple? Because \"tuples are immutable\" only means you cannot modify the tuple. The list that's referred to from the tuple is not part of the tuple, it doesn't \"know\" that it is in a tuple, and it has no means to resist being modified. Why does the first example raise an error and the other two not? Because of how += works. It calls __iadd__ on the list and then (because __iadd__ is not required to return the original object) attempts to assign the resulting modified object back to the tuple. The first thing succeeds, the second thing fails. That is, for this case where t[2] has an __iadd__ function, t[2] += [5,6] is equivalent to: t[2] = t[2].__iadd__([5,6]) In the first example, why is the list inside the tuple changed even though an error is raised? Because this Python operation doesn't offer what in C++ we'd call a \"strong exception guarantee\". The first part of the operation has already been performed, and cannot be (or at any rate is not) reversed when the second part fails. For the official version see Why does a_tuple[i] += [\u2018item\u2019] raise an exception when the addition works?", "id": 39658654, "owner_tier": 0.9, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/39658446/why-can-you-extend-append-to-a-list-in-a-tuple-but-not-assign-to-it", "question": {"content": "Inspired by reading footnote 4 of this article. Consider the following scenario: Tuples are immutable. So, as expected, trying to add to the list inside the tuple raises an error. However if we inspect our tuple, the list has been added to!! (I can imagine this leading to very hard to track down bugs) Also, both extending and appending work without raising an error. So, my questions are:", "id": 39658446, "title": "Why can you extend/append to a list in a tuple, but not assign to it?", "traffic_rate": 1192}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "tuples"]}, {"answers": [{"content": "The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works The short version is that += actually does two things, one right after the other: In this case, step 1 works because you\u2019re allowed to add stuff to lists (they\u2019re mutable), but step 2 fails because you can\u2019t put stuff into tuples after creating them (tuples are immutable).  In a real program, I would suggest you don't do this because t[0].extend(['c']) does the exact same thing.", "id": 38345741, "owner_tier": 0.3, "score": -7.142857099446636e-10}, {"content": "It can also help to understand this behavior by taking a look at the bytecode with dis.dis.  ", "id": 38344424, "owner_tier": 0.9, "score": 0.285714285}, {"content": "Found the answer on IRC. t[0] += [1] is several discrete actions: It seems that x += y is basically x = x + y (but, is it?) The tricky bit is that += implies assignment to both the tuple t and to the list t[0] t[0] += [1] is not literally t[0] = t[0] + [1], it is: t[0] = t[0].__iadd__([1]) What really happens is: Why is this not visible in plain sight? Because a n00b like me would expect t[0] += [1] to either succeed all together or fail, because it's one short line of python. But that's not always the case.", "id": 38344245, "owner_tier": 0.5, "score": 0.9999999992857143}], "link": "https://stackoverflow.com/questions/38344244/tuples-operator-throws-exception-but-succeeds", "question": {"content": "Why does the following throw an exception, although it succeeds?", "id": 38344244, "title": "Tuples: += operator throws exception, but succeeds?", "traffic_rate": 32}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "tuples"]}, {"answers": [{"content": "Um, am I missing something or are you comparing the output of with ??? The second uses \"+\", but the first uses \",\", which does and should give the output you show! (nb. the question was edited from a version with \"+\" in both cases. Perhaps this question should be deleted???)", "id": 530475, "owner_tier": 0.9, "score": 0.99999999875}, {"content": "This instantiates the ValueError exception with a single argument, your concated (or added) string: This instantiates the ValueError exception with 2 arguments, whatever card is and a string:", "id": 530477, "owner_tier": 0.5, "score": 0.49999999875}, {"content": "In the second case card is not a string for sure. If it was a string then len('2') would be equal to 2 and the exception wouldn't be raised, so check first what are you trying to concatenate, it seems something that added to a string returns something represented as a tuple. I recommend you to use string formatting instead of string concatenation to create the error message. It will use the string representation (__repr__) of the object. With string formatting: With string concatenation: And other question... what python version/implementation are you using? My cpython interpreter on Linux reports ValueErrors as ValueError, not ERROR...", "id": 530436, "owner_tier": 0.5, "score": 0.12499999875}, {"content": "Have you overloaded the __add__() somewhere in the code, that could be causing it to return a tuple or something?", "id": 530401, "owner_tier": 0.9, "score": -1.25e-09}, {"content": "\"card\" probably represents a tuple containing the string \"Kr.\"  When you use the + operator on a tuple, you create a new tuple with the extra item added. edit: nope, I'm wrong.  Adding a string to a tuple: generates an error: It would probably be helpful to determine the type of \"card.\" Do you know what type it is?  If not, try putting in a print statement like:", "id": 530358, "owner_tier": 0.5, "score": 0.74999999875}], "link": "https://stackoverflow.com/questions/530329/why-does-concatenation-work-differently-in-these-two-samples", "question": {"content": "I am raising exceptions in two different places in my Python code: AND (edited to correct raising code) For some reason, the first outputs a concatenated string like I expected: But, the second outputs some weird hybrid of set and string: Why is the \"+\" operator behaving differently in these two cases? Edit: The call to init looks like this:", "id": 530329, "title": "Why does concatenation work differently in these two samples?", "traffic_rate": 3200}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "concatenation"]}, {"answers": [{"content": "The tuple and list functions take a single (optional) iterable argument, not multiple arguments.  You can therefore do any of the following: but you can't pass tuple itself multiple comma-separated args: Passing a single non-iterable arg with a trailing comma (the way you might construct a tuple literal) will similarly give you an error, because the tuple() function doesn't work the same way as a tuple literal expression: and passing a single empty iterable arg will always get you an empty tuple: Note that it is possible to re-assign the builtin names tuple and list, which will make using the actual functions difficult: To fix this, del the locally assigned name and the built-in one will work again:", "id": 75514001, "owner_tier": 0.9, "score": 0.0}], "link": "https://stackoverflow.com/questions/75513973/why-does-using-tuple-function-while-making-a-tuple-give-me-a-error-but-doing-the", "question": {"content": "I was trying to create a tuple with tuple() with its only element being empty list but it gave me an error, 'list' object is not callable This code gave me error while this code did not give me any error Can anyone explain why this is happening and if I can do this with list and tuple functions", "id": 75513973, "title": "Why does using tuple function while making a tuple give me a error but doing the same using () does not", "traffic_rate": 791}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "list", "tuples"]}, {"answers": [{"content": "When validating, the purpose of your function is to tell you if the criteria are met. You expect to get a boolean result; valid or not valid. You'd only throw errors if, say, the inputs to the function are not supported, or some dependency for the validation process itself was not met. In that case, the normal operation of the validator cannot be completed, you cannot return valid or not valid in such cases because there is no way for the validator to make that determination. You can compare this with isinstance() or issubclass(); these two functions test a value against another value. They return True or False, and raise exceptions if you give them unsupported input: Normal operation is validation, giving it unsupported input means no valid or invalid value can be returned and thus warrants an exception. So, for a validator that returns either a (True, message) or a (False, message) tuple, I'd only raise exceptions if there was a problem with the validation process itself, not to indicate the (False, message) case. Note that it doesn't matter what your validator returns; if you need to return both a valid / invalid flag and corresponding message (and only the validator can produce that message) then returning a tuple is just fine. You could return a custom class too: then use that as a test:", "id": 23875846, "owner_tier": 0.9, "score": 0.9999999991666666}, {"content": "Using an exception to indicate invalid data is the idiomatic, canonical, Python solution to this problem. Consider the int() function, if you pass it invalid data, an exception occurs:", "id": 23875151, "owner_tier": 0.5, "score": -8.333333282687742e-10}], "link": "https://stackoverflow.com/questions/23875126/validation-and-exception-vs-error-message-tuple", "question": {"content": "I am working on a validation function. I understand that exceptions are used for errors and unexpected situations, but in the case of a validation function, if a condition is not met inside, I would expect it to return False instead of an exception. The thing is that after the validation finishes I need to raise an message window with a message like: \"Tool exited because X condition not met\". My workflow has been to return tuples with the result and message: or\n    (False, X_condition_not_met) and then: However recently I have stumbled upon multiple answers raising a controversy about this issue and I am confused. For example some people say to always go with exceptions: What's the best way to return multiple values from a function in Python? and others say tuples are the way to go Best practice in python for return value on error vs. success. I would appreciate if someone could point me in the right direction.", "id": 23875126, "title": "Validation and exception vs. error message tuple", "traffic_rate": 2}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "exception", "tuples"]}, {"answers": [{"content": "The best way to explain this is to show it \"algebraically\": As you can see, the update form is not the same, it modifies foo[0] in place. __or__ generates a new set from the elements of the left and right operands. This is then assigned back to foo. Note that for simplicity, the expansions that aren't helpful to the problem are not expanded (such as foo[0] -> tuple.__getitem__(foo, 0)). The TypeError thrown is in tuple.__setitem__. tuple does not allow its items references to be replaced. The update form does not touch foo in any way (ie. it doesn't not invoke tuple.__setitem__).", "id": 3492735, "owner_tier": 0.9, "score": -9.090909090909091e-10}, {"content": "That explains the behaviour you are observing. The underlying problem, is that changing the value of a tuple is a violation of contract. You should not try doing it. Since you can have any object in a tuple, there are loopholes you can exploit, but then you get the kind of weird behaviour you are observing. Tuple items should be frozenset instead of set. If you do this, you will get a consistent behaviour, and no unwanted side-effect on error.", "id": 3493013, "owner_tier": 0.9, "score": -9.090909090909091e-10}, {"content": "This shows that the statement x[0] |= y is implemented by calling x[0].__ior__(y) and then assigning the returned value to x[0]. set implements in-place |= by having set.__ior__ return self.  However, the assignment to x[0] still takes place.  The fact that it's assigning the same value that was already there is irrelevant; it fails for the same reason that: fails.", "id": 3492715, "owner_tier": 0.5, "score": 0.999999999090909}, {"content": "\"Why the TypeError, when the operation obviously was successful?\".   Because there are multiple side-effects.  Try to avoid that. That's what the  foo[0] |= set(range(5)) update the set and throw an exception Correct.  First the set mutation is done. Then the tuple mutation is attempted and fails. foo[0].update(set(range(10))) work without a problem?  Correct.  The set is mutated.   Should it not have the same result as the first statement? No.  The first statement involves explicit assignment -- changing the tuple -- which is forbidden. The second statement updates a member of an immutable tuple, an operation that is not forbidden, but is suspicious as pushing the envelope. But the Legalism Scholar argues, aren't they supposed to be the same?  Or similar?  No. Updating the tuple object (via assignment) is forbidden. Updating a member of an existing tuple object (via a mutator function) is not forbidden.", "id": 3492523, "owner_tier": 0.9, "score": -9.090909090909091e-10}, {"content": "doesn't work, because what you wanted to achieve is: and you can't assign new elements to an old tuple, because they are immutable. For example you cant do this: When you are running update, you don't change references in the tuple, but only object behind the reference. You could also do this like this: as you can see you don't change the tuple, but x (and y[0]) will be changed. and  aren't the same, because update works in place and x |= y will create a new object (x | y) and store it under name x.", "id": 3492256, "owner_tier": 0.9, "score": 0.09090909}, {"content": "Tuples are immutable so u cannot reassign values to it. But if a tuple contains a mutable type such as list or set u can update them.\nnow in your case when u use '|=' u actually first update the set (which is a value in the tuple) then assign it to tuple which causes the exception. \nException is thrown after the updation of the set. In the next case u r simply updating the set so there is no exception.\nRefer to http://docs.python.org/reference/datamodel.html", "id": 3492473, "owner_tier": 0.5, "score": -9.090909090909091e-10}, {"content": "In your example foo is a tuple. Tuples in python are inmutable, this means that you cannot change the reference of any tuple element - foo[0] in your case. Things like the following can't be done: You could use a list instead", "id": 3492276, "owner_tier": 0.5, "score": 0.1818181809090909}, {"content": "Tuples are immutable. By trying to assign to foo[0], you are attempting to change a value that the tuple stores (a reference to a set). When you use the update() function, you are not changing the reference, but instead the actual set. Because the reference is the same, this is allowed.", "id": 3492239, "owner_tier": 0.9, "score": -9.090909090909091e-10}], "link": "https://stackoverflow.com/questions/3492216/why-does-updating-a-set-in-a-tuple-cause-an-error", "question": {"content": "I have just tried the following in Python 2.6: I have several questions here: Edit Many people have pointed out, that tuples are immutable. I am aware of that. They have also pointed out, that |= would create a new set object and assign it to the tuple. That is wrong. See this: This means that no new object has been created, but the existing one was modified. This should work with the tuple. Please note also that, although my first code throws a TypeError, the set within the tuple is still updated. That is the effect I am interested in. Why the TypeError, when the operation obviously was successful?", "id": 3492216, "title": "Why does updating a set in a tuple cause an error?", "traffic_rate": 2816}, "saved_time": 1721102247, "source": "stackoverflow", "tags": ["python", "tuples"]}, {"answers": [{"content": "try except is for catching errors, you need to raise an error.\n\nYou can use isinstance function to check for the type of a variable.\n\nNote that the check includes inherited types.\n\n    if not isinstance(t, tuple):\n        raise TypeError(\"first argument must be a tuple\")\n\nAbove will check if t is an instance of class tuple, if not, it'll raise TypeError\n\nOk, I think get it, I never knew you can raise errors without `try...except`.\n\nOne more question: I wish to print a message alongside the error. For example, giving x = 'Hello' should give something like this:\n\n`TypeError: Invalid Data Type`\n\nSo far the code is enough to tell me that there is a type error, how do I print the message?\n\nOk after I bit more research I got the answer myself. Turns out TypeError has a parameter where you can input the error message. Thanks!\n\nYou may have missed my edit,  you can provide a message like this:\n\n    raise TypeError(\"Invalid Data Type\")\n\nYup I missed that haha. It works perfectly now :)", "id": "hl3ga8x", "owner_tier": 0.7, "score": 0.9999999988888888}, {"content": "You could make it a bit more flexible by passing \\*args and unpacking the tuple. that way you can pass the tuple as first argument, and then insert as many elements as you want to the tuple.\n\n    def insert_t(t,*i):\n        if not isinstance(t, tuple):\n            raise TypeError(\"first argument must be a tuple\")\n        return tuple([*t,*i])\n\nThank you for this! The purpose of this code was to insert one element at a time, similar to the insert function for lists. I haven't learnt about args and kwargs yet but I'll be doing that next. Thanks!", "id": "hl3hls3", "owner_tier": 0.3, "score": 0.11111111000000001}, {"content": "Probably a dumb question, but why do you feel the need to restrict the function to only work for tuples?\n\nSure, it's possible to use `isinstance` to raise an exception when `t` is not a tuple, but personally I'd rather use a soft restriction instead. You could use a type hint:\n\n    def insert_t(t: tuple, i: int, v) -> tuple:\n        l = list(t)\n        l.insert(i, v)\n        tu = tuple(l)\n        return tu\n\nOn another note, generally you shouldn't be using a tuple if you need to insert things into it later on, as it's inefficient to convert back and forth. In fact you could probably write your function as\n\n    def insert_t(t: tuple, idx: int, value) -> tuple:\n        return (*t[:idx], value, *t[idx:])\n\nand skip the conversion process. I'll validate later if my suspicions are correct, can't right now.", "id": "hl3ozoo", "owner_tier": 0.7, "score": -1.1111111043583657e-09}], "link": "https://www.reddit.com/r/learnpython/comments/qwkimb/exception_handling_in_python_need_to_allow_only/", "question": {"content": "I have this code to create a function to insert to a tuple in python:\n\n    def insert_t(t, i, v):\n        l = list(t)\n        l.insert(i, v)\n        tu = tuple(l)\n        return tu \n\nThe code works, but there is one problem. Passing t to be any sequence type variable works. But I want t to be only a tuple, not a  list or a string. See below for what I mean:\n\n    x = 'Hello'\n    insert_t(x, 2, 4) \n\nThe code works for when x is a string, however, this breaks the purpose of the code to append to only tuples. I would like it to raise `TypeError` if the parameter t is not a tuple.\n\nAfter looking online, I found that `try...except` exists, which can raise the required error. However, I don't know how to implement it, since as you can see, I have never used `try...except` before. How do I implement it?", "id": "qwkimb", "title": "Exception Handling in Python - Need to allow only one datatype", "traffic_rate": 153.13018518518518}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "I'd say this is bad and uncommon when done literally. You're losing the ability for the IDE to tell you that a function call has the wrong number of or type of arguments unless you use a tuple and hint that. You're also forcing needless `[]` for all calls, and destructuring inside every function.\n\nI don't at all see the benefit to this. If you changed the number of arguments a function requires, the existing calls *should* fail. And they would fail with an index error with your way anyway when you tried to access the second element of an array that only has one. If you want to add a parameter and not need to change all the existing calls, you could give the new parameter a default argument, or create a new function and potentially deprecate the old version.\n\nThe closest I've seen to this is `*args`, which is basically an implicit version of what you're doing, but with var-args, the individual elements don't tend to have different purposes.", "id": "kydy1jn", "owner_tier": 0.9, "score": 0.9999999995833333}, {"content": "Function arguments should be descriptive to help the user understand what they refer to or expect. In my experience, arrays should be passed when array are used as arrays. From the sounds of it, you should really have a float argument, or in your second case, two float arguments, not an array. Also, argument names like \"float1\" and \"float2\" are useless, they don't describe what is expected by the function.", "id": "kydy8ub", "owner_tier": 0.3, "score": 0.29166666625}, {"content": ">if I do it in an array, then it doesn't throw the error that it needs 2 inputs\n\nSo what happens when you change your function from\n\n    def function(array):\n        return array[0]\n\nto \n\n    def function(array):\n        return array[0] * array[1]\n\nSure, all \"calls\" to the function will succeed, but then immediately fail, because you'll be referring to array[1], which doesn't exist.  So it's... exactly the same except worse because a linter or your IDE won't warn you that the function signature has changed and your calls are all now incorrect.\n\n(along with hiding the actual inputs to your function, which requires yourself or anyone else using it to read the code just to know what elements to pass in what position)", "id": "kye3k11", "owner_tier": 0.5, "score": 0.41666666625}, {"content": "Others have already provided good answers for this particular case, but I think there's a more general valuable lesson here: Many errors are GOOD THINGS. You say if you change an existing function from having only 1 argument to 2 arguments, then existing code that calls the function with only 1 argument will raise an exception. THIS IS GOOD. Calling the function with only one argument is a mistake that needs to be fixed. You want to be made aware of this mistake as soon as possible!\n\nIn fact, if your IDE is set up properly, it should make you aware of this error before you even run the program, by showing you red squiggly lines under the function calls that use the wrong number or arguments. Those red squiggly lines are good! They show you something important.\n\nIt's possible you have a hangup I've seen in other beginners, where they feel uncomfortable having the computer \"yell\" at them, telling them they \"did something wrong\". Let go of that anxiety. Programming usually involves being wrong 20 times until finally you get it right the 21st, then you can move on to being wrong about the next section. Lots of hard work and billions of dollars has gone into developing tools that let us know where and how we're wrong, as quickly as possible. Embrace them.\n\nI have said before that all programmers are egotistical, because those are the only people who still feel smart after being told repeatedly they're wrong.", "id": "kyf3wip", "owner_tier": 0.3, "score": 0.24999999958333333}, {"content": ">is it common to use the array to do inputs?\n\nNo, it's not common, and is (IMO) bad practice. It obfuscates the function definition and makes it easier to introduce errors.\n\n>I realized that if I went to using 2 number inputs, for example if \"def function(number):\" became \"def function(number1,number2):\" then the function would fail in literally every piece of code it ran in, but, if I do it in an array, then it doesn't throw the error that it needs 2 inputs, \"def function(array):\" doesn't throw the same error?\n\nIt doesn't throw the error, sure, **but the error still exists**. Whether you change every function call to include the additional parameter or whether you change every list that you are passing to the function, you still have the same underlying issue.\n\nMore importantly, if you use parameters individually, you get an IDE warning where the parameters don't match, which makes updating easier. If you put in a list (array) then the interpreter has no way to tell your input parameters are wrong until it tries to access an invalid index.\n\nThere are other issues...now you either need to break out your parameters using unpacking (i.e. `param1, param2 = parameter_list`) or reference them repeatedly by index, which is confusing (what does `parameter_list[0]` actually represent?). And if you assign them to variables, you are just repeating the same thing the parameters would have done directly, and if you change the number of parameters, you still have to change all your calls (if just changing the input list). It's awkward and solving a problem the language already does.\n\nInstead, if you are worried about parameters changing or being optional, you should use optional and named parameters, i.e. `foo(name, age=12, hair_color=\"brown\")` and then you can call it with `foo(my_name, hair_color=my_hair_color)` if you want to leave certain things as default values.\n\nNow, there are times when you want to do *some* of this, such as if you have a variable number of parameters and intend to loop through something and do something else based on what you get (although you usually use a dictionary for this, but not always). There is also the slightly more advanced usage of `*args` and `**kwargs` when you are trying to make a function accept an arbitrary number of parameters. As a general practice, however, it's a very bad idea.", "id": "kye6xic", "owner_tier": 0.7, "score": 0.08333333291666667}, {"content": "If you have a good reason for actually needing variable arguments use something like `*args` or `**kwargs`. Otherwise just deal with fixing after you change stuff or version your functions/code", "id": "kyegiv8", "owner_tier": 0.5, "score": 0.041666666250000005}, {"content": "Never do this", "id": "kyfwjrr", "owner_tier": 0.7, "score": 0.041666666250000005}, {"content": "Isn't it essentially a tuple already?  () tuples are everywhere in python.", "id": "kye0ri1", "owner_tier": 0.5, "score": -4.166666641343871e-10}, {"content": "You can put any object you wish as an input in a Python function.\n\nI wouldn\u2019t call it an array, unless it\u2019s an actual array. Arrays dont\u2019t exist in vanilla Python, but if you import a C library like numpy.array you can have the traditional array, so call it a list in vanilla because that usually what it is \n\nI\u2019d prefer the object name to represent its actual expected data structure. Or some reasonable description/convention.. I don\u2019t think I\u2019m alone in this. \n\nThere is no problem running a function like you are in Python as is. I would type hint it, and be more explicit though of the type of object, to be formal.\n\nYour problem IMHO probably comes from design.  You don\u2019t exactly know what coming into the function, which always becomes a problem.", "id": "kye7qii", "owner_tier": 0.7, "score": -4.166666641343871e-10}, {"content": "I hope I never have to maintain code you have written. This would be horrible from a readability perspective.", "id": "kyj7uok", "owner_tier": 0.7, "score": -4.166666641343871e-10}, {"content": "If that array used for something else besides that variable, I'd use it, otherwise single number.\n\nOr I'd do number and then rest of array as 2nd argument. Or it would be a dict or some class instance (might be preferable because you'd have data validation code in it)\n\nUse proper code blocks for code.", "id": "kyl1hkp", "owner_tier": 0.5, "score": -4.166666641343871e-10}], "link": "https://www.reddit.com/r/learnpython/comments/1bxo358/when_writing_functions_in_python_is_it_common_you/", "question": {"content": "I don't know if this is common in python, but, I have a habit of always making the input to a function an array as opposed to anything else, so, that I can expand it if I need it without functions failing, for example if I define a function with a number input in in python, I do-\n\ndef function(array):\n\nnumber= array\\[0\\]\n\ninstead of-\n\ndef function(number):\n\nis it common to use the array to do inputs?  I realized that if I went to using 2 number inputs, for example if \"def function(number):\" became \"def function(number1,number2):\" then the function would fail in literally every piece of code it ran in, but, if I do it in an array, then it doesn't throw the error that it needs 2 inputs, \"def function(array):\" doesn't throw the same error?\n\n", "id": "1bxo358", "title": "When writing functions in Python is it common you put the inputs in an array as opposed to the parenthesis by the function so that there is always 1 input (the array) and the function doesn't automatically fail in everything that it runs in because the inputs have expanded?", "traffic_rate": 153.13018518518518}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "I'm with your colleague, return None or raise an exception. Returning some random type from an unrelated module is terrible\n\nOr make a sentinel value if you really don't want to return None. Or raise an exception.\n\nNot just *some* random type, a type that was specifically marked private by being named with a single leading underscore. `from any_module import _something` is usually a code smell. (cf. [PEP8](https://peps.python.org/pep-0008/); ctrl+F *leading underscore*)\n\nNow, that doesn't necessarily make it wrong on its own. Somebody can easily design and implement a module where they intend for public parts of the interface to be prefixed with a single leading underscore (although to do so would be very unconventional). But in this case you can also ctrl+F `_empty` on the official docs. Neither [the 2.7 docs](https://docs.python.org/2.7/library/inspect.html) nor the [current version](https://docs.python.org/3/library/inspect.html) have any mention of it anywhere on the page. (I actually went through every version of the `inspect` docs available in the drop-down, and `_empty` isn't mentioned in ANY of them.) So OP is relying on private, undocumented members of a module. Very, *very* bad.\n\n[deleted]\n\nShould have specified, this is only for internal use within the system, not returning it to the end user (who may indeed receive either None or an exception depending on the circumstance)\n\nYes, what OP has done is basically using someone else's sentinel. https://peps.python.org/pep-0661/ has a proposal for better support for sentinel pattern, and one rejected idea was having a standard sentinel in the stdlib - because sentinels for different uses should be distinct.\n\nSentinels have their uses, the times I've found them useful is as a default value for a function arg, distinct from None. But 99% of the time I think a \"get\" operation probably ought to return None or raise some kind of \"not found\" exception (preferably one you've defined, for same reasons).\n\nOr if you'd rather pass the buck to the caller, make them pass their preferred sentinel.\n\nYeah this. Don't use internals from other modules. The entire point of the leading underscore notation is to tell you not to import it.\n\nI do wish sometimes that linters didn't complain when you import something with an underscore from a test file.\n\nThere is plenty of room to discuss whether you should be testing private functions and I actually do tend to agree with those who say you shouldn't test private functions directly since the internal implementation should be able to change without needing to refactor a test while also testing all the functionality for the range of valid and invalid inputs of the public API. However, in practice I wind up needing to write tests just to sanity check that I'm understanding private functions as I write them\n\nA lot of programmers think of exceptions as something you only use when things have gone very wrong, but they aren't. They're a way to handle any type of failure condition, even those that are expected to happen under normal conditions.\n\nAnother common alternative in other languages is a `Result<T, E>` or `Either<T, E>` type, but Python exceptions have the same cost as any other operation, so there's no need to go out of one's way to avoid them in business-logic type code.\n\n*However,* if a \"sentinel\" value is normal or expected, using an exception for that might be strange. In those cases, one should prefer `Option<T>` or `Maybe<T>`. However, these are not common in Python since returning `None` usually does the job. When `None` is a valid value, one needs to be a bit more creative. One way is to return a second parameter denoting validity:\n\n    def f(x):\n        ok = True\n        value = x\n        return ok, value\n\nA \"heavy-weight\" alternative is to create a custom type specific to that operation:\n\n    class OptionalResult:\n        def __init__(self, value=None, ok=True):\n            self._value = value\n            self._ok = ok\n    \n        @property\n        def value(self):\n            if not self._ok: raise\n            return self._value\n    \n        @property\n        def ok(self):\n            return self._ok\n    \nThis allows the user to check if `value` exists before trying to extract it. It also keeps the number of return values down to 1. However, this is usually overkill.", "id": "i4qorq3", "owner_tier": 0.5, "score": 0.9999999999841772}, {"content": "There actually exist a whole lot of standard libs that are considered bad practice to use nowadays. That's also why [PEP 594 \u2013 Removing dead batteries from the standard library](https://peps.python.org/pep-0594/) exists.\n\nAre these to-be-removed modules going to keep their name spaces?  I can see a need for uu or xdrfs to exist in pypi/pip but not in core, especially since there is no suggested replacement capability.\n\nTry and use them now guys before they're gone in ~2030\n\nuuencode made sense to include in the standard library because it was used heavily in Usenet (nntp) and because nntplib is also part of the standard library.\n\nBut because nobody really uses usenet nowadays, and certainly not scripting with them, and with nntplib itself being scheduled for removal, yeah, it doesn't really make sense to keep uu.", "id": "i4r0xm2", "owner_tier": 0.3, "score": 0.24367088606012657}, {"content": ">It got me thinking - are there any notable parts of the language's standard modules, that would be considered a poor or incorrect use of the language if you were to use them in production?\n\nMaybe using urllib instead of requests.\n\nGod, I wish requests was part of the standard library. Having to use urllib because you can't install external libraries is a painful experience to the point that I've got a bookmarked stackoverflow post to copy the code from\n\nmemorize shame familiar pet pie imagine juggle fly afterthought toy\n\n *This post was mass deleted and anonymized with [Redact](https://redact.dev)*\n\nI would use it if I were writing an AWS Lambda and didn\u2019t want to drag in any dependencies \ud83e\udd37\u200d\u2642\ufe0f\n\nEh, I realise I'm probably out on my own here, but I find requests gets in the way about as often as it helps out. For simple stuff it's neat, but as soon as I get into the kinds of problems that need adapters to solve, I regret not using an uglier library where you just construct connection objects yourself.\n\nThe terrible secret is... \"requests\" actually *does* ship with Python, and has for years.  shhh!\n\np.s. look in Lib/ensurepip/_bundled/pip*.whl\n\nI'm fairly sure this has been suggested a few times but the development teams would rather they stay separate.\n\n> because you can't install external libraries \n\nIf you can't install external libraries, your whole programming life is going to be miserable.\n\nJust on the testing side - no flake8?  No pytest?  No mypy?\n\nAre you going to rewrite yaml parsing?\n\nAre you going to rewrite numpy?\n\nDevelopers like this are a tiny outlier who are also very difficult to help.  They shouldn't be taken into consideration in the Python roadmap.\n\nLinkers?\n\nIt's easy enough, about 15 lines actually, to make urllib act close enough to imitate requests. I've done that before on systems where I couldn't install it.\n\nRequests exists because urllib is needlessly complicated", "id": "i4qnykh", "owner_tier": 0.5, "score": 0.3465189873259494}, {"content": "The inspect module has a valid specific reason for returning a sentinel - it deals with reflection. Borrowing it is no bueno unless you\u2019re extending inspect.", "id": "i4qywd3", "owner_tier": 0.9, "score": 0.052215189857594935}, {"content": "Another unpythonic thing in the standard library is the heavy use of camelCase in certain modules. For example, `logging.getLogger().setLevel()` should really be `logging.get_logger().set_level()`.\n\n`unittest` is guilty as well. But i personally don't much care, the whole snake case obsession in python feels kinda culty.\n\n`logging` and `unittest` APIs are borrowed from somewhere else. For sure, `unittest` comes from JUnit, not sure about logging.\nThe funny thing is, as they're thought from other languages and libraries, they also feel often weird to use (you need quite some reading to use `logging` properly and understand how it works)\n\nAgreed. In fact, your trivial case should be reduced to `logging.root_logger.level = ...`.\n\nThey really should just rename everything in `logging`.\n\nKeep the old names as aliases for backwards compatibility, of course.\n\nAs a person with OCD, this shit grinds my gears so much to the point I start using Go.\n\n[deleted]\n\nI just think its a little extra to say a variable naming scheme is \"not pythonic\". I know many will disagree with me but i think it should be on individual teams to decide which case they prefer and not have it mandated to them by the language.  We have mixed cases in the python standard library now and its not bad. With modern code editors its not even inconvenient or annoying imo.", "id": "i4sce2v", "owner_tier": 0.7, "score": 0.08702531643987342}, {"content": "It depends, but i think using csv module vs pandas can be a bad practice if you need to do complex stuff with the csv.\n\nOr like using os instead of Pathlib..they are both in the std library tho\n\nConversely using pandas only to load in a csv is probably bad practice. It's a lot of bloat for something very simple.\n\nYap, totally agree with you on pathlib. It just takes out all the annoyances of supporting windows and POSIX.\n\nUsing os over pathlib makes sense if you expect that code to be running on a legacy system and utilizing a version of python older than 3.4.\n\nThis isn't a great example. `csv` and pandas both have their time and place.\n\nYes that happens too\n\nFor that specific example, I have to disagree. Only for the fact that pandas is much faster to load csv files. \n\nOtherwise, I agree that it is better to keep at minimum the amount of large module dependancies when possible.\n\n(I recall having a colleague trying to add a pytorch dependancy just for a single function that was totally unnecessary)\n\nMost python modules have their time and place, doing something non-pythonic means getting 1 of the 2 wrong. Like hawai pizza, pineapple and pizza are great food, just not together.\n\n> Only for the fact that pandas is much faster to load csv files. \n\nIf I'm writing a function that reads a csv and transforms the data or writes it to a DB then not only is the csv library much faster but I can handle csv of arbitrary size. You got a 1 TB csv? No problem with csv module, literally `MemoryError` with Pandas.\n\nI'll be honest I'm guilty of similar.\n\nNo need to get political or anything", "id": "i4qpx3o", "owner_tier": 0.3, "score": 0.24367088606012657}, {"content": "In Python, \"_\" indicates that a method is private, so using a method that starts with this is definitely bad practice.\n\nIt's a smell but not exactly bad practice.  Python takes the stance that \"we're all grown ups here\".\n\nAnd grownups know using undocumented features with no guarantee of future support or behavior is unprofessional. It's definitely a bad practice except for extreme circumstances, POC, and emergencies", "id": "i4rf77b", "owner_tier": 0.7, "score": 0.03797468352848101}, {"content": "The unpythonic thing is not that you are using the standard library, but you are literally accessing a private property of inspect.  the underscore prior to empty is to indicate it's for internal use by that package.\n\nIn other words, parts of the standard library with underscores preceding them are generally unpythonic to use directly in your code!  It is a convention in python.\n\nMoreover, it is a part of the *inspect* library, it was meant for code introspection, unless your result is also related to introspection it's weird to use an object from the inspect library this way.\n\n Probably more importantly, changes to the behavior of private properties will **not** be seen as backwards incompatible api changes, so you might see them occur in an update to the minor version of python in which suddenly the _empty object behaves differently.  With this particular case, it probably will not change, but it's still a bad practice.", "id": "i4sb6ww", "owner_tier": 0.5, "score": 0.017405063275316456}, {"content": "The pythonic sentinel for \"no value\" is None. If your data allows for \"no value\" as a valid value, you must make your api more specific.\n\ne.g.\n\n     return data\n\nThis returns the actual data, including None as a valid value. If you need a specific \"no value\" create your own sentinel:\n\n    class Nothing: pass\n\nThen your function returns this whenever there is no data:\n\n     if <no value>: #insert your check\n          data = Nothing\n     return data\n\nAnd then hopefully your ci rejects the commit because you're returning two types from a function with a docstring that specifies one type.\n\nBetter to return None for no value and try/catch anything that would prevent you from getting to value/novalue.\n\nAs far as creating sentinal objects goes, it's better to do: `Nothing = object()` so that you don't accidentally instantiate it or confuse people with a class being passed around.\n\nReturning None + other valid data is already 2 types..\n\nTo each their own, but in my experience whether either of these approaches are appropriate depends on the purpose of the function:\n\nIf the target data cannot contain `None`, or if `None` is functionally equivalent to \"item not found\", then by all means use `None` to indicate \"not found\".\n\nSimilarly, if your function is framed such that finding no item is exceptional behaviour, then by all means throw an exception.\n\nBut, if \"item not found\" is not considered exceptional, and `None` is functionally different from \"not found\", then a sentinel value or metadata wrapper may well be more appropriate.\n\nI know many feel that it's good form to use exceptions for non-exceptional cases, and that's their prerogative. But I'd caution that exceptions add significant overhead, so all else being equal they're at least mildly contraindicated for expected behaviour when performance is a factor (and I happen to feel that an exception is a misleading way to handle normal, expected behaviour).\n\nUnless you also change the docstring to match?\n\nWell classes are singleton objects, so not much of a difference.\n\nWhich is fine and expected, so you handle None/Valid. You don't handle class Nothing. And your CI should reject such a change, even though it \"works.\"\n\n404s aren't particularly exceptional, but they're still errors, and they're fundamentally different than 200 OK with no content.\n\nExceptions doesn't \"add significant overhead\".\n\nIt may be true in other languages like Java, but not in Python.\n\nNot very hard to type hint, what are you implying? A two type union is a-okay but three types is suddenly impossibru?", "id": "i4rcsqx", "owner_tier": 0.3, "score": 0.055379746819620254}, {"content": "global", "id": "i4qonlg", "owner_tier": 0.9, "score": 0.009493670870253164}, {"content": "A potential pattern you could use here is a named `default` argument, which defaults to `None`. This would allow you to pass in your own sentinel, if desired.\n\nAnother pattern would be a named `must_exist` boolean, which *optionally* throws an exception if the query doesn't return any results. I'm not a huge fan of this though, as it makes method access \"muddy\".\n\nI like the first pattern a lot, then having separate methods for the second pattern. Something that looks like this is usually what I go for. An example for an ORM type of use case below. Also bear with the spacing, am on mobile.\n\n    class Customer:\n        @classmethod\n        def get_by_id(cls, id) -> \u201cCustomer\u201d:\n            # Assuming it raises a RowNotFound error if it\u2019s missing\n            return self.query.filter_by(customer_id=id).one()\n        \n        @classmethod\n        def try_get_by_id(cls, id) -> Optional[\u201cCustomer\u201d]:\n            try:\n                return cls.get_by_id(id)\n             except RowNotFound:\n                 return None", "id": "i4rcsau", "owner_tier": 0.7, "score": 0.014240506313291138}, {"content": "anything in camelCase", "id": "i4st4co", "owner_tier": 0.7, "score": 0.0015822784651898735}, {"content": "from datetime import datetime\n\nWho hasn't been caught by this? Class names should be capitalized.\n\nI think it was done to imitate the literal types like `int`, `list` etc. and imply that in some way, `datetime` was a really basic type... but I find this choice weird since it's not a builtin class", "id": "i4tib19", "owner_tier": 0.1, "score": 0.007911392389240506}, {"content": "A dedicated sentinel value is a perfectly normal thing to make when `None` or `False` can't be used IMHO.\n\nUrllib is kinda hard to wrangle, so is the xmllib, a lot of jank server / network things, logging is super Java-y, etc", "id": "i4s2siu", "owner_tier": 0.9, "score": 0.0015822784651898735}, {"content": "This thread just reminds me how much I love Haskell's `Maybe` class", "id": "i4rlg8i", "owner_tier": 0.9, "score": -1.5822784713964067e-11}, {"content": "Not standard lib by any means but sklearn has some \"special\" code paradigms. A while ago I had to dive into their Gaussian Process Regression code. Building your own kernel types is a mess. It is very doable but the behavior of the kernels is driven by the naming pattern of the arguments. Its been a while so I may have the details off but I remember thinking WTF as I had to figure it out. Oh, and by \"figure it out\", I mean read the source code!\n\nI see the things that may have pushed them into doing it that way but man is it a mess!\n\n\\>driven by the naming pattern of the arguments\n\nHow long did you spend going insane before you said fuck it and opened the source code?", "id": "i4r7cmw", "owner_tier": 0.7, "score": -1.5822784713964067e-11}, {"content": "Reminds me, DAE hate how `re.match` returns None sometimes, so when one tries to do `.groups()` on it a little later you get `AttributeError: 'NoneType' object has no attribute 'groups'`. I really wish it raised an exception instead. This API seems very unpythonic.\n\nThat was one of the justifications for the walrus operator:\n\n    if m := re.match(...):\n        print(m.groups())", "id": "i4somhf", "owner_tier": 0.5, "score": 0.011075949351265824}], "link": "https://www.reddit.com/r/Python/comments/u3p62s/parts_of_the_standard_library_that_are_considered/", "question": {"content": "I had an argument today about the using the `_empty` object from the `inspect` module to denote an item not found in a lookup, rather than just returning None (as None could well be a value in our data), or erroring (as too many try/excepts make code more difficult to read, and failing to find something in our system is not actually an error anyway). \n\nAside from the idea of using a private attribute of another module, the other person says it's \"not Pythonic\" to use smaller custom types like this, as it's too close to something like `typedef` in c++ (never mind that Python has `namedtuple` for almost the exact same purpose anyway, but I digress).\n\nI argued that it's a ready-made and easily legible solution to the problem, and regardless, if it's good enough for the standard library then it should be good enough for us. \n\nWhile I think I'm right in this case, I know the last point is a very dogmatic way of looking at things.\n\nIt got me thinking - are there any notable parts of the language's standard modules, that would be considered a poor or incorrect use of the language if you were to use them in production?", "id": "u3p62s", "title": "Parts of the Standard Library that are considered to be bad practice / un-Pythonic ?", "traffic_rate": 207.942496260595}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "    x += y\n\nis equivalent to:\n\n    x = x.__iadd__(y)\n\nThe list's \\_\\_iadd\\_\\_ function succeeds in updating the list, and returns itself, but the assignment fails. The number's \\_\\_iadd\\_\\_ function changes nothing, but returns the new value and the assignment fails.\n\nThe issue here is that lists are mutable (can be modified), whereas numbers are immutable (cannot be modified).\n\nFor the += operator to work on a mutable object like a list, it has to actually modify the object. You can't modify a number though, so for the += to work on a number, you need to store the result of the addition back to the same variable.\n\nPython doesn't know the types of variables at compile time, though. So when it compiles the += operation, it doesn't know if it will be running on a list or a number. As such, it does both: it calls \\_\\_iadd\\_\\_ and then it assigns the result back in to the same variable. The number does the calculation and a new number for the result, and the list updates itself and returns itself. In both cases the assignment back causes an error, but in the list's case the change has already happened.\n\nSo, if `list.__iadd__` was changed to return a new list object rather than do an in-place update and return itself, this particular oddity would disappear.\n\nI guess the problem is that people expect `x += y` to be equivalent to `x = x + y`, which it is not (because of the in-place modification, and the extra evaluation of x). If the `__ixxx___` family of methods did not exist, this gotcha wouldn't either. The upside of doing it this way, I suppose, is that it lets people write more efficient code by avoiding allocation of a new object. The downside is that it's confusing.\n\nThe Python language reference mentions specifically that `__iadd__` and related `__ixxx___` methods should do in-place modifications if possible, so this bit of behaviour is completely standardized. Also, it's interesting to note that mutable objects that don't have an `__iadd__` method don't exhibit this gotcha, but still can support += just fine, either by implementing `__add__` or by the other object implementing `__radd__`.\n\nIt's a gotcha that only appears when you optimize in-place operations.\n\nA similar explanation is (now?) in the comments of the original article.\n\nBut as I comment there, this certainly doesn't mean that this behavior isn't very surprising!\n\nConsider the following:\n\n\n    tup = ([], )\n    def plus_equals(x, y):\n      x += y\n\n    plus_equals(tup[0], [1])  # Succeeds.\n    tup[0] += [1]             # Fails.\n\nOne would be forgiven for expecting the last two lines to do the same thing!  Do recall that in Python, unlike in C or C++, `+=` doesn't return a value, so on first or even second glance these two lines seem \"practically identical\".\n\nI \"understand\" why this is true, but that doesn't mean that it isn't still surprising behavior to me. \n\nThere's also the other surprising behavior - where the operation _succeeds_ but still raises an exception.  I can't think of any other place in Python where this happens - heck, I can't think of any other place in _any_ language where this happens...!\n\n> So, if `list.__iadd__` was changed to return a new list object rather than do an in-place update and return itself, this particular oddity would disappear.\n\nNo, you can't do that. This isn't just an optimization. Your version would break other behavior.\n\n    >>> a = b = []\n    >>> a += [1]\n    >>> b\n    [1]\n\nUnder your version, `b` would still be `[]`.\n\nDidn\u2019t know reddit markdown supports ``-syntax`. Cool! Is this new?\n\nNot as far as I'm aware!  Reddit mostly supports standard [markdown](http://daringfireball.net/projects/markdown/), and has supported \\``backticks`\\` for a while.", "id": "c7q5kaq", "owner_tier": 0.1, "score": 0.9999999997674418}, {"content": "So \"x[0] += [1]\" is equivalent to \"x[0] = x[0] + [1]\"?\n\nIsn't that what we'd expect?\n\n(i.e. \"x[0] + [1]\" is evaluated, and then the assignment to \"x[0]\" fails.)\n\nYou missed part of the odd behavior: after executing `x[0]+=[1]` the list at `x[0]` *has* been modified.\n\nActually, they aren't equivalent. I just tried this in the interpreter. x[0]+=[1] throws an error, but the list is still altered. x[0] = x[0] + [1] doesn't alter the list.\n\nThe reason they are not equivalent is that `x[0] += [1]` invokes the `__iadd__` method on `x[0]`, whereas `x[0] = x[0] + [1]` invokes the `__add__` method.\n\nThe discontinuity and confusion comes from the fact that `__iadd__` is used and the tuple is assigned to, as opposed to just one or the other.\n\nActually, \"x[0] += [1]\" is equivalent to \"x[0] = x[0].\\_\\_iadd\\_\\_([1])\".\n\nThe effect of \\_\\_iadd\\_\\_ on a list is to change the list and return itself, but the effect of \\_\\_iadd\\_\\_ on an int is to return a new value.", "id": "c7q2pmb", "owner_tier": 0.5, "score": 0.697674418372093}, {"content": "I don't really see how this would be a bug. `__iadd__` returns a value, which allows it to do either change the current object or create a new one. Since value is being reassigned to the original variable this behavior makes perfect sense, as (`x[0] = x[0]` fails as well in this case). \n\nIt *succeeds*, but still raises an exception. It should do one or the other, but not both.\n\nSeconded. As an engineer, I'm constantly fascinated by these cases -- surprising, unintuitive behavior that's direct consequence of a chain of seemly intuitive decisions. `X += Y` in Python is shorthand for `X = X.__iadd__(Y)` (save that X is only evaluated once), and __iadd__ for lists modifies the existing list. The only strange bit here is that tuple member assignment fails.\n\nYou can see this by executing:\n\n    >>> x = [0]; y = x;\n    >>> x += [1]\n    >>> print y\n    [0, 1]\n\nMost of us are expecting the original list contents, but += on lists behaves more like `extend()` than like `+`. That's where most of the surprise comes from; while strange, it's less confusing than always failing operation to have a side effect.\n\nWell the assignment is what is failing, no the actual `__iadd__` method. \n\nThis is unrelated to the topic. Both `x` and `y` refer to the same object, initially `[0]`, then appended to as `[0, 1]`. This is the distinction between mutable and immutable data types.\n\n    >>> x = [0]\n    >>> y = list(x)\n    >>> x += [1]\n    >>> y\n    [0]\n\nThe difference in this code is that *y is a new list*, rather than a reference to an existing list.\n\n> Most of us are expecting the original list contents\n\nOnly if you think assignment like `y = x` means creating a new copy, as in C++. I don't think many people would expect += to be anything other than a mutation operation, which means x and y will continue to refer to the same object.\n\nI think what most people are missing in this discussion is that, sure, it makes \"sense\" that it happens, but this is the sort of strange behavior that makes a language ugly. Javascript is filled with these super strange unnatural oddities. I personally love Python because it works like you expect it to and that things behave nicely, but I don't think an error and an effect are very natural.\n\nYou're making the assumption that everyone who programs is a computer scientist, and/or has a deep understanding of what happens behind the scenes of the interpreter. As someone who uses python for administrative scripting, and simple tasks, I don't think it's far fetched to say there are a lot of people like me who expect it to just work the way you would think it would work, not raise an exception, but still kind of work. \n\nYou could say that that makes me a shitty programmer, but since I'm not a programmer that's a fair assessment.\n\nThat's almost it. Rather, we're accustomed to x += z to be roughly equivalent to x = x + z, but for Python lists that's not the case at all. We don't expect x += z to affect y as x = x+z would not have affected y. \n\nWhat do you propose should happen to get the desired results? \n\nI don't think I am making that assumption, and I don't think it requires any knowledge of the interpreter (of which I have little). Nor do I think this is sensible behaviour on Python's part. I was just pointing out that aaronla's expectation that following `y = x` with a `x += [1]` will not change y only applies if you either have a misunderstanding of what assignment means in Python or you have a rather unusual understanding of what += means. The former is much more common than the latter and is understandable.", "id": "c7q527z", "owner_tier": 0.5, "score": 0.8604651160465117}, {"content": "There is also another interesting twist to this \n\n    import operator\n    x = ([], )\n    operator.iadd(x[0], [1])\n    >>> [1]\n    x\n    >>> ([1], )", "id": "c7qd6n8", "owner_tier": 0.5, "score": 0.046511627674418604}, {"content": "You can't do this: x[0] += y, where x is a tuple.  Because this is equivalent to x[0] = x[0] + y.   The right hand side might be okay, but the assignment back to x[0] raises an exception because x is an immutable tuple. \n\nIt isnt equivalent actually, using `__iadd__` allows the object to be changed in place rather than creating a new list. ", "id": "c7qdeww", "owner_tier": 0.7, "score": -2.3255813812151838e-10}, {"content": "Undefined behaviour is undefined?\n\nActually, I believe this behavior is fully defined (see all the other comments) but it brings up a good question. Does Python have any undefined behavior at all?\n\nWhich bit is undefined? And why would it be undefined?\n\nThis is a bit of a cop-out answer, that will be buried under a buried comment, but it's an interesting question, so I'll try to say something anyway.\n\nThere isn't a \"Python standard\", there's just a reference implementation and a reference manual. Almost all behaviour is \"defined\" by the reference implementation, even if it is as confusing as the example in the original post. Because of this, it might look like everything is defined, but there are actually a few different kinds of undefined behaviour.\n    \n* **Documented undefined behaviour** \u2013 This is when the documentation says that something is undefined or unpredictable. Other implementations have no obligation to do it the same, this is just how CPython works. For example, if you search for \"CPython\" on [this page](http://docs.python.org/3/reference/executionmodel.html), you'll see a box explaining that if you modify \\_\\_builtins\\_\\_ it may not work on other Python implementations. So you'll probably get a \"NameError\" or a redefined builtin if you modify it, but it's possible that another valid python implementation launches a game of chess when you touch \\_\\_builtins\\_\\_.\n* **Classic undefined behaviour** \u2013 Just as writing past the end of a buffer in C is undefined, this is also true if you write past the end of a buffer in Python. Python deliberately makes this really hard, but you can still do it (and lots of other insane, evil things) if you use ctypes. It will behave unpredictably differently depending on which Python version was compiled with which compiler.\n* **Conflictingly defined behaviour** \u2013 According to Tim Peters on [this issue page from Python 2.3 in 2001](http://bugs.python.org/issue448679), and [the python docs](http://docs.python.org/2/reference/expressions.html#evaluation-order), everything is meant to go left-to-right. But I just tested on 3.3.0, and dictionary key/value evaluation order is not as documented (as mentioned in the issue). If the reference implementation and the documentation disagree, is it defined? Maybe it really is a twelve-year-old bug and any python code that relies on that behaviour is correct - it just doesn't run on CPython because of a bug. Try it yourself:\n\n        >>> def f(a): print(a)\n        >>> {f(1):f(2)}\n        2\n        1\n        {None: None}\n\n> Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side.\n\nFrom the Python Docs you linked\n\nTrue. Although {'a': 'b'} isn't exactly an assignment, that part of the specification is probably the reason for this behaviour. If it was unclear, the specific documentation I was referring to was:\n\n> In the following lines, expressions will be evaluated in the arithmetic order of their suffixes:  \n> ...  \n> {expr1: expr2, expr3: expr4}\n\nWhich is explicitly saying that the dictionary example I wrote should print 1 first then 2.\n\nWell you are doing an assignment.  You're assigning a value to a key in the dictionary.\n\nI'd expect the first key, value pair to be evaluated before the 2nd and so on.  So that portion is left to right but the assignment is still right to left.", "id": "c7q2jbe", "owner_tier": 0.9, "score": 0.44186046488372094}], "link": "https://www.reddit.com/r/Python/comments/15v46b/pythons_is_weird_part_ii/", "question": {"content": "", "id": "15v46b", "title": "Python's += Is Weird, Part II", "traffic_rate": 207.942496260595}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "If you have a super-generic function like that and type hinting enforced, you just use `Any` and don't care about it.\n\nIt's better than not type hinting your codebase at all, as in 99% of cases you can use the proper hints.\n\nWorking in a big python codebase without type hints is a huge PIA.\n\n[deleted]\n\nExactly. Python type hints aren't enforced, so they're really mainly a form of documentation. Using `Any` is an effectively a way of warning other programmers that the parameter in question is unusually complex and needs to be handled with care, e.g. I usually represent JSON-like objects as `Dict[str, Any]` without worrying about trying to correctly unreadable monstrosities like `Dict[str, Dict[str, int]] | Dict[Str, Dict[str, str]]` which can't be read by humans and will be ignored by the interpreter in any case.\n\n`Any + Any -> Any` is wrong though. Sure it makes the errors go away, but it does so by asserting completely false things like `int + str -> dict`.\n\nIn large codebases typing is better than not having typing, but it isn't a good expressive type system, and it therefore cannot actually assure you type safety.\n\nAll the `Any + Any -> Any` annotation does is tell mypy not to complain about an unannotated function, but it's no better than telling mypy to ignore the function entirely.\n\nWorking in code without strong types is annoying imo\n\nThis is the (Any) way.\n\n> and type hinting enforced\n\nThis is the biggest error. In 99% of cases, you should not check the types of the arguments passed to your function for the sole purpose of throwing a `TypeError`. That's the whole point of duck typing. (I'm saying this as someone who prefers strong, ML-like type systems.)\n\n> Data types have helped me find so many bugs during development time it's nuts.\n\nMy experience begrudgingly trying them out while playing with Advent of Code was pretty much exactly this. The static analysis saved me from multiple issues before I ever execute a single line of my code.\n\nIf the view is that type annotations are documentation, then my opinion is that  `Any, Any -> Any` should be avoided because it isn't actually documenting anything. It is really mis-documenting things. I would prefer `#type: ignore` for these situations.\n\nIf you could provide some information about the types: `int, Any -> Any` then it would be a little better (although many objections still remain).\n\nYou could probably fix this by just defining some type alias `Unknown = Any` and then you would have things like `Unknown, Unknown -> Unknown` and `int, Unknown -> Unknown`, which is the same signature to the type checker, but is a little clearer to the reader that you have in fact given up trying.\n\nWell, they can actually be read by humans, but I kinda get your point.\n\nWhy don't you use dataclass or pydantic for JSON?", "id": "j83cwzo", "owner_tier": 0.3, "score": 0.999999999988345}, {"content": "God tier post. My incredibly flippant answer is use type hinting when it\u2019s helpful and not strive for completeness, kinda like how complete test coverage is often more about dick-Waving than code safety.\n\nTruish regarding test coverage, but the old phrase \"Any untested code is broken.\" is also surprisingly often true.\n\nOur team mantra on coverage is, 0% coverage means your tests are definitely bad, 100% coverage doesn\u2019t mean your tests are any good.\n\nNoob question, how do you handle your ide/language server complaining? Just ignore?\n\nExcept when you think about it - in reality code being untested doesn't mean it's broken. It's a nice saying but someone needed to bend reality to prove their point.\n\nYou fix the issue.\n\n99% if the time, you just made a mistake. 1% of the time it\u2019s a bug in the typechecker/library and you create an issue on GitHub.\n\nVery true. My approach to testing is:\n\n* How might this test break, and how likely is that scenario?\n* Is this test the only way I'll know the code isn't behaving?\n* When the test breaks, can it clearly explain what went wrong? Even to someone who isn't me?\n* If I refactor my code, will this test still pass without changes? \n\nWhen looking at testing through these questions, a lot of tests start to seem worthless. And, sadly, that's to be expected. Many programmers write tests only because they were told to write tests. It's really only after going through the five why's that you start to understand what the point of it all is.\n\nIt is a heavy handed statement meant to be scare people into more testing. I would alter the statement and say you should have *zero confidence* in untested code (you can't always have full confidence in tested code).\n\nIt's obviously just a saying that is meant to instill good habits. There is no reason to take the comment pedantically.\n\nYou seem to have posted this comment just a couple extra times.  Reddit's being goofy today and I'm seeing a crapton of multi-posting.\n\nYeah, sorry. 2 or 3 times my app would hang for a minute and say try again later.", "id": "j82zy2y", "owner_tier": 0.1, "score": 0.38578088576923075}, {"content": "I would probably pick step 4 and stop there. Full generality and trying to handle all special rules in python is often a pain. If your user really wants to use a type with only add and no radd they can just type ignore. There are other places both for stubs and type checkers where python behavior vs describing it grows to be painful enough that you pick reasonable approximation that covers most cases and stop there. One easy example there is no way to describe functools.partial fully in type system. Or even a simple decorator can give you problems if you try to use it on an overloaded function as mypy does not support mixing paramspec + overloads. I consider these esoteric pains and that a few type ignore/casts is fine. You should expect type hints to cover most usage. \n\nIt\u2019s similarish to test coverage. 100% coverage is often pain to maintain. 90% (exact number team decision) is fine. 100% type coverage is also painful and at times essentially impossible.\n\nOne place that tries hard to do type hints very precisely is typeshed and you can see the protocol they define here to describe very generic add/radd usage. I don\u2019t recommend going this far but it can be helpful to look in typeshed to see how they solved similar issues.\n\nhttps://github.com/python/typeshed/blob/afb7704b36ad9b43704bf2444ba1997858b6f677/stdlib/builtins.pyi#L1719\n\n> I would probably pick step 4 and stop there.\n\nUnfortunately 4 is fundamentally broken with tuples, I had to raise a ticket with pyright to understand why: https://github.com/microsoft/pyright/issues/4613/\n\n(#4) permits `int+str` as mypy finds no issues with the following:\n\n    from typing import Protocol,TypeVar\n    T = TypeVar(\"T\")\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    def binary(a: Addable, b: Addable) -> Addable:\n        return a + b\n\n    x:int = 0\n    y:str = \"foo\"\n    z:Addable = binary(x, y)\n\nI read ticket. I\u2019d still stop there. The ticket response boils down to how do you know if a tuple if intended to be fixed length or dynamic length. it\u2019d be nice if bidirectional inference solved it but I can understand maintainer thinking it\u2019s not worth special complexity for tuple to cover this. As a user you could specify it,\n\nx: tuple[int, \u2026]\ny: tuple[int, \u2026]\n\nAnd then your sum function would work with those two arguments.\n\nIn practice I\u2019d just type ignore and move on if I ever end with tuple add problem here.\n\n[deleted]\n\nAnd that argument would be wrong.\n\n1. There is no immutable list. You have to use tuples in immutable contexts. Consequently, it\u2019s not hashable and therefore not cacheable. \n2. Adding two sequences doesn\u2019t imply you need a dynamic length sequence (and even then, see point 1). Adding two fixed length tuples results in another fixed length tuple.\n\nThe critical point is: Is the tuple\u2018s length known at the time of writing or is it known at runtime? The implementers of the typehinting ecosystem apparently prioritize tuples as \u201ccompile-time\u201c constants, i.e. the length is known at the time of writing. That\u2019s already implied by the difference between `List[int]` and `Tuple[int]`. Now here\u2019s my point: If you really think you can limit tuple usage mostly to fixed length known at the time of writing, that\u2019s just unrealistic. Let us have `frozenlist` and maybe that becomes a bit more realistic.\n\nKey take away, you can not count only on static checking, some checks have to be done at runtime, that is just Python nature", "id": "j82zlqs", "owner_tier": 0.5, "score": 0.2494172494055944}, {"content": "Lol.\n\nI\u2019m sorry but no. Type hinting is awesome and has caught so many bugs in my code it\u2019s ridiculous. If you have certain code that requires this level of dynamic typing then just use Any on the function in question and move on.\n\nTyping clues your users in how the function is supposed be used and what it returns. 99% of the code I write requires very specific argument types, and if it doesn\u2019t then I use Union or else Any as an ultimate fallback. That way your users are going to get a mypy error if they try to pass in a string or possible None to a math function expecting number types.\n\nIf you don\u2019t follow this advice then have fun inspecting excessively long functions to try and figure out what is supposed to be passed in and is returned. Heck, without mypy your functions could return different return types depending on the code path and now you have a major bug that slipped into prod!\n\nIn my experience, `typing` has not been particularly good for finding bugs compared with unit tests and consumes considerable effort.\n\nAnd I come from the C++ world, where everything is typed.  I _like_ typed languages!\n\nAnd I do add type hints to most of my code - _as documentation_. \n\nBut I rely on strong test coverage because tests can potentially find all bugs, not a small subject of bugs.\n\nI would say 80%+ of my bugs are returning a wrong value of the correct type, or a crash because one of my arguments was the right type, but out of range.\n\n> have fun inspecting excessively long functions\n\nExcessively long functions are a code smell and a problem for reliability whether or not they are typed.\n\n> Your functions could return different return types depending on the code path\n\nYour functions could return a wrong value of the correct type, depending on the code path.\n\nGood test coverage will find both of those issues.\n\n---\n\nAs a senior engineer, I would prefer a completely typed codebase.\n\nBut I have spent many hours helping juniors figure out how to type hint their programs, and none of them have ever come back to me and said, \"This found so many errors, wow!\" mainly because these projects already had good test coverage.\n\nSince I have to work with junior programmers, since time is limited, I prioritize tests over type checking.\n\n----\n\n> Lol.\n\nCan you knock that off?  We're adults here.  Mocking what someone said is not a good look.\n\n> If you have certain code that requires this level of dynamic typing then just use Any and move on.\n\n...but that would be a lie, wouldn't it? Is it better to have no annotations in that case at all or objectively wrong ones because the actually correct ones are extremely hard to express?\n\nYou don\u2019t understand the post.\n\nUnit tests only test what args you actually use. They don\u2019t test the unbounded set of all possible input types to your function that a user may throw into it.\n\nThe biggest win is preventing your users from putting in None into your function. Those None values screw your code paths and wreck havoc on code bases. None (and null in other languages) is the number one cause of all bugs in production. Heck, Google made an entire language, kotlin, primarily to fix the null crashes in Android.\n\nAdditionally, when I used type annotations the number of unit tests required decreased to a fraction of what I needed before.\n\nThere is literally no construct in python that finds so many deep bugs as type checking does.\n\nEDIT: and chat gpt uses those type hints to help generate code.\n\n> Can you knock that off? We're adults here. Mocking what someone said is not a good look.\n\nI mean, they did come on pretty strong with the \"type hinting sucks\" statement even if they did walk it back in the body of the post.\n\n> In my experience, typing has not been particularly good for finding bugs compared with unit tests and consumes considerable effort.\n\nAt my company (we have millions of lines of Python) it caught _lots_ of bugs and the effort was reduced by automated tooling for inferring the annotations\n\nUsing Any is not objectively wrong\u2026 at all.\n\nUntyped functions are equivalent to typed functions using Any.\n\nOP wants to throw the baby out with bath water and this makes no sense whatsoever. Use mypy and reduce the pain of users using your API. And if you don\u2019t then you only have yourself to blame because you threw out type checking over a freaking contrived corner case.\n\n>but that would be a lie\n\nNot at all.\n\nPython has dynamic typing - that's not an accident or a bug, it's a feature.\n\nType hints are not laws, they are \"hints\".\n\nConsider the trivial example:\n\n    def add_ints(val1: int, val2: int) -> int:\n        return val1 + val2\n\nMyPy will correctly show an error if you attempt to call \\`add\\_int()\\` with string arguments, because we have told MyPy to only accept integer arguments. But the Python code in this example will work perfectly well with string values.\n\nThe \\`int\\` type hint isn't a lie, it's just a hint about the *intended* use, and MyPy will warn us if we attempt to use the code in ways that were not intended.\n\nUsing the 'Any' type tells MyPy to accept any type, which means that we won't get useful hints about usage. It doesn't mean that code will work with \"all\" data types, it just means that MyPy won't complain about the type and won't offer useful hints. It also tells us that the author has considered the data type and chosen to not annotate restrictions.\n\nMy solution to the original problem would be to use \\`Any\\`. IF as a user of the \\`slow\\_add\\` function, I needed MyPy to be more restrictive, then I would write a wrapper for \\`slow\\_add\\` and restrict the types that the wrapper could accept. That would be my task as a user of library to suit my specific use case, not the job of the developer that wrote the generic \\`slow\\_add()\\`.\n\nPretty sure Google did not \u201cmake\u201d Kotlin, and they do *recommend* it for Android development. Kotlin was founded by JetBrains, although I\u2019d be surprised if Google hasn\u2019t contributed to it.\n\nI did not know this, and it surprises me.\n\nMost of the None errors that I experience come from data at runtime, meaning that no amount of static type analysis will help. Indeed, it can encourage me to be complacent and avoid using defensive strategies.\n\nThat said, I don't have much experience of typed, massive, interconnected codebases and am more familiar with untyped ones. Certainly, None issues didn't stand out particularly in those cases.", "id": "j8337r6", "owner_tier": 0.1, "score": 0.14801864800699302}, {"content": "slow_add is trying to do too much at once you were screwed from the beginning. It appears to me that you have purposefully made slow_add this functionally \"bloated\" as a strawman against type hinting\n\nIt's \"doing too much\" from the viewpoint of explicit typing. When your mindset is to consider each type separately, then you will see the function as bloated and unruly (as it tries to handle so many different types at the same time).\n\nBut from the mindset of classic Python duck typing, this is a very simple and elegant function that \"adds any two things that can handle being added\". What could be more simple?\n\nI'm not saying that one of those two mindsets is more correct. But I understand OP's call for more empathy between the mindsets.\n\nI disagree. I think the function is readable, usable, and has a clear purpose. Adding type hints degrades all of the above.\n\nOP's example demonstrates the adage ubiquitous in computing: no tool suits all jobs, use the right tool for the job. \n\nTyping isn't the solution to all problems.\n\n[deleted]\n\nIt\u2019s just an add function. That\u2019s the expressiveness of Python. Your argument is to castrate it to make it work with the type system. Might as well use Java or Go at that point.\n\nThere isn\u2019t any actual difference between the two mindsets.\n\nIf you consider the function from a types perspective, it\u2019s quite clear that you can\u2019t actually restrict the types of the argument. The underlying binary plus (operator.add) can\u2019t be restricted because any user is free to implement it however they want.\n\nIf you were actually trying to accurately type this function, it would be\n\n    def slow_add(a: Any, b: Any): -> Any\n\nOP\u2019s premise \u201cI can and must restrict these types\u201d is wrong and antithetical to proper typing.\n\nWhen you define the function without types, what you're saying is that you're delegating the responsibility to have types that work to the client. That's not \"elegant\" or \"simple\" for the client, although it might be simple for you because you simply don't want to deal with it. \n\nThe problem is that that's probably not your intention. If it's, mypy has you covered, just give an `Any` type to both parameter and return type, that will work.\n\nFunctions and methods should ideally have a single job, if you need the function or method to do more you extend it. Python has great tools for this including decorators, ABC, and class inheritance. \n\nOP gave a great example of the dangers of code that does too much. I've been using python since at least v2.6 and I have yet to come across issues with type hinting that actual broke the code (from when it was added in v3 something). On the other hand functions that do too much are usually broken from the start.\n\nFunctions and methods should ideally have a single job, if you need the function or method to do more you extend it. Python has great tools for this including decorators, ABC, and class inheritance. \n\nOP gave a great example of the dangers of code that does too much. I've been using python since at least v2.6 and I have yet to come across issues with type hinting that actual broke the code (from when it was added in v3 something). On the other hand functions that do too much are usually broken from the start.\n\nThis is like worst case scenario too much. If your code looks like this we have more to worry about than type hints. OP is clearly trying to present a strawman to demonstrate is point\n\nDidnt know expressiveness meant bad design. Some ducks shouldnt be able to quack even if they technically can. Type hinting should communicate that. Separate your functionality. On top of that OP is showing that type hinting cant elegantly support a *global* adding function. Therefore type hinting bad. Smells like a strawman to me", "id": "j833lqr", "owner_tier": 0.5, "score": 0.18181818180652679}, {"content": "Ironically, I think this post proves the exact opposite of what it's trying to, i.e. that typing works well.\n\n1. Guido actually mentioned something similar a while ago about typing, which is that he likes that it's not a core feature of the language, because you get the advantages of static typing but aren't bound to it in situations that aren't fitting, like this one.  \n\n2. If I ran into all these problems, I'd say that mypy was giving me a good indication that there's an architectural problem happening.  The issue basically boils down to, \"I have an API/library code that has behavior and use cases that are apparently impossible to define or constrain\".  Obviously this is a toy example, so it's hard to make specific claims but in real code I'd think things like, \"why do I need this incredibly generic function?\" or \"what behavior am I really trying to permit or constrain?\"\n\n      For example, my library probably isn't actually responsible for providing an \"add literally anything addable\" function.  Why is my function not constrained to adding types that are relevant and leaving adding other things to other libraries?  Or, if defining a robust addable type is important to my library, why haven't I done that, annotated a T = typevar('Addable', bound='AddableBase') and then provided helpers to box primitives or convert objects so that the 'right' answer for customers isn't to add anything willy billy, but to either implement a subtype of addable or to use my helpers/factories on their types to get an addable that my library is specialized to handle?\n\n      Mypy has correctly helped you identify potential code smell and the answer isn't to double down, it's to re-evaluate.\n\nIf you consider type hints as optional then I 100% agree with you.\n\nIf you expect type hints to guide you on your application development like types do in Rust you're likely to hit fundamental limitations of Python's type hints.", "id": "j840n3n", "owner_tier": 0.9, "score": 0.07226107224941725}, {"content": "Instead of \"type hinting sucks\", my conclusion would be \"type hints aren't meant to express every constraint on the arguments to a function, so don't adopt style standards that expect them to.\" If [`Any` is good enough when typeshed is hinting `operator.add`](https://github.com/python/typeshed/blob/main/stdlib/_operator.pyi#L53), it should be good enough for similar cases in your code.\n\nyup this post just screams of someone trying to force python to work like INSERT\\_FAVORITE\\_LANGUAGE\\_WITH\\_STATIC\\_TYPES\n\nwhat you say is true, but the point OP is making is that it's difficult to express this semantic in a more effective way. Either you go the Any way, which allows for absurdity like allowing int + int -> dict, or you go the painful way of doing what OP did. \n\nI think this only points out that the semantic flexibility of the typing system is still incomplete to be able to express this level of typing with the language we currently have. More PEPs may cover this gap.\n\nI love Python.  I just wish it didn't use whitespace delimiters (modern IDEs can do smart indenting), was strongly typed, 1-indexed, used `else if`instead of `elif`, and gave me direct memory access.  Totally unrelated, though: I *hate* FORTRAN.\n\n^^^^/s", "id": "j83kkor", "owner_tier": 0.7, "score": 0.057109557097902094}, {"content": "So you're saying that it's difficult to build a _global_ add function for every type, and you're frustrated or irritated about it?\n\nThis initial situation is horrible: non-graceful handling of errors (adding non-addable types being added, that's just praying for the best), just throwing.\n\nThe final situation is great (if it covers all cases). Yes, the code might look meh but hey, you tried to create a _global_ adder. That's the price the lib author has to pay to get there. The journey to get there just shows how painful the python ecosystem is when working with its dynamic types.\n\nTL;DR: the premise was bad, because it was to create a single function to add them all and in the type hinting bind them.\n\nNo, the premise is: Python is more expressive than its type system, so you have to choose: Fully make use of Python\u2018s expressiveness and accept some untyped code or limit yourself to a subset and have 100% type coverage. OP is arguing for the former, and I\u2019d agree. Because if you choose the latter, why choose Python in the first place?\n\nWhat??? The global function existed before. It\u2018s there and it works.\n\nI\u2019d say that OP isn\u2019t even arguing for that - they are just imploring the community to have patience and empathy for authors of code that have been designed before type hints were added (to the language/project).", "id": "j8378q8", "owner_tier": 0.3, "score": 0.06993006991841491}, {"content": "The thing to realise is that Python\u2019s typing system works the same as any mainstream statically typed language does. How would you type that function in a statically typed language like C#? It\u2019s tricky there so it will be tricky here too.\n\nPeople get frustrated with Python type annotations usually because they\u2019re trying to type hint a codebase that uses lots of dynamic language features. Typing works best when you type annotate from the start and the types steer the design of the codebase, and not the other way around.\n\nIt is actually possible to type this kind of function in modern C++, and people do use this pretty often.\n\n    auto slow_add(auto a, auto b) -> decltype(a + b) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        return a + b;\n    }\n\n`decltype` essentially means: *\u00abgive me the type you can infer for this specific expression\u00bb*, and would be checked for each use of slow_add, as opposed to trying to prescribe a single return type at the definition time. Typing in Python is still a very fresh feature compared to many other languages, and I can imagine a feature like that implemented in some future tooling, it would fit Python a lot.\n\nWhich means you\u2019re limiting yourself to a very unexpressive subset. Other languages have alternatives that Python doesn\u2019t offer (like *real* overloading and generics). This would be a non-issue with trait based generics. It\u2019s only tricky in languages where the type system doesn\u2019t match the expressiveness of the language.\n\n> dynamic language features\n\nIs why I use Python and not statically typed language.\n\nThat is cool and on hell ya it would.\n\nTotally unrelated but if you're `using namespace std::chrono_literals;` then you can specify the duration as `100ms` which is super cool.\n\nWhich ends up being very similar to\n\n>     def slow_add(a: Any, b: Any): -> Any\n      time.sleep(0.1)\n      return a + b\n\nIf by very similar you mean completely different.\n\nWith C++ the compiler identifies if S+T is even possible and emits the correct version of the function with the correct return type and then completes all subsequent static type analysis steps. If S+T is not possible you get a compile error. If the resulting type of S+T is incompatible with its subsequent use, you get a compile error.\n\nMypy when it sees Any+Any->Any and just stops checking types. It is perfectly with code that would take int+str and treat the output as a dict. There would be no objections from mypy, but when you ran the code it will obviously fail.\n\nI mean in terms of the syntax", "id": "j837x6j", "owner_tier": 0.1, "score": 0.07808857807692308}, {"content": "I read all the way through that to find its all numbers? What about the user who for some unknown reason decided to use my library to add strings!?\n\nStrings implement `__add__`, so they work with the fourth attempt.", "id": "j835has", "owner_tier": 0.7, "score": 0.038461538449883446}, {"content": "Exceptionally good post. This remins me of ~~\"don't write classes\"~~ \"Stop writing classes\" presentation. Going extreme in any python feature is a bad decision.\n\nEdit: name\n\nThe presentation is 1https://youtu.be/o9pEzgHorH0\n\nIt is called Stop Writing Classes because the title \"stop writing classes when it isn't necessary because you've come from Java and don't know any better\" isn't as pithy. No one, especially Jack dieterich means that you should never write classes, that would be silly.\n\n[deleted]\n\nOh, that's not that I meant. What I mean was, don't go extreme on neither subclassing, nor typing.\n\nSure other comment posted it.\n\nThat is the wise point to be made. Sorry that I misinterpreted you.", "id": "j83akrn", "owner_tier": 0.5, "score": 0.020979020967365966}, {"content": "Yes, exactly. As soon as you try to push python into statically typed realm, you find that python is not that good at type expressions.", "id": "j8375ow", "owner_tier": 0.5, "score": 0.006993006981351982}, {"content": "I think the trick here is to consider introducing type hints to be a breaking change. If you have them in from the start, awesome! If you're retrofitting them later, expect suffering.", "id": "j833mao", "owner_tier": 0.5, "score": 0.0023310023193473194}, {"content": "Awesome post OP.  Quite funny.  \n\nWhich users run mypy against other people's code though?  That's fine, and I could support that, but if a customer asked for it, as a freelancer I would require an extra work package or milestone ($$$).\n\nA huge benefit of type hinting is to catch bugs early at the source code stage, precisely by stopping otherwise addable things like tuples being passed to arithmetic functions.  \n\nSo you should've just pushed back against the request to support tuples.  Or at the very least, if a valuable customer requests that a clearly numeric type hinted function support tuples, then that's not the language's fault, it's your job to find a work around for them.", "id": "j83f4m8", "owner_tier": 0.1, "score": 0.0023310023193473194}, {"content": "Fuck these users. Who do they think they are, making you do all these changes while they could just fix their code.", "id": "j83f8ow", "owner_tier": 0.5, "score": -1.165501158417866e-11}, {"content": "As an old-school python programmer who remembers when built-in types and classes were a different thing, I fully understand the sentiment.\n\nTyping is a  path that eventually takes you to a bad state (Java) or to a place of mathematical correctness, a path that has been taken and you can see the results in Haskell, Rust, StandardML (my favourite somewhat).\n\nSo I'd rather have Python without types, and if I think I need types pick Haskell or something.\n\nThat being said, a primary reason for type annotations being added was that JetBrains  wanted to provide better code-completion.  This is probably a level where type annotations kind of make sense (could have been deduced from the docstrings though). That we have now type checkers and have TypeErrors on the static-analysis level is IMHO taking things a little too far. and Type Errors at runtime never were rare in production. Much rarer than any kind of logic error.", "id": "j83ic5q", "owner_tier": 0.5, "score": 0.001165501153846154}], "link": "https://www.reddit.com/r/Python/comments/10zdidm/why_type_hinting_sucks/", "question": {"content": "Type hints are great! But I was [playing Devil's advocate](https://www.reddit.com/r/Python/comments/10vh1v5/mypy_10_released/j7igi8q/?context=3) on a thread recently where I claimed actually type hinting can be legitimately annoying, especially to old school Python programmers.\n\nBut I think a lot of people were skeptical, so let's go through a made up scenario trying to type hint a simple Python package. Go to the end for a TL;DR.\n\n# The scenario \n\nThis is completely made up, all the events are fictitious unless explicitly stated otherwise (also editing this I realized attempts 4-6 have even more mistakes in them than intended but I'm not rewriting this again):\n\n**You** maintain a popular third party library `slowadd`, your library has many supporting functions, decorators, classes, and metaclasses, but your main function is:\n\n    def slow_add(a, b):\n        time.sleep(0.1)\n        return a + b\n\nYou've always used traditional Python duck typing, if a and b don't add then the function throws an exception. But you just dropped support for Python 2 and your users are demanding type hinting, so it's your next major milestone.\n\n# First attempt at type hinting\n\nYou update your function:\n\n    def slow_add(a: int, b: int) -> int:\n        time.sleep(0.1)\n        return a + b\n\nAll your tests pass, mypy passes against your personal code base, so you ship with the release note \"Type Hinting Support added!\"\n\n# Second attempt at type hinting\n\nUsers immediately flood your GitHub issues with complaints! MyPy is now failing for them because they pass floats to `slow_add`, build processes are broken, they can't downgrade because of internal Enterprise policies of always having to increase type hint coverage, their weekend is ruined from this issue.\n\nYou do some investigating and find that MyPy supports [Duck type compatibility](https://mypy.readthedocs.io/en/latest/duck_type_compatibility.html) for `ints -> floats -> complex`. That's cool! New release:\n\n    def slow_add(a: complex, b: complex) -> complex:\n        time.sleep(0.1)\n        return a + b\n\nFunny that this is a MyPy note and not a PEP standard...\n\n# Third attempt at type hinting\n\nYour users thank you for your quick release, but a couple of days later one user asks why you no longer support `Decimal`. You replace `complex` with `Decimal` but now your other MyPy tests are failing.\n\nYou remember Python 3 added [Numeric abstract base classes](https://docs.python.org/3/library/numbers.html), what a perfect use case, just type hint everything as `numbers.Number`.\n\nHmmm, MyPy doesn't consider any of integers, or floats, or Decimals to be numbers :(.\n\nAfter reading through [typing](https://docs.python.org/3/library/typing.html) you guess you'll just `Union` in the Decimals:\n\n    def slow_add(\n        a: Union[complex, Decimal], b: Union[complex, Decimal]\n    ) -> Union[complex, Decimal]:\n        time.sleep(0.1)\n        return a + b\n\nOh no! MyPy is complaining that you can't add your other number types to Decimals, well that wasn't your intention anyway...\n\nMore reading later and you try overload:\n\n    @overload\n    def slow_add(a: Decimal, b: Decimal) -> Decimal:\n        ...\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\n    def slow_add(a, b):\n        time.sleep(0.1)\n        return a + b\n\nBut MyPy on strict is complaining that `slow_add` is missing a type annotation, after reading [this issue](https://github.com/python/mypy/issues/3360) you realize that `@overload` is only useful for users of your function but the body of your function will not be tested using `@overload`. Fortunately in the discussion on that issue there is an alternative example of how to implement:\n\n\n    T = TypeVar(\"T\", Decimal, complex)\n\n    def slow_add(a: T, b: T) -> T:\n        time.sleep(0.1)\n        return a + b\n\n# Fourth attempt at type hinting\n\nYou make a new release, and a few days later more users start complaining. A very passionate user explains the super critical use case of adding tuples, e.g. `slow_add((1, ), (2, ))`\n\nYou don't want to start adding each type one by one, there must be a better way! You learn about Protocols, and Type Variables, and positional only parameters, *phew*, this is a lot but this should be perfect now:\n\n\n    T = TypeVar(\"T\")\n\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    def slow_add(a: Addable, b: Addable) -> Addable:\n        time.sleep(0.1)\n        return a + b\n\n\n# A mild diversion\n\nYou make a new release noting \"now supports any addable type\".\n\nImmediately the tuple user complains again and says type hints don't work for longer Tuples: `slow_add((1, 2), (3, 4))`. That's weird because you tested multiple lengths of Tuples and MyPy was happy.\n\nAfter debugging the users environment, via a series of \"back and forth\"s over GitHub issues, you discover that pyright is throwing this as an error but MyPy is not (even in strict mode). You **assume** MyPy is correct and move on in bliss ignoring there is actually a fundamental mistake in your approach so far.\n\n(**Author Side Note** - It's not clear [if MyPy is wrong](https://github.com/python/mypy/issues/14679) but it defiantly makes sense for Pyright to throw an error here, I've filed issues against both projects and a pyright maintainer has [explained the gory details](https://github.com/microsoft/pyright/issues/4613/) if you're interested. Unfortunately this was not really addressed in this story until the \"Seventh attempt\")\n\n\n# Fifth attempt at type hinting\n\nA week later a user files an issue, the most recent release said that \"now supports any addable type\" but they have a bunch of classes that can *only* be implemented using `__radd__` and the new release throws typing errors.\n\nYou try a few approaches and find this seems to best solve it:\n\n    T = TypeVar(\"T\")\n\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: T, other: Any, /) -> T:\n            ...\n\n    @overload\n    def slow_add(a: Addable, b: Addable) -> Addable:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> RAddable:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\nAnnoyingly there is now no consistent way for MyPy to do anything with the body of the function. Also you weren't able to fully express that when b is \"RAddable\" that \"a\" should not be the same type because Python type annotations don't yet support being able to exclude types.\n\n# Sixth attempt at type hinting\n\nA couple of days later a new user complains they are getting type hint errors when trying to raise the output to a power, e.g. `pow(slow_add(1, 1), slow_add(1, 1))`. Actually this one isn't too bad, you quick realize the problem is your annotating Protocols, but really you need to be annotating Type Variables, easy fix:\n\n    T = TypeVar(\"T\")\n\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    A = TypeVar(\"A\", bound=Addable)\n\n    class RAddable(Protocol):\n        def __radd__(self: T, other: Any, /) -> T:\n            ...\n\n    R = TypeVar(\"R\", bound=RAddable)\n\n    @overload\n    def slow_add(a: A, b: A) -> A:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: R) -> R:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\n\n# Seventh attempt at type hinting\n\nTuple user returns! He says MyPy in strict mode is now complaining with the expression `slow_add((1,), (2,)) == (1, 2)` giving the error:\n\n> Non-overlapping equality check (left operand type: \"Tuple[int]\", right operand type: \"Tuple[int, int]\")\n\nYou realize you can't actually guarantee anything about the return type from some arbitrary `__add__` or `__radd__`, so you starting throwing `Any` Liberally around:\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\n\n# Eighth attempt at type hinting\n\nUsers go crazy! The nice autosuggestions their IDE provided them in the previous release have all gone! Well you can't type hint the world, but I guess you could include type hints for the built-in types and *maybe* some Standard Library types like Decimal:\n\nYou think you can rely on some of that MyPy duck typing but you test:\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\nAnd realize that MyPy throws an error on something like `slow_add(1, 1.0).as_integer_ratio()`. So much for that nice duck typing article on MyPy you read earlier.\n\nSo you end up implementing:\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    @overload\n    def slow_add(a: int, b: int) -> int:\n        ...\n\n    @overload\n    def slow_add(a: float, b: float) -> float:\n        ...\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\n    @overload\n    def slow_add(a: str, b: str) -> str:\n        ...\n\n    @overload\n    def slow_add(a: tuple[Any, ...], b: tuple[Any, ...]) -> tuple[Any, ...]:\n        ...\n\n    @overload\n    def slow_add(a: list[Any], b: list[Any]) -> list[Any]:\n        ...\n\n    @overload\n    def slow_add(a: Decimal, b: Decimal) -> Decimal:\n        ...\n\n    @overload\n    def slow_add(a: Fraction, b: Fraction) -> Fraction:\n        ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\nAs discussed earlier MyPy doesn't use the signature of any of the overloads and compares them to the body of the function, so all these type hints have to manually validated as accurate by you.\n\n# Ninth attempt at type hinting\n\nA few months later a user says they are using an embedded version of Python and it hasn't implemented the Decimal module, they don't understand why your package is even importing it given it doesn't use it. So finally your code looks like:\n\n    from __future__ import annotations\n\n    import time\n    from typing import TYPE_CHECKING, Any, Protocol, TypeVar, overload\n\n    if TYPE_CHECKING:\n        from decimal import Decimal\n        from fractions import Fraction\n\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    @overload\n    def slow_add(a: int, b: int) -> int:\n        ...\n\n    @overload\n    def slow_add(a: float, b: float) -> float:\n        ...\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\n    @overload\n    def slow_add(a: str, b: str) -> str:\n        ...\n\n    @overload\n    def slow_add(a: tuple[Any, ...], b: tuple[Any, ...]) -> tuple[Any, ...]:\n        ...\n\n    @overload\n    def slow_add(a: list[Any], b: list[Any]) -> list[Any]:\n        ...\n\n    @overload\n    def slow_add(a: Decimal, b: Decimal) -> Decimal:\n        ...\n\n    @overload\n    def slow_add(a: Fraction, b: Fraction) -> Fraction:\n        ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\n\n# TL;DR\n\nTurning even the simplest function that relied on Duck Typing into a Type Hinted function that is useful can be painfully difficult.\n\nPlease always put on your empathetic hat first when asking someone to update their code to how you think it should work.\n\nIn writing up this post I learnt a lot about type hinting, please try and find edge cases where my type hints are wrong or could be improved, it's a good exercise.\n\n**Edit:** Had to fix a broken link.\n\n**Edit 2:** It was late last night and I gave up on fixing everything, some smart people nicely spotted the errors!\n\nI have a \"tenth attempt\" to address these error. But pyright complains about it because my overloads overlap, however I don't think there's a way to express what I want in Python annotations without overlap. Also Mypy complains about some of the user code I posted earlier giving the error [comparison-overlap](https://mypy.readthedocs.io/en/stable/error_code_list2.html#check-that-comparisons-are-overlapping-comparison-overlap), interestingly though pyright seems to be able to detect here that the types don't overlap in the user code.\n\nI'm going to file issues on pyright and mypy, but fundamentally they might be design choices rather than strictly bugs and therefore a limit on the current state of Python Type Hinting:\n\n    T = TypeVar(\"T\")\n\n    class SameAddable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class SameRAddable(Protocol):\n        def __radd__(self: T, other: Any, /) -> T:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    SA = TypeVar(\"SA\", bound=SameAddable)\n    RA = TypeVar(\"RA\", bound=SameRAddable)\n\n\n    @overload\n    def slow_add(a: SA, b: SA) -> SA:\n        ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RA) -> RA:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b", "id": "10zdidm", "title": "Why Type Hinting Sucks!", "traffic_rate": 207.942496260595}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "Ummm ... if a function returns a collection of rows matching a criteria, and finds none that match, should it not return an empty collection?\n\n\n\nYes, in the case of a collection returned, the empty collection seem to be the best choice when nothing has been found, but what to do if you ask for a unique value, and no value found is a normal case that you prefer to handle without exception catching, like with a *get_me_user_if_exists(id)* function? Then None seem to be the correct return value, but its meaning overlaps with other None result.\n\nReturning a *no_user* singleton would make it not so obvious to handle, especially in a \"if not user:\" context, or would you use  **__non_zero__** black magic?\n\nEdit, sorry for the boldface, not very used to reddit markup and didn't find a <tt> equivalent.\n\n[deleted]\n\nYour problem seems to be that you're overloading `None`. You want it to mean \"a value of `None` was put into the cache\", but you *also* want it to mean \"no value exists in the cache corresponding to what you asked for\". So the first thing you need to decide is what you want a value of `None` from the cache to mean; then you can see if you need to change what you're putting into it or change the way you handle that value when it comes from the cache.\n\n(also, don't be afraid of exceptions! Raising some sort of \"you asked for something I can't give you\" exception is *not* a bad thing)\n\nYour function name is wrong, it should just be *get_me_user()* and return an *exception* if the user does not exist.\n\n    try:\n        user = get_me_user(id)\n    except:\n        pass # Whatever you do if the user does not exist.\n\nPython has a very efficient way of dealing with exceptions, no stack trace overhead like most other languages. In Python, exceptions are usually the way to go.\n\nBackticks are the <tt> equivalent: \\`\\_\\_nonzero\\_\\_\\` produces `__nonzero__`.\n\n\nErm ... what was getting at is if you say to the database \"give me back a list of all the guys named Steve\", then if there isn't anyone called Steve, it should give you back an empty list, not an unexpected thing like None or False or 0.\n\nOf course, there are some situations, like looking up a user by a user_id which is a primary key, where you might want the function to return just a single user rather than a list of users with length 1.  But it might be appropriate in those circumstances to throw an exception because you that magic primary key you got from *somewhere* turned out to be *wrong*.\n\n\n... There, I said it, Django gets something right :-)\n\n\n\nAlternatively, if the function is returning an arbitrary number of collections (including zero) with arbitrary results (including `None`), it could be implemented as a generator. This allows the code to use Pythonic constructs like\n\n    for result in function(arguments):\n         operate(result)\n    else:\n         no_results_found_handler()\n\nAnd most importantly, because generators hold state, it might be possible to handle cache/memoization implicitly (depending on whether OP's use case allows it), rather than having an explicit variable holding it.\n\nI'm sure you just left it out for tge eake of brevity, but I feel it is important to mention: always catch a specific exception.  Eg:\n\n    try:\n        user = get_user(user_id)\n    except KeyError:     # or whatever\n        do_something()\n\nBecause consider what happens here:\n\n    try:\n        user = get_uesr(user_id)\n    except:\n         do_something()\n\nHint: did you miss a NameError?\n\nI think in this context raising an exception is the correct thing to do if (and only if) finding no user is a special case or an abnormal result. If it is expected and normal, for instance if this user id is coming from some user input, then returning something that has the meaning of \"no user\" seem better.\n\nIn fact it comes to collapsing two functions, user_exists() and get_user(), into a single get_user() that tells you nicely that if the result is not a user, then, well, there is no user at this number.\n\nThe code becomes as simple as it can be:\n\n    u = get_user(123)\n    if not u:\n        return 'oh no!, no user'\n    # do something with this user\n    return 'you got it'\n\nRaising an exception in this context and having to catch specifically an exception seem to be hindering a bit the readability and simplicity.\n\nwrong use of for/else\n\n    >>> for a in [1]:\n    ...     print a\n    ... else:\n    ...     print 2 \n    1\n    2\n", "id": "c59kez3", "owner_tier": 0.5, "score": 0.8428571427142857}, {"content": "One trick is that you can create cheap singletons via...\n\n    NO_RESULT = object()\n\nAnd then import that singleton everywhere, and use it as the special cache return value. If needed you can even use a class type which evaluates to False. \n\nThe one thing is that you have to use this very sparingly, as you can easily get tangled up in a mess of special singletons, not knowing which ones you can return where, and under what conditions. When I use something like that, I try to get it out of the way as fast as possible, minimizing the number of functions in a chain which might return weird values. \n\nThe other option is to change the cache return value to be a tuple `(True,value)` or `(False,None)` so you can distinguish the cases... though I've found this is slightly more annoying to use, but it does save the need to always import NO_RESULT from whereever it was defined.\n\n[deleted]\n\nI like to use this trick for default arguments, when you want to distinguish between None and no argument being given.\n\nThe other option for return values, of course, is to raise a KeyError.\n\nYes, that's a possibility.\n\nBut it would mean that client code should always check a returned value against such a singleton, so it would need to import explicitely the caching module, and this would add quite some lines in the code base.\n\nExceptions are for exceptional conditions only IMO, depending on context, \"NO_RESULT\" may not be \"exceptional\"\n\nAs pointed out later a cache miss is a much more valid \"exceptional\" behaviour than a no result (again I suppose that depends on context).\n\nI don't think this is accurate. Look at [iterators](http://docs.python.org/py3k/library/stdtypes.html#iterator-types). When you call \\_\\_next\\_\\_() on an iterator with no items remaining, it raises a StopIteration exception.\n\nWhat if, for whatever reason, you want to be able to cache the value NO_RESULT? Then you have the same problem you had before. Exceptions are the only way to completely avoid this.\n\nIf you try to read a value from a cache given its key, and that key does not exist in the cache, that sounds like an exceptional case to me-- the function reaches a state in which it can not possibly provide coherent output for its input.\n\nYou seem to have other languages' ideas of exceptions deeply ingrained in the way you're thinking. Which, when applied to Python, may not be a good thing -- there are languages where you bend over backwards and do everything you can imagine, including over-complicating your code, in order to avoid using an exception, but Python *isn't one of those languages*.\n\nIn Python, it's OK to use exceptions to signal something other than \"program is crashing now\". In Python, exceptions *are* used, frequently, to do precisely that sort of signalling. This is not a bad thing, just a *different* thing from what you're probably used to.\n\nMaybe infinull comes from the Java or C++ world where, commonly, exception handling was implemented very poorly and/or poorly understood, leading to a desire to avoid its use. \n\nAnd that kind of rubs me the wrong way, but I understand why that design decision was made., I dunno Exceptions & sentinels are both kind of terrible in their own way.\n\nExceptions stop execution if they aren't handled, then again, a sentinel could cause some sort of `TypeError` and the point would be moot.\n\nFor something like a query, returning an empty collection on no result, feels like \"the right thing\" a cache miss, is pretty exceptional, and I can dig that.\n\nStop iteration is a pretty unusual case, there's basically no way to determine whether what it returns is exceptional, unless you use the tuple return method, and that's clearly bad, so I can dig exceptions there.\n\nCache miss has similar properties. A Query doesn't have these properties IMO, but there are clearly some judgement calls here.\n\nI dunno on the one hand, I have a hard time calling sentinels unequivocally bad, they seem to have a lot of the same bad properties that exceptions have, on the other, I can't think of a valid use of sentinels in an interface (w/i a function fine, but not as return values/arguments).\n\nI think you missed my ninja edit, but that's OK.", "id": "c59kamz", "owner_tier": 0.5, "score": 0.9999999998571429}, {"content": "Perhaps it would be more useful for the caching function to return a tuple or an object, and pass the status along with the value, so you can check if the item was found or not. Of course, this assumes that you wrote the caching function, which might not be the case. That's just my initial thought. Something along the lines of:\n\n    status, obj = cache.get('my item')\n\nAlso, instead of your functions returning None, you could write them to return an empty instance of whichever data type it's using. So {} for dict, [] for list, etc.\n\nHaving a return code sounds like like a very C-ish solution. Surely, raising `KeyError` (or another exception provided by the caching module) upon a cache miss would be more Pythonic?\n\nwhile i've read on python.org that raising errors are Pythonic, I never understood why.  i only raise errors when there's been a problem.  in this case there's no problem; it's just a special case.  can you explain why you would use error handling to deal with this case?\n\nI'm surprised no one has suggested this yet. Raising KeyError (or a new exception such as CacheError) seems like a good way to do it, but then you have to wrap all the function calls in try except statements, which (depending on the size of the codebase) could be a ballache.\n\nThe use of exceptions for \"special cases\" rather than \"problems\" is mirrored in the standard library, for instance the use of `StopIteration` in iterators. It's more of a \"problem\" if `StopIteration` **isn't** raised, yet `StopIteration` is used to indicate the special case that the iterator is done.\n\nI usually think of a Python exception not as meaning \"something is broken\", but rather meaning \"I'm doing something different to what you expected me to do for some reason\" (or more specifically, in some cases including this one, \"I can't give you a meaningful return value\").\n\nIn this case, `cache.get()` is expected to get something from the cache; it raises `KeyError` or some other exception (say `CacheMissException`) to tell the calling code that it couldn't do that because of the special case that the key isn't in the cache. In the iterator example, `iterator.next()` is expected to return the next item to iterate over; `StopIteration` indicates the special case that the iteration is done.\n\nOne could probably argue that the words \"exception\" and \"special case\" are close to synonymous.\n\nI think that's the difference between \"special case\" and \"something is brokenn\" is the difference between exceptions called `SomethingException` and `SomethingError` in the standard library, although I haven't studied the names of the stdlib exceptions in depth.\n\nAlso of note: Pythonicness of using exceptions here aside, the alternative - error codes - would probably be considered un-Pythonic. (Or, at least, I think so.)\n\nIt's always going to be a PITA changing the behaviour of the cache in any way (return values or exceptions); I just think raising an exception is the better way to do it.\n\nPlus, if you forget something, \"unhandled KeyError on line x: cache.get(foo)\" is going to be a hell of a lot easier to debug than \"SomeRandomError on line some-unrelated-line: can't contatenate str with tuple\"\n\nWell every time this is called you'd need to be checking its return value anyway, so it isn't *more* code, just different code. It sounds like since new behaviour is being added, changes will be needed to the codebase no matter what.\n\nI think the idea of \"I can't give you a meaningful return value\" sums up exceptions perfectly.\n\nThat makes sense especially with the differentiation between SomethingException and SomethingError.  I always had in my mind that the they were synonymous, but they don't need to be used that way.\n\nthanks!\n\nAnytime. As I said, though, I haven't really looked at them in depth so I could be wrong and it could be completely arbitrary.", "id": "c59kff2", "owner_tier": 0.3, "score": 0.2428571427142857}, {"content": "I'm not clear why you don't write a class and/or function which encapsulates all the involved steps.\n\n    def query_db(arg):\n        cached = existing_cache_system.get_cached_query(arg)\n        if cached is not None:\n            return cached\n        # run query manually\n        # cache query if appropriate\n        # return result\n\nAny reason something like this wouldn't work?\n\nIf the result of existing_cache_system.get_cached_query() is None (for whatever reason), you would end up running existing_cache_system.get_cached_query() every time you used that value.\n\nMore pythonic, have the cache raise an exception if nothing was found, no *None* needed.\n\n    def query_db(arg):\n        try:\n            cached = existing_cache_system.get_cached_query(arg)\n            return cached\n        except:\n            # run query manually\n            # cache query if appropriate\n            # return result\n\n\nOP wants to cache None in some cases... if None is the empty cache value, then one cannot cache it.", "id": "c59krvd", "owner_tier": 0.1, "score": 0.07142857128571428}, {"content": "Return a tuple rather than \"Sometimes status, some times cached value\". Silly non-object oriented example:\n\n    import time\n    _cache = {}\n\n    def cached(key):\n        if key in _cache:\n            return _cache[key]\n        return (None, None)\n    \n    def expire(key):\n       del _cache[key]\n    \n    def cache(key, value):\n        _cache[key] = (value, time.time())\n    \n    \n    def example():\n        cache(\"fred\", 1337)\n        (v,t) = cached(\"fred\")\n        if not t: # assumes cache can't be populated on 1970-01-01 00:00:00.000Z !\n            print \"It was not cached\"\n        else:\n            print \"Value \", v, \" cached at \", t\n        (v,_) = cached(\"bob\")\n        if not v:\n            print \"Not here in any form\"\n\n\n\nThat way, users who care about the None-ness vs. not-cached-ness can inspect the time. If you don't care, just use the first value of the tuple, v.  You can customize this to do expiry, etc.", "id": "c59o1tk", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "That's broken.  Can you change what you send into the cache?  That is, always, always, always make a tuple on sending the value into the cache, and unpack it?\n\n(None,)\n\nNone\n\n    def cache(function, *args, **kwargs):\n        cached_value = get_cache(function, args, kwargs)\n        if cached_value is None:\n            return_value = function(*args, **kwargs)\n            set_cache( (return_value,) , function, args, kwargs)\n        else:\n            (return_value,) = cached_value\n        return return_value\n", "id": "c59opoh", "owner_tier": 0.7, "score": 0.028571428428571428}, {"content": "My instinct here is to say the cache code is badly written: it doesn't seem pythonic to represent failure with a return code, if that's how you get your data out. Instead of returning None if the cache is empty, you should throw an exception.  Over the lifetime of the program, if it needs caching, misses are going to be the exceptional event.  That way, there's no value at all your cache can't handle.", "id": "c59osxg", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "ubernostrum suggested exceptions which was my first idea, but I have another one: return a tuple of two-items, one being the actual value and the second a boolean representing whether that value was cached or not.\n\nthen `(None, False)` would mean \"cache is empty\" and `(None, True)` would mean \"the value None is cached\"", "id": "c59xkif", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "Your cache should just raise KeyError when there is nothing, as None and [] are valid values that can be cached.", "id": "c59xwrb", "owner_tier": 0.7, "score": 0.014285714142857142}, {"content": "If you are wondering, this sort of problem is called the semipredicate problem\n\nhttp://en.wikipedia.org/wiki/Semipredicate_problem", "id": "c59zt0k", "owner_tier": 0.3, "score": 0.014285714142857142}, {"content": "If your cache is usually not empty (or if you're not worried about speed), you could raise an exception when the cache is empty, leaving you free to return None where there are no results.", "id": "c5arwat", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "can use Ellipsis object as sentinel\n\nSounds like an odd use - if anything its interpretation is \"More\", not \"None\"!", "id": "c59lvxh", "owner_tier": 0.7, "score": 0.014285714142857142}, {"content": "That's why you can also do `if foo is None`.", "id": "c59mqh2", "owner_tier": 0.3, "score": -1.4285714285714285e-10}], "link": "https://www.reddit.com/r/Python/comments/w23rn/none_false_0_or_as_returned_values/", "question": {"content": "I noticed in our project many issues arise from a gray blurry zone over null values, especially when returned from function or method that are cahed or memoized.\n\nA concrete issue: our caching cannot cache \"None\", because it returns \"None\" when cache is empty. So when we cache a function querying the database, if the result of the select is empty, we need to return \"0\", \"[]\", \"False\" or any other \"no result found\" value, but we can't use the most obvious one, which is \"None\" and is used to mean this exact \"no result found\" value in many other similar contexts.\n\nDid you meet this kind of issues? How did you solve them?", "id": "w23rn", "title": "None, False, 0 or []  as returned values", "traffic_rate": 207.942496260595}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "You would often see this used like this: \n\n    names = ['James', 'David', 'Terence', 'Steve', \n        'Pam', 'Pat', 'Stewart', 'Frederick']\n    names_with_a = sum( 'a' in n for n in names)\n\nAlso, newline escapes are ugly and you usually don't need them.\n\nI would argue that `['a' in n for n in names].count(True)` is a much more efficient and Pythonic solution.\n\nThanks, I actually don't use newline escapes in lists like this normally, but I do use them all the damned time (import statements, long strings outside of docstrings, with a good example of that being in assert statement error strings, actually luckily that's it), to maintain a width of 78 characters in my code. What do you recommend for long code lines? As a result of that response I checked the two most recent modules I've worked on and I only found one exception, where I was making a tuple without using parentheses, which I thereafter edited to include the parentheses, which I do like better, so, thanks for that. :)\n\nIt's been a long time since I've used comprehensions due to readability, how common are they in professional settings?\n\nIt's really not though. `sum()` over a generator is going to be far better here, especially if your list of strings is large.\n\nHow is that more efficient? You are making a list (memory cost) and then iterating over it (CPU cost) for no reason. \n\nPythonic is subjective. I'd argue my code could be just as pythonic by adding a few comments.\n\n> What do you recommend for long code lines?\n\nOption 1: use variables. They double as comments. \n\nOption 2: use brackets, like parenthesis. In most cases, like your example, you already have them there. \n\nOption 3: just go over. PEP8 is not a law. You can choose to disagree with it. \n\n> It's been a long time since I've used comprehensions due to readability, how common are they in professional settings?\n\nExtremely common, but technically this is a generator, not a comprehension.\n\nBTW a triple quoted string is not the same as a docstring. \n    \n    def func():\n        \"any string in this position is a docstring\"\n        print(\"\"\"the only thing special about a triple quote string\n            is that newlines are included\"\"\")\n        print(\"but it's usually better \"\n            \"to simply concat normal strings like this\")\n\n`count` is definitely faster than `sum` and is much more explicit about the process being carried out.\n\n    names = ['James', 'David', 'Terence', 'Steve', 'Pam', 'Pat', 'Stewart', 'Frederick'] * 100\n    print(timeit(\"sum('a' in n for n in names)\", globals=globals(), number=10))\n    print(timeit(\"['a' in n for n in names].count(True)\", globals=globals(), number=10))\n\n`sum`: `0.06602010000005976`  \n`count`: `0.05176459999995586`\n\n> Best: use variables. They double as comments. \n\nDeclarative variables are great, and yeah I'm using a CLI for my program so I have \"prompt\" as a lot of my string variables, but even so, sometimes the 78 limit doesn't fit, especially when I'm using f strings and/or (logical or?) it's deeply nested. :)\n\nThanks for the response on the comprehension/generator thing.\n\nI think the main problem with using the triple quotes like that is the whitespace on the left, correct? But yeah, by concatenating the strings that seems pretty solid, though it only works inside parenthesis. If instead of a print function you were assigning that string to a variable, would you wrap in in a str() function, or use the continuation symbol (\\).\n\nWow that's significant. I never knew count was that much faster than sum. Thanks.", "id": "h03mhqp", "owner_tier": 0.7, "score": 0.9999999995238095}, {"content": "I think this is what I'm using:\n\n    sum(1 for i in <container> if <condition>)", "id": "h055fte", "owner_tier": 0.9, "score": 0.14285714238095237}, {"content": "I\u2019d be hesitant in using tricks. If you can\u2019t understand it by skimming, you shouldn\u2019t use it imo.\n\nDamn, I honestly do this (bool to int math) a lot. :(", "id": "h04vecm", "owner_tier": 0.3, "score": 0.14285714238095237}, {"content": "That said, True is not 1 and False is not 0.  They fixed that in Python 3 and thank goodness.\n\nHmm, is it an object with an `__add__` method or something?\n\nIn python, everything is an object including integers, floats, and strings.  Simply checking equality doesn't check if they're the same.\n\n       1.0 == 1\n       True\n       1.0 == True\n       True\n       1 == True\n       True\n       # they're not the same object though\n       1.0 is 1\n       False\n       1.0 is True\n   False\n   1 is True\n   False", "id": "h05kqkk", "owner_tier": 0.7, "score": 0.19047619}, {"content": "What? I get it's a loop that counts the number of a in the items of a list and adds it to a variable but i don't get the title or what makes this particularly noteworthy.\n\nI understand the syntax but it seems i am missing the bigger picture, last time i used python was many months ago.", "id": "h05j2ro", "owner_tier": 0.9, "score": 0.04761904714285714}, {"content": "Wait, this has blown my mind. Does the 'in' cancel out the need for an if statement here? As a newcomer I would typically use the same syntax but:\n\n    for n in names:\n        if 'a' in n[0]:\n            names_with_a += n\n\nI also find this to be much more readable code. Not sure if I am just completely overlooking this or not lol\n\n&#x200B;\n\nEDIT: Typo\\*\\*\n\nI hope I'm correct here.\n\nin is an operator, and like a logical operator, it returns true or false, which can be numerically interpreted as 1 or 0.\n\nn[0] is just the first element of n. I should have written `'a' in n.lower()` instead, though, just in case the name was all caps or a was the first letter, etc.\n\nedit: I called in a logical operator, that's not correct.\n\nLOL Absolute Facepalm. \n\nI just realised what this code is even doing and my comment is absolutely rendered null and void at this stage. I retract all statements.\n\nIts been a long day\n\nSorry my code was incorrect and it should\u2019ve been if \u2018a\u2019 in n[0] == True: \n\nThat\u2019s my bad it\u2019s been a long long day\n\nAlso, usually in best practice it\u2019s best to convert your strings into lower or upper case, usually lower, when using them but for readability you should do this outside of a conditional statement so you have one singular instance of the lower case variable. If you\u2019re only using and converting it once it\u2019s okay but for multiple use-cases you should definitely always declare new_variable = old_variable.lower()", "id": "h04wlyj", "owner_tier": 0.3, "score": -4.761904761904762e-10}], "link": "https://www.reddit.com/r/learnpython/comments/np7vpl/psa_true_1_false_0_you_can_use_it_in_addition/", "question": {"content": "I assume some other languages have this but I never used it until I learned some python and it's amazing. Some example code (edited (in reddit) to cut the list width):\n\n    names = ['James', 'David', 'Terence', 'Steve', \n        'Pam', 'Pat', 'Stewart', 'Frederick']\n    names_with_a = 0\n    for n in names:\n        names_with_a += 'a' in n\n\nEdit to remove that `\\` for good reason.\n\nEdit part deux: Just want to say this thread has just a ton of awesome stuff in it, thanks very much everyone!", "id": "np7vpl", "title": "PSA True == 1, False == 0, you can use it in addition", "traffic_rate": 153.13018518518518}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "You'll likely need to format your code properly.\n\n`str(score)'/10'` is invalid though. Did you mean `str(score) + '/10'`?", "id": "hjywj08", "owner_tier": 0.9, "score": 0.9999999966666667}, {"content": "1. Format your code by indenting it with 4 spaces.\n\n2. You likely need a + sign between `str(score)` and the string that follows.\n\nEdit: here's how [friendly](https://friendly-traceback.github.io/docs/index.html) might be able to help you:\n\n\n     print(str(10)'/10')\n\n      Code block [4], line 1\n        print(str(10)'/10')\n                 ^\n    SyntaxError: invalid syntax\n\n        Did you forget something between `)` and `'/10'`?\n\n\n    [5]: why()\n\n    Python indicates that the error is caused by `'/10'` written immediately after `)`.\n    It is possible that you forgot a comma between items in a tuple,\n    or between function arguments,\n    before the position indicated by ^.\n    Perhaps you meant to insert an operator like `+, -, *`\n    between `)` and `'/10'`.\n    The following lines of code would not cause any `SyntaxError`:\n\n        print(str(10), '/10')\n        print(str(10) + '/10')\n        print(str(10) - '/10')\n        print(str(10) * '/10')\n    Note: these are just some of the possible choices and that\n    some of them might raise other types of exceptions.", "id": "hjywid7", "owner_tier": 0.5, "score": 0.33333333000000004}, {"content": "This is the problem:\n\n    str(score)'/10'\n\nIn a nutshell you need to add a `+`\n\n    str(score) + '/10'\n\nor, preferably, you'll want to use string formatting instead, like an f-string:\n\n    f'{score}/10'\n\nYou *can* add string literals next to each other as Python joins them automatically, but `str(score)` is not a literal.\n\n    print(\n        \"This will be printed, \"\n        \"and this comes right after on the same line.\"\n    )", "id": "hk1xrhd", "owner_tier": 0.7, "score": -3.3333333130750966e-09}], "link": "https://www.reddit.com/r/learnpython/comments/qqagza/syntax_error_but_it_seems_fine_yea_i_know_the/", "question": {"content": "Here is my code:\n        if score < 1:\n\t        print(str(score)'/10')\n\t        print('---')\n\t        print('You could improve!')\n\t        print(' ')\n\t        option = input('[1]- Submit score [2]- Exit')\n\nI dont get what\u2019s wrong with it? It says syntax error by line 2/the print score part. Any help?", "id": "qqagza", "title": "Syntax error but it seems fine! (Yea I know the answer is probably gonna be obvious af lol)", "traffic_rate": 153.17203703703703}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "> I thought s += b is the same as s = s + b, no?\n\nDepends on what `s` is. \n\nFor lists, no. `+` will add and return a new object, while `+=` will extend (mutate) the existing object.\n\nFor integers (and most immutable types) yes, it is exactly the same thing.\n\nbut apparently, += changes the type of string to array. Why doesn't \"+\" behave the same way?\n\nThis is interesting . Need to email Guido\n\nAgain, it depends on what `s` is and what the programmer that wrote the code for that type made it do. For lists, it will loop over `b` and adds each element to the existing list. For lists, \n\n    s += b \n\nis equivalent to \n\n    s.extend(b)\n\nOr\n\n    for item in b:\n        s.append(item)\n\nThat's why `b` can be any iterable, including strings.\n\n---\n\n> Why doesn't \"+\" behave the same way?\n\nIn short, because the person who invented python wanted it that way. I don't see the logic in it either.\n\nIn python, everything is overloadable. When you do `a + b`, you're actually calling `a.__add__(b)` or `b.__radd__(a)` (depending on how they're defined).\n\n`+=` uses the method `__iadd__`, which, again, any class can implement how they want. So `a += b` becomes `a.__iadd__(b)`, which may or may not be equivalent to `a = a + b` (i.e. `a = a.__add__(b)`).\n\nThis page has all the details: https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types\n\n> but apparently, += changes the type of string to array.\n\nto a list, strictly speaking.\n\n> Why doesn't \"+\" behave the same way?\n\nBecause '+' for sequence types represents concatenation, so forming a new sequence from the two operands (s and b). That isn't possible because the types are different.\n\n+= however means 'extend', so keep the left operand as-is, add the items from the right operand. That's possible because the b-string is iterable. \n\nI know, it's one perspective that can be argued and I would agree there's something to be said to keep + consistent in both cases (either they both work or they both don't), but I wouldn't see much benefit from it over the current implementation. Sometimes perfect stands in the way of good enough.\n\n>s += b \n\n>is equivalent to \n\n>s.extend(b) \n\nYou sure coz I have been very consciously avoiding += and using extend coz I didn't want it to discard and create objects for teeny tiny insertion.\n\nYes.  We tend to forget, but the combined operators like \\`+=\\` were not part of the language originally, because Guido valued simplicity.  They were added later (in Python 2.x?), and the team who added them chose a path that allowed it to work with any iterable.  It was not worth the trouble to modify the basic addition operator.\n\nJust tested it. Seems like it. \na = [1,2]; b = a\n\nIf I use \"b = b +\"2\" \", a would still be [1,2] while b is [1,2,\"2\"]. \n\nBut if I use \"b +=\"2\" \", a would change along with b to [1,2,\"2\"]. (This has the same results as extend)\n\nFunctionally, += at least doesn't recreate a new array and assign it to the variable, but extends the current array object with the new elements.\n\nOh great. Thank you.", "id": "jw8orxz", "owner_tier": 0.7, "score": 0.9999999998039215}, {"content": "`s += b` means `s.__iadd__(b)`.*\n\n\n`s = s + b` means `s = s.__add__(b)` (assuming `s` supports `__add__`, which it does, but not for other types).\n\n\nIn this case `s` is a `list`, so `__iadd__` winds up extending `s` with each element of the iterable `b`. `extend` accepts any iterable to append all its items to the existing list, and a string is an iterable of characters.\n\n\n`__add__` is valid for concatenating two lists into a new list, but it is not for concatenating a list and a non-list iterable, so we get a `TypeError`.\n\n\nhttps://docs.python.org/3/reference/datamodel.html#object.__iadd__\n\n____\n\n\\* See minor correction below\n\nSmall correction: `s += b` is `s = s.__iadd__(b)`\n\nThis is the real answer.\n\nTrue, for those wondering what you're talking about, `__iadd__` returns `self` in this case, so the object gets mutated, then `s` gets assigned to refer to the same object it already referred to.", "id": "jw96dbj", "owner_tier": 0.5, "score": 0.19607843117647059}, {"content": "> I thought s += b is the same as s = s + b, no?\n\nNot always. If s is a list, it's actually the same as `.extend`. It depends on the type of s.", "id": "jw8zyjv", "owner_tier": 0.5, "score": 0.01960784294117647}, {"content": "    __iadd__ = <method-wrapper '__iadd__' of list object>\n    Implement self+=value.\n\nIn Python, `+=` implements an object's `__iadd__` method. This is an augmented assignment operator and acts on iterables. In Python, Strings are iterable.\n\nWhen the object is a list and is passed an iterable, the iterable is appended to the list (added in-place):\n\n    mylist = []\n    mylist += \"A\"\n    print(mylist)  # Prints ['A']\n\nThe same as:\n\n    mylist = []\nmylist.__iadd__(\"A\")\nprint(mylist)  # Prints ['A']\n\nWhen passed an iterable with more than one element, \\_\\_iadd\\_\\_ iterates through the elements and appends them to the list:\n\n    mylist = ['a', 'b', 'c']\n    another_list = [1, 2, 3]\n    mylist +=  another_list\n    print(mylist)  # Prints ['a', 'b', 'c', 1, 2, 3]\n\nNote that this does not work because numbers are not iterable:\n\n    a = []\n    b = 3\n    a += b\n    Traceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'int' object is not iterable\n\n\nIf you want to append a non-iterable, such as a number, to a list, you can do so like this:\n\n    my_list += (7,)\n\nNote the comma after the number literal which means that we have a tuple  with one element, and tuples are iterable.\n\nThere is also an equivalent `operator` function: [iadd](https://docs.python.org/3/library/operator.html#in-place-operators)\n\n(The link goes to the docs).\n\n\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\n\nAn expression like `x += 1` is roughly equivalent to `x = x + 1` but not exactly the same. \n\nWhen using the augmented assignment operator `+=`, then `x` is only evaluated once, and if `x` is a mutable object, the value `1` is assigned in place (appended) to `x`.\n\nWhen using x = x + 1, then x is evaluated twice (each time it occurs).", "id": "jw9dfy6", "owner_tier": 0.3, "score": -1.9607843018088803e-10}], "link": "https://www.reddit.com/r/learnpython/comments/15rhl4l/why_is_it_the_case/", "question": {"content": "s = \\[\\] b = \"abc\"  \nI can do s += b, which makes s to be \\['a', 'b', 'c'\\]  \nBut if I do s = s + b, it throws exception  \nI thought s += b is the same as s = s + b, no?  \n", "id": "15rhl4l", "title": "why is it the case?", "traffic_rate": 153.17203703703703}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "Hard pass on #4. If I see someone popping exceptions left and right as a signal of \"I didn't find what you asked for\" that code does not make it past code review.  A try/except is cheap (as long as the exception is rare) but code littered with these every time it tries to call another function is ugly and painful to refactor.\n\nA function with a return type of Optional[some_normal_return_type] is fine and the resulting code is usually cleaner and easier to read/understand.\n\n[deleted]\n\nAgree that it is certainly not an absolute rule, but the opposite is also not always best practice.\n\nThe most important thing is to have clearly defined semantics / a clear interface contract. In many cases, returning None is perfectly acceptable, while in other cases an error makes more sense.\n\nNote that in the standard library both approaches are also taken: `d[key]` gives an error if key cannot be found, while e.g. `d.get(key)` and `re.match` return None. In frequently used libraries both choices also exist, e.g. Django `model.objects.get` raises an `NotFoundError` if no objeect is found, while `requests.get` returns an object with a non-OK status code, and then have a `raise_for_status` method to raise an Exception anyway... In all these cases the opposite choice would also make perfect sense.\n\nAnd ironically, 5 is a direct violation of 4, as dict.get (without default) returns None when the key could not be found, while rule #4 claims that it should raise an exception instead :)\n\nI defer to returning None, which is semantically similar to returning null on a database query.\n\nOne thing I find odd about point #4 is that in general the rule (don't return more than one object type in function call) makes sense but the specific example is not the best illustration. I would look very askance at a function that could return either an `int` or a `str`.\n\nThat said, I have mixed feelings about Python's `Optional[Foo]` effectively meaning `Foo|None`. I program in multiple languages and and after experience true `Optional` objects such as in Haskell or Java8 I'm less of a fan of returning None to indicate failure/missing/whatever.\n\nCould you give an example for the second paragraph? Clarity on what you mean by  Optional[some_normal_return_type]?\n\nI came to say the same thing.\n\nI agree. Also I think in the example provided by the author it would be even better to return values of correct type but where I am certain this is not feasible output, e.g. returning None, -1 instead of just None, or None, NAN\n\nThis keeps not only the consistence of the output but also makes it easy to check if something went wrong.\n\nAnd using the base exception class, no less, to make sure that you can't just catch this exception without catching every possible exceptions...\n\nYep, it annoys the hell out of me that None is somehow a type all of its own. It's absolutely fine for a function to either return something or return None, I don't see that as returning different types.\n\nSuggesting that the function should raise an exception instead isn't helpful either. That means the caller needs to use a `try..except` block instead of just checking whether the function returned None. The latter is fewer lines and easier to read.\n\nI actually like exceptions everywhere.\n\nCould you make a post explaining what you think is too much exceptions with some examples or just dm me some stuff.\n\nI'm out here always trying to learn. What's wrong with duck typing", "id": "gjc3o6t", "owner_tier": 0.3, "score": 0.9999999999781182}, {"content": "These aren't even anti patterns, just like random syntatic sugar stuff for python.  stop posting crap like this\n\nHey, if you follow all these best practices you can take the runtime of a 20 second script down to 20 seconds\n\nBarely even that. Most of these have cases for them. It's just \"here's things I like more and don't know how to use\"\n\nB-but my micro-optimizations!\n\nLike that fact that number 7 is literally wrong, as the only way to create an empty set is by using `set()`. There's no empty literal for a set.\n\n\\#7 really bothered me because I've come from a different mindset, that the `list` and `dict` functions are like constructors, returning a new instance of the object, where using a literal reads as \"set the value equal to this specific object\". I have always recommended people use `list()` instead of `[]`\n\nHonestly, it doesn't matter. Useb whatever you want in your project, just be consistent.", "id": "gjclt1h", "owner_tier": 0.5, "score": 0.49015317284463894}, {"content": "**#7** There is no literal syntax for an empty set :(\n\n[deleted]\n\nYeah, 7 makes absolutely no sense\n\nYeah I noticed that too. I think the author meant to write tuple instead of set.\n\nI wish the syntax for an empty set was \n    \n    s = {}\n\nand for an empty dict\n\n    d = {:}\n\nI ran this on an old 2011 mbp, but the results surprised me:\n\n    $ python -m timeit '[]'\n    5000000 loops, best of 5: 44.2 nsec per loop\n\n    $ python -m timeit 'list()'\n    2000000 loops, best of 5: 126 nsec per loop\n\n    $ python -m timeit '{}'\n    5000000 loops, best of 5: 44.9 nsec per loop\n\n    $ python -m timeit 'dict()'\n    2000000 loops, best of 5: 166 nsec per loop\n\nhttps://images.app.goo.gl/vdCdv84G9pPGUrMC8\n\nThis is actually pretty good. Not as readable, but still good.\n\nWouldn\u2019t \n    s = {,}\nFor empty sets make more sense to not break existing code?\n\nMaybe we can push for it in py40 (or the macros PEP gets adopted and someone releases a package to change the syntax)\n\nThe use of {} for empty set makes more sense in terms of classical representations of it, and it should have been the empty set literal from the start.  I personally agree that {:} would make more sense as an empty dict literal with that history considered, but {,} as the empty set literal is probably the best solution for backwards compatibility.  \n\n\nAlternatively we introduce \u00d8 as the empty set icon and request that all python developers get a Norwegian keyboard or get REALLY good with their alt-codes.\n\nit would break way too much existing code.", "id": "gjcn4iq", "owner_tier": 0.5, "score": 0.24945295402625822}, {"content": "    comma_seperated_numbers = ','.join(name for name in my_fav_superheroes)\n\nHow is that good practice? It's totally equivalent to\n\n    comma_seperated_numbers = ','.join(my_fav_superheroes)\n\nassuming that `my_fav_superheroes` is an iterable &mdash; as it must be, for the first form to work.\n\nProbably meant to do something more like this instead:\n\n`comma_seperated_numbers = ','.join(superhero.name for superhero in my_fav_superheroes)`\n\n[deleted]\n\nYeah. that would make more sense.\n\nA generator is an iterable too.\n\nThat's right, thanks for correcting me. I thought it was reverse.", "id": "gjcfjvr", "owner_tier": 0.3, "score": 0.12472647700218818}, {"content": "\\#7 looks like a premature optimization.\n\nI would say that using literals for initializing empty collections because it's more performant is unnecessary. Do it because it's the more standard style. On the other hand, I'd really enjoy seeing this empty set literal the author mentioned.\n\nIt's premature micro-optimization. Which in 99% cases (anywhere other than loop doing little else and run a massive number of times) savings will be insignificantly miniscule.\n\nIt's also just clearer and more consistent (works like set, like all the other thing that doesn't have special literal syntax) to use full names int() list()  set() dict(), etc.\n\nHow about the empty immutable tuple. Very useful when you need nothing but a tuple.\n\nIt looks like there isn't\n\nbut you can do this \\^^ :\n\n    In [1]: s = {0}-{0}\n    \n    In [2]: type(s)\n    Out[2]: set\n\nhttps://stackoverflow.com/questions/6130374/empty-set-literal\n\n[deleted]\n\nSnazzy for default arguments.\n\n    def f(items=()):\n        s = set(items)\n\nFinally, some common sense. Myself, I prefer `{*()}`.\n\nI know less about python than I already knew I didn't know.\n\nIs this a true Singleton or just an optimization in the reference implementation like small integers?\n\n    a = 1 + 1\n    b = 2\n    c = 750 + 750\n    d = 1500\n    print(a is b)\n    print(c is d)\n\nWow that's quite something. Although it doesn't look as a shocked emoji face as emoji like as `{0}-{0}`", "id": "gjc4dei", "owner_tier": 0.5, "score": 0.16630196934354488}, {"content": "What is #8 about ... \"pushing debugger\"? What does that mean?\n\nShipping code littered with `breakpoint()` calls.\n\nLeftover `print()` or `logger.warning/info/debug()` from during debugging?\n\nYeah, not particularly helpful to show no examples for that one.\n\nThanks!\n\nWhat is the pro of debugging like this instead of setting breakpoints in the GUI in an IDE?\n\nCalls to `logger.debug` are fine as long as you have an appropriate logging level set to production and you aren't interpolating strings yourself in the call. Calls to info/warning/error is just normal course of business.\n\nI'm definitely not a seasoned python programmer but are \n\n    if __debug__:\n            print(\"you're so wrong\")  \n\nok?\n\n`pdb` is in the standard library and works in a terminal, so you can use it to debug python code *anywhere*. Also, some folks don't use an IDE. Many people do all their coding in a text editor like (neo)vim, emacs, or sublime text. In these cases, a terminal debugger may be your only option. Graphical debuggers are very nice, but there isn't really anything you can do in most graphical debuggers you can't also do in `pdb` if you know what you're doing and prefer a terminal interface.", "id": "gjchyuf", "owner_tier": 0.7, "score": 0.10065645512035011}, {"content": "Missed an opportunity to call out all those people who try/except, catching all exceptions and then silently pass them.\n\n@#$&\n\nEdit:\n\nAnyone who doesn't know what I'm talking about: https://realpython.com/the-most-diabolical-python-antipattern/. You also see warnings about it when you 'import this'.\n\nThis should be number 1 indeed. I would also add  \"put kwargs in every function\" (just in case) + pass half of the arguments through\n\nAnd #4 is great because his fix *requires you to catch all exceptions* if you want to safely run the function!", "id": "gjcu8gw", "owner_tier": 0.7, "score": 0.03719912470459518}, {"content": "Is #7 really an anit-pattern? I think thats perfectly fine. And \"relatively slower\" is completely over-the-top. It is *trivially* slower. Slower, yes. But of any importance, no.\n\nAlso, you lose the symmetry with sets since `{}` is an empty dict, not an empty set (which I understand why but still)\n\nAlso, #8 is not an \"anti-pattern\". It's a mistake (or bug)", "id": "gjd64y7", "owner_tier": 0.7, "score": 0.02188183805251641}, {"content": "> 1. Not using with to open files\n\nWith is a godsend but can get messy with complex setups.  While you can use commas for two I would suggest using an ExitStack for more than one.\n\n    from contextlib import ExitStack\n    \n    with ExitStack() as cm:\n        res1 = cm.enter(open('first_file', 'r'))\n        # do stuff with res1\n        res2 = cm.enter(open('second_file', 'r'))\n        # do stuff with res1 and res2\n \nExitStack can also add non-context cleanup functions to the stack.  If any entry fails it will unwind all of them in reverse order.  There are a lot of options and it really helps to cleanup messy `with` statements.\n\nhttps://www.rath.org/on-the-beauty-of-pythons-exitstack.html", "id": "gje5zvy", "owner_tier": 0.7, "score": 0.013129102822757113}, {"content": "\\#4 and #5 back to back is pretty ironic, given that Dict.get() returns None if you don't find the element :|\n\nYou can provide a default value though", "id": "gjdl40a", "owner_tier": 0.3, "score": 0.006564551400437637}, {"content": "Generally a nice article, but ...\n\nI disagree with #4. I find that using a `None` return to flag an error is a very reasonable practice, and often one that results in simpler and more maintainable code than we would get by using exceptions.\n\nAlso, #7 is just wrong. You can't initialize an empty `set` with `{ }`, as that's an empty `dict`. Use `set()` for that. So the mention of `set` in the title for #7 needs to go.\n\nEDIT. /u/Halkcyon mentions `{*()}`. Yeah, interesting. I'd even say cool. Now don't do that. :-)", "id": "gjdf2jq", "owner_tier": 0.7, "score": 0.004376367592997812}, {"content": "I just learned file manipulation in Python last night. The only way they taught me was the method without with... I'm nervous that other things they teach me will also be ineffective. I learn on SoloLearn, just so people know who teaches the wrong way.\n\npoint (1) is questionable in general and is clearly irrelevant in your case\n\nA. cpython WILL close files for you even without with (AND, even if it did not, leaving files open is not a big deal for a lot of code)\n\nB. if you are learning about files, then you absolutely should start without \"with\": .close() is fundamental file operation and there are plenty of situations when \"with\" does not work at all (e.g. for long lived file objects)\n(and \"with\" is a language construct with fairly complicated semantics not directly related to file IO)", "id": "gjcv42r", "owner_tier": 0.3, "score": 0.002188183785557987}, {"content": "> It is recommended to return only one type of object from a function.\n\nIf only there was a feature in programming languages that could ensure this.", "id": "gjd1s8j", "owner_tier": 0.3, "score": -2.1881837941412013e-11}, {"content": "Disagree with #4, it's a pain to deal with exceptions (and if used everywhere for everything they lose their value). I've also heard (and I agree more with) \"Exceptions should be fore exceptional conditions.  Not expected conditions. Like person not being in db is common/expected.  db connection timing out is exceptional.\n\n\nStrongly disagree with #7 The tiny amount of speed is so not important. And that is the important lesson to learn, don't pre-optimize, and micro-optimizations should not influence code structure etc.\n\nMany of the others are caught by flake8", "id": "gjdaez7", "owner_tier": 0.5, "score": -2.1881837941412013e-11}, {"content": "Disagree with some of #7 too. Using {} for a dict and [] for a list works well and is easy to read. However an empty set is {} ... a dict, and an empty tuple is (,) ... which has never really looked like correct code to me. \n\nThough, in general, I\u2019ve never been satisfied with significant comma use.  More than once I\u2019ve spent too much time hunting down why a string was now a tuple due to a stray comma.\n\n    my_string = (\u2018this is a long string, \u2019\n        \u2018that can span several lines \u2019\n        \u2018and may have punctuation too.\u2019)\n    another_string = \u2018Hi there,\u2019\n\n    my_bad_string = (\u2018this is a long string \u2019,\n        \u2018that can span several lines \u2019\n        \u2018and may have punctuation too.\u2019)\n    another_bad = \u201cHi there\u2019,", "id": "gjdb03u", "owner_tier": 0.5, "score": -2.1881837941412013e-11}, {"content": "The Ansible code base uses `dict()` everywhere. IIRC it's in their style guide.\n\nI prefer the literal syntax for style. But if you're worrying about the performance impact of a single variable lookup, Python is probably the wrong language for your project.", "id": "gjeh7md", "owner_tier": 0.7, "score": -2.1881837941412013e-11}], "link": "https://www.reddit.com/r/Python/comments/kxsnvv/common_antipatterns_in_python/", "question": {"content": "", "id": "kxsnvv", "title": "Common anti-patterns in Python", "traffic_rate": 207.97108193451885}, "saved_time": 1721102247, "source": "reddit", "tags": []}, {"answers": [{"content": "\r\n    Yay! A chance to use Regular Expressions without summoning the elder gods! :)\n\r\nStart with a structure to convert a string to a bad word, taking the \"bonus points\" rules into account:\nC#\n\r\npublic struct BadWord\r\n{\r\n    public BadWord(string word)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(word)) throw new ArgumentNullException(nameof(word));\r\n        \r\n        int startIndex = 0;\r\n        int length = word.Length;\r\n        \r\n        // Skip leading / trailing white-space:\r\n        while (length > 0 && char.IsWhiteSpace(word[startIndex]))\r\n        {\r\n            startIndex++;\r\n            length--;\r\n        }\r\n        while (length > 0 && char.IsWhiteSpace(word[startIndex + length - 1]))\r\n        {\r\n            length--;\r\n        }\r\n        \r\n        // If the word ends with \"!\", then it's a case-sensitive match:\r\n        if (length > 0 && word[startIndex + length - 1] == '!')\r\n        {\r\n            CaseSensitive = true;\r\n            length--;\r\n        }\r\n        else\r\n        {\r\n            CaseSensitive = false;\r\n        }\r\n        \r\n        // If the word ends with \"*\", filter anything starting with the word:\r\n        if (length > 0 && word[startIndex + length - 1] == '*')\r\n        {\r\n            Suffix = \"(?=\\\\w*\\\\b)\";\r\n            length--;\r\n        }\r\n        else\r\n        {\r\n            Suffix = \"\\\\b\";\r\n        }\r\n        \r\n        // If the word starts with \"*\", filter anything ending with the word:\r\n        if (length > 0 && word[startIndex] == '*')\r\n        {\r\n            Prefix = \"(?<=\\\\b\\\\w*)\";\r\n            startIndex++;\r\n            length--;\r\n        }\r\n        else\r\n        {\r\n            Prefix = \"\\\\b\";\r\n        }\r\n        \r\n        Word = length != 0 ? word.Substring(startIndex, length) : null;\r\n    }\r\n    \r\n    public string Word { get; }\r\n    public string Prefix { get; }\r\n    public string Suffix { get; }\r\n    public bool CaseSensitive { get; }\r\n    \r\n    public Regex ToRegularExpression()\r\n    {\r\n        if (string.IsNullOrWhiteSpace(Word)) return null;\r\n        \r\n        string pattern = Prefix + Regex.Escape(Word) + Suffix;\r\n        var options = CaseSensitive ? RegexOptions.ExplicitCapture : RegexOptions.ExplicitCapture | RegexOptions.IgnoreCase;\r\n        return new Regex(pattern, options);\r\n    }\r\n}\r\nThen a class to represent a single bad word and its replacement:\nEDIT: Now with the part of the spec the \"customer\" forgot to mention! :)\nC#\n\r\npublic sealed class WordReplacement\r\n{\r\n    public WordReplacement(BadWord word, string replacement)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(word.Word)) throw new ArgumentNullException(nameof(word));\r\n        \r\n        Pattern = word.ToRegularExpression();\r\n        CaseSensitive = word.CaseSensitive;\r\n        Replacement = replacement;\r\n        \r\n        if (CaseSensitive || replacement == null || replacement.Any(char.IsUpper))\r\n        {\r\n            Replacer = (Match m) => Replacement;\r\n        }\r\n        else\r\n        {\r\n            Replacer = (Match m) => MatchCase(m.Value, Replacement);\r\n        }\r\n    }\r\n    \r\n    public WordReplacement(string word, string replacement) : this(new BadWord(word), replacement)\r\n    {\r\n    }\r\n    \r\n    public Regex Pattern { get; }\r\n    public string Replacement { get; }\r\n    public bool CaseSensitive { get; }\r\n    public MatchEvaluator Replacer { get; }\r\n    \r\n    public static string MatchCase(string wordToReplace, string replacement)\r\n    {\r\n        if (null == replacement) return string.Empty;\r\n        if (wordToReplace.All(char.IsLower)) return replacement;\r\n        if (wordToReplace.All(char.IsUpper)) return replacement.ToUpperInvariant();\r\n        \r\n        char[] result = replacement.ToCharArray();\r\n        bool changed = false;\r\n        \r\n        if (wordToReplace.Length == replacement.Length)\r\n        {\r\n            for (int index = 0; index < result.Length; index++)\r\n            {\r\n                if (char.IsUpper(wordToReplace[index]))\r\n                {\r\n                    char c = result[index];\r\n                    result[index] = char.ToUpperInvariant(c);\r\n                    if (result[index] != c) changed = true;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (char.IsUpper(wordToReplace[0]))\r\n            {\r\n                char c = result[0];\r\n                result[0] = char.ToUpperInvariant(c);\r\n                if (result[0] != c) changed = true;\r\n            }\r\n            if (char.IsUpper(wordToReplace[wordToReplace.Length - 1]))\r\n            {\r\n                int index = result.Length - 1;\r\n                char c = result[index];\r\n                result[index] = char.ToUpperInvariant(c);\r\n                if (result[index] != c) changed = true;\r\n            }\r\n        }\r\n        \r\n        return changed ? new string(result) : replacement;\r\n    }\r\n    \r\n    public string Replace(string input) => Pattern.Replace(input, Replacer);\r\n}\r\nAnd finally, a class to represent a list of bad word replacements:\nC#\n\r\npublic sealed class Clbuttifier2000\r\n{\r\n    public Clbuttifier2000(IEnumerable<KeyValuePair<string, string>> replacements)\r\n    {\r\n        Replacements = replacements.Select(p => new WordReplacement(p.Key, p.Value)).ToList().AsReadOnly();\r\n    }\r\n    \r\n    public IReadOnlyList<WordReplacement> Replacements { get; }\r\n    \r\n    public string Clbuttify(string message)\r\n    {\r\n        if (!string.IsNullOrWhiteSpace(message))\r\n        {\r\n            foreach (var replacement in Replacements)\r\n            {\r\n                message = replacement.Replace(message);\r\n            }\r\n        }\r\n        \r\n        return message;\r\n    }\r\n}\r\nSample usage:\nC#\n\r\nvar filter = new Clbuttifier2000(new Dictionary<string, string>\r\n{\r\n    [\"poop*\"] = \"p**p\",\r\n    [\"PHB!\"] = \"boss\",\r\n    [\"gotten\"] = \"become\",\r\n});\r\n\r\nstring input = \"My PHB has gotten started on his new blog phblog.com. He's SUCH A MISBEGOTTEN Poophead!\";\r\nstring expected = \"My boss has become started on his new blog phblog.com. He's SUCH A MISBEGOTTEN P**phead!\";\r\nstring actual = filter.Clbuttify(input);\r\nDebug.Assert(actual == expected);\n", "id": "2_1157811_3", "owner_tier": 0.7, "score": 2.5}, {"content": "\r\n    I was reading up on Python online, then chanced upon this pooping oops I mean coding challenge, thought why not try this out on Python. Here it is fresh from the loo oops again I mean oven.\nPython\n\r\n\"\"\"\r\npoop.py\r\n\r\nby Peter Leow the pooper\r\n\r\n\"\"\"\r\n\r\nimport re\r\n\r\ndef functionStartWithPoop(m):\r\n    wordFound = m.group(0)\r\n\r\n    if wordFound[:5].lower()=='poop*':\r\n        wordRepl = wordFound[0] + '**' + wordFound[3] + wordFound[5:]\r\n    else: #wordFound[:4].lower()=='poop':\r\n        wordRepl = wordFound[0] + '**' + wordFound[3] + wordFound[4:] \r\n\r\n    return wordRepl\r\n\r\ndef functionEndWithPoop(m):\r\n    wordFound = m.group(0)\r\n\r\n    if wordFound[-5:].lower()=='*poop':\r\n        wordRepl = wordFound[:-5] + wordFound[-4] + '**' + wordFound[-1]\r\n    else: #wordFound[-4:].lower()=='poop':\r\n        wordRepl = wordFound[:-4] + wordFound[-4] + '**' + wordFound[-1]\r\n\r\n    return wordRepl\r\n\r\ndef main():\r\n    originalSentence = '''\r\n    poop*ing is in front of make*poop.\r\n    Whether poop* or *poop, there are just pOoP!\r\n    A POOPHEAD cannot change but an exclaimed POOPHEAD! can.'''\r\n\r\n    print('Before:')\r\n    print(originalSentence)\r\n    print()\r\n    print('After:')\r\n    \r\n    # Without ! ending\r\n    patternStartWithPoop=r'(?<!\\S)poop\\*?[\\S]*'\r\n    patternEndWithPoop=r'[\\S]*\\*?poop(?=[?!,.;]?$|[?!,.;]?\\s+)'\r\n\r\n    # with ! ending\r\n    patternStartWithPoopEndWithExclamation = r'(?<!\\S)poop\\*?[\\S]*!(?=\\s|$)'\r\n    patternEndWithPoopAndExclamation=r'[\\S]*\\*?poop!(?=[?!,.;]?$|[?!,.;]?\\s+)'\r\n\r\n    # Case sensitive\r\n    filteredSentence = re.sub(patternStartWithPoop, functionStartWithPoop, originalSentence, flags=0)\r\n    #print(filteredSentence)\r\n    filteredSentence = re.sub(patternEndWithPoop, functionEndWithPoop, filteredSentence, flags=0)\r\n    #print(filteredSentence)\r\n\r\n    # Case ignorance\r\n    filteredSentence = re.sub(patternStartWithPoopEndWithExclamation, functionStartWithPoop, filteredSentence, flags=re.IGNORECASE)\r\n    #print(filteredSentence)\r\n    filteredSentence = re.sub(patternEndWithPoopAndExclamation, functionEndWithPoop, filteredSentence, flags=re.IGNORECASE)\r\n    print(filteredSentence)\r\n  \r\nmain()\r\nTry this out at Coding challenge bad word filter | Python Fiddle[^] and you should see the following OUTPOOP:\n \n\r\nBefore:\r\n\r\n    poop*ing is in front of make*poop.\r\n    Whether poop* or *poop, there are just pOoP!\r\n    A POOPHEAD cannot change but an exclaimed POOPHEAD! can.\r\n\r\nAfter:\r\n\r\n    p**ping is in front of makep**p.\r\n    Whether p**p or p**p, there are just p**P!\r\n    A POOPHEAD cannot change but an exclaimed P**PHEAD! can.\r\nI have ignored 'PHB' and 'gotten' as they are simply too trivial.\r\n", "id": "2_1157928_5", "owner_tier": 0.5, "score": 2.0}, {"content": "\r\n    Not sure on the rules, just wanted to add this for fun.  I love code challenges.\n\r\nThis solution, in contrast to my other one, reduces the number of strings nuked during processing.  It also uses only a single Regex call to process all bad words.  Even though I construct an additional dictionary, my diagnostic tool shows me coming in at less memory consumed than my previous solution.  This solution does everything the previous did, plus adds optional casing.\n\nC#\n\r\npublic class BadWordFilter\r\n{\r\n    public static string Replace(string input, \r\n        IDictionary<string, string> badWordMap)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(input))\r\n            throw new ArgumentException(nameof(input),\r\n                \"String cannot be null, empty, or whitespace.\");\r\n\r\n        Dictionary<string, string> idMap = new Dictionary<string, string>();\r\n        StringBuilder pattern = new StringBuilder();\r\n        int idCounter = 0;\r\n        //For each bad word pair, create an ID mapped to the value and construct the match pattern using the ID and key\r\n        foreach (KeyValuePair<string, string> badWord in badWordMap)\r\n        {\r\n            string id = \"ID\" + idCounter++;\r\n            idMap.Add(id, badWord.Value);\r\n            ConstructMatchPattern(badWord.Key, id, pattern);\r\n        }\r\n        //Remove the first | from the pattern\r\n        pattern.Remove(0, 1);\r\n\r\n        Regex filter = new Regex(pattern.ToString(), RegexOptions.IgnoreCase);\r\n        string[] groupNames = filter.GetGroupNames();\r\n        MatchEvaluator evaluator = match =>\r\n        {\r\n            string replacement = \"\";\r\n            //Find which group was matched and retrieve the replacement value\r\n            for (int i = 1; i < groupNames.Length; i++)\r\n                if (match.Groups[groupNames[i]].Success)\r\n                {\r\n                    replacement = idMap[groupNames[i]];\r\n                    break;\r\n                }\r\n\r\n            //Handle casing\r\n            if (replacement.StartsWith(\"!\"))\r\n            {\r\n                replacement = replacement.Remove(0, 1);\r\n                //All caps check\r\n                if (match.Value == match.Value.ToUpper())\r\n                    replacement = replacement.ToUpper();\r\n                //First letter caps check\r\n                else if (match.Value[0] == char.ToUpper(match.Value[0]))\r\n                    replacement = char.ToUpper(replacement[0]) + replacement.Substring(1);\r\n            }\r\n            return replacement;\r\n        };\r\n\r\n        return filter.Replace(input, evaluator);\r\n    }\r\n\r\n    private static void ConstructMatchPattern(string badWord, string id, \r\n        StringBuilder pattern)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(badWord))\r\n            return;\r\n        int patternLength = pattern.Length;\r\n        pattern.Append($@\"|(?<{id}>(?:\\b){badWord.Trim('*')}\");\r\n        if (badWord.StartsWith(\"*\"))\r\n            pattern.Insert(patternLength + id.Length + 11, @\"\\w*\", 1);\r\n        if (badWord.EndsWith(\"*\"))\r\n            pattern.Append(@\"\\w*\");\r\n        pattern.Append(')');\r\n    }\r\n}\n\r\nUsed the same way as the previous example, with the inclusion of the \"!\" option.\n\nC#\n\r\nstatic void Main(string[] args)\r\n{\r\n    Dictionary<string, string> badWords = new Dictionary<string, string>()\r\n    {\r\n        {\"poop*\", \"p**phead\"},\r\n        {\"*HB\", \"boss\"},\r\n        {\"gotten\", \"become\"},\r\n        {\"*crap*\", \"taco supreme\"}\r\n    };\r\n    string input = \"My PHB is such a poophead. It's gotten worse since his promotion. In fact you might call him a supercraphead.\";\r\n    string filteredInput = BadWordFilter.Replace(input, badWords);\r\n    Console.WriteLine(filteredInput);\r\n    Console.ReadKey();\r\n}\r\n\n\r\nReplacing  {\"*HB\", \"boss\"} with {\"*HB\", \"!boss\"} will yield BOSS instead of boss since it cases to its key's match.\r\n", "id": "2_1157969_2", "owner_tier": 0.3, "score": 3.0}, {"content": "\r\n    Actually, stating that this challenge is easy is misleading. Handling text is never easy, if you want to work with Unicode. Here is a my take on it.\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nclass WordFilter\r\n{\r\n    private static Dictionary<string, string> badWords = null;\r\n\r\n    private static List<KeyValuePair<string, string>> badWordsStart = new List<KeyValuePair<string, string>>();\r\n    private static List<KeyValuePair<string, string>> badWordsEnd = new List<KeyValuePair<string, string>>();\r\n    private static List<KeyValuePair<string, string>> badWordsMiddle = new List<KeyValuePair<string, string>>();\r\n    private static Dictionary<string, string> badWordsCaseSensitive = new Dictionary<string, string>();\r\n    private static Dictionary<string, string> badWordsCaseInsensitive = new Dictionary<string, string>();\r\n        \r\n    private static void Init()\r\n    {\r\n        if (badWords != null)\r\n        {\r\n            return;\r\n        }\r\n\r\n        badWords = new Dictionary<string, string>()\r\n        {\r\n            {\"poop*\", \"p**p\"},\r\n            {\"PHB!\", \"boss\"},\r\n            {\"gotten\", \"become\"},\r\n            {\"*crap*\", \"taco supreme\"}\r\n        };\r\n\r\n        foreach (var item in badWords)\r\n        {\r\n            bool startWord = item.Key.EndsWith(\"*\");\r\n            bool endWord = item.Key.StartsWith(\"*\");\r\n            bool caseSensitive = item.Key.EndsWith(\"!\");\r\n\r\n            if (startWord && endWord)\r\n            {\r\n                badWordsMiddle.Add(new KeyValuePair<string, string>(item.Key.Trim('*').ToLower(CultureInfo.InvariantCulture), item.Value));\r\n            }\r\n            else if (startWord)\r\n            {\r\n                badWordsStart.Add(new KeyValuePair<string, string>(item.Key.TrimEnd('*').ToLower(CultureInfo.InvariantCulture), item.Value));\r\n            }\r\n            else if (endWord)\r\n            {\r\n                badWordsEnd.Add(new KeyValuePair<string, string>(item.Key.TrimStart('*').ToLower(CultureInfo.InvariantCulture), item.Value));\r\n            }\r\n            else if (caseSensitive)\r\n            {\r\n                badWordsCaseSensitive.Add(item.Key.TrimEnd('!'), item.Value);\r\n            }\r\n            else\r\n            {\r\n                badWordsCaseInsensitive.Add(item.Key.ToLower(CultureInfo.InvariantCulture), item.Value);\r\n            }\r\n        }\r\n    }\r\n\r\n    public WordFilter()\r\n    {\r\n        Init();\r\n    }\r\n\r\n    public string Filter(string s)\r\n    {\r\n        var word = new StringBuilder();\r\n        var sout = new StringBuilder();\r\n\r\n        foreach (var c in s.GetUTF32Chars())\r\n        {\r\n            if (c.IsLetter)\r\n            {\r\n                word.Append(c);\r\n            }\r\n            else \r\n            {\r\n                if (word.Length > 0)\r\n                {\r\n                    var niceWord = Replace(word.ToString());\r\n                    word.Clear();\r\n                    sout.Append(niceWord);\r\n                }\r\n                sout.Append(c);\r\n            }\r\n        }\r\n        return sout.ToString();\r\n    }\r\n\r\n    private string Replace(string word)\r\n    {\r\n        string newWord;\r\n        if (badWordsCaseSensitive.TryGetValue(word, out newWord)) return newWord;\r\n\r\n        var lword = word.ToLower(CultureInfo.InvariantCulture);\r\n        if (badWordsCaseInsensitive.TryGetValue(word, out newWord)) return newWord;\r\n\r\n        newWord = badWordsStart.Where(it => word.StartsWith(it.Key)).Select(it => word.Replace(it.Key, it.Value)).FirstOrDefault();\r\n        if (newWord != null) return newWord;\r\n\r\n        newWord = badWordsEnd.Where(it => word.EndsWith(it.Key)).Select(it => word.Replace(it.Key, it.Value)).FirstOrDefault();\r\n        if (newWord != null) return newWord;\r\n\r\n        newWord = badWordsMiddle.Where(it => word.Contains(it.Key)).Select(it => word.Replace(it.Key, it.Value)).FirstOrDefault();\r\n        if (newWord != null) return newWord;\r\n\r\n        return word;\r\n    }\r\n}\r\n\r\npublic static class StringExtensions\r\n{\r\n    public static System.Collections.Generic.IEnumerable<UTF32Char> GetUTF32Chars(this string s)\r\n    {\r\n        var tee = System.Globalization.StringInfo.GetTextElementEnumerator(s);\r\n\r\n        while (tee.MoveNext())\r\n        {\r\n            yield return new UTF32Char(s, tee.ElementIndex);\r\n        }\r\n    }\r\n}\r\n\r\npublic struct UTF32Char\r\n{\r\n    private string s;\r\n    private int index;\r\n\r\n    public UTF32Char(string s, int index)\r\n    {\r\n        this.s = s;\r\n        this.index = index;\r\n    }\r\n\r\n    public override string ToString()\r\n    {\r\n        return char.ConvertFromUtf32(this.UTF32Code);\r\n    }\r\n\r\n    public int UTF32Code {  get { return char.ConvertToUtf32(s, index); } }\r\n    public double NumericValue { get { return char.GetNumericValue(s, index); } }\r\n    public UnicodeCategory UnicodeCategory { get { return char.GetUnicodeCategory(s, index); } } \r\n    public bool IsControl { get { return char.IsControl(s, index); } }\r\n    public bool IsDigit { get { return char.IsDigit(s, index); } }\r\n    public bool IsLetter { get { return char.IsLetter(s, index); } }\r\n    public bool IsLetterOrDigit { get { return char.IsLetterOrDigit(s, index); } }\r\n    public bool IsLower { get { return char.IsLower(s, index); } }\r\n    public bool IsNumber { get { return char.IsNumber(s, index); } }\r\n    public bool IsPunctuation { get { return char.IsPunctuation(s, index); } }\r\n    public bool IsSeparator { get { return char.IsSeparator(s, index); } }\r\n    public bool IsSurrogatePair { get { return char.IsSurrogatePair(s, index); } }\r\n    public bool IsSymbol { get { return char.IsSymbol(s, index); } }\r\n    public bool IsUpper { get { return char.IsUpper(s, index); } }\r\n    public bool IsWhiteSpace { get { return char.IsWhiteSpace(s, index); } }\r\n}\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        var wf = new WordFilter();\r\n\r\n        var rawSentence = \"My PHB is such a poophead. It's gotten worse since his promotion.  In fact you might call him a supercraphead!\";\r\n        var niceSentence = wf.Filter(rawSentence);\r\n        Console.WriteLine(rawSentence);\r\n        Console.WriteLine(niceSentence);\r\n    }\r\n}\n", "id": "2_1158227_1", "owner_tier": 0.1, "score": 5.0}, {"content": "\r\n    Not sure if my Excel VBA solution posted, so I'm trying again\nVB.NET\n\r\nPublic Function noBad(ByVal badstr As String) As String\r\n    Dim badWords As Variant, goodWords As Variant\r\n    Dim i As Integer, bw As String\r\n    badWords = Array(\"poop*\", \"PHB\", \"gotten\", \"POOP*\")\r\n    goodWords = Array(\"p**p\", \"boss\", \"become\", \"P**P\")\r\n    For i = 0 To UBound(badWords)\r\n        bw = badWords(i)\r\n        With CreateObject(\"VBScript.RegExp\")\r\n            .Pattern = \"\\b\" & bw & IIf(InStr(bw, \"*\"), \"\", \"\\b\")\r\n            .Global = True\r\n            badstr = .Replace(badstr, goodWords(i))\r\n        End With\r\n    Next i\r\n    noBad = badstr\r\nEnd Function\n\r\nWorth a go, I thought.  Okay so the case thing isn't so good, but I only get a short lunch\r\n", "id": "2_1158254_1", "owner_tier": 0.1, "score": 2.5}, {"content": "\r\n    COBOL has awesome string handling:\n\nC#\n\r\nidentification division.\r\nprogram-id. FixBadWords.\r\n\r\ndata division.\r\n  \r\nworking-storage section.\r\n   \r\n\t01 wsData.\r\n\t    03 wsComment occurs 5 times pic a(255).\r\n\t01 i         pic 9(1).\r\n\r\nprocedure division. \r\n\t\r\n\tmove \"My PHBis such a poophead. It's gotten worse since his promotion\" \r\n            to wscomment(1)\r\n\tmove \"My PHB is such a POOPHEAD!\" to wscomment(2)\r\n\r\n\tperform varying i from 1 by 1 until i > 5\r\n\t    \r\n\t\tinspect wsComment(i) \r\n\t\t\treplacing all 'poophead' by 'p**phead'\r\n\t\t\t\t      'POOPHEAD' BY 'P**PHEAD'\r\n\t\t\t\t      'PHB'      BY 'boss'\r\n\t\t\t\t      'gotten'   BY 'become'\r\n\t\t\r\n\t\tdisplay wsComment(i)\r\n\r\n\tend-perform\r\n\r\nstop run\r\n.\n", "id": "2_1158571_2", "owner_tier": 0.1, "score": 5.0}, {"content": "\r\n    EDIT:\r\n* Figured out way to make 'poopoopoop' become 'p**p**p**p' (without recursion) and keep other design constraints.\n\r\n* Figured out an 'Oh Duh - that's so simple!' way to keep 'nincompoop' as 'nincompoop' - just replace it with itself!\n\r\n* Made class static, which resulted in about 8% inprovement.  But the additional 'p**p**p**p' routine (replaceRepeatingStrings) dropped speed from 0.24ms to 0.37ms.  Still 7 times faster than Solution 10 on my machine.\r\n-END EDIT\n\nQuote:The point is to make the question a little loose to allow ... pointless religious warsGood, I'll use some 'goto's :)\n\r\nI'm not very familiar with regex, but believe it doesn't allow you to change the case of a word based on the cases of the surrounding words.  (If I'm wrong, please enlighten me.)  If that is the case, 'PHB' will always become 'boss' in the regex solutions, regardless of whether the input 'shouted' the phrase.\n\r\nThe following solution is C++ all the way, and is about 7 times faster than Solution 10 on my machine using Grant's newest timing routine.  It does take the capitalization of the surrounding words into effect.  It will also change 'pooppoop' to 'p**pp**p', which doesn't seem to have been specified by the specifications, although logically should occur.  Additionally, it changes 'poopoopoop' into 'p**p**p**p' without recursion.\n\nQuote:A weekly simple programming problem that should take no more than half an hour or soYeah, right Chris... :rolleyes: This logic was a friggin' pain!\n\nC++\n\r\n#include <map>\r\n#include <string>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <tuple>\r\n#include <ctime>\r\n#include <iostream>\r\n#include \"windows.h\" //For QueryPerformanceCounter\r\nusing namespace std;\r\n\r\n//I am going to use a tuple of: the input word, the small case output word, and the\r\n//capped case output word, so they don't have to be calculated each time.\r\n//So some defines are just for additional clarity:\r\n#define GetTupleWord      get<0>\r\n#define GetTupleSmallCase get<1>\r\n#define GetTupleCapCase   get<2>\r\n\r\n\r\n//Utility class for the timing...\r\nclass TimerLowRes {\r\n   private:\r\n      std::clock_t begC;\r\n      std::clock_t avgTotC;\r\n      std::clock_t diffC;\r\n      int numTimesC;\r\n   public:\r\n      TimerLowRes() : avgTotC(0), numTimesC(0) { }\r\n\r\n      void start() { begC = std::clock(); }\r\n\r\n      std::clock_t stop() {\r\n         diffC = std::clock() - begC;\r\n         avgTotC = avgTotC + diffC;\r\n         numTimesC++;\r\n         return diffC;\r\n         }\r\n\r\n      std::clock_t getAvg() {\r\n         if (numTimesC == 0) return 0;\r\n         return avgTotC / numTimesC;\r\n         }\r\n\r\n      void reset() {\r\n         numTimesC = 0;\r\n         avgTotC = 0;\r\n         }\r\n\r\n      std::clock_t getLapTime() { return std::clock() - begC; }\r\n   };\r\n\r\n\r\n\r\n\r\n//High precision timer utility class for the timing.\r\n//Derived from https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx\r\nclass TimerHighRes {\r\n   private:\r\n      LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds, Frequency;\r\n      int numTimesC;\r\n   public:\r\n      TimerHighRes() : numTimesC(0) {\r\n         QueryPerformanceFrequency(&Frequency);\r\n         }\r\n\r\n      void start() {\r\n         QueryPerformanceCounter(&StartingTime);\r\n         }\r\n\r\n      LARGE_INTEGER stop() {\r\n         QueryPerformanceCounter(&EndingTime);\r\n         ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;\r\n         ElapsedMicroseconds.QuadPart *= 1000000;\r\n         ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;\r\n         numTimesC++;\r\n         return ElapsedMicroseconds;\r\n         }\r\n   };\r\n\r\n\r\nclass Reformatter {\r\n   private:\r\n      //Good chance that the implied design requirements involve UNICODE text, but for quick\r\n      //prototype of similar design use wstring:\r\n\r\n      typedef tuple<wstring, wstring, wstring> WordTuples;\r\n      vector<WordTuples> repeatingStringsC;     //This will address items like 'poopoopoop'\r\n      vector<WordTuples> caseSensitiveSubsC;    //This means that the inputted word must be\r\n                                                //matched on exact case.\r\n      vector<WordTuples> nonCaseSensitiveSubsC; //By this, it is meant that the inputted word\r\n                                                //can be either caps or small case in the text.\r\n      vector<WordTuples> asteriskSubsC;         //The CapCase will be ignored - only the\r\n                                                //asterisks in the small case will be modified.\r\n\r\n      wstring resultC;\r\n      size_t  strLenC;\r\n      wstring::const_iterator beginLocC;\r\n      wstring::const_iterator curLocC;\r\n      wstring::const_iterator endLocC;\r\n\r\n      bool replaceAsterisks();\r\n      bool replaceNonCaseSensitiveBegin();\r\n      bool replaceCaseSensitive();\r\n      bool replaceRepeatingStrings();\r\n      bool previousWordIsCapitalized(wstring::const_iterator & thisWord, wstring::const_iterator & prevWord);\r\n      bool nextWordIsCapitalized(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord);\r\n      void findBeginningOfPrevious(wstring::const_iterator & thisWord, wstring::const_iterator & prevWord);\r\n      void findBeginningOfNext(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord);\r\n\r\n      bool isWhiteSpaceOrPunctuation(const wstring::const_iterator & temp);\r\n\r\n   public:\r\n      Reformatter() {\r\n         repeatingStringsC.push_back(make_tuple(L\"poo\", L\"p**\", L\"p\"));\r\n\r\n         caseSensitiveSubsC.push_back(make_tuple(L\"PHB\", L\"boss\", L\"BOSS\"));\r\n\r\n         //The following 'gotten to be' must be defined before 'gotten':\r\n         nonCaseSensitiveSubsC.push_back(make_tuple(L\"gotten to be\", L\"become\", L\"BECOME\"));\r\n         nonCaseSensitiveSubsC.push_back(make_tuple(L\"gotten\", L\"become\", L\"BECOME\"));\r\n\r\n         asteriskSubsC.push_back(make_tuple(L\"nincompoop\", L\"nincompoop\", L\"nincomp##p\"));\r\n         asteriskSubsC.push_back(make_tuple(L\"poop\", L\"p**p\", L\"P**P\"));\r\n         asteriskSubsC.push_back(make_tuple(L\"p##p\", L\"p**p\", L\"P**P\"));\r\n         asteriskSubsC.push_back(make_tuple(L\"ass\", L\"a**\", L\"A**\"));\r\n         }\r\n\r\n      void reformat(const wstring & str);\r\n      void outputResult();\r\n   };\r\n\r\n\r\nvoid Reformatter::outputResult() {\r\n   wcout << L\"OUTPUT: \" << resultC << endl << endl;\r\n   }\r\n\r\n\r\nbool Reformatter::isWhiteSpaceOrPunctuation(const wstring::const_iterator & it) {\r\n   if (*it == L' ' || *it == L'\\t' || *it == L'.' || *it == L'!' || *it == L'_' ||\r\n               *it == L'\\r' || *it == L'\\n') return true;\r\n   return false;\r\n   }\r\n\r\n\r\nvoid Reformatter::findBeginningOfNext(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord) {\r\n   //There is the possibility that there is no next word, but there is whitespace.\r\n   //If that is the case, return prevWord = thisWord = curLocC.\r\n\r\n   //Go to the whitespace at the end of the current word:\r\n   while (thisWord != endLocC && !isWhiteSpaceOrPunctuation(thisWord)) ++thisWord;\r\n   //Move 'thisWord' back to the beginning of the whitespace:\r\n   nextWord = thisWord;\r\n   //Now skip any additional whitespace:\r\n   while (nextWord != endLocC && isWhiteSpaceOrPunctuation(nextWord)) ++nextWord;\r\n   if (nextWord == endLocC) {\r\n      nextWord = endLocC;\r\n      thisWord = endLocC;\r\n      return;\r\n      }\r\n   }\r\n\r\n\r\nvoid Reformatter::findBeginningOfPrevious(wstring::const_iterator & thisWord, wstring::const_iterator & prevWord) {\r\n   //There is the possibility that there is no previous word, but there is whitespace.\r\n   //If that is the case, return prevWord = thisWord = (beginning of word).\r\n\r\n   //Go to the whitespace before the current word:\r\n   while (thisWord != beginLocC && !isWhiteSpaceOrPunctuation(thisWord)) --thisWord;\r\n   //Move 'thisWord' back to the beginning (one space forward), and set 'prevWord' current pos:\r\n   prevWord = thisWord;\r\n   ++thisWord;\r\n   //Now skip any additional whitespace:\r\n   while (prevWord != beginLocC && isWhiteSpaceOrPunctuation(prevWord)) --prevWord;\r\n   if (prevWord == beginLocC) {\r\n      if (isWhiteSpaceOrPunctuation(prevWord)) prevWord = thisWord;\r\n      return;\r\n      }\r\n   //We are now on the last character of the previous word.  Iterate to the beginning of it:\r\n   while (prevWord != beginLocC && !isWhiteSpaceOrPunctuation(prevWord)) --prevWord;\r\n   //Check for the case where the user starts the input with a space character:\r\n   if (isWhiteSpaceOrPunctuation(prevWord)) ++prevWord;\r\n   }\r\n\r\n\r\nbool Reformatter::previousWordIsCapitalized(wstring::const_iterator & thisWord,\r\n               wstring::const_iterator & prevWord) {\r\n\r\n   //We are working from the 'curLocC' position in the string.\r\n   //Create a temporary iterator and find the beginning of the previous word.\r\n   //If it reaches the beginning of the string, return 'true' so the 'shouting'\r\n   //routines only rely on the following word.\r\n   findBeginningOfPrevious(thisWord, prevWord);\r\n   if (thisWord == prevWord) return true; //We will default to 'true' for the previous word\r\n               //and 'false' for the next word, so next word processing can occur.\r\n   //Now find the case of each letter until the next whitespace:\r\n   while (!isWhiteSpaceOrPunctuation(prevWord)) {\r\n      wchar_t temp = *prevWord;\r\n      if (iswlower(*prevWord)) return false;\r\n      ++prevWord;\r\n      }\r\n   return true;\r\n   }\r\n\r\n\r\nbool Reformatter::nextWordIsCapitalized(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord) {\r\n   //We are working from the 'curLocC' position in the string.\r\n   //Create a temporary iterator and find the beginning of the previous word.\r\n   //If it reaches the beginning of the string, return 'true' so the 'shouting'\r\n   //routines only rely on the following word.\r\n   findBeginningOfNext(thisWord, nextWord);\r\n   if (thisWord == nextWord) return false;   //We are defaulting to 'true' for previous word\r\n               //processing, and 'false' for this, so if there isn't any text before or\r\n               //after the word, both processings will occur.\r\n   //Now find the case of each letter until the next whitespace:\r\n   while (nextWord != endLocC && !isWhiteSpaceOrPunctuation(nextWord)) {\r\n      wchar_t temp = *nextWord;\r\n      if (iswlower(*nextWord)) return false;\r\n      ++nextWord;\r\n      }\r\n   return true;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceCaseSensitive() {\r\n   //This returns true if a replacement has been made.\r\n   bool found = false;\r\n   wstring::const_iterator inputIterator;\r\n   for (auto it = caseSensitiveSubsC.begin(); it != caseSensitiveSubsC.end(); ++it) {\r\n      const wstring & str = GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str.length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || *inputIterator != str[pos]) {\r\n            //The string doesn't match the criteria\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) {\r\n         //There is a non-specified scenario to take care of.  If the user inputs something\r\n         //like 'PHBblog.com', in reality we may not want this to substitute 'boss'.  Here\r\n         //is logic to take care of that scenario:\r\n         if (inputIterator == endLocC || !isWhiteSpaceOrPunctuation(inputIterator)) {\r\n            return false;\r\n            }\r\n         //We now know that we need to replace the string, but we don't know if it needs to\r\n         //be 'shouted'.\r\n         //curLocC is still at the beginning of the text being checked against.  This can\r\n         //only be at the beginning of a word.\r\n         wstring::const_iterator thisWord = curLocC;\r\n         wstring::const_iterator prevWord = curLocC;\r\n         wstring::const_iterator nextWord = curLocC;\r\n         //If someone has different length words for cap and small, this will need to be changed in the cases:\r\n         if (previousWordIsCapitalized(thisWord, prevWord) && nextWordIsCapitalized(thisWord, nextWord)) {\r\n            resultC.append(GetTupleCapCase(*it));\r\n            }\r\n         else {\r\n            resultC.append(GetTupleSmallCase(*it));\r\n            }\r\n         //Now append any whitespace after the string:\r\n         curLocC += str.length();\r\n         while (curLocC != endLocC && isWhiteSpaceOrPunctuation(curLocC)) {\r\n            resultC.append(1, *curLocC);\r\n            ++curLocC;\r\n            }\r\n         return found;\r\n         }\r\n      }\r\n   return found;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceNonCaseSensitiveBegin() {\r\n   //By 'non-case-sensitive', it is meant that the routine will check for either capped or\r\n   //non-capped matches.\r\n   bool found;\r\n   vector<tuple<wstring, wstring, wstring>>::iterator it;\r\n   wstring::const_iterator inputIterator;\r\n   const wstring * str;\r\n\r\n   //If there isn't a character before 'curLocC' we don't need to look any further.\r\n   if (curLocC == beginLocC) return false;\r\n   if (!(curLocC-1==beginLocC || isWhiteSpaceOrPunctuation(curLocC-1))) return false;\r\n   if (!isWhiteSpaceOrPunctuation(curLocC-1)) return false;\r\n\r\n   for (it = nonCaseSensitiveSubsC.begin(); it != nonCaseSensitiveSubsC.end(); ++it) {\r\n      str = &GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str->length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || towlower(*inputIterator) != (*str)[pos]) {\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) break;\r\n      }\r\n   if (found) {\r\n      //We need to see if it is capped, and if so, cap the output:\r\n      inputIterator = curLocC;\r\n      bool isCapped = true;\r\n      for (int pos=0, len=(*str).length(); pos<len; ++pos) {\r\n         if (iswlower(*inputIterator)) {\r\n            isCapped = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (isCapped) {\r\n         resultC.append(GetTupleCapCase(*it));\r\n         }\r\n      else {\r\n         resultC.append(GetTupleSmallCase(*it));\r\n         }\r\n      curLocC += GetTupleWord(*it).length();\r\n      return true;\r\n      }\r\n   return false;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceAsterisks() {\r\n   bool found;\r\n   vector<tuple<wstring, wstring, wstring>>::iterator it;\r\n   wstring::const_iterator inputIterator;\r\n   const wstring * str;\r\n\r\n   for (it = asteriskSubsC.begin(); it != asteriskSubsC.end(); ++it) {\r\n      str = &GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str->length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || towlower(*inputIterator) != (*str)[pos]) {\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) break;\r\n      }\r\n   if (found) {\r\n      //Go through the small cap tuple and if a character is an asterisk, replace\r\n      //the corresponding character with an asterisk:\r\n      str = &GetTupleSmallCase(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=(*str).length(); pos<len; ++pos) {\r\n         if ((*str)[pos] == L'*') {\r\n            resultC.append(L\"*\");\r\n            }\r\n         else {\r\n            resultC.append(1, *curLocC);\r\n            }\r\n         ++curLocC;\r\n         ++inputIterator;\r\n         }\r\n      return true;\r\n      }\r\n   return false;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceRepeatingStrings() {\r\n   bool found;\r\n   vector<tuple<wstring, wstring, wstring>>::iterator it;\r\n   wstring::const_iterator inputIterator;\r\n   const wstring * str;\r\n\r\n   for (it = repeatingStringsC.begin(); it != repeatingStringsC.end(); ++it) {\r\n      str = &GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str->length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || towlower(*inputIterator) != (*str)[pos]) {\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) {\r\n         //The inputIterator is pointing to the letter right after the initial string\r\n         //(ie, the final 'p' in 'poop')\r\n         str = &GetTupleCapCase(*it);\r\n         if (*inputIterator != (*str)[0]) found = false;\r\n         }\r\n      if (found) break;\r\n      }\r\n   if (found) {\r\n      //Go through the small cap tuple and if a character is an asterisk, replace\r\n      //the corresponding character with an asterisk:\r\n      str = &GetTupleSmallCase(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=(*str).length(); pos<len; ++pos) {\r\n         if ((*str)[pos] == L'*') {\r\n            resultC.append(L\"*\");\r\n            }\r\n         else {\r\n            resultC.append(1, *curLocC);\r\n            }\r\n         ++curLocC;\r\n         ++inputIterator;\r\n         }\r\n      return true;\r\n      }\r\n   return false;\r\n   }\r\n\r\n\r\nvoid Reformatter::reformat(const wstring & str) {\r\n   resultC.reserve(str.length()+1);\r\n   resultC.clear();\r\n   beginLocC = str.begin();\r\n   curLocC = beginLocC;\r\n   strLenC = str.length();\r\n   endLocC = str.end();\r\n   while (curLocC != endLocC) {\r\n      //Skip processing on whitespace:\r\n      while (curLocC != endLocC && isWhiteSpaceOrPunctuation(curLocC)) {\r\n         resultC.append(1, *curLocC);\r\n         ++curLocC;\r\n         }\r\n      if (curLocC == endLocC) return;\r\n      //Now do the non-whitespace processing:\r\n      if (!(replaceCaseSensitive() || replaceNonCaseSensitiveBegin() ||\r\n                  replaceRepeatingStrings() || replaceAsterisks())) {\r\n         resultC.append(1, *curLocC);\r\n         ++curLocC;\r\n         }\r\n      }\r\n   }\r\n\r\n\r\nint main() {\r\n   static Reformatter reformatter;\r\n\r\n   //First, some tests to show that it is working:\r\n   wstring str = L\"I GOTTEN PHB lettuce!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   str = L\"I GOTTEN phb lettuce!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   str = L\"Not Poopoop, and PoopPoop nInComPoop!!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   str = L\"My PHB is such a poophead. It's gotten worse since his promotion\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   //Changed the following to 'phb.com', so that program checks for more general case.\r\n   //phb.com redirects to another site in reality, but there is no reason not to check\r\n   //against being a URL in the implied design requirements.\r\n   cout << \"NOTE THAT 'boss' BECOMES CAPPED OR NON-CAPPED DEPENDING ON THE SURROUNDING WORDS:\"\r\n               << endl << \"ALSO, 'PHB' BECOMES 'boss' DEPENDING UPON WHETHER 'PHB' IS BY ITSELF.\"\r\n               << endl;\r\n   str = L\"MY PHB HAS started his new BLOG PHB_BLOG.com. And PHBBlog.com! \"\r\n               \"He's GOTTEn TO BE SUCH A MISBEGOTTEN POOPHEAD!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   //Now do an timing run:\r\n   TimerLowRes timerLowRes;\r\n   TimerHighRes timerHighRes;\r\n   LARGE_INTEGER timeRighRes;\r\n   vector<float> timeList;\r\n   int numIterations = 100;\r\n   int totalTests = 10;\r\n   for (int numTimes=0; numTimes<totalTests; ++numTimes) {\r\n      timerLowRes.start();\r\n      timerHighRes.start();\r\n      for (int x=0; x<numIterations; ++x) {\r\n         //reformatter.reformat(L\"MY PHB HAS started his new BLOG PHB_BLOG.com. And PHBBlog.com! He's gotten TO BE \"\r\n         //            \" SUCH A MISBEGOTTEN POOPHEAD!\");\r\n         reformatter.reformat(L\"My PHB is such a poophead. It's gotten worse since his promotion\");\r\n         //reformatter.reformat(L\"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\");\r\n         //reformatter.reformat(L\"I GOTTEN PHB lettuce!\");\r\n         //reformatter.reformat(L\"Not Poopoop, but PoopPoop!!\");  //Note that this will handle subsequent 'poops' correctly if 2 'p's together at end.\r\n         }\r\n      timeRighRes = timerHighRes.stop();\r\n      clock_t timeLowRes(timerLowRes.stop());\r\n      cout << \"low res time: \" << timeLowRes << \" milliseconds\" << endl;\r\n      cout << \"high res time: \" << timeRighRes.QuadPart/(float)1000 << \" milliseconds\" << endl;\r\n      timeList.push_back(timeRighRes.QuadPart/(float)1000);\r\n      }\r\n   float avg = 0.0;\r\n   for (int i=0; i<totalTests; ++i) avg += timeList[i];\r\n   avg = avg/totalTests;\r\n   cout << endl << \"Average = \" << avg << \" milliseconds\";\r\n   cout << endl << \"Enter any key, then an 'Enter' to exit: \";\r\n   cin >> timeRighRes.QuadPart; //Junk way to exit console, but good enough!\r\n   return 0;\r\n   }\n\r\nDidn't use any goto's, for those who are counting, but wouldn't have given a crap if I did.\n\r\nIt might be possible to streamline the logic in the replaceCaseSensitive and other replacement routines.  All the 'found' checking and setting seemed excessive, but it worked and I moved on.\n\r\nDavid\r\n", "id": "2_1158872_2", "owner_tier": 0.3, "score": 5.0}, {"content": "\r\n    EDIT: Ah, the wonders sleep can do.  Even though a solution was already chosen, I had an idea to improve my solution.\n\r\nThis was fun.  I don't get to use regex too much in my day to day sadly.\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\n\r\npublic class BadWordFilter\r\n{\r\n    public static void Replace(ref string input,\r\n        IDictionary<string, string> badWordMap)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(input))\r\n            throw new ArgumentException(nameof(input),\r\n                \"String cannot be null, empty, or whitespace.\");\r\n\r\n        foreach (KeyValuePair<string, string> badWord in badWordMap)\r\n            ReplaceBadWord(ref input, badWord);\r\n    }\r\n\r\n    private static void ReplaceBadWord(ref string input,\r\n        KeyValuePair<string, string> badWord)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(badWord.Key))\r\n            throw new ArgumentException(nameof(badWord.Key),\r\n                \"Key cannot be null, empty, or whitespace.\");\r\n\r\n        string pattern = GetReplacementPattern(badWord.Key);\r\n        MatchEvaluator evaluator = match =>\r\n        {\r\n            string replacement = badWord.Value;\r\n            if (match.Value == match.Value.ToUpper())\r\n            {\r\n                if (badWord.Key != badWord.Key.ToUpper())\r\n                    replacement = badWord.Value.ToUpper();\r\n            }\r\n            else if (match.Value[0] == char.ToUpper(match.Value[0]))\r\n                replacement = char.ToUpper(badWord.Value[0]) + badWord.Value.Substring(1);\r\n            return replacement;\r\n        };\r\n        input = Regex.Replace(input, pattern, evaluator, RegexOptions.IgnoreCase);\r\n    }\r\n\r\n    private static string GetReplacementPattern(string badWordKey)\r\n    {\r\n        StringBuilder pattern = new StringBuilder(\r\n            $@\"(?:\\b){badWordKey.Trim('*')}\"\r\n        );\r\n        if (badWordKey.StartsWith(\"*\"))\r\n            pattern.Insert(6, @\"\\w*\", 1);\r\n        if (badWordKey.EndsWith(\"*\"))\r\n            pattern.Append(@\"\\w*\");\r\n        return pattern.ToString();\r\n    }\r\n}\n\r\nYou use it like this:\nC#\n\r\nstatic void Main(string[] args)\r\n{\r\n    Dictionary<string, string> badWords = new Dictionary<string, string>()\r\n    {\r\n        {\"poop*\", \"p**phead\"},\r\n        {\"*HB\", \"boss\"},\r\n        {\"gotten\", \"become\"},\r\n        {\"*crap*\", \"taco supreme\"}\r\n    };\r\n    string input = \"My PHB is such a poophead. It's gotten worse since his promotion.  In fact you might call him a supercraphead!\";\r\n    BadWordFilter.Replace(ref input, badWords);\r\n    Console.WriteLine(input);\r\n    Console.ReadKey();\r\n}\r\n//Output:\r\n//My boss is such a p**phead.  It's become worse since his promotion.  In fact you might call him a taco supreme!\n\r\nHandles *text, text*, and *text* wildcards.  Will not capitalize a replacement for a word that is by default capitalized (ex. PHB -> boss). Maintains first-letter capitalization when appropriate.  Also support any regex code you'd like to put in the key since I directly inject it.  For example {\"p[oO0]+p*\", \"p**phead\"} will catch poop, poOp, p0OPhead, or even PoO0o0Ophead.\r\n", "id": "2_1157850_7", "owner_tier": 0.3, "score": 0}, {"content": "\r\n    After a little more refactoring and such:\n\nC#\n\r\nPIEBALD.Type.ReplaceOmatic replacer = \r\n  new PIEBALD.Type.ReplaceOmatic\r\n  (\r\n    new System.Tuple<string,string> ( \"PHB!\"        , \"boss!\"  ) \r\n  ,\r\n    new System.Tuple<string,string> ( \"gotten\"      , \"become\" ) \r\n  ,\r\n    new System.Tuple<string,string> ( \"*p[o0]{2}p*\" , \"p**p\"   ) \r\n  ) ;\r\n\r\nstring intext = \"My PHB is such a poophead. It's gotten worse since his promotion. My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\" ;\r\n\r\nstring outtext = intext ;\r\n\r\nint total = replacer.Replace ( ref outtext ) ;\r\n\r\nSystem.Console.WriteLine ( \"{0}\\n{1}\\n{2}\" , intext , total , outtext ) ;\n\r\nProduces: \n\n \n\r\nMy PHB is such a poophead. It's gotten worse since his promotion. My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\r\n5\r\nMy boss is such a p**phead. It's become worse since his promotion. My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\n\n\nThis just in (2016-11-27): ReplaceOmatic[^]\n\n\nLate breaking news (2016-11-28):\r\nI now have it tracking how many characters were replaced in each section, so it will stop applying replacements once the entire section has been replaced.\r\nThis is a reason to sort the more-frequently-hit replacements to the front of the List.\n\r\nAnd I've tightened up the code for copying characters to a StringBuilder.\n\r\nPart of the change:\nC#\n\r\nint r = 0 ;\r\n\r\n/* Apply ReplacementSpecs to the section until we run out of them or we've replaced the entire section. */\r\nfor ( int i = 0 ; ( i < this.rep.Count ) && ( r < Candidate.Length ) ; i++ )\r\n{\r\n  /* Track how many characters have been replaced so far. */\r\n  r += this.rep [ i ].Replace ( ref temp ) ;\r\n}\r\n\n\n\nNews flash! (2016-11-30):\r\nAdded Sorting and updated the Article and uploaded the latest code (I hope).\r\n", "id": "2_1157869_9", "owner_tier": 0.7, "score": 0}, {"content": "\r\n    I saw that no one addressed JavaScript jet...\r\nI did...\nJavaScript\n\r\nfunction Bad2Good(text)\r\n{\r\n\tvar T = {\r\n\t\t'poophead': 'p**phead',\r\n\t\t'PHB!': 'boss',\r\n\t\t'gotten': 'become',\r\n\t\t'poop*': 'p**p',\r\n\t\t'*poop': 'p**p'\r\n\t};\r\n\r\n\tfor (var prop in T)\r\n\t{\r\n\t\tvar flags = 'ig';\r\n\r\n\t\t// starts with\r\n\t\tif (prop[prop.length-1] == '*')\r\n\t\t{\r\n\t\t\tprop = /(\\s|[!?.,])poop(\\w*)/;\r\n\t\t}\r\n\r\n\t\t// ends with\r\n\t\tif (prop[0] == '*')\r\n\t\t{\r\n\t\t\tprop = /(\\w*)poop(\\s|[!?.,])/;\r\n\t\t}\r\n\r\n\t\t// case sensitive\r\n\t\tif (prop[prop.length - 1] == '!')\r\n\t\t{\r\n\t\t\tflags = 'g';\r\n\t\t\tprop = prop.substr(0, prop.length - 1);\r\n\t\t}\r\n\r\n\t\ttext = text.replace(new RegExp(prop, flags), function (match, p1, p2, p3, p4)\r\n\t\t{\r\n\t\t\tif (Number.isInteger(p1))\r\n\t\t\t{\r\n\t\t\t\tif (match.toUpperCase() == match)\r\n\t\t\t\t{\r\n\t\t\t\t\t// case sensitive\r\n\t\t\t\t\tif (T[match.toLowerCase()] == undefined)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (T[match + '!']);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// shouting\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (T[match.toLowerCase()].toUpperCase());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// normal\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (T[match]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// starts with\r\n\t\t\t\tif(/(\\s|[!?.,])/.test(p1))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatch = match.substr(p1.length, match.length - p1.length - p2.length);\r\n\r\n\t\t\t\t\treturn (p1 + ((match.toUpperCase() == match) ? T[match.toLowerCase() + '*'].toUpperCase() : T[match.toLowerCase() + '*']) + p2);\r\n\t\t\t\t}\r\n\t\t\t\t// ends with\r\n\t\t\t\telse if (/(\\s|[!?.,])/.test(p2))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatch = match.substr(p1.length, match.length - p1.length - p2.length);\r\n\r\n\t\t\t\t\treturn (p1 + ((match.toUpperCase() == match) ? T['*' + match.toLowerCase()].toUpperCase() : T['*' + match.toLowerCase()]) + p2);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (match);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn (text);\r\n}\n\r\nGot home. Got time. Saw some of my bugs and smashed them...\nJavaScript\n\r\nfunction Bad2Good(text)\r\n{\r\n\tvar T = {\r\n\t\t'PHB!': 'boss',\r\n\t\t'gotten': 'become',\r\n\t\t'poop*': 'p**p',\r\n\t\t'*poop': 'p**p'\r\n\t};\r\n\r\n\tfor (var prop in T)\r\n\t{\r\n\t\tvar flags = 'ig';\r\n\r\n        // case sensitive\r\n\t\tif (prop[prop.length - 1] == '!')\r\n\t\t{\r\n\t\t\tflags = 'g';\r\n\t\t\tprop = prop.substr(0, prop.length - 1);\r\n\t\t}\r\n\r\n\t\t// starts with\r\n\t\tif (prop[prop.length - 1] == '*')\r\n\t\t{\r\n\t\t\tprop = '(\\\\b)' + prop.substr(0, prop.length - 1) + '(\\\\w*)(\\\\b)';\r\n\t\t} \r\n        \r\n        // ends with\r\n\t\tif (prop[0] == '*')\r\n\t\t{\r\n\t\t\tprop = '(\\\\b)(\\\\w*)' + prop.substr(1, prop.length) + '(\\\\b)';\r\n\t\t}\r\n\r\n\t\ttext = text.replace(new RegExp(prop, flags), function (match, len, p1)\r\n\t\t{\r\n            var lookup;\r\n            var replace;\r\n            var good;\r\n\r\n            if(Number.isInteger(len))\r\n            {\r\n                replace = match;\r\n                lookup = match;\r\n            }\r\n            else \r\n            {\r\n                if(match.startsWith(p1)) \r\n                {\r\n                    replace = match.replace(p1, '');\r\n                    lookup = '*' + replace;\r\n                }\r\n                else\r\n                {\r\n                    replace = match.replace(p1, '');\r\n                    lookup = replace + '*';\r\n                }\r\n            }\r\n\r\n            good = T[lookup.toLowerCase()] || T[lookup + '!'];\r\n\r\n            if(T[lookup + '!'] == undefined)\r\n            {\r\n                if((replace.toUpperCase() == replace))\r\n                {\r\n                    good = good.toUpperCase();\r\n                }\r\n                else if((replace.toLowerCase() == replace))\r\n                {\r\n                    good = good.toLowerCase();\r\n                }\r\n            }\r\n\r\n            return(match.replace(replace, good));\r\n\t\t});\r\n\t}\r\n\r\n\treturn (text);\r\n}\n", "id": "2_1158031_3", "owner_tier": 0.5, "score": 0}, {"content": "\r\n    Quick and dirty Javascript\n\nJavaScript\n\r\nvar bad = [\"poop*\", \"PHB!\", \"gotten\"];\r\nvar replacement = [\"p**p\", \"boss\", \"become\"];\r\nfunction escapeRegExp(str) {\r\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\nfunction replaceBad(sentence){\r\n\treturn sentence.split(/\\b/).map(w => {\r\n\t\tfor(var i=0, m=bad.length; i<m; i++){\r\n\t\t\tvar badToken = bad[i];\r\n\t\t\tif(badToken.slice(-1)==='*') { // ends with *\r\n\t\t\t\treturn w.replace(new RegExp('^' + escapeRegExp(badToken.slice(0,-1)) + '(.*)$', 'i'), replacement[i]+'$1');\r\n\t\t\t}\r\n\t\t\tif(badToken.slice(0)==='*') { // starts with *\r\n\t\t\t\treturn w.replace(new RegExp('^(.*)'+ escapeRegExp(badToken.slice(1)) + '$', 'i'), '$1' + replacement[i]);\r\n\t\t\t}\r\n\t\t\tif(badToken.slice(-1)==='!') { // ens with !\r\n\t\t\t\treturn w.replace(new RegExp('^'+ escapeRegExp(badToken.slice(0,-1)) + '$', ''), replacement[i]);\r\n\t\t\t}\r\n\t\t\treturn w.replace(new RegExp('^'+badToken+'$', 'i'), replacement[i]);\r\n\t\t}\r\n\t}).join('');\r\n}\r\n\r\nvar test=['Hello poophead; glad your PHB has \"gotten\" less rotten',\r\n'Hi poopheadpoop; glad your PhB has \"undergotten\" less NOPHB'\r\n];\r\n\r\ntest.forEach(s => {\r\n\tconsole.log(s + ' => ' + replaceBad(s)); \r\n})\n", "id": "2_1158222_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    Only spotted this 20 min ago, so hopefully not too late to the tea party!\n\r\nC# code allows for individual word case sensitivity + shortcut override (in bonus requirement). All cases use the same bad word replacement extension methods. ReplaceWords string extension for a set of words or ReplaceText string extension for single word granularity.\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace BadWordFilter\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            FirstTest();\r\n            BonusTest();\r\n\r\n            Console.WriteLine(\"-- Press any key to exit --\");\r\n            Console.ReadKey();\r\n        }\r\n\r\n        private static void FirstTest()\r\n        {\r\n            var badWords = new Dictionary<string, tuple<string, bool>>()\r\n            {\r\n                {\"poophead\", new Tuple<string, bool>(\"p**phead\", false)},\r\n                {\"PHB\", new Tuple<string, bool>(\"boss\", false)},\r\n                {\"gotten\",new Tuple<string, bool>(\"become\", false) }\r\n            };\r\n\r\n            string badMessage = \"My        PHB is such a poophead. It's gotten worse since his promotion\";\r\n            string goodMessage = badMessage.ReplaceWords(badWords, filtered: false);\r\n\r\n            Console.WriteLine(\"First Test\");\r\n            Console.WriteLine(\"==========\");\r\n            Console.WriteLine($\"Before: {badMessage}\");\r\n            Console.WriteLine($\"After:  {goodMessage}\");\r\n            Console.WriteLine();\r\n\r\n            badWords = new Dictionary<string, tuple<string, bool>>()\r\n            {\r\n                {\"POOPHEAD\", new Tuple<string, bool>(\"P**PHEAD\", true)},\r\n                {\"poophead\", new Tuple<string, bool>(\"p**phead\", false)},\r\n                {\"PHB\", new Tuple<string, bool>(\"boss\", true)}\r\n            };\r\n\r\n            badMessage = \"My PHB is such a POOPHEAD!\";\r\n            goodMessage = badMessage.ReplaceWords(badWords, filtered: false);\r\n\r\n            Console.WriteLine($\"Before: {badMessage}\");\r\n            Console.WriteLine($\"After:  {goodMessage}\");\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n        private static void BonusTest()\r\n        {\r\n            var badWords = new Dictionary<string, tuple<string, bool>>()\r\n            {\r\n                {\"POOP*\", new Tuple<string, bool>(\"P**P\", true) },\r\n                {\"poop*\", new Tuple<string, bool>(\"p**p\", false) },\r\n                {\"PHB!\", new Tuple<string, bool>(\"boss\", true) },\r\n                {\"gotten\",new Tuple<string, bool>(\"become\", true) }\r\n            };\r\n\r\n            string badMessage = \"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\";\r\n            string goodMessage = badMessage.ReplaceWords(badWords, filtered: true);\r\n\r\n            Console.WriteLine(\"Bonus Test\");\r\n            Console.WriteLine(\"==========\");\r\n            Console.WriteLine($\"Before: {badMessage}\");\r\n            Console.WriteLine($\"After:  {goodMessage}\");\r\n            Console.WriteLine();\r\n        }\r\n    }\r\n\r\n    public static class StringExtension\r\n    {\r\n        private static readonly string[] spaceSplitChar = { \" \" };\r\n        private static readonly char[] wordSplitChars = @\"?<=[\\.!\\?])\".ToCharArray();\r\n\r\n        public static string ReplaceWords(this string input, Dictionary<string, tuple<string, bool>> badWords, bool filtered = false, bool trimWhitespaces = true)\r\n        {\r\n            if (string.IsNullOrEmpty(input))\r\n                return input;\r\n\r\n            foreach (var word in badWords)\r\n                input = input.ReplaceText(word.Value.Item1, word.Key, filtered: filtered, isCaseSensitive: word.Value.Item2, trimWhitespaces: trimWhitespaces);\r\n\r\n            return input;\r\n        }\r\n\r\n        public static string ReplaceText(this string input, string replaceText, string findText = \"\", bool filtered = false, bool isCaseSensitive = false, bool trimWhitespaces = true)\r\n        {\r\n            if (string.IsNullOrEmpty(input))\r\n                return input;\r\n\r\n            var sb = new StringBuilder();\r\n            bool isMatchStart = false, \r\n                 isMatchEnd = false;\r\n            StringComparison compareMode = isCaseSensitive ? StringComparison.InvariantCulture : StringComparison.InvariantCultureIgnoreCase;\r\n\r\n            if (filtered)\r\n            {\r\n                isMatchStart = findText.EndsWith(\"*\");\r\n                isMatchEnd = findText.StartsWith(\"*\");\r\n                compareMode = findText.EndsWith(\"!\") ? StringComparison.InvariantCulture : compareMode;\r\n                findText = findText.Trim(new[] { '*', '!' });\r\n            }\r\n\r\n            int lenOldValue = findText.Length,\r\n                curPosition = 0,\r\n                idxNext = input.IndexOf(findText, compareMode);\r\n\r\n            while (idxNext >= 0)\r\n            {\r\n                if (isMatchStart || !isMatchEnd)\r\n                {\r\n                    if (input.Substring(idxNext - 1, 1).Equals(\" \"))\r\n                        sb.Append(input, curPosition, idxNext - curPosition)\r\n                          .Append(replaceText);\r\n                }\r\n                else if (isMatchEnd)\r\n                {\r\n                    sb.Append(input, curPosition, idxNext - curPosition)\r\n                      .Append(curPosition < input.Length && input.Substring(curPosition, curPosition + 1)[0].IsEndChar() ? findText : replaceText);\r\n                }\r\n\r\n                curPosition = idxNext + lenOldValue;\r\n                idxNext = input.IndexOf(findText, curPosition, compareMode);\r\n            }\r\n            sb.Append(input, curPosition, input.Length - curPosition);\r\n\r\n            input = sb.ToString();\r\n            if (trimWhitespaces)\r\n                input= input.TrimCharacter(' ');\r\n\r\n            return input;\r\n        }\r\n\r\n        public static bool IsEndChar(this char c)\r\n            => wordSplitChars.Contains(c);\r\n\r\n        public static string TrimCharacter(this string input, char c)\r\n            => string.Join(c.ToString(), input.Split(c).Where(str => str != string.Empty).ToArray());\r\n\r\n    }\r\n}\n\r\nOutput from execution:\n \n\r\nFirst Test\r\n==========\r\n\r\nBefore: My        PHB is such a poophead. It's gotten worse since his promotion\r\nAfter:  My boss is such a p**phead. It's become worse since his promotion\r\n\r\nBefore: My PHB is such a POOPHEAD!\r\nAfter:  My boss is such a P**PHEAD!\r\n\r\n\r\nBonus Test\r\n==========\r\n\r\nBefore: My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\r\nAfter:  My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\r\n\r\n-- Press any key to exit --\n\r\nThis code is built for efficiency, so no RegEx used! ;)\n\r\n[edit: hopefully I have fixed all the weird stuff when code pasted in...]\r\n", "id": "2_1158266_12", "owner_tier": 0.5, "score": 0}, {"content": "\r\n    VISUAL PROLOG 7.5 Solution.\n\r\nNote:  the bad_nice/2 clauses can be moved to an external file for maintenance independent of the rest of the code.\n\r\nThis could be tidied up more, but I considered speed of submission to be the priority here.\n\r\nHarrison Pratt\n\n\n\n\r\nclass predicates\r\n    badWordFix : ( string TextToFilter ) -> string FixedText.\r\nclauses\r\n    badWordFix( Text ) = FixedText :-\r\n        Splitters = \" .,:!\",\r\n        FixedText = fixText ( Text, Splitters, \"\" ).\r\n\r\n        class predicates\r\n            fixText : ( string, string Separators, string Temp ) -> string.\r\n        clauses\r\n            fixText( \"\",_,S ) = S :-!.\r\n            fixText( S, Separators, Temp ) = FixedText :-\r\n                string::splitStringBySeparators(S,Separators,HeadStr,CurrSep,Rest ),\r\n                !,\r\n                FixedText = fixText( Rest, Separators, string::concat( Temp, filteredWord(HeadStr), string::charToString(CurrSep) )).\r\n            fixText( S, Separators, Temp ) = FixedText :-\r\n                FixedText = fixText(\"\",Separators,string::concat(Temp,S )).\r\n\r\n    class predicates\r\n        filteredWord : ( string ) -> string .\r\n    clauses\r\n        filteredWord( S ) = NiceWord :-\r\n            CleanS = stripPrefix( stripSuffix(S,\"*\"), \"*\" ),\r\n            bad_nice( CleanS, NiceWord ), !.\r\n        filteredWord( S ) = S.\r\n\r\n    class predicates\r\n        bad_nice : ( string, string [out] ) determ.\r\n    clauses\r\n        bad_nice( \"poophead\", \"p***head\" ).\r\n        bad_nice( \"PHB\", \"boss\" ).\r\n        bad_nice( \"gotten\", \"become\" ).\r\n\r\n    class predicates\r\n        stripPrefix : ( string, string ) -> string.\r\n    clauses\r\n        stripPrefix( S, Pre ) = StripStr :-\r\n            string::hasPrefix(S,Pre,StripStr), !.\r\n        stripPrefix( S, _ ) = S.\r\n    \r\n    class predicates\r\n        stripSuffix : ( string, string ) -> string.\r\n    clauses    \r\n        stripSuffix( S, Suff ) = StripStr :-\r\n            string::hasSuffix(S,Suff,StripStr), !.\r\n        stripSuffix( S, _ ) = S.\n", "id": "2_1158270_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    I'm a fan of clean code.\r\nWhich for me is at least:\r\n    - It should be expressive-> meaningful names\r\n    - Smaller is better -> methods should be short\r\n    - Can be easily extended by any other developer -> if requiremets changes easy to adapt\r\n    - Reading the code should be pleasant -> because you can follow the logic without overstress your brain\n\r\nHere it is (BadWordsMatch.cs):\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\n\r\nnamespace BadWords\r\n{\r\n    public enum eHow { easy, hard };\r\n\r\n    public class BadWordsMatchAndReplace\r\n    {\r\n            public enum eMatchMode { startsWith, Endswith, Equals };\r\n            public struct sWildCardAndCase\r\n            {\r\n                public eMatchMode matchMode;\r\n                public bool respectCase;\r\n                public string key;\r\n            }\r\n\r\n            public static Dictionary<sWildCardAndCase, string> dictBadWordsEasy = new Dictionary<sWildCardAndCase, string>(){\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key =\"poophead\"}, \"p**phead\"},\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key =\"PHB\"}, \"boss\"},\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key =\"gotten\"} , \"become\"}\r\n            };\r\n\r\n            public static Dictionary<sWildCardAndCase, string> dictBadWordsHard = new Dictionary<sWildCardAndCase, string>(){\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.startsWith, respectCase = false, key = \"poop\" }, \"p**p\" },\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key = \"PHB\" }, \"boss\" },\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = false, key = \"gotten\" }, \"become\" }\r\n\r\n           };\r\n\r\n            // shouting is retrieved by allowing an exclamation mark in words and later on compared to last char therein\r\n            public static Regex r = new Regex(@\"([!\\w])+\", RegexOptions.None);\r\n            public static bool shouting = false;\r\n\r\n            /// <summary>\r\n            /// checks an input sentence for bad words and replaces them by safer expressions\r\n            /// </summary>\r\n            /// <param name=\"input\">sentence to check</param>\r\n            /// <param name=\"how\">easy or hard substitution rule</param>\r\n            /// <returns>corrected string</returns>           \r\n            /// \r\n            public static string MatchAndReplace(string input, eHow how)\r\n            {\r\n\r\n                string output = input;\r\n                string s = string.Empty;\r\n                shouting = false;\r\n\r\n                Dictionary<sWildCardAndCase, string> baseDict = (how == eHow.easy ? dictBadWordsEasy : dictBadWordsHard);\r\n                Match m = r.Match(input);\r\n\r\n                while (m.Success)\r\n                {\r\n                    s = m.Value;\r\n                    bool found = false;\r\n\r\n                    foreach (KeyValuePair<sWildCardAndCase, string> kvp in baseDict)\r\n                    {\r\n                        bool respectCase = kvp.Key.respectCase;\r\n                        if ( s.EndsWith(\"!\"))\r\n                        {\r\n                            // case insensitive and make replacement uppercase\r\n                            shouting = true;\r\n                            respectCase = false;\r\n                        }\r\n                        // looks for matches under given constraints and updates output accordingly\r\n                        found = ProcessWord(s, kvp.Key.key, respectCase, kvp.Key.matchMode, kvp.Value, ref output);\r\n                        if (found) break;\r\n                    }\r\n                    m = m.NextMatch();\r\n                }\r\n                return output;\r\n \r\n\r\n            }\r\n\r\n            /// <summary>\r\n            /// looks for a match of word under given constraints and updates output accordingly\r\n            /// </summary>\r\n            /// <param name=\"word\">word from input string</param>\r\n            /// <param name=\"key\">bad word</param>\r\n            /// <param name=\"respectCase\">match only case exactly</param>\r\n            /// <param name=\"matchMode\">wildcard specifier</param>\r\n            /// <param name=\"value\">replacement</param>\r\n            /// <param name=\"output\">output -> output with replacement</param>\r\n            /// <returns>no match -> false else true</returns>\r\n            ///             \r\n            private static bool ProcessWord(string word, string key, bool respectCase, eMatchMode matchMode, string value, ref string output)\r\n            {\r\n                if (respectCase && !word.Contains(key)) return false;\r\n                if (!respectCase && !word.ToLower().Contains(key.ToLower())) return false;\r\n                if (!ConstraintsMet(  word,  key,  respectCase,  matchMode)) {\r\n                    return false;\r\n                }\r\n                if (respectCase)\r\n                {\r\n                    output = output.Replace(key, value);\r\n                }\r\n                else\r\n                {\r\n                    if (word.Any(char.IsUpper))\r\n                        output = output.Replace(key.ToUpper(), value.ToUpper());\r\n                    else if (shouting)\r\n                        output = output.Replace(key, value.ToUpper());\r\n                    else\r\n                        output = output.Replace(key, value);\r\n                }\r\n                return true;\r\n\r\n            }\r\n\r\n            /// <summary>\r\n            /// checks for constraints\r\n            /// </summary>\r\n            /// <param name=\"word\">word from input string</param>\r\n            /// <param name=\"key\">bad word</param>\r\n            /// <param name=\"respectCase\">match only case exactly</param>\r\n            /// <param name=\"matchMode\">wildcard specifier</param>\r\n            /// <returns>constraints met -> true else false</returns>\r\n            ///              \r\n            private static bool ConstraintsMet( string word, string key, bool respectCase, eMatchMode matchMode)\r\n            {\r\n                string wordToCompare = word;\r\n                if (shouting) { wordToCompare = wordToCompare.TrimEnd('!'); };\r\n                switch (matchMode)\r\n                {\r\n                    case eMatchMode.Equals:\r\n                        if (respectCase && !wordToCompare.Equals(key)) { return false; }\r\n                        else if (!respectCase && !wordToCompare.ToLower().Equals(key.ToLower())) { return false; }\r\n                        break;\r\n                    case eMatchMode.startsWith:\r\n                        if (respectCase && !wordToCompare.StartsWith(key)) { return false; }\r\n                        else if (!respectCase && !wordToCompare.ToLower().StartsWith(key.ToLower())) { return false; }\r\n                         break;\r\n                    case eMatchMode.Endswith:\r\n                        if (respectCase && !wordToCompare.EndsWith(key)) { return false; }\r\n                        else if (!respectCase && !wordToCompare.ToLower().EndsWith(key.ToLower())) { return false; }\r\n                        break;\r\n                }\r\n                return true;\r\n\r\n            }\r\n\r\n    }\r\n}\n\n\r\nIt should be self explaining.\r\nMost important is: I concentrate the requirements about case sensitivity and wildcard rules in a data structure which relieves me from looking for *s before or\r\nafter the search key.\r\nFor the 'Easy part' I would not had a need for this but once I made it for the hard\r\npart it's nice to have it for this part too, because the code can be one for both \r\n(C#\n\r\nDictionary<sWildCardAndCase, string> baseDict = (how == eHow.easy ? dictBadWordsEasy : dictBadWordsHard);\n\r\nFor Testing my Code I have provided a little Console Main, which is here (Program.cs):\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\n\r\nnamespace BadWords\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {        \r\n            string input = string.Empty;\r\n            string s = string.Empty;\r\n            string output = string.Empty;\r\n\r\n            while (!(s.Equals(\"q\")))\r\n            {\r\n                while (!(s = Console.ReadLine()).Equals(\".\"))\r\n                {\r\n                    input = input + s;\r\n                }\r\n                Console.WriteLine(\"------------- Easy Match ---------------\"); \r\n                Console.WriteLine(input);\r\n                output = BadWordsMatchAndReplace.MatchAndReplace(input, eHow.easy);\r\n                Console.WriteLine(output);\r\n                Console.WriteLine(\"------------- Bonus Match ---------------\");\r\n                Console.WriteLine(input);\r\n                output = BadWordsMatchAndReplace.MatchAndReplace(input, eHow.hard);\r\n                Console.WriteLine(output);\r\n                Console.WriteLine(\"-------------- Next Input ---------------\");\r\n                s = Console.ReadLine();\r\n                input = s;\r\n\r\n            }\r\n        }\r\n    }\r\n}\n\nUsage: Paste your input (multiline allowed), then type <return>.<return>\r\n        If you want to stop the program then type <return>q<return>\n", "id": "2_1158317_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    I decided to use F#\u2026\n\r\nEach filter specification is converted to a closure that takes a string, potentially sanitises it and returns the good string. To process all words in a string, use Regex.Replace with a MatchEvaluator that runs the filter list over the matched word.\n\nF#\n\r\nopen System\r\nopen System.Text.RegularExpressions\r\n\r\n// Define an active pattern to match a string starting with a prefix and return the remnant of the string\r\nlet (|Prefix|_|) (ignoreCase:bool) (prefix:string) (s:string) =\r\n   let maybePrefix = s.Substring(0, (min prefix.Length s.Length))\r\n   match String.Compare(maybePrefix, prefix, ignoreCase) with\r\n   | 0 -> Some(maybePrefix, s.Substring(prefix.Length))\r\n   | _ -> None\r\n\r\n// Define an active pattern to match a string ending with a suffix and return the remnant of the string\r\nlet (|Suffix|_|) (ignoreCase:bool) (suffix:string) (s:string) =\r\n   let maybeSuffix = s.Substring((max 0 (s.Length - suffix.Length)))\r\n   match String.Compare(maybeSuffix, suffix, ignoreCase) with\r\n   | 0 -> Some(maybeSuffix, s.Substring(0, s.Length - suffix.Length))\r\n   | _ -> None\r\n\r\n// Adjust case of a good word to reflect how the bad word's been used\r\nlet AdjustCase (suffix:string) (badBit:string) (goodWord:string) (ignoreCase:bool) =\r\n   if not ignoreCase then\r\n      goodWord\r\n   else if badBit = suffix.ToUpper() then\r\n      goodWord.ToUpper()\r\n   else if badBit = suffix.ToLower() then\r\n      goodWord.ToLower()\r\n   else\r\n      goodWord\r\n\r\n// Create a filter (a closure of string -> string) from a filter spec (pair of strings, \r\n// first = bad word, second = replacement). Applying the closure to a string will sanitise it.\r\nlet createFilter (spec:string*string) =\r\n   let rec createFilterHelper (badWord:string) (goodWord:string) (ignoreCase:bool) =\r\n      match badWord with\r\n      // Case sensitive?\r\n      | Suffix true \"!\" (_, prefix) -> createFilterHelper prefix goodWord false\r\n      // badWord is a prefix (<string>*)\r\n      | Suffix true \"*\" (_, prefix) ->\r\n         fun (word:string) ->\r\n            match word with\r\n            | Prefix ignoreCase prefix (badBit, restOfWord) -> (AdjustCase prefix badBit goodWord ignoreCase) + restOfWord\r\n            | anyOtherWord -> anyOtherWord\r\n      // badWord is a sufffix (*<string>)\r\n      | Prefix true \"*\" (_, suffix) ->\r\n         fun (word:string) ->\r\n            match word with\r\n            | Suffix ignoreCase suffix (badBit, restOfWord) -> restOfWord + (AdjustCase suffix badBit goodWord ignoreCase)\r\n            | anyOtherWord -> anyOtherWord\r\n      // badWord is fixed\r\n      | anyOtherWord -> \r\n         fun (word:string) ->\r\n            match String.Compare(word, badWord, ignoreCase) with\r\n            | 0 -> AdjustCase badWord word goodWord ignoreCase\r\n            | _ -> word\r\n   // Invoke createFilterHelper\r\n   createFilterHelper (fst spec) (snd spec) true\r\n\r\n// Create a filter list from a spec list\r\nlet createFilters specs = specs |> List.map createFilter\r\n\r\n// Apply a sequence of filters to a word\r\nlet filterAWord filters word = filters |> Seq.fold (fun word filter -> filter word) word\r\n\r\n// Apply a sequence of filters to each word in a string\r\nlet filterWords filters text = Regex.Replace(text, \"\\w+\", MatchEvaluator(fun regexMatch -> filterAWord filters regexMatch.Value))\r\n\r\n// These are my test filter specs\r\nlet filterSpecs = [ (\"poop*\", \"p**p\"); (\"PHB!\", \"boss\") ; (\"gotten\", \"become\") ]\r\n\r\n// And my test filters\r\nlet compiledFilters = createFilters filterSpecs\r\n\r\nlet tests = \r\n   printfn \"Poophead -> p**phead = %b\" ((filterAWord compiledFilters \"Poophead\") = \"p**phead\")\r\n   printfn \"PHB -> boss = %b\" ((filterAWord compiledFilters \"PHB\") = \"boss\")\r\n   printfn \"Phb -> Phb = %b\" ((filterAWord compiledFilters \"Phb\") = \"Phb\")\r\n   printfn \"gotten -> become = %b\" ((filterAWord compiledFilters \"gotten\") = \"become\")\r\n   printfn \"<long string=\"\"> - %b\" ((filterWords compiledFilters \"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\") = \"My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\")\r\n</long></string></string>\n", "id": "2_1158506_1", "owner_tier": 0.3, "score": 0}, {"content": "\nNOTE: This is a performance summary comparison of the above C# solutions only\n\r\n** Updated 2/12/16: Stuart Dootson supplied test project, so timings updated.\n\r\nI was curious to see how the other C# solutions compared performance wise to my own, so I build a test bed that you can download[^] and try yourself. I balanced out all the solutions so they ran equally against the same test strings.\n\nDisclaimer: I did not check each solution to see if they all gave the same output or not. I have now run tests on each of the solutions and 3 of them fail the benchmark set. (I suggest that the authors of solutions 3, 5 & 12 download the link above and check for errors.)\n\r\nHere are the results (best to worse ranked by average) on my dev machine compiled in Release Mode and run from the command line.\n\r\n(Note: Results will differ for you based on your system configuration)\n\r\nAfter the initial positioning of results and tweaks to all the tests (v2), I felt that I could improve my results a little, so I've made some minor changes (can be found in the download link above), and the revised results are now:\n\n \n\r\n-----------------------------------------------------------------------------------\r\n \r\nTests run:        10\r\nIterations/test:  100\r\nTotal executions: 1,000\r\n \r\nBasic Test\r\n \r\n   Solution 10   : MIN:  0.72670 ms | MAX:  0.96770 ms | AVG:  0.75483 ms\r\n   Solution 1    : MIN:  1.17980 ms | MAX:  2.08300 ms | AVG:  1.30762 ms\r\n   Solution 3    : MIN:  2.92230 ms | MAX:  3.71300 ms | AVG:  3.03632 ms\r\n   Solution 8    : MIN:  3.97410 ms | MAX:  4.34740 ms | AVG:  4.06542 ms\r\n   Solution 12   : MIN:  4.97950 ms | MAX:  5.31250 ms | AVG:  5.04871 ms\r\n   Solution 13*2 : MIN:  7.2594 ms  | MAX: 10.2251 ms  | AVG:  8.18209 ms\r\n   Solution 2    : MIN:  7.33320 ms | MAX:  8.42080 ms | AVG:  7.63468 ms\r\n   Solution 13*1 : MIN:  8.4053 ms  | MAX: 14.0585 ms  | AVG: 10.4869 ms\r\n   Solution 5    : MIN: 14.79730 ms | MAX: 17.29360 ms | AVG: 15.54762 ms\r\n \r\nBonus Test\r\n \r\n   Solution 10   : MIN:  1.08750 ms | MAX:  1.13540 ms | AVG:  1.10539 ms\r\n   Solution 1    : MIN:  1.09130 ms | MAX:  1.35580 ms | AVG:  1.15636 ms\r\n   Solution 3    : MIN:  2.95310 ms | MAX:  3.38000 ms | AVG:  3.04058 ms\r\n   Solution 8    : MIN:  5.37370 ms | MAX:  5.74020 ms | AVG:  5.46218 ms\r\n   Solution 12   : MIN:  7.44160 ms | MAX:  7.72250 ms | AVG:  7.50184 ms\r\n   Solution 13*2 : MIN:  7.4998 ms  | MAX: 12.9918 ms  | AVG:  8.99166 ms\r\n   Solution 13*1 : MIN:  8.2866 ms  | MAX: 11.5506 ms  | AVG:  9.42119 ms\r\n   Solution 2    : MIN:  8.54510 ms | MAX:  8.86510 ms | AVG:  8.64252 ms\r\n   Solution 5    : MIN: 16.79520 ms | MAX: 17.75920 ms | AVG: 17.19089 ms\r\n \r\n*1 F#Solution\r\n*2 PreCompiledF#Solution\r\n-----------------------------------------------------------------------------------\r\n \r\nTests run:        10\r\nIterations/test:  1000\r\nTotal executions: 10,000\r\n \r\nBasic Test\r\n \r\n   Solution 10   : MIN:   7.24660 ms | MAX:   7.52710 ms | AVG:   7.35793 ms\r\n   Solution 1    : MIN:  10.38490 ms | MAX:  10.72050 ms | AVG:  10.53257 ms\r\n   Solution 3    : MIN:  29.32480 ms | MAX:  29.52170 ms | AVG:  29.41673 ms\r\n   Solution 8    : MIN:  39.87840 ms | MAX:  40.39850 ms | AVG:  40.05387 ms\r\n   Solution 12   : MIN:  49.83420 ms | MAX:  50.64540 ms | AVG:  50.08076 ms\r\n   Solution 2    : MIN:  73.15800 ms | MAX:  74.28660 ms | AVG:  73.62445 ms\r\n   Solution 13*2 : MIN:  78.6023 ms  | MAX:  93.5715 ms  | AVG:  83.0625 ms\r\n   Solution 13*1 : MIN:  88.4249 ms  | MAX:  93.8609 ms  | AVG:  90.9543 ms\r\n   Solution 5    : MIN: 140.52420 ms | MAX: 148.83820 ms | AVG: 143.44404 ms\r\n \r\n\r\nBonus Test\r\n \r\n   Solution 1    : MIN:   9.54210 ms | MAX:  10.12520 ms | AVG:   9.72796 ms\r\n   Solution 10   : MIN:  10.84060 ms | MAX:  11.22680 ms | AVG:  10.94738 ms\r\n   Solution 3    : MIN:  29.66310 ms | MAX:  30.13180 ms | AVG:  29.79657 ms\r\n   Solution 8    : MIN:  54.05920 ms | MAX:  59.03390 ms | AVG:  56.43869 ms\r\n   Solution 12   : MIN:  74.48620 ms | MAX:  75.41370 ms | AVG:  74.66223 ms\r\n   Solution 13*2 : MIN:  78.3943 ms  | MAX:  98.3158 ms  | AVG:  83.7617 ms\r\n   Solution 2    : MIN:  87.62770 ms | MAX:  92.20400 ms | AVG:  91.17817 ms\r\n   Solution 13*1 : MIN:  87.9642 ms  | MAX:  99.3946 ms  | AVG:  91.8193 ms\r\n   Solution 5    : MIN: 168.75850 ms | MAX: 201.33640 ms | AVG: 175.94069 ms\r\n\r\n*1 F#Solution\r\n*2 PreCompiledF#Solution\r\n-----------------------------------------------------------------------------------\n\nNOTE: with a small adjustment to the test to better reflect real-world examples, many of the solutions received a performance gain.\n\r\nLastly, if I have not correctly used a solution, please let me know so that I can update results. If any authors make changes, also please let me know and I will make sure that the tests are re-run and results published.\n\r\n* old test: download[^]\r\n* old v2 test: download[^]\r\n", "id": "2_1158646_6", "owner_tier": 0.5, "score": 0}, {"content": "\r\n    A Haskell solution\u2026 Essentially a rough translation of my F# one!\n\n\n\r\n{-# LANGUAGE OverloadedStrings, TemplateHaskell, QuasiQuotes #-}\r\n\r\nmodule Main where\r\n\r\nimport Criterion.Main\r\nimport Data.CaseInsensitive (mk, CI)\r\nimport Data.Char as C\r\nimport Data.List (find)\r\nimport Data.Maybe (fromJust, isJust)\r\nimport Data.Stringable\r\nimport Data.Text (Text)\r\nimport qualified Data.Text as T\r\nimport Text.Regex.PCRE.Heavy\r\n\r\ndata FilterSpec = FilterSpec { badPattern::Text, goodWord::Text }\r\ntype FilterSpecs = [FilterSpec]\r\ntype Filter = Text -> Maybe Text\r\ntype Filters = [Filter]\r\n\r\ndouble :: Text -> Text\r\ndouble match = (match `T.append` match)\r\n\r\nwordRegex = [re|\\w+|]\r\n\r\nstringsAreEqual ignoreCase left right\r\n  | ignoreCase && (mk left) == (mk right) = True\r\n  | (not ignoreCase) && left == right = True\r\n  | otherwise = False\r\n\r\nadjustCase badBit actualBit goodWord ignoreCase\r\n  | not ignoreCase = goodWord\r\n  | actualBit == (T.toUpper badBit) = T.toUpper goodWord\r\n  | actualBit == (T.toLower badBit) = T.toLower goodWord\r\n  | (T.head actualBit) == (C.toUpper $ T.head badBit) = makeFirstCharUpper\r\n  | otherwise = goodWord\r\n  where\r\n    upperFirstChar = C.toUpper $ T.head goodWord\r\n    makeFirstCharUpper = T.cons upperFirstChar (T.tail goodWord)\r\n\r\nprefixFilter :: Text -> Text -> Bool -> Text -> Maybe Text\r\nprefixFilter badWord goodWord ignoreCase word\r\n  | stringsAreEqual ignoreCase prefix badWord = Just $ T.append caseAdjusted rest\r\n  | otherwise = Nothing\r\n  where\r\n    (prefix, rest) = T.splitAt (T.length badWord) word\r\n    caseAdjusted = adjustCase badWord prefix goodWord ignoreCase\r\n\r\nsuffixFilter :: Text -> Text -> Bool -> Text -> Maybe Text\r\nsuffixFilter badWord goodWord ignoreCase word\r\n  | stringsAreEqual ignoreCase suffix badWord = Just $ T.append rest caseAdjusted\r\n  | otherwise = Nothing\r\n  where\r\n    (rest, suffix) = T.splitAt (T.length word - T.length badWord) word\r\n    caseAdjusted = adjustCase badWord suffix goodWord ignoreCase\r\n    \r\nwordFilter :: Text -> Text -> Bool -> Text -> Maybe Text\r\nwordFilter badWord goodWord ignoreCase word\r\n  | stringsAreEqual ignoreCase word badWord = Just goodWord\r\n  | otherwise = Nothing\r\n  where\r\n    caseAdjusted = adjustCase badWord word goodWord ignoreCase\r\n\r\nnullFilter :: Text -> Maybe Text\r\nnullFilter = Just\r\n\r\ncreateFilter :: FilterSpec -> Filter\r\ncreateFilter spec = createFilterHelper (badPattern spec) (goodWord spec) True\r\n  where\r\n    createFilterHelper spec goodWord ignoreCase\r\n      | (T.last spec) == '!' = createFilterHelper (T.init spec) goodWord False\r\n      | (T.last spec) == '*' = prefixFilter (T.init spec) goodWord ignoreCase\r\n      | (T.head spec) == '*' = suffixFilter (T.tail spec) goodWord ignoreCase\r\n      | otherwise = wordFilter spec goodWord ignoreCase\r\n\r\ncreateFilters specs = (map createFilter specs) ++ [nullFilter]\r\n\r\napplyFilters :: Filters -> Text -> Text\r\napplyFilters filters word = fromJust activeFilter\r\n  where\r\n    filteredWords = map ($ word) filters\r\n    activeFilter = fromJust $ find isJust filteredWords \r\n\r\nfilterWords :: Filters -> Text -> Text\r\nfilterWords filters text = gsub wordRegex sanitiseWord text\r\n  where\r\n    sanitiseWord word = applyFilters filters word\n", "id": "2_1159104_1", "owner_tier": 0.3, "score": 0}], "link": "https://www.codeproject.com/Questions/1157796/Coding-challenge-bad-word-filter", "question": {"content": "\nThis is the first of our weekly coding challenges. Once a week we'll post a simple programming problem and the person who posts the best answer wins a T-shirt. The winner is decided by votes, or be comments, or be the audacity of their answer. Use any language in your answer except profanity.\n\r\nImagine that you allow users of your website to post comments, but some users, mainly the Australians, get a little colourful with their language. You decided to implement a Bad Word Filter that will replace certain words in a sentence with safer versions of that word.\n\r\nThe list of bad words and their replacements is\n\r\nBad: \"poophead\", \"PHB\", \"gotten\"\r\nReplacement: \"p**phead\", \"boss\", \"become\"\n\r\nSo \"My PHB is such a poophead. It's gotten worse since his promotion\" should be \"My boss is such a p**phead. It's become worse since his promotion\".\n\r\nWe also have to allow shouting. So \n\r\n\"My PHB is such a POOPHEAD!\" should become \"My boss is such a P**PHEAD!\"\n\nBonus points:\n\r\nLet's make it harder. If the \"bad\" word starts with \"*\" then it means any word that ends with that word. If it ends with a star then any word starting with that. If it ends with an \"!\" then it means that it should do the match case sensitive.\n\r\nBad words: \"poop*\", \"PHB!\", \"gotten\"\r\nReplacement: \"p**p\", \"boss\", \"become\"\n\r\n\"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\"\n\r\nshould become\n\r\n\"My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\"\n\nWhat I have tried:\n\r\nRemember: any programming language can be used.\r\n\t\t    ", "id": "1157796", "title": "Coding challenge: bad word filter", "traffic_rate": 0}, "saved_time": 1721102247, "source": "codeproject", "tags": ["code-challenge"]}, {"answers": [{"content": "Update: For Python 3, check Ben's answer Update 2023: I wrote this answer more than ten years ago and there are better answers now. You should be using python 3 and the answer above. Original answer: To attach a message to the current exception and re-raise it:\n(the outer try/except is just to show the effect) For python 2.x where x>=6: This will also do the right thing if err is derived from ValueError. For example UnicodeDecodeError. Note that you can add whatever you like to err. For example err.problematic_array=[1,2,3]. Edit: @Ducan points in a comment the above does not work with python 3 since .message is not a member of ValueError. Instead you could use this (valid python 2.6 or later or 3.x): Edit2: Depending on what the purpose is, you can also opt for adding the extra information under your own variable name. For both python2 and python3:", "id": 9157277, "owner_tier": 0.9, "score": 0.3658536585094851}, {"content": "I tried this compact version of @RobinL, and worked as well:", "id": 70380633, "owner_tier": 0.3, "score": 0.016260162574525745}, {"content": "PEP 678 \u2013 Enriching Exceptions with Notes was accepted and landed in Python 3.11. New APIs allow users to attach custom message(s) to existing errors. This is useful for adding additional context when an error is encountered. Using the add_note method is suitable for answering the original question: It would render like this: Modifying the args attribute, which is used by BaseException.__str__ to render an exception, is the only way. You could either extend the args: Which will render as: Or you could replace the args[0], which is a little more complicated but produces a cleaner result. This will render the same way as the Python 3.11+ exception __notes__ do:", "id": 75549200, "owner_tier": 0.9, "score": 0.0704607045799458}, {"content": "Raising same error, with prepending custom text message in front.\n(edit -  sorry, actually same as https://stackoverflow.com/a/65494175/15229310 , why there is like 10 (upvoted) 'solutions' that simply don't answer question as posted?)", "id": 75146373, "owner_tier": 0.3, "score": 0.013550135474254743}, {"content": "This only works with Python 3.  You can modify the exception's original arguments and add your own arguments. An exception remembers the args it was created with.  I presume this is so that you can modify the exception. In the function reraise we prepend the exception's original arguments with any new arguments that we want (like a message).  Finally we re-raise the exception while preserving the trace-back history.", "id": 62662138, "owner_tier": 0.5, "score": 0.06504065037940379}, {"content": "Try below: Output:", "id": 65494175, "owner_tier": 0.1, "score": 0.027100270975609755}, {"content": "If you're lucky enough to only support python 3.x, this really becomes a thing of beauty :) We can chain the exceptions using raise from. In this case, the exception your caller would catch has the line number of the place where we raise our exception. Notice the bottom exception only has the stacktrace from where we raised our exception. Your caller could still get the original exception by accessing the __cause__ attribute of the exception they catch. Or you can use with_traceback. Using this form, the exception your caller would catch has the traceback from where the original error occurred. Notice the bottom exception has the line where we performed the invalid division as well as the line where we reraise the exception.", "id": 29442282, "owner_tier": 0.5, "score": 0.9999999999728997}, {"content": "None of the above solutions did exactly what I wanted, which was to add some information to the first part of the error message i.e. I wanted my users to see my custom message first. This worked for me:", "id": 60185186, "owner_tier": 0.5, "score": 0.02168021677506775}, {"content": "Either raise the new exception with your error message using or within the place where you want to raise it OR attach (replace) error message into current exception using 'from' (Python 3.x supported only):", "id": 49380379, "owner_tier": 0.5, "score": 0.027100270975609755}, {"content": "It seems all the answers are adding info to e.args[0], thereby altering the existing error message.  Is there a downside to extending the args tuple instead?  I think the possible upside is, you can leave the original error message alone for cases where parsing that string is needed; and you could add multiple elements to the tuple if your custom error handling produced several messages or error codes, for cases where the traceback would be parsed programmatically (like via a system monitoring tool). or Can you see a downside to this approach?", "id": 17030625, "owner_tier": 0.7, "score": 0.054200541978319784}, {"content": "Python 3 built-in exceptions have the strerror field:", "id": 45960221, "owner_tier": 0.3, "score": 0.02168021677506775}, {"content": "This is the function I use to modify the exception message in Python 2.7 and 3.x while preserving the original traceback. It requires six", "id": 38772267, "owner_tier": 0.5, "score": 0.029810298075880756}, {"content": "prints:", "id": 9157254, "owner_tier": 0.9, "score": 0.03794037937669376}, {"content": "The current answer did not work good for me, if the exception is not re-caught the appended message is not shown. But doing like below both keeps the trace and shows the appended message regardless if the exception is re-caught or not. ( I used Python 2.7, have not tried it in Python 3 )", "id": 31155263, "owner_tier": 0.5, "score": 0.02168021677506775}, {"content": "This code template should allow you to raise an exception with a custom message.", "id": 10997792, "owner_tier": 0.5, "score": 0.040650406476964766}, {"content": "if you want to custom the error type, a simple thing you can do is to define an error class based on ValueError.", "id": 9157273, "owner_tier": 0.1, "score": -2.7100270838008917e-11}], "link": "https://stackoverflow.com/questions/9157210/how-do-i-raise-the-same-exception-with-a-custom-message-in-python", "question": {"content": "I have this try block in my code: Strictly speaking, I am actually raising another ValueError, not the ValueError thrown by do_something...(), which is referred to as err in this case. How do I attach a custom message to err? I try the following code but fails due to err, a ValueError instance, not being callable:", "id": 9157210, "title": "How do I raise the same Exception with a custom message in Python?", "traffic_rate": 52}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "exception", "message"]}, {"answers": [{"content": "With PEP 678 (Python 3.11) adding notes to exceptions is natively supported: Rendered as: I was hopping it could replace Steve Howard solution, Unfortunately, it does not give user any control on how to format the final exception (e.g. can't add a note before the exception like: 'Error in fn: {original_exc}') If you want more control on the traceback, you can use https://github.com/google/etils: Or:", "id": 71605371, "owner_tier": 0.5, "score": 0.14963503645985402}, {"content": "I use in my codes: output:", "id": 73295409, "owner_tier": 0.1, "score": 0.018248175145985403}, {"content": "Here's what I use for personal projects (I'm sure there's ample reason not to do this in production code): The code (1) intercepts the error; (2) creates a copy of the error's .args property, which is a tuple that is assumed to include an error message at index 0, achieved using a list comprehension; (3) appends a line break and a custom message to the error message; (4) appends any additional items of .args to the copy using\nunpacking; (5) converts the copy to a tuple; and finally (6) replaces .args with the amended copy. Most of these operations are to circumvent the immutability of the .args tuple.", "id": 71818728, "owner_tier": 0.1, "score": 0.029197080255474454}, {"content": "This is my implementation, to use it as a context manager and optionally add extra message to exception: Usage: This would resolve in such traceback:", "id": 68848804, "owner_tier": 0.1, "score": 0.0255474452189781}, {"content": "In case you came here searching for a solution for Python 3 the manual  says: When raising a new exception (rather than using a bare raise to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using from with raise: Example: Which looks like this in the end: Turning a totally nondescript TypeError into a nice message with hints towards a solution without messing up the original Exception.", "id": 46091127, "owner_tier": 0.5, "score": 0.9999999999635036}, {"content": "One handy approach that I used is to use class attribute as storage for details, as class attribute is accessible both from class object and class instance:  Then in your code: And when catching an error:", "id": 12370499, "owner_tier": 0.5, "score": 0.0547445255109489}, {"content": "I'd do it like this so changing its type in foo() won't require also changing it in bar(). Update 1 Here's a slight modification that preserves the original traceback: Update 2 For Python 3.x, the code in my first update is syntactically incorrect plus the idea of having a message attribute on BaseException was retracted in a change to PEP 352 on 2012-05-16 (my first update was posted on 2012-03-12). So currently, in Python 3.5.2 anyway, you'd need to do something along these lines to preserve the traceback and not hardcode the type of exception in function bar(). Also note that there will be the line: in the traceback messages displayed. Update 3 A commenter asked if there was a way that would work in both Python 2 and 3. Although the answer might seem to be \"No\" due to the syntax differences, there is a way around that by using a helper function like reraise() in the six add-on module. So, if you'd rather not use the library for some reason, below is a simplified standalone version. Note too, that since the exception is reraised within the reraise() function, that will appear in whatever traceback is raised, but the final result is what you want.", "id": 6062799, "owner_tier": 0.9, "score": 0.6021897809854014}, {"content": "I don't like all the given answers so far. They are still too verbose imho. In either code and message output. All i want to have is the stacktrace pointing to the source exception, no exception stuff in between, so no creation of new exceptions, just re-raising the original with all the relevant stack frame states in it, that led there. Steve Howard gave a nice answer which i want to extend, no, reduce ... to python 3 only. The only new thing is the parameter expansion/unpacking which makes it small and easy enough for me to use.  Try it: This will give you: A simple pretty-print could be something like", "id": 58270258, "owner_tier": 0.1, "score": 0.08759124083941605}, {"content": "Assuming you don't want to or can't modify foo(), you can do this:  This is indeed the only solution here that solves the problem in Python 3 without an ugly and confusing \"During handling of the above exception, another exception occurred\" message. In case the re-raising line should be added to the stack trace, writing raise e instead of raise will do the trick.", "id": 6062677, "owner_tier": 0.5, "score": 0.17518248171532846}, {"content": "I will provide a snippet of code that I use often whenever I want to add extra info to an exception.  I works both in Python 2.7 and 3.6.   The code above results in the following output:    I know this deviates a little from the example provided in the question, but nevertheless I hope someone finds it useful. ", "id": 42359068, "owner_tier": 0.9, "score": 0.0401459853649635}, {"content": "Unlike previous answers, this works in the face of exceptions with really bad __str__.\nIt does modify the type however, in order to factor out unhelpful __str__ implementations. I'd still like to find an additional improvement that doesn't modify the type. The original traceback and type (name) are preserved.", "id": 20532167, "owner_tier": 0.9, "score": 0.0328467152919708}, {"content": "You can define your own exception that inherits from another and create it's own constructor to set value. For example:", "id": 6062657, "owner_tier": 0.3, "score": 0.0328467152919708}, {"content": "Maybe", "id": 6062653, "owner_tier": 0.9, "score": -3.649635014315799e-11}], "link": "https://stackoverflow.com/questions/6062576/adding-information-to-an-exception", "question": {"content": "I want to achieve something like this: But what I get is: Any clues as to how to achieve this? How to do it both in Python 2 and 3?", "id": 6062576, "title": "Adding information to an exception?", "traffic_rate": 32}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "exception"]}, {"answers": [{"content": "The error handling, written in C, uses type checking for the special case of a tuple, before other type-checking and exception handling, so that multiple types of exceptions may be caught.  At least one Python core developer advocates using exception handling for control flow. Adding lists as an additional type to check would work against this strategy. It appears that expanding this to allow for sets or lists has not been specifically addressed by the core development team, though I will gladly reference it if it can be found. There has been a discussion on the Python mailing list that speculates quite a lot (another answer here quotes one response at length).  After performing the below analysis, and in the context of the mailing list discussion, I think the reasoning is obvious. I do not suggest proposing to add other containers. Catching the tuple of exceptions does work: outputs: But catching the list of exceptions does not work: prints: This demonstrates that we are doing type checking for the special case of a tuple. It would certainly make the code slower to add another type to check for, and the core developers have been saying that it's a good thing to use exception handling for control flow in Python for a while now.  An analysis of the source agrees with this above conclusion. This is not an issue for Python's grammar or parsing. It will accept any expression. Thus any expression that results in an Exception or tuple of Exceptions should be legal. If we disassemble a function that does this in Python 3, we see that it looks to match an exception with a comparison operation.  Which outputs: This leads us inside the Python interpreter. The CPython control flow first checks for if the value is a tuple. If so, \nit iterates through the tuple using tuple specific code - looking for the value to be a Exception: Adding another type would require more internal control flow, slowing down control flow inside of the Python interpreter. Tuples are lightweight arrays of pointers. So are lists, but they may be allocated extra space so that you may quickly add to them (up to the point they need to get larger). In Python 3.7.3 on Linux: Sets take up even more space because they are hash tables. They have both a hash of the object they contain as well as a pointer to that which they point to. This is for the CPython core development team to debate and decide.  But my conclusion is that slowing down control flow in Python by checking for other types even at the C level would work against the strategy of using exception handling for control flow in Python modules.  After reasoning through the above, I would not propose that they add this.", "id": 35852234, "owner_tier": 0.9, "score": 0.99999999875}, {"content": "@BrenBarn Thanks for your link to the discussion at https://mail.python.org/pipermail/python-list/2012-January/619107.html I think the best and clearest response comes from Steven D'Aprano's reply at https://mail.python.org/pipermail/python-list/2012-January/619120.html I copied the content below for easy read. Steven's reply: Simplicity. If you also allow lists, then why not allow arbitrary sequences? What \nabout iterators, do you allow them? That could be awkward, because \niterators can only be run through once. Dictionaries are also iterable, \nso once you allow arbitrary iterables, you get dicts. The whole thing \nbecomes a mess. Better to keep it simple and only allow a single \ncanonical collection type, and in Python, that type is tuple, not list. Tuples are that canonical collection type because they have a number of \ndesirable properties: Tuples are small and memory efficient, using the smallest amount of\nmemory needed to hold their items. Lists typically carry a block of\nspare memory, to make insertions fast. Consequently the Python virtual machine can create them rapidly and\nefficiently. Tuples are immutable, so you don't have to worry about passing one to a\nfunction and having the function modify it behind your back. Tuples are ordered, for the times where that matters. Since the typical use-case is to iterate over the items in fixed order,\nthere's no need to pay the extra expense for a dict or set. Tuples are simple to write: in general you only need commas between\nitems. Sometimes, to avoid ambiguity or change the precedence of\ncalculation, you also need round brackets (parentheses for Americans).\nExcept clauses are one of those times. Frozensets and sets are ruled out for historical reasons: they didn't\nexist until Python 2.3. Besides, which would you rather write? (\"abc\", \"def\")\n  frozenset([abc\", \"def\"]) Sets and lists are ruled out because they are mutable, both require\nmuch more memory, and sets have a heavier computational burden. The latter makes more sense semantically to me -- \"catch all exception\n  types in a list\" as opposed to \"catch this single thing composed of\n  three exception types\". Then you are labouring under a misunderstanding. You're not catching a \ntuple, because tuples are never thrown. You're catching any of the \nexceptions that are contained in that tuple. Both lists and tuples are single things in themselves. Both lists and \ntuples are containers: A list is a single thing that contains other things.  A tuple is a single thing that contains other things.", "id": 36236179, "owner_tier": 0.5, "score": -1.2499999924031613e-09}], "link": "https://stackoverflow.com/questions/35851782/why-does-handling-multiple-exceptions-require-a-tuple-but-not-a-list", "question": {"content": "Consider the following example: The tuple is the correct way to handle multiple exception types. Using a list for the multiple exception types causes neither to be handled. I am wondering why Python syntax requires a tuple for multiple exception types.  The docs say that it uses a tuple, so perhaps it is just \"never was implemented using a list instead of a tuple.\" It seems reasonable to me that a list could also be used in this situation, conceptually at least. Is there any reason why Python uses a tuple instead of a list for this situation?", "id": 35851782, "title": "Why does handling multiple exceptions require a tuple, but not a list?", "traffic_rate": 5}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "python-2.7", "exception", "error-handling"]}, {"answers": [{"content": "The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works The short version is that += actually does two things, one right after the other: In this case, step 1 works because you\u2019re allowed to add stuff to lists (they\u2019re mutable), but step 2 fails because you can\u2019t put stuff into tuples after creating them (tuples are immutable).  In a real program, I would suggest you don't do a try-except clause, because tup[0].extend([4,5,6]) does the exact same thing.", "id": 39872951, "owner_tier": 0.3, "score": -2.8571428397786543e-10}, {"content": "Yes it's expected.  A tuple cannot be changed. A tuple, like a list, is a structure that points to other objects. It doesn't care about what those objects are. They could be strings, numbers, tuples, lists, or other objects. So doing anything to one of the objects contained in the tuple, including appending to that object if it's a list, isn't relevant to the semantics of the tuple. (Imagine if you wrote a class that had methods on it that cause its internal state to change. You wouldn't expect it to be impossible to call those methods on an object based on where it's stored). Or another example: Two mutable lists referenced by a list and by a tuple. Should I be able to do the last line (answer: yes). If you think the answer's no, why not? Should t change the semantics of l3 (answer: no). If you want an immutable object of sequential structures, it should be tuples all the way down. This example uses the infix operator: Many operations have an \u201cin-place\u201d version. The following functions\n  provide a more primitive access to in-place operators than the usual\n  syntax does; for example, the statement x += y is equivalent to x =\n  operator.iadd(x, y). Another way to put it is to say that z =\n  operator.iadd(x, y) is equivalent to the compound statement z = x; z\n  += y. https://docs.python.org/2/library/operator.html So this: is equivalent to this: The __iadd__ line succeeds, and modifies the first list. So the list has been changed. The __iadd__ call returns the mutated list.  The second line tries to assign the list back to the tuple, and this fails. So, at the end of the program, the list has been extended but the second part of the += operation failed. For the specifics, see this question.", "id": 29747287, "owner_tier": 0.9, "score": 0.9999999997142857}, {"content": "Tuples cannot be changed directly, correct. Yet, you may change a tuple's element by reference. Like:", "id": 29747543, "owner_tier": 0.5, "score": 0.114285714}, {"content": "Well I guess tup[0] += (4, 5, 6) is translated to: tup[0].__iadd__((4,5,6)) is executed normally changing the list in the first element. But the assignment fails since tuples are immutables.", "id": 29747466, "owner_tier": 0.5, "score": 0.2857142854285714}], "link": "https://stackoverflow.com/questions/29747224/append-to-a-list-defined-in-a-tuple-is-it-a-bug", "question": {"content": "So I have this code: which generates this error: While this code: prints this: Is this behavior expected? I realize this is not a very common use case. However, while the error is expected, I did not expect the list change. ", "id": 29747224, "title": "Append to a list defined in a tuple - is it a bug?", "traffic_rate": 6}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "list", "tuples"]}, {"answers": [{"content": "If tuples are immutable, why is it possible to change a list within a tuple? Because \"tuples are immutable\" only means you cannot modify the tuple. The list that's referred to from the tuple is not part of the tuple, it doesn't \"know\" that it is in a tuple, and it has no means to resist being modified. Why does the first example raise an error and the other two not? Because of how += works. It calls __iadd__ on the list and then (because __iadd__ is not required to return the original object) attempts to assign the resulting modified object back to the tuple. The first thing succeeds, the second thing fails. That is, for this case where t[2] has an __iadd__ function, t[2] += [5,6] is equivalent to: t[2] = t[2].__iadd__([5,6]) In the first example, why is the list inside the tuple changed even though an error is raised? Because this Python operation doesn't offer what in C++ we'd call a \"strong exception guarantee\". The first part of the operation has already been performed, and cannot be (or at any rate is not) reversed when the second part fails. For the official version see Why does a_tuple[i] += [\u2018item\u2019] raise an exception when the addition works?", "id": 39658654, "owner_tier": 0.9, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/39658446/why-can-you-extend-append-to-a-list-in-a-tuple-but-not-assign-to-it", "question": {"content": "Inspired by reading footnote 4 of this article. Consider the following scenario: Tuples are immutable. So, as expected, trying to add to the list inside the tuple raises an error. However if we inspect our tuple, the list has been added to!! (I can imagine this leading to very hard to track down bugs) Also, both extending and appending work without raising an error. So, my questions are:", "id": 39658446, "title": "Why can you extend/append to a list in a tuple, but not assign to it?", "traffic_rate": 1192}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "tuples"]}, {"answers": [{"content": "The Python developers wrote an official explanation about why it happens here: https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works The short version is that += actually does two things, one right after the other: In this case, step 1 works because you\u2019re allowed to add stuff to lists (they\u2019re mutable), but step 2 fails because you can\u2019t put stuff into tuples after creating them (tuples are immutable).  In a real program, I would suggest you don't do this because t[0].extend(['c']) does the exact same thing.", "id": 38345741, "owner_tier": 0.3, "score": -7.142857099446636e-10}, {"content": "It can also help to understand this behavior by taking a look at the bytecode with dis.dis.  ", "id": 38344424, "owner_tier": 0.9, "score": 0.285714285}, {"content": "Found the answer on IRC. t[0] += [1] is several discrete actions: It seems that x += y is basically x = x + y (but, is it?) The tricky bit is that += implies assignment to both the tuple t and to the list t[0] t[0] += [1] is not literally t[0] = t[0] + [1], it is: t[0] = t[0].__iadd__([1]) What really happens is: Why is this not visible in plain sight? Because a n00b like me would expect t[0] += [1] to either succeed all together or fail, because it's one short line of python. But that's not always the case.", "id": 38344245, "owner_tier": 0.5, "score": 0.9999999992857143}], "link": "https://stackoverflow.com/questions/38344244/tuples-operator-throws-exception-but-succeeds", "question": {"content": "Why does the following throw an exception, although it succeeds?", "id": 38344244, "title": "Tuples: += operator throws exception, but succeeds?", "traffic_rate": 32}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "tuples"]}, {"answers": [{"content": "Um, am I missing something or are you comparing the output of with ??? The second uses \"+\", but the first uses \",\", which does and should give the output you show! (nb. the question was edited from a version with \"+\" in both cases. Perhaps this question should be deleted???)", "id": 530475, "owner_tier": 0.9, "score": 0.99999999875}, {"content": "This instantiates the ValueError exception with a single argument, your concated (or added) string: This instantiates the ValueError exception with 2 arguments, whatever card is and a string:", "id": 530477, "owner_tier": 0.5, "score": 0.49999999875}, {"content": "In the second case card is not a string for sure. If it was a string then len('2') would be equal to 2 and the exception wouldn't be raised, so check first what are you trying to concatenate, it seems something that added to a string returns something represented as a tuple. I recommend you to use string formatting instead of string concatenation to create the error message. It will use the string representation (__repr__) of the object. With string formatting: With string concatenation: And other question... what python version/implementation are you using? My cpython interpreter on Linux reports ValueErrors as ValueError, not ERROR...", "id": 530436, "owner_tier": 0.5, "score": 0.12499999875}, {"content": "Have you overloaded the __add__() somewhere in the code, that could be causing it to return a tuple or something?", "id": 530401, "owner_tier": 0.9, "score": -1.25e-09}, {"content": "\"card\" probably represents a tuple containing the string \"Kr.\"  When you use the + operator on a tuple, you create a new tuple with the extra item added. edit: nope, I'm wrong.  Adding a string to a tuple: generates an error: It would probably be helpful to determine the type of \"card.\" Do you know what type it is?  If not, try putting in a print statement like:", "id": 530358, "owner_tier": 0.5, "score": 0.74999999875}], "link": "https://stackoverflow.com/questions/530329/why-does-concatenation-work-differently-in-these-two-samples", "question": {"content": "I am raising exceptions in two different places in my Python code: AND (edited to correct raising code) For some reason, the first outputs a concatenated string like I expected: But, the second outputs some weird hybrid of set and string: Why is the \"+\" operator behaving differently in these two cases? Edit: The call to init looks like this:", "id": 530329, "title": "Why does concatenation work differently in these two samples?", "traffic_rate": 3200}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "concatenation"]}, {"answers": [{"content": "The tuple and list functions take a single (optional) iterable argument, not multiple arguments.  You can therefore do any of the following: but you can't pass tuple itself multiple comma-separated args: Passing a single non-iterable arg with a trailing comma (the way you might construct a tuple literal) will similarly give you an error, because the tuple() function doesn't work the same way as a tuple literal expression: and passing a single empty iterable arg will always get you an empty tuple: Note that it is possible to re-assign the builtin names tuple and list, which will make using the actual functions difficult: To fix this, del the locally assigned name and the built-in one will work again:", "id": 75514001, "owner_tier": 0.9, "score": 0.0}], "link": "https://stackoverflow.com/questions/75513973/why-does-using-tuple-function-while-making-a-tuple-give-me-a-error-but-doing-the", "question": {"content": "I was trying to create a tuple with tuple() with its only element being empty list but it gave me an error, 'list' object is not callable This code gave me error while this code did not give me any error Can anyone explain why this is happening and if I can do this with list and tuple functions", "id": 75513973, "title": "Why does using tuple function while making a tuple give me a error but doing the same using () does not", "traffic_rate": 791}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "list", "tuples"]}, {"answers": [{"content": "When validating, the purpose of your function is to tell you if the criteria are met. You expect to get a boolean result; valid or not valid. You'd only throw errors if, say, the inputs to the function are not supported, or some dependency for the validation process itself was not met. In that case, the normal operation of the validator cannot be completed, you cannot return valid or not valid in such cases because there is no way for the validator to make that determination. You can compare this with isinstance() or issubclass(); these two functions test a value against another value. They return True or False, and raise exceptions if you give them unsupported input: Normal operation is validation, giving it unsupported input means no valid or invalid value can be returned and thus warrants an exception. So, for a validator that returns either a (True, message) or a (False, message) tuple, I'd only raise exceptions if there was a problem with the validation process itself, not to indicate the (False, message) case. Note that it doesn't matter what your validator returns; if you need to return both a valid / invalid flag and corresponding message (and only the validator can produce that message) then returning a tuple is just fine. You could return a custom class too: then use that as a test:", "id": 23875846, "owner_tier": 0.9, "score": 0.9999999991666666}, {"content": "Using an exception to indicate invalid data is the idiomatic, canonical, Python solution to this problem. Consider the int() function, if you pass it invalid data, an exception occurs:", "id": 23875151, "owner_tier": 0.5, "score": -8.333333282687742e-10}], "link": "https://stackoverflow.com/questions/23875126/validation-and-exception-vs-error-message-tuple", "question": {"content": "I am working on a validation function. I understand that exceptions are used for errors and unexpected situations, but in the case of a validation function, if a condition is not met inside, I would expect it to return False instead of an exception. The thing is that after the validation finishes I need to raise an message window with a message like: \"Tool exited because X condition not met\". My workflow has been to return tuples with the result and message: or\n    (False, X_condition_not_met) and then: However recently I have stumbled upon multiple answers raising a controversy about this issue and I am confused. For example some people say to always go with exceptions: What's the best way to return multiple values from a function in Python? and others say tuples are the way to go Best practice in python for return value on error vs. success. I would appreciate if someone could point me in the right direction.", "id": 23875126, "title": "Validation and exception vs. error message tuple", "traffic_rate": 2}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "exception", "tuples"]}, {"answers": [{"content": "The best way to explain this is to show it \"algebraically\": As you can see, the update form is not the same, it modifies foo[0] in place. __or__ generates a new set from the elements of the left and right operands. This is then assigned back to foo. Note that for simplicity, the expansions that aren't helpful to the problem are not expanded (such as foo[0] -> tuple.__getitem__(foo, 0)). The TypeError thrown is in tuple.__setitem__. tuple does not allow its items references to be replaced. The update form does not touch foo in any way (ie. it doesn't not invoke tuple.__setitem__).", "id": 3492735, "owner_tier": 0.9, "score": -9.090909090909091e-10}, {"content": "That explains the behaviour you are observing. The underlying problem, is that changing the value of a tuple is a violation of contract. You should not try doing it. Since you can have any object in a tuple, there are loopholes you can exploit, but then you get the kind of weird behaviour you are observing. Tuple items should be frozenset instead of set. If you do this, you will get a consistent behaviour, and no unwanted side-effect on error.", "id": 3493013, "owner_tier": 0.9, "score": -9.090909090909091e-10}, {"content": "This shows that the statement x[0] |= y is implemented by calling x[0].__ior__(y) and then assigning the returned value to x[0]. set implements in-place |= by having set.__ior__ return self.  However, the assignment to x[0] still takes place.  The fact that it's assigning the same value that was already there is irrelevant; it fails for the same reason that: fails.", "id": 3492715, "owner_tier": 0.5, "score": 0.999999999090909}, {"content": "\"Why the TypeError, when the operation obviously was successful?\".   Because there are multiple side-effects.  Try to avoid that. That's what the  foo[0] |= set(range(5)) update the set and throw an exception Correct.  First the set mutation is done. Then the tuple mutation is attempted and fails. foo[0].update(set(range(10))) work without a problem?  Correct.  The set is mutated.   Should it not have the same result as the first statement? No.  The first statement involves explicit assignment -- changing the tuple -- which is forbidden. The second statement updates a member of an immutable tuple, an operation that is not forbidden, but is suspicious as pushing the envelope. But the Legalism Scholar argues, aren't they supposed to be the same?  Or similar?  No. Updating the tuple object (via assignment) is forbidden. Updating a member of an existing tuple object (via a mutator function) is not forbidden.", "id": 3492523, "owner_tier": 0.9, "score": -9.090909090909091e-10}, {"content": "doesn't work, because what you wanted to achieve is: and you can't assign new elements to an old tuple, because they are immutable. For example you cant do this: When you are running update, you don't change references in the tuple, but only object behind the reference. You could also do this like this: as you can see you don't change the tuple, but x (and y[0]) will be changed. and  aren't the same, because update works in place and x |= y will create a new object (x | y) and store it under name x.", "id": 3492256, "owner_tier": 0.9, "score": 0.09090909}, {"content": "Tuples are immutable so u cannot reassign values to it. But if a tuple contains a mutable type such as list or set u can update them.\nnow in your case when u use '|=' u actually first update the set (which is a value in the tuple) then assign it to tuple which causes the exception. \nException is thrown after the updation of the set. In the next case u r simply updating the set so there is no exception.\nRefer to http://docs.python.org/reference/datamodel.html", "id": 3492473, "owner_tier": 0.5, "score": -9.090909090909091e-10}, {"content": "In your example foo is a tuple. Tuples in python are inmutable, this means that you cannot change the reference of any tuple element - foo[0] in your case. Things like the following can't be done: You could use a list instead", "id": 3492276, "owner_tier": 0.5, "score": 0.1818181809090909}, {"content": "Tuples are immutable. By trying to assign to foo[0], you are attempting to change a value that the tuple stores (a reference to a set). When you use the update() function, you are not changing the reference, but instead the actual set. Because the reference is the same, this is allowed.", "id": 3492239, "owner_tier": 0.9, "score": -9.090909090909091e-10}], "link": "https://stackoverflow.com/questions/3492216/why-does-updating-a-set-in-a-tuple-cause-an-error", "question": {"content": "I have just tried the following in Python 2.6: I have several questions here: Edit Many people have pointed out, that tuples are immutable. I am aware of that. They have also pointed out, that |= would create a new set object and assign it to the tuple. That is wrong. See this: This means that no new object has been created, but the existing one was modified. This should work with the tuple. Please note also that, although my first code throws a TypeError, the set within the tuple is still updated. That is the effect I am interested in. Why the TypeError, when the operation obviously was successful?", "id": 3492216, "title": "Why does updating a set in a tuple cause an error?", "traffic_rate": 2816}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "stackoverflow", "tags": ["python", "tuples"]}, {"answers": [{"content": "try except is for catching errors, you need to raise an error.\n\nYou can use isinstance function to check for the type of a variable.\n\nNote that the check includes inherited types.\n\n    if not isinstance(t, tuple):\n        raise TypeError(\"first argument must be a tuple\")\n\nAbove will check if t is an instance of class tuple, if not, it'll raise TypeError\n\nOk, I think get it, I never knew you can raise errors without `try...except`.\n\nOne more question: I wish to print a message alongside the error. For example, giving x = 'Hello' should give something like this:\n\n`TypeError: Invalid Data Type`\n\nSo far the code is enough to tell me that there is a type error, how do I print the message?\n\nOk after I bit more research I got the answer myself. Turns out TypeError has a parameter where you can input the error message. Thanks!\n\nYou may have missed my edit,  you can provide a message like this:\n\n    raise TypeError(\"Invalid Data Type\")\n\nYup I missed that haha. It works perfectly now :)", "id": "hl3ga8x", "owner_tier": 0.7, "score": 0.9999999988888888}, {"content": "You could make it a bit more flexible by passing \\*args and unpacking the tuple. that way you can pass the tuple as first argument, and then insert as many elements as you want to the tuple.\n\n    def insert_t(t,*i):\n        if not isinstance(t, tuple):\n            raise TypeError(\"first argument must be a tuple\")\n        return tuple([*t,*i])\n\nThank you for this! The purpose of this code was to insert one element at a time, similar to the insert function for lists. I haven't learnt about args and kwargs yet but I'll be doing that next. Thanks!", "id": "hl3hls3", "owner_tier": 0.3, "score": 0.11111111000000001}, {"content": "Probably a dumb question, but why do you feel the need to restrict the function to only work for tuples?\n\nSure, it's possible to use `isinstance` to raise an exception when `t` is not a tuple, but personally I'd rather use a soft restriction instead. You could use a type hint:\n\n    def insert_t(t: tuple, i: int, v) -> tuple:\n        l = list(t)\n        l.insert(i, v)\n        tu = tuple(l)\n        return tu\n\nOn another note, generally you shouldn't be using a tuple if you need to insert things into it later on, as it's inefficient to convert back and forth. In fact you could probably write your function as\n\n    def insert_t(t: tuple, idx: int, value) -> tuple:\n        return (*t[:idx], value, *t[idx:])\n\nand skip the conversion process. I'll validate later if my suspicions are correct, can't right now.", "id": "hl3ozoo", "owner_tier": 0.7, "score": -1.1111111043583657e-09}], "link": "https://www.reddit.com/r/learnpython/comments/qwkimb/exception_handling_in_python_need_to_allow_only/", "question": {"content": "I have this code to create a function to insert to a tuple in python:\n\n    def insert_t(t, i, v):\n        l = list(t)\n        l.insert(i, v)\n        tu = tuple(l)\n        return tu \n\nThe code works, but there is one problem. Passing t to be any sequence type variable works. But I want t to be only a tuple, not a  list or a string. See below for what I mean:\n\n    x = 'Hello'\n    insert_t(x, 2, 4) \n\nThe code works for when x is a string, however, this breaks the purpose of the code to append to only tuples. I would like it to raise `TypeError` if the parameter t is not a tuple.\n\nAfter looking online, I found that `try...except` exists, which can raise the required error. However, I don't know how to implement it, since as you can see, I have never used `try...except` before. How do I implement it?", "id": "qwkimb", "title": "Exception Handling in Python - Need to allow only one datatype", "traffic_rate": 153.13018518518518}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "I'd say this is bad and uncommon when done literally. You're losing the ability for the IDE to tell you that a function call has the wrong number of or type of arguments unless you use a tuple and hint that. You're also forcing needless `[]` for all calls, and destructuring inside every function.\n\nI don't at all see the benefit to this. If you changed the number of arguments a function requires, the existing calls *should* fail. And they would fail with an index error with your way anyway when you tried to access the second element of an array that only has one. If you want to add a parameter and not need to change all the existing calls, you could give the new parameter a default argument, or create a new function and potentially deprecate the old version.\n\nThe closest I've seen to this is `*args`, which is basically an implicit version of what you're doing, but with var-args, the individual elements don't tend to have different purposes.", "id": "kydy1jn", "owner_tier": 0.9, "score": 0.9999999995833333}, {"content": "Function arguments should be descriptive to help the user understand what they refer to or expect. In my experience, arrays should be passed when array are used as arrays. From the sounds of it, you should really have a float argument, or in your second case, two float arguments, not an array. Also, argument names like \"float1\" and \"float2\" are useless, they don't describe what is expected by the function.", "id": "kydy8ub", "owner_tier": 0.3, "score": 0.29166666625}, {"content": ">if I do it in an array, then it doesn't throw the error that it needs 2 inputs\n\nSo what happens when you change your function from\n\n    def function(array):\n        return array[0]\n\nto \n\n    def function(array):\n        return array[0] * array[1]\n\nSure, all \"calls\" to the function will succeed, but then immediately fail, because you'll be referring to array[1], which doesn't exist.  So it's... exactly the same except worse because a linter or your IDE won't warn you that the function signature has changed and your calls are all now incorrect.\n\n(along with hiding the actual inputs to your function, which requires yourself or anyone else using it to read the code just to know what elements to pass in what position)", "id": "kye3k11", "owner_tier": 0.5, "score": 0.41666666625}, {"content": "Others have already provided good answers for this particular case, but I think there's a more general valuable lesson here: Many errors are GOOD THINGS. You say if you change an existing function from having only 1 argument to 2 arguments, then existing code that calls the function with only 1 argument will raise an exception. THIS IS GOOD. Calling the function with only one argument is a mistake that needs to be fixed. You want to be made aware of this mistake as soon as possible!\n\nIn fact, if your IDE is set up properly, it should make you aware of this error before you even run the program, by showing you red squiggly lines under the function calls that use the wrong number or arguments. Those red squiggly lines are good! They show you something important.\n\nIt's possible you have a hangup I've seen in other beginners, where they feel uncomfortable having the computer \"yell\" at them, telling them they \"did something wrong\". Let go of that anxiety. Programming usually involves being wrong 20 times until finally you get it right the 21st, then you can move on to being wrong about the next section. Lots of hard work and billions of dollars has gone into developing tools that let us know where and how we're wrong, as quickly as possible. Embrace them.\n\nI have said before that all programmers are egotistical, because those are the only people who still feel smart after being told repeatedly they're wrong.", "id": "kyf3wip", "owner_tier": 0.3, "score": 0.24999999958333333}, {"content": ">is it common to use the array to do inputs?\n\nNo, it's not common, and is (IMO) bad practice. It obfuscates the function definition and makes it easier to introduce errors.\n\n>I realized that if I went to using 2 number inputs, for example if \"def function(number):\" became \"def function(number1,number2):\" then the function would fail in literally every piece of code it ran in, but, if I do it in an array, then it doesn't throw the error that it needs 2 inputs, \"def function(array):\" doesn't throw the same error?\n\nIt doesn't throw the error, sure, **but the error still exists**. Whether you change every function call to include the additional parameter or whether you change every list that you are passing to the function, you still have the same underlying issue.\n\nMore importantly, if you use parameters individually, you get an IDE warning where the parameters don't match, which makes updating easier. If you put in a list (array) then the interpreter has no way to tell your input parameters are wrong until it tries to access an invalid index.\n\nThere are other issues...now you either need to break out your parameters using unpacking (i.e. `param1, param2 = parameter_list`) or reference them repeatedly by index, which is confusing (what does `parameter_list[0]` actually represent?). And if you assign them to variables, you are just repeating the same thing the parameters would have done directly, and if you change the number of parameters, you still have to change all your calls (if just changing the input list). It's awkward and solving a problem the language already does.\n\nInstead, if you are worried about parameters changing or being optional, you should use optional and named parameters, i.e. `foo(name, age=12, hair_color=\"brown\")` and then you can call it with `foo(my_name, hair_color=my_hair_color)` if you want to leave certain things as default values.\n\nNow, there are times when you want to do *some* of this, such as if you have a variable number of parameters and intend to loop through something and do something else based on what you get (although you usually use a dictionary for this, but not always). There is also the slightly more advanced usage of `*args` and `**kwargs` when you are trying to make a function accept an arbitrary number of parameters. As a general practice, however, it's a very bad idea.", "id": "kye6xic", "owner_tier": 0.7, "score": 0.08333333291666667}, {"content": "If you have a good reason for actually needing variable arguments use something like `*args` or `**kwargs`. Otherwise just deal with fixing after you change stuff or version your functions/code", "id": "kyegiv8", "owner_tier": 0.5, "score": 0.041666666250000005}, {"content": "Never do this", "id": "kyfwjrr", "owner_tier": 0.7, "score": 0.041666666250000005}, {"content": "Isn't it essentially a tuple already?  () tuples are everywhere in python.", "id": "kye0ri1", "owner_tier": 0.5, "score": -4.166666641343871e-10}, {"content": "You can put any object you wish as an input in a Python function.\n\nI wouldn\u2019t call it an array, unless it\u2019s an actual array. Arrays dont\u2019t exist in vanilla Python, but if you import a C library like numpy.array you can have the traditional array, so call it a list in vanilla because that usually what it is \n\nI\u2019d prefer the object name to represent its actual expected data structure. Or some reasonable description/convention.. I don\u2019t think I\u2019m alone in this. \n\nThere is no problem running a function like you are in Python as is. I would type hint it, and be more explicit though of the type of object, to be formal.\n\nYour problem IMHO probably comes from design.  You don\u2019t exactly know what coming into the function, which always becomes a problem.", "id": "kye7qii", "owner_tier": 0.7, "score": -4.166666641343871e-10}, {"content": "I hope I never have to maintain code you have written. This would be horrible from a readability perspective.", "id": "kyj7uok", "owner_tier": 0.7, "score": -4.166666641343871e-10}, {"content": "If that array used for something else besides that variable, I'd use it, otherwise single number.\n\nOr I'd do number and then rest of array as 2nd argument. Or it would be a dict or some class instance (might be preferable because you'd have data validation code in it)\n\nUse proper code blocks for code.", "id": "kyl1hkp", "owner_tier": 0.5, "score": -4.166666641343871e-10}], "link": "https://www.reddit.com/r/learnpython/comments/1bxo358/when_writing_functions_in_python_is_it_common_you/", "question": {"content": "I don't know if this is common in python, but, I have a habit of always making the input to a function an array as opposed to anything else, so, that I can expand it if I need it without functions failing, for example if I define a function with a number input in in python, I do-\n\ndef function(array):\n\nnumber= array\\[0\\]\n\ninstead of-\n\ndef function(number):\n\nis it common to use the array to do inputs?  I realized that if I went to using 2 number inputs, for example if \"def function(number):\" became \"def function(number1,number2):\" then the function would fail in literally every piece of code it ran in, but, if I do it in an array, then it doesn't throw the error that it needs 2 inputs, \"def function(array):\" doesn't throw the same error?\n\n", "id": "1bxo358", "title": "When writing functions in Python is it common you put the inputs in an array as opposed to the parenthesis by the function so that there is always 1 input (the array) and the function doesn't automatically fail in everything that it runs in because the inputs have expanded?", "traffic_rate": 153.13018518518518}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "I'm with your colleague, return None or raise an exception. Returning some random type from an unrelated module is terrible\n\nOr make a sentinel value if you really don't want to return None. Or raise an exception.\n\nNot just *some* random type, a type that was specifically marked private by being named with a single leading underscore. `from any_module import _something` is usually a code smell. (cf. [PEP8](https://peps.python.org/pep-0008/); ctrl+F *leading underscore*)\n\nNow, that doesn't necessarily make it wrong on its own. Somebody can easily design and implement a module where they intend for public parts of the interface to be prefixed with a single leading underscore (although to do so would be very unconventional). But in this case you can also ctrl+F `_empty` on the official docs. Neither [the 2.7 docs](https://docs.python.org/2.7/library/inspect.html) nor the [current version](https://docs.python.org/3/library/inspect.html) have any mention of it anywhere on the page. (I actually went through every version of the `inspect` docs available in the drop-down, and `_empty` isn't mentioned in ANY of them.) So OP is relying on private, undocumented members of a module. Very, *very* bad.\n\n[deleted]\n\nShould have specified, this is only for internal use within the system, not returning it to the end user (who may indeed receive either None or an exception depending on the circumstance)\n\nYes, what OP has done is basically using someone else's sentinel. https://peps.python.org/pep-0661/ has a proposal for better support for sentinel pattern, and one rejected idea was having a standard sentinel in the stdlib - because sentinels for different uses should be distinct.\n\nSentinels have their uses, the times I've found them useful is as a default value for a function arg, distinct from None. But 99% of the time I think a \"get\" operation probably ought to return None or raise some kind of \"not found\" exception (preferably one you've defined, for same reasons).\n\nOr if you'd rather pass the buck to the caller, make them pass their preferred sentinel.\n\nYeah this. Don't use internals from other modules. The entire point of the leading underscore notation is to tell you not to import it.\n\nI do wish sometimes that linters didn't complain when you import something with an underscore from a test file.\n\nThere is plenty of room to discuss whether you should be testing private functions and I actually do tend to agree with those who say you shouldn't test private functions directly since the internal implementation should be able to change without needing to refactor a test while also testing all the functionality for the range of valid and invalid inputs of the public API. However, in practice I wind up needing to write tests just to sanity check that I'm understanding private functions as I write them\n\nA lot of programmers think of exceptions as something you only use when things have gone very wrong, but they aren't. They're a way to handle any type of failure condition, even those that are expected to happen under normal conditions.\n\nAnother common alternative in other languages is a `Result<T, E>` or `Either<T, E>` type, but Python exceptions have the same cost as any other operation, so there's no need to go out of one's way to avoid them in business-logic type code.\n\n*However,* if a \"sentinel\" value is normal or expected, using an exception for that might be strange. In those cases, one should prefer `Option<T>` or `Maybe<T>`. However, these are not common in Python since returning `None` usually does the job. When `None` is a valid value, one needs to be a bit more creative. One way is to return a second parameter denoting validity:\n\n    def f(x):\n        ok = True\n        value = x\n        return ok, value\n\nA \"heavy-weight\" alternative is to create a custom type specific to that operation:\n\n    class OptionalResult:\n        def __init__(self, value=None, ok=True):\n            self._value = value\n            self._ok = ok\n    \n        @property\n        def value(self):\n            if not self._ok: raise\n            return self._value\n    \n        @property\n        def ok(self):\n            return self._ok\n    \nThis allows the user to check if `value` exists before trying to extract it. It also keeps the number of return values down to 1. However, this is usually overkill.", "id": "i4qorq3", "owner_tier": 0.5, "score": 0.9999999999841772}, {"content": "There actually exist a whole lot of standard libs that are considered bad practice to use nowadays. That's also why [PEP 594 \u2013 Removing dead batteries from the standard library](https://peps.python.org/pep-0594/) exists.\n\nAre these to-be-removed modules going to keep their name spaces?  I can see a need for uu or xdrfs to exist in pypi/pip but not in core, especially since there is no suggested replacement capability.\n\nTry and use them now guys before they're gone in ~2030\n\nuuencode made sense to include in the standard library because it was used heavily in Usenet (nntp) and because nntplib is also part of the standard library.\n\nBut because nobody really uses usenet nowadays, and certainly not scripting with them, and with nntplib itself being scheduled for removal, yeah, it doesn't really make sense to keep uu.", "id": "i4r0xm2", "owner_tier": 0.3, "score": 0.24367088606012657}, {"content": ">It got me thinking - are there any notable parts of the language's standard modules, that would be considered a poor or incorrect use of the language if you were to use them in production?\n\nMaybe using urllib instead of requests.\n\nGod, I wish requests was part of the standard library. Having to use urllib because you can't install external libraries is a painful experience to the point that I've got a bookmarked stackoverflow post to copy the code from\n\nmemorize shame familiar pet pie imagine juggle fly afterthought toy\n\n *This post was mass deleted and anonymized with [Redact](https://redact.dev)*\n\nI would use it if I were writing an AWS Lambda and didn\u2019t want to drag in any dependencies \ud83e\udd37\u200d\u2642\ufe0f\n\nEh, I realise I'm probably out on my own here, but I find requests gets in the way about as often as it helps out. For simple stuff it's neat, but as soon as I get into the kinds of problems that need adapters to solve, I regret not using an uglier library where you just construct connection objects yourself.\n\nThe terrible secret is... \"requests\" actually *does* ship with Python, and has for years.  shhh!\n\np.s. look in Lib/ensurepip/_bundled/pip*.whl\n\nI'm fairly sure this has been suggested a few times but the development teams would rather they stay separate.\n\n> because you can't install external libraries \n\nIf you can't install external libraries, your whole programming life is going to be miserable.\n\nJust on the testing side - no flake8?  No pytest?  No mypy?\n\nAre you going to rewrite yaml parsing?\n\nAre you going to rewrite numpy?\n\nDevelopers like this are a tiny outlier who are also very difficult to help.  They shouldn't be taken into consideration in the Python roadmap.\n\nLinkers?\n\nIt's easy enough, about 15 lines actually, to make urllib act close enough to imitate requests. I've done that before on systems where I couldn't install it.\n\nRequests exists because urllib is needlessly complicated", "id": "i4qnykh", "owner_tier": 0.5, "score": 0.3465189873259494}, {"content": "The inspect module has a valid specific reason for returning a sentinel - it deals with reflection. Borrowing it is no bueno unless you\u2019re extending inspect.", "id": "i4qywd3", "owner_tier": 0.9, "score": 0.052215189857594935}, {"content": "Another unpythonic thing in the standard library is the heavy use of camelCase in certain modules. For example, `logging.getLogger().setLevel()` should really be `logging.get_logger().set_level()`.\n\n`unittest` is guilty as well. But i personally don't much care, the whole snake case obsession in python feels kinda culty.\n\n`logging` and `unittest` APIs are borrowed from somewhere else. For sure, `unittest` comes from JUnit, not sure about logging.\nThe funny thing is, as they're thought from other languages and libraries, they also feel often weird to use (you need quite some reading to use `logging` properly and understand how it works)\n\nAgreed. In fact, your trivial case should be reduced to `logging.root_logger.level = ...`.\n\nThey really should just rename everything in `logging`.\n\nKeep the old names as aliases for backwards compatibility, of course.\n\nAs a person with OCD, this shit grinds my gears so much to the point I start using Go.\n\n[deleted]\n\nI just think its a little extra to say a variable naming scheme is \"not pythonic\". I know many will disagree with me but i think it should be on individual teams to decide which case they prefer and not have it mandated to them by the language.  We have mixed cases in the python standard library now and its not bad. With modern code editors its not even inconvenient or annoying imo.", "id": "i4sce2v", "owner_tier": 0.7, "score": 0.08702531643987342}, {"content": "It depends, but i think using csv module vs pandas can be a bad practice if you need to do complex stuff with the csv.\n\nOr like using os instead of Pathlib..they are both in the std library tho\n\nConversely using pandas only to load in a csv is probably bad practice. It's a lot of bloat for something very simple.\n\nYap, totally agree with you on pathlib. It just takes out all the annoyances of supporting windows and POSIX.\n\nUsing os over pathlib makes sense if you expect that code to be running on a legacy system and utilizing a version of python older than 3.4.\n\nThis isn't a great example. `csv` and pandas both have their time and place.\n\nYes that happens too\n\nFor that specific example, I have to disagree. Only for the fact that pandas is much faster to load csv files. \n\nOtherwise, I agree that it is better to keep at minimum the amount of large module dependancies when possible.\n\n(I recall having a colleague trying to add a pytorch dependancy just for a single function that was totally unnecessary)\n\nMost python modules have their time and place, doing something non-pythonic means getting 1 of the 2 wrong. Like hawai pizza, pineapple and pizza are great food, just not together.\n\n> Only for the fact that pandas is much faster to load csv files. \n\nIf I'm writing a function that reads a csv and transforms the data or writes it to a DB then not only is the csv library much faster but I can handle csv of arbitrary size. You got a 1 TB csv? No problem with csv module, literally `MemoryError` with Pandas.\n\nI'll be honest I'm guilty of similar.\n\nNo need to get political or anything", "id": "i4qpx3o", "owner_tier": 0.3, "score": 0.24367088606012657}, {"content": "In Python, \"_\" indicates that a method is private, so using a method that starts with this is definitely bad practice.\n\nIt's a smell but not exactly bad practice.  Python takes the stance that \"we're all grown ups here\".\n\nAnd grownups know using undocumented features with no guarantee of future support or behavior is unprofessional. It's definitely a bad practice except for extreme circumstances, POC, and emergencies", "id": "i4rf77b", "owner_tier": 0.7, "score": 0.03797468352848101}, {"content": "The unpythonic thing is not that you are using the standard library, but you are literally accessing a private property of inspect.  the underscore prior to empty is to indicate it's for internal use by that package.\n\nIn other words, parts of the standard library with underscores preceding them are generally unpythonic to use directly in your code!  It is a convention in python.\n\nMoreover, it is a part of the *inspect* library, it was meant for code introspection, unless your result is also related to introspection it's weird to use an object from the inspect library this way.\n\n Probably more importantly, changes to the behavior of private properties will **not** be seen as backwards incompatible api changes, so you might see them occur in an update to the minor version of python in which suddenly the _empty object behaves differently.  With this particular case, it probably will not change, but it's still a bad practice.", "id": "i4sb6ww", "owner_tier": 0.5, "score": 0.017405063275316456}, {"content": "The pythonic sentinel for \"no value\" is None. If your data allows for \"no value\" as a valid value, you must make your api more specific.\n\ne.g.\n\n     return data\n\nThis returns the actual data, including None as a valid value. If you need a specific \"no value\" create your own sentinel:\n\n    class Nothing: pass\n\nThen your function returns this whenever there is no data:\n\n     if <no value>: #insert your check\n          data = Nothing\n     return data\n\nAnd then hopefully your ci rejects the commit because you're returning two types from a function with a docstring that specifies one type.\n\nBetter to return None for no value and try/catch anything that would prevent you from getting to value/novalue.\n\nAs far as creating sentinal objects goes, it's better to do: `Nothing = object()` so that you don't accidentally instantiate it or confuse people with a class being passed around.\n\nReturning None + other valid data is already 2 types..\n\nTo each their own, but in my experience whether either of these approaches are appropriate depends on the purpose of the function:\n\nIf the target data cannot contain `None`, or if `None` is functionally equivalent to \"item not found\", then by all means use `None` to indicate \"not found\".\n\nSimilarly, if your function is framed such that finding no item is exceptional behaviour, then by all means throw an exception.\n\nBut, if \"item not found\" is not considered exceptional, and `None` is functionally different from \"not found\", then a sentinel value or metadata wrapper may well be more appropriate.\n\nI know many feel that it's good form to use exceptions for non-exceptional cases, and that's their prerogative. But I'd caution that exceptions add significant overhead, so all else being equal they're at least mildly contraindicated for expected behaviour when performance is a factor (and I happen to feel that an exception is a misleading way to handle normal, expected behaviour).\n\nUnless you also change the docstring to match?\n\nWell classes are singleton objects, so not much of a difference.\n\nWhich is fine and expected, so you handle None/Valid. You don't handle class Nothing. And your CI should reject such a change, even though it \"works.\"\n\n404s aren't particularly exceptional, but they're still errors, and they're fundamentally different than 200 OK with no content.\n\nExceptions doesn't \"add significant overhead\".\n\nIt may be true in other languages like Java, but not in Python.\n\nNot very hard to type hint, what are you implying? A two type union is a-okay but three types is suddenly impossibru?", "id": "i4rcsqx", "owner_tier": 0.3, "score": 0.055379746819620254}, {"content": "global", "id": "i4qonlg", "owner_tier": 0.9, "score": 0.009493670870253164}, {"content": "A potential pattern you could use here is a named `default` argument, which defaults to `None`. This would allow you to pass in your own sentinel, if desired.\n\nAnother pattern would be a named `must_exist` boolean, which *optionally* throws an exception if the query doesn't return any results. I'm not a huge fan of this though, as it makes method access \"muddy\".\n\nI like the first pattern a lot, then having separate methods for the second pattern. Something that looks like this is usually what I go for. An example for an ORM type of use case below. Also bear with the spacing, am on mobile.\n\n    class Customer:\n        @classmethod\n        def get_by_id(cls, id) -> \u201cCustomer\u201d:\n            # Assuming it raises a RowNotFound error if it\u2019s missing\n            return self.query.filter_by(customer_id=id).one()\n        \n        @classmethod\n        def try_get_by_id(cls, id) -> Optional[\u201cCustomer\u201d]:\n            try:\n                return cls.get_by_id(id)\n             except RowNotFound:\n                 return None", "id": "i4rcsau", "owner_tier": 0.7, "score": 0.014240506313291138}, {"content": "anything in camelCase", "id": "i4st4co", "owner_tier": 0.7, "score": 0.0015822784651898735}, {"content": "from datetime import datetime\n\nWho hasn't been caught by this? Class names should be capitalized.\n\nI think it was done to imitate the literal types like `int`, `list` etc. and imply that in some way, `datetime` was a really basic type... but I find this choice weird since it's not a builtin class", "id": "i4tib19", "owner_tier": 0.1, "score": 0.007911392389240506}, {"content": "A dedicated sentinel value is a perfectly normal thing to make when `None` or `False` can't be used IMHO.\n\nUrllib is kinda hard to wrangle, so is the xmllib, a lot of jank server / network things, logging is super Java-y, etc", "id": "i4s2siu", "owner_tier": 0.9, "score": 0.0015822784651898735}, {"content": "This thread just reminds me how much I love Haskell's `Maybe` class", "id": "i4rlg8i", "owner_tier": 0.9, "score": -1.5822784713964067e-11}, {"content": "Not standard lib by any means but sklearn has some \"special\" code paradigms. A while ago I had to dive into their Gaussian Process Regression code. Building your own kernel types is a mess. It is very doable but the behavior of the kernels is driven by the naming pattern of the arguments. Its been a while so I may have the details off but I remember thinking WTF as I had to figure it out. Oh, and by \"figure it out\", I mean read the source code!\n\nI see the things that may have pushed them into doing it that way but man is it a mess!\n\n\\>driven by the naming pattern of the arguments\n\nHow long did you spend going insane before you said fuck it and opened the source code?", "id": "i4r7cmw", "owner_tier": 0.7, "score": -1.5822784713964067e-11}, {"content": "Reminds me, DAE hate how `re.match` returns None sometimes, so when one tries to do `.groups()` on it a little later you get `AttributeError: 'NoneType' object has no attribute 'groups'`. I really wish it raised an exception instead. This API seems very unpythonic.\n\nThat was one of the justifications for the walrus operator:\n\n    if m := re.match(...):\n        print(m.groups())", "id": "i4somhf", "owner_tier": 0.5, "score": 0.011075949351265824}], "link": "https://www.reddit.com/r/Python/comments/u3p62s/parts_of_the_standard_library_that_are_considered/", "question": {"content": "I had an argument today about the using the `_empty` object from the `inspect` module to denote an item not found in a lookup, rather than just returning None (as None could well be a value in our data), or erroring (as too many try/excepts make code more difficult to read, and failing to find something in our system is not actually an error anyway). \n\nAside from the idea of using a private attribute of another module, the other person says it's \"not Pythonic\" to use smaller custom types like this, as it's too close to something like `typedef` in c++ (never mind that Python has `namedtuple` for almost the exact same purpose anyway, but I digress).\n\nI argued that it's a ready-made and easily legible solution to the problem, and regardless, if it's good enough for the standard library then it should be good enough for us. \n\nWhile I think I'm right in this case, I know the last point is a very dogmatic way of looking at things.\n\nIt got me thinking - are there any notable parts of the language's standard modules, that would be considered a poor or incorrect use of the language if you were to use them in production?", "id": "u3p62s", "title": "Parts of the Standard Library that are considered to be bad practice / un-Pythonic ?", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "    x += y\n\nis equivalent to:\n\n    x = x.__iadd__(y)\n\nThe list's \\_\\_iadd\\_\\_ function succeeds in updating the list, and returns itself, but the assignment fails. The number's \\_\\_iadd\\_\\_ function changes nothing, but returns the new value and the assignment fails.\n\nThe issue here is that lists are mutable (can be modified), whereas numbers are immutable (cannot be modified).\n\nFor the += operator to work on a mutable object like a list, it has to actually modify the object. You can't modify a number though, so for the += to work on a number, you need to store the result of the addition back to the same variable.\n\nPython doesn't know the types of variables at compile time, though. So when it compiles the += operation, it doesn't know if it will be running on a list or a number. As such, it does both: it calls \\_\\_iadd\\_\\_ and then it assigns the result back in to the same variable. The number does the calculation and a new number for the result, and the list updates itself and returns itself. In both cases the assignment back causes an error, but in the list's case the change has already happened.\n\nSo, if `list.__iadd__` was changed to return a new list object rather than do an in-place update and return itself, this particular oddity would disappear.\n\nI guess the problem is that people expect `x += y` to be equivalent to `x = x + y`, which it is not (because of the in-place modification, and the extra evaluation of x). If the `__ixxx___` family of methods did not exist, this gotcha wouldn't either. The upside of doing it this way, I suppose, is that it lets people write more efficient code by avoiding allocation of a new object. The downside is that it's confusing.\n\nThe Python language reference mentions specifically that `__iadd__` and related `__ixxx___` methods should do in-place modifications if possible, so this bit of behaviour is completely standardized. Also, it's interesting to note that mutable objects that don't have an `__iadd__` method don't exhibit this gotcha, but still can support += just fine, either by implementing `__add__` or by the other object implementing `__radd__`.\n\nIt's a gotcha that only appears when you optimize in-place operations.\n\nA similar explanation is (now?) in the comments of the original article.\n\nBut as I comment there, this certainly doesn't mean that this behavior isn't very surprising!\n\nConsider the following:\n\n\n    tup = ([], )\n    def plus_equals(x, y):\n      x += y\n\n    plus_equals(tup[0], [1])  # Succeeds.\n    tup[0] += [1]             # Fails.\n\nOne would be forgiven for expecting the last two lines to do the same thing!  Do recall that in Python, unlike in C or C++, `+=` doesn't return a value, so on first or even second glance these two lines seem \"practically identical\".\n\nI \"understand\" why this is true, but that doesn't mean that it isn't still surprising behavior to me. \n\nThere's also the other surprising behavior - where the operation _succeeds_ but still raises an exception.  I can't think of any other place in Python where this happens - heck, I can't think of any other place in _any_ language where this happens...!\n\n> So, if `list.__iadd__` was changed to return a new list object rather than do an in-place update and return itself, this particular oddity would disappear.\n\nNo, you can't do that. This isn't just an optimization. Your version would break other behavior.\n\n    >>> a = b = []\n    >>> a += [1]\n    >>> b\n    [1]\n\nUnder your version, `b` would still be `[]`.\n\nDidn\u2019t know reddit markdown supports ``-syntax`. Cool! Is this new?\n\nNot as far as I'm aware!  Reddit mostly supports standard [markdown](http://daringfireball.net/projects/markdown/), and has supported \\``backticks`\\` for a while.", "id": "c7q5kaq", "owner_tier": 0.1, "score": 0.9999999997674418}, {"content": "So \"x[0] += [1]\" is equivalent to \"x[0] = x[0] + [1]\"?\n\nIsn't that what we'd expect?\n\n(i.e. \"x[0] + [1]\" is evaluated, and then the assignment to \"x[0]\" fails.)\n\nYou missed part of the odd behavior: after executing `x[0]+=[1]` the list at `x[0]` *has* been modified.\n\nActually, they aren't equivalent. I just tried this in the interpreter. x[0]+=[1] throws an error, but the list is still altered. x[0] = x[0] + [1] doesn't alter the list.\n\nThe reason they are not equivalent is that `x[0] += [1]` invokes the `__iadd__` method on `x[0]`, whereas `x[0] = x[0] + [1]` invokes the `__add__` method.\n\nThe discontinuity and confusion comes from the fact that `__iadd__` is used and the tuple is assigned to, as opposed to just one or the other.\n\nActually, \"x[0] += [1]\" is equivalent to \"x[0] = x[0].\\_\\_iadd\\_\\_([1])\".\n\nThe effect of \\_\\_iadd\\_\\_ on a list is to change the list and return itself, but the effect of \\_\\_iadd\\_\\_ on an int is to return a new value.", "id": "c7q2pmb", "owner_tier": 0.5, "score": 0.697674418372093}, {"content": "I don't really see how this would be a bug. `__iadd__` returns a value, which allows it to do either change the current object or create a new one. Since value is being reassigned to the original variable this behavior makes perfect sense, as (`x[0] = x[0]` fails as well in this case). \n\nIt *succeeds*, but still raises an exception. It should do one or the other, but not both.\n\nSeconded. As an engineer, I'm constantly fascinated by these cases -- surprising, unintuitive behavior that's direct consequence of a chain of seemly intuitive decisions. `X += Y` in Python is shorthand for `X = X.__iadd__(Y)` (save that X is only evaluated once), and __iadd__ for lists modifies the existing list. The only strange bit here is that tuple member assignment fails.\n\nYou can see this by executing:\n\n    >>> x = [0]; y = x;\n    >>> x += [1]\n    >>> print y\n    [0, 1]\n\nMost of us are expecting the original list contents, but += on lists behaves more like `extend()` than like `+`. That's where most of the surprise comes from; while strange, it's less confusing than always failing operation to have a side effect.\n\nWell the assignment is what is failing, no the actual `__iadd__` method. \n\nThis is unrelated to the topic. Both `x` and `y` refer to the same object, initially `[0]`, then appended to as `[0, 1]`. This is the distinction between mutable and immutable data types.\n\n    >>> x = [0]\n    >>> y = list(x)\n    >>> x += [1]\n    >>> y\n    [0]\n\nThe difference in this code is that *y is a new list*, rather than a reference to an existing list.\n\n> Most of us are expecting the original list contents\n\nOnly if you think assignment like `y = x` means creating a new copy, as in C++. I don't think many people would expect += to be anything other than a mutation operation, which means x and y will continue to refer to the same object.\n\nI think what most people are missing in this discussion is that, sure, it makes \"sense\" that it happens, but this is the sort of strange behavior that makes a language ugly. Javascript is filled with these super strange unnatural oddities. I personally love Python because it works like you expect it to and that things behave nicely, but I don't think an error and an effect are very natural.\n\nYou're making the assumption that everyone who programs is a computer scientist, and/or has a deep understanding of what happens behind the scenes of the interpreter. As someone who uses python for administrative scripting, and simple tasks, I don't think it's far fetched to say there are a lot of people like me who expect it to just work the way you would think it would work, not raise an exception, but still kind of work. \n\nYou could say that that makes me a shitty programmer, but since I'm not a programmer that's a fair assessment.\n\nThat's almost it. Rather, we're accustomed to x += z to be roughly equivalent to x = x + z, but for Python lists that's not the case at all. We don't expect x += z to affect y as x = x+z would not have affected y. \n\nWhat do you propose should happen to get the desired results? \n\nI don't think I am making that assumption, and I don't think it requires any knowledge of the interpreter (of which I have little). Nor do I think this is sensible behaviour on Python's part. I was just pointing out that aaronla's expectation that following `y = x` with a `x += [1]` will not change y only applies if you either have a misunderstanding of what assignment means in Python or you have a rather unusual understanding of what += means. The former is much more common than the latter and is understandable.", "id": "c7q527z", "owner_tier": 0.5, "score": 0.8604651160465117}, {"content": "There is also another interesting twist to this \n\n    import operator\n    x = ([], )\n    operator.iadd(x[0], [1])\n    >>> [1]\n    x\n    >>> ([1], )", "id": "c7qd6n8", "owner_tier": 0.5, "score": 0.046511627674418604}, {"content": "You can't do this: x[0] += y, where x is a tuple.  Because this is equivalent to x[0] = x[0] + y.   The right hand side might be okay, but the assignment back to x[0] raises an exception because x is an immutable tuple. \n\nIt isnt equivalent actually, using `__iadd__` allows the object to be changed in place rather than creating a new list. ", "id": "c7qdeww", "owner_tier": 0.7, "score": -2.3255813812151838e-10}, {"content": "Undefined behaviour is undefined?\n\nActually, I believe this behavior is fully defined (see all the other comments) but it brings up a good question. Does Python have any undefined behavior at all?\n\nWhich bit is undefined? And why would it be undefined?\n\nThis is a bit of a cop-out answer, that will be buried under a buried comment, but it's an interesting question, so I'll try to say something anyway.\n\nThere isn't a \"Python standard\", there's just a reference implementation and a reference manual. Almost all behaviour is \"defined\" by the reference implementation, even if it is as confusing as the example in the original post. Because of this, it might look like everything is defined, but there are actually a few different kinds of undefined behaviour.\n    \n* **Documented undefined behaviour** \u2013 This is when the documentation says that something is undefined or unpredictable. Other implementations have no obligation to do it the same, this is just how CPython works. For example, if you search for \"CPython\" on [this page](http://docs.python.org/3/reference/executionmodel.html), you'll see a box explaining that if you modify \\_\\_builtins\\_\\_ it may not work on other Python implementations. So you'll probably get a \"NameError\" or a redefined builtin if you modify it, but it's possible that another valid python implementation launches a game of chess when you touch \\_\\_builtins\\_\\_.\n* **Classic undefined behaviour** \u2013 Just as writing past the end of a buffer in C is undefined, this is also true if you write past the end of a buffer in Python. Python deliberately makes this really hard, but you can still do it (and lots of other insane, evil things) if you use ctypes. It will behave unpredictably differently depending on which Python version was compiled with which compiler.\n* **Conflictingly defined behaviour** \u2013 According to Tim Peters on [this issue page from Python 2.3 in 2001](http://bugs.python.org/issue448679), and [the python docs](http://docs.python.org/2/reference/expressions.html#evaluation-order), everything is meant to go left-to-right. But I just tested on 3.3.0, and dictionary key/value evaluation order is not as documented (as mentioned in the issue). If the reference implementation and the documentation disagree, is it defined? Maybe it really is a twelve-year-old bug and any python code that relies on that behaviour is correct - it just doesn't run on CPython because of a bug. Try it yourself:\n\n        >>> def f(a): print(a)\n        >>> {f(1):f(2)}\n        2\n        1\n        {None: None}\n\n> Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side.\n\nFrom the Python Docs you linked\n\nTrue. Although {'a': 'b'} isn't exactly an assignment, that part of the specification is probably the reason for this behaviour. If it was unclear, the specific documentation I was referring to was:\n\n> In the following lines, expressions will be evaluated in the arithmetic order of their suffixes:  \n> ...  \n> {expr1: expr2, expr3: expr4}\n\nWhich is explicitly saying that the dictionary example I wrote should print 1 first then 2.\n\nWell you are doing an assignment.  You're assigning a value to a key in the dictionary.\n\nI'd expect the first key, value pair to be evaluated before the 2nd and so on.  So that portion is left to right but the assignment is still right to left.", "id": "c7q2jbe", "owner_tier": 0.9, "score": 0.44186046488372094}], "link": "https://www.reddit.com/r/Python/comments/15v46b/pythons_is_weird_part_ii/", "question": {"content": "", "id": "15v46b", "title": "Python's += Is Weird, Part II", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "If you have a super-generic function like that and type hinting enforced, you just use `Any` and don't care about it.\n\nIt's better than not type hinting your codebase at all, as in 99% of cases you can use the proper hints.\n\nWorking in a big python codebase without type hints is a huge PIA.\n\n[deleted]\n\nExactly. Python type hints aren't enforced, so they're really mainly a form of documentation. Using `Any` is an effectively a way of warning other programmers that the parameter in question is unusually complex and needs to be handled with care, e.g. I usually represent JSON-like objects as `Dict[str, Any]` without worrying about trying to correctly unreadable monstrosities like `Dict[str, Dict[str, int]] | Dict[Str, Dict[str, str]]` which can't be read by humans and will be ignored by the interpreter in any case.\n\n`Any + Any -> Any` is wrong though. Sure it makes the errors go away, but it does so by asserting completely false things like `int + str -> dict`.\n\nIn large codebases typing is better than not having typing, but it isn't a good expressive type system, and it therefore cannot actually assure you type safety.\n\nAll the `Any + Any -> Any` annotation does is tell mypy not to complain about an unannotated function, but it's no better than telling mypy to ignore the function entirely.\n\nWorking in code without strong types is annoying imo\n\nThis is the (Any) way.\n\n> and type hinting enforced\n\nThis is the biggest error. In 99% of cases, you should not check the types of the arguments passed to your function for the sole purpose of throwing a `TypeError`. That's the whole point of duck typing. (I'm saying this as someone who prefers strong, ML-like type systems.)\n\n> Data types have helped me find so many bugs during development time it's nuts.\n\nMy experience begrudgingly trying them out while playing with Advent of Code was pretty much exactly this. The static analysis saved me from multiple issues before I ever execute a single line of my code.\n\nIf the view is that type annotations are documentation, then my opinion is that  `Any, Any -> Any` should be avoided because it isn't actually documenting anything. It is really mis-documenting things. I would prefer `#type: ignore` for these situations.\n\nIf you could provide some information about the types: `int, Any -> Any` then it would be a little better (although many objections still remain).\n\nYou could probably fix this by just defining some type alias `Unknown = Any` and then you would have things like `Unknown, Unknown -> Unknown` and `int, Unknown -> Unknown`, which is the same signature to the type checker, but is a little clearer to the reader that you have in fact given up trying.\n\nWell, they can actually be read by humans, but I kinda get your point.\n\nWhy don't you use dataclass or pydantic for JSON?", "id": "j83cwzo", "owner_tier": 0.3, "score": 0.999999999988345}, {"content": "God tier post. My incredibly flippant answer is use type hinting when it\u2019s helpful and not strive for completeness, kinda like how complete test coverage is often more about dick-Waving than code safety.\n\nTruish regarding test coverage, but the old phrase \"Any untested code is broken.\" is also surprisingly often true.\n\nOur team mantra on coverage is, 0% coverage means your tests are definitely bad, 100% coverage doesn\u2019t mean your tests are any good.\n\nNoob question, how do you handle your ide/language server complaining? Just ignore?\n\nExcept when you think about it - in reality code being untested doesn't mean it's broken. It's a nice saying but someone needed to bend reality to prove their point.\n\nYou fix the issue.\n\n99% if the time, you just made a mistake. 1% of the time it\u2019s a bug in the typechecker/library and you create an issue on GitHub.\n\nVery true. My approach to testing is:\n\n* How might this test break, and how likely is that scenario?\n* Is this test the only way I'll know the code isn't behaving?\n* When the test breaks, can it clearly explain what went wrong? Even to someone who isn't me?\n* If I refactor my code, will this test still pass without changes? \n\nWhen looking at testing through these questions, a lot of tests start to seem worthless. And, sadly, that's to be expected. Many programmers write tests only because they were told to write tests. It's really only after going through the five why's that you start to understand what the point of it all is.\n\nIt is a heavy handed statement meant to be scare people into more testing. I would alter the statement and say you should have *zero confidence* in untested code (you can't always have full confidence in tested code).\n\nIt's obviously just a saying that is meant to instill good habits. There is no reason to take the comment pedantically.\n\nYou seem to have posted this comment just a couple extra times.  Reddit's being goofy today and I'm seeing a crapton of multi-posting.\n\nYeah, sorry. 2 or 3 times my app would hang for a minute and say try again later.", "id": "j82zy2y", "owner_tier": 0.1, "score": 0.38578088576923075}, {"content": "I would probably pick step 4 and stop there. Full generality and trying to handle all special rules in python is often a pain. If your user really wants to use a type with only add and no radd they can just type ignore. There are other places both for stubs and type checkers where python behavior vs describing it grows to be painful enough that you pick reasonable approximation that covers most cases and stop there. One easy example there is no way to describe functools.partial fully in type system. Or even a simple decorator can give you problems if you try to use it on an overloaded function as mypy does not support mixing paramspec + overloads. I consider these esoteric pains and that a few type ignore/casts is fine. You should expect type hints to cover most usage. \n\nIt\u2019s similarish to test coverage. 100% coverage is often pain to maintain. 90% (exact number team decision) is fine. 100% type coverage is also painful and at times essentially impossible.\n\nOne place that tries hard to do type hints very precisely is typeshed and you can see the protocol they define here to describe very generic add/radd usage. I don\u2019t recommend going this far but it can be helpful to look in typeshed to see how they solved similar issues.\n\nhttps://github.com/python/typeshed/blob/afb7704b36ad9b43704bf2444ba1997858b6f677/stdlib/builtins.pyi#L1719\n\n> I would probably pick step 4 and stop there.\n\nUnfortunately 4 is fundamentally broken with tuples, I had to raise a ticket with pyright to understand why: https://github.com/microsoft/pyright/issues/4613/\n\n(#4) permits `int+str` as mypy finds no issues with the following:\n\n    from typing import Protocol,TypeVar\n    T = TypeVar(\"T\")\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    def binary(a: Addable, b: Addable) -> Addable:\n        return a + b\n\n    x:int = 0\n    y:str = \"foo\"\n    z:Addable = binary(x, y)\n\nI read ticket. I\u2019d still stop there. The ticket response boils down to how do you know if a tuple if intended to be fixed length or dynamic length. it\u2019d be nice if bidirectional inference solved it but I can understand maintainer thinking it\u2019s not worth special complexity for tuple to cover this. As a user you could specify it,\n\nx: tuple[int, \u2026]\ny: tuple[int, \u2026]\n\nAnd then your sum function would work with those two arguments.\n\nIn practice I\u2019d just type ignore and move on if I ever end with tuple add problem here.\n\n[deleted]\n\nAnd that argument would be wrong.\n\n1. There is no immutable list. You have to use tuples in immutable contexts. Consequently, it\u2019s not hashable and therefore not cacheable. \n2. Adding two sequences doesn\u2019t imply you need a dynamic length sequence (and even then, see point 1). Adding two fixed length tuples results in another fixed length tuple.\n\nThe critical point is: Is the tuple\u2018s length known at the time of writing or is it known at runtime? The implementers of the typehinting ecosystem apparently prioritize tuples as \u201ccompile-time\u201c constants, i.e. the length is known at the time of writing. That\u2019s already implied by the difference between `List[int]` and `Tuple[int]`. Now here\u2019s my point: If you really think you can limit tuple usage mostly to fixed length known at the time of writing, that\u2019s just unrealistic. Let us have `frozenlist` and maybe that becomes a bit more realistic.\n\nKey take away, you can not count only on static checking, some checks have to be done at runtime, that is just Python nature", "id": "j82zlqs", "owner_tier": 0.5, "score": 0.2494172494055944}, {"content": "Lol.\n\nI\u2019m sorry but no. Type hinting is awesome and has caught so many bugs in my code it\u2019s ridiculous. If you have certain code that requires this level of dynamic typing then just use Any on the function in question and move on.\n\nTyping clues your users in how the function is supposed be used and what it returns. 99% of the code I write requires very specific argument types, and if it doesn\u2019t then I use Union or else Any as an ultimate fallback. That way your users are going to get a mypy error if they try to pass in a string or possible None to a math function expecting number types.\n\nIf you don\u2019t follow this advice then have fun inspecting excessively long functions to try and figure out what is supposed to be passed in and is returned. Heck, without mypy your functions could return different return types depending on the code path and now you have a major bug that slipped into prod!\n\nIn my experience, `typing` has not been particularly good for finding bugs compared with unit tests and consumes considerable effort.\n\nAnd I come from the C++ world, where everything is typed.  I _like_ typed languages!\n\nAnd I do add type hints to most of my code - _as documentation_. \n\nBut I rely on strong test coverage because tests can potentially find all bugs, not a small subject of bugs.\n\nI would say 80%+ of my bugs are returning a wrong value of the correct type, or a crash because one of my arguments was the right type, but out of range.\n\n> have fun inspecting excessively long functions\n\nExcessively long functions are a code smell and a problem for reliability whether or not they are typed.\n\n> Your functions could return different return types depending on the code path\n\nYour functions could return a wrong value of the correct type, depending on the code path.\n\nGood test coverage will find both of those issues.\n\n---\n\nAs a senior engineer, I would prefer a completely typed codebase.\n\nBut I have spent many hours helping juniors figure out how to type hint their programs, and none of them have ever come back to me and said, \"This found so many errors, wow!\" mainly because these projects already had good test coverage.\n\nSince I have to work with junior programmers, since time is limited, I prioritize tests over type checking.\n\n----\n\n> Lol.\n\nCan you knock that off?  We're adults here.  Mocking what someone said is not a good look.\n\n> If you have certain code that requires this level of dynamic typing then just use Any and move on.\n\n...but that would be a lie, wouldn't it? Is it better to have no annotations in that case at all or objectively wrong ones because the actually correct ones are extremely hard to express?\n\nYou don\u2019t understand the post.\n\nUnit tests only test what args you actually use. They don\u2019t test the unbounded set of all possible input types to your function that a user may throw into it.\n\nThe biggest win is preventing your users from putting in None into your function. Those None values screw your code paths and wreck havoc on code bases. None (and null in other languages) is the number one cause of all bugs in production. Heck, Google made an entire language, kotlin, primarily to fix the null crashes in Android.\n\nAdditionally, when I used type annotations the number of unit tests required decreased to a fraction of what I needed before.\n\nThere is literally no construct in python that finds so many deep bugs as type checking does.\n\nEDIT: and chat gpt uses those type hints to help generate code.\n\n> Can you knock that off? We're adults here. Mocking what someone said is not a good look.\n\nI mean, they did come on pretty strong with the \"type hinting sucks\" statement even if they did walk it back in the body of the post.\n\n> In my experience, typing has not been particularly good for finding bugs compared with unit tests and consumes considerable effort.\n\nAt my company (we have millions of lines of Python) it caught _lots_ of bugs and the effort was reduced by automated tooling for inferring the annotations\n\nUsing Any is not objectively wrong\u2026 at all.\n\nUntyped functions are equivalent to typed functions using Any.\n\nOP wants to throw the baby out with bath water and this makes no sense whatsoever. Use mypy and reduce the pain of users using your API. And if you don\u2019t then you only have yourself to blame because you threw out type checking over a freaking contrived corner case.\n\n>but that would be a lie\n\nNot at all.\n\nPython has dynamic typing - that's not an accident or a bug, it's a feature.\n\nType hints are not laws, they are \"hints\".\n\nConsider the trivial example:\n\n    def add_ints(val1: int, val2: int) -> int:\n        return val1 + val2\n\nMyPy will correctly show an error if you attempt to call \\`add\\_int()\\` with string arguments, because we have told MyPy to only accept integer arguments. But the Python code in this example will work perfectly well with string values.\n\nThe \\`int\\` type hint isn't a lie, it's just a hint about the *intended* use, and MyPy will warn us if we attempt to use the code in ways that were not intended.\n\nUsing the 'Any' type tells MyPy to accept any type, which means that we won't get useful hints about usage. It doesn't mean that code will work with \"all\" data types, it just means that MyPy won't complain about the type and won't offer useful hints. It also tells us that the author has considered the data type and chosen to not annotate restrictions.\n\nMy solution to the original problem would be to use \\`Any\\`. IF as a user of the \\`slow\\_add\\` function, I needed MyPy to be more restrictive, then I would write a wrapper for \\`slow\\_add\\` and restrict the types that the wrapper could accept. That would be my task as a user of library to suit my specific use case, not the job of the developer that wrote the generic \\`slow\\_add()\\`.\n\nPretty sure Google did not \u201cmake\u201d Kotlin, and they do *recommend* it for Android development. Kotlin was founded by JetBrains, although I\u2019d be surprised if Google hasn\u2019t contributed to it.\n\nI did not know this, and it surprises me.\n\nMost of the None errors that I experience come from data at runtime, meaning that no amount of static type analysis will help. Indeed, it can encourage me to be complacent and avoid using defensive strategies.\n\nThat said, I don't have much experience of typed, massive, interconnected codebases and am more familiar with untyped ones. Certainly, None issues didn't stand out particularly in those cases.", "id": "j8337r6", "owner_tier": 0.1, "score": 0.14801864800699302}, {"content": "slow_add is trying to do too much at once you were screwed from the beginning. It appears to me that you have purposefully made slow_add this functionally \"bloated\" as a strawman against type hinting\n\nIt's \"doing too much\" from the viewpoint of explicit typing. When your mindset is to consider each type separately, then you will see the function as bloated and unruly (as it tries to handle so many different types at the same time).\n\nBut from the mindset of classic Python duck typing, this is a very simple and elegant function that \"adds any two things that can handle being added\". What could be more simple?\n\nI'm not saying that one of those two mindsets is more correct. But I understand OP's call for more empathy between the mindsets.\n\nI disagree. I think the function is readable, usable, and has a clear purpose. Adding type hints degrades all of the above.\n\nOP's example demonstrates the adage ubiquitous in computing: no tool suits all jobs, use the right tool for the job. \n\nTyping isn't the solution to all problems.\n\n[deleted]\n\nIt\u2019s just an add function. That\u2019s the expressiveness of Python. Your argument is to castrate it to make it work with the type system. Might as well use Java or Go at that point.\n\nThere isn\u2019t any actual difference between the two mindsets.\n\nIf you consider the function from a types perspective, it\u2019s quite clear that you can\u2019t actually restrict the types of the argument. The underlying binary plus (operator.add) can\u2019t be restricted because any user is free to implement it however they want.\n\nIf you were actually trying to accurately type this function, it would be\n\n    def slow_add(a: Any, b: Any): -> Any\n\nOP\u2019s premise \u201cI can and must restrict these types\u201d is wrong and antithetical to proper typing.\n\nWhen you define the function without types, what you're saying is that you're delegating the responsibility to have types that work to the client. That's not \"elegant\" or \"simple\" for the client, although it might be simple for you because you simply don't want to deal with it. \n\nThe problem is that that's probably not your intention. If it's, mypy has you covered, just give an `Any` type to both parameter and return type, that will work.\n\nFunctions and methods should ideally have a single job, if you need the function or method to do more you extend it. Python has great tools for this including decorators, ABC, and class inheritance. \n\nOP gave a great example of the dangers of code that does too much. I've been using python since at least v2.6 and I have yet to come across issues with type hinting that actual broke the code (from when it was added in v3 something). On the other hand functions that do too much are usually broken from the start.\n\nFunctions and methods should ideally have a single job, if you need the function or method to do more you extend it. Python has great tools for this including decorators, ABC, and class inheritance. \n\nOP gave a great example of the dangers of code that does too much. I've been using python since at least v2.6 and I have yet to come across issues with type hinting that actual broke the code (from when it was added in v3 something). On the other hand functions that do too much are usually broken from the start.\n\nThis is like worst case scenario too much. If your code looks like this we have more to worry about than type hints. OP is clearly trying to present a strawman to demonstrate is point\n\nDidnt know expressiveness meant bad design. Some ducks shouldnt be able to quack even if they technically can. Type hinting should communicate that. Separate your functionality. On top of that OP is showing that type hinting cant elegantly support a *global* adding function. Therefore type hinting bad. Smells like a strawman to me", "id": "j833lqr", "owner_tier": 0.5, "score": 0.18181818180652679}, {"content": "Ironically, I think this post proves the exact opposite of what it's trying to, i.e. that typing works well.\n\n1. Guido actually mentioned something similar a while ago about typing, which is that he likes that it's not a core feature of the language, because you get the advantages of static typing but aren't bound to it in situations that aren't fitting, like this one.  \n\n2. If I ran into all these problems, I'd say that mypy was giving me a good indication that there's an architectural problem happening.  The issue basically boils down to, \"I have an API/library code that has behavior and use cases that are apparently impossible to define or constrain\".  Obviously this is a toy example, so it's hard to make specific claims but in real code I'd think things like, \"why do I need this incredibly generic function?\" or \"what behavior am I really trying to permit or constrain?\"\n\n      For example, my library probably isn't actually responsible for providing an \"add literally anything addable\" function.  Why is my function not constrained to adding types that are relevant and leaving adding other things to other libraries?  Or, if defining a robust addable type is important to my library, why haven't I done that, annotated a T = typevar('Addable', bound='AddableBase') and then provided helpers to box primitives or convert objects so that the 'right' answer for customers isn't to add anything willy billy, but to either implement a subtype of addable or to use my helpers/factories on their types to get an addable that my library is specialized to handle?\n\n      Mypy has correctly helped you identify potential code smell and the answer isn't to double down, it's to re-evaluate.\n\nIf you consider type hints as optional then I 100% agree with you.\n\nIf you expect type hints to guide you on your application development like types do in Rust you're likely to hit fundamental limitations of Python's type hints.", "id": "j840n3n", "owner_tier": 0.9, "score": 0.07226107224941725}, {"content": "Instead of \"type hinting sucks\", my conclusion would be \"type hints aren't meant to express every constraint on the arguments to a function, so don't adopt style standards that expect them to.\" If [`Any` is good enough when typeshed is hinting `operator.add`](https://github.com/python/typeshed/blob/main/stdlib/_operator.pyi#L53), it should be good enough for similar cases in your code.\n\nyup this post just screams of someone trying to force python to work like INSERT\\_FAVORITE\\_LANGUAGE\\_WITH\\_STATIC\\_TYPES\n\nwhat you say is true, but the point OP is making is that it's difficult to express this semantic in a more effective way. Either you go the Any way, which allows for absurdity like allowing int + int -> dict, or you go the painful way of doing what OP did. \n\nI think this only points out that the semantic flexibility of the typing system is still incomplete to be able to express this level of typing with the language we currently have. More PEPs may cover this gap.\n\nI love Python.  I just wish it didn't use whitespace delimiters (modern IDEs can do smart indenting), was strongly typed, 1-indexed, used `else if`instead of `elif`, and gave me direct memory access.  Totally unrelated, though: I *hate* FORTRAN.\n\n^^^^/s", "id": "j83kkor", "owner_tier": 0.7, "score": 0.057109557097902094}, {"content": "So you're saying that it's difficult to build a _global_ add function for every type, and you're frustrated or irritated about it?\n\nThis initial situation is horrible: non-graceful handling of errors (adding non-addable types being added, that's just praying for the best), just throwing.\n\nThe final situation is great (if it covers all cases). Yes, the code might look meh but hey, you tried to create a _global_ adder. That's the price the lib author has to pay to get there. The journey to get there just shows how painful the python ecosystem is when working with its dynamic types.\n\nTL;DR: the premise was bad, because it was to create a single function to add them all and in the type hinting bind them.\n\nNo, the premise is: Python is more expressive than its type system, so you have to choose: Fully make use of Python\u2018s expressiveness and accept some untyped code or limit yourself to a subset and have 100% type coverage. OP is arguing for the former, and I\u2019d agree. Because if you choose the latter, why choose Python in the first place?\n\nWhat??? The global function existed before. It\u2018s there and it works.\n\nI\u2019d say that OP isn\u2019t even arguing for that - they are just imploring the community to have patience and empathy for authors of code that have been designed before type hints were added (to the language/project).", "id": "j8378q8", "owner_tier": 0.3, "score": 0.06993006991841491}, {"content": "The thing to realise is that Python\u2019s typing system works the same as any mainstream statically typed language does. How would you type that function in a statically typed language like C#? It\u2019s tricky there so it will be tricky here too.\n\nPeople get frustrated with Python type annotations usually because they\u2019re trying to type hint a codebase that uses lots of dynamic language features. Typing works best when you type annotate from the start and the types steer the design of the codebase, and not the other way around.\n\nIt is actually possible to type this kind of function in modern C++, and people do use this pretty often.\n\n    auto slow_add(auto a, auto b) -> decltype(a + b) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        return a + b;\n    }\n\n`decltype` essentially means: *\u00abgive me the type you can infer for this specific expression\u00bb*, and would be checked for each use of slow_add, as opposed to trying to prescribe a single return type at the definition time. Typing in Python is still a very fresh feature compared to many other languages, and I can imagine a feature like that implemented in some future tooling, it would fit Python a lot.\n\nWhich means you\u2019re limiting yourself to a very unexpressive subset. Other languages have alternatives that Python doesn\u2019t offer (like *real* overloading and generics). This would be a non-issue with trait based generics. It\u2019s only tricky in languages where the type system doesn\u2019t match the expressiveness of the language.\n\n> dynamic language features\n\nIs why I use Python and not statically typed language.\n\nThat is cool and on hell ya it would.\n\nTotally unrelated but if you're `using namespace std::chrono_literals;` then you can specify the duration as `100ms` which is super cool.\n\nWhich ends up being very similar to\n\n>     def slow_add(a: Any, b: Any): -> Any\n      time.sleep(0.1)\n      return a + b\n\nIf by very similar you mean completely different.\n\nWith C++ the compiler identifies if S+T is even possible and emits the correct version of the function with the correct return type and then completes all subsequent static type analysis steps. If S+T is not possible you get a compile error. If the resulting type of S+T is incompatible with its subsequent use, you get a compile error.\n\nMypy when it sees Any+Any->Any and just stops checking types. It is perfectly with code that would take int+str and treat the output as a dict. There would be no objections from mypy, but when you ran the code it will obviously fail.\n\nI mean in terms of the syntax", "id": "j837x6j", "owner_tier": 0.1, "score": 0.07808857807692308}, {"content": "I read all the way through that to find its all numbers? What about the user who for some unknown reason decided to use my library to add strings!?\n\nStrings implement `__add__`, so they work with the fourth attempt.", "id": "j835has", "owner_tier": 0.7, "score": 0.038461538449883446}, {"content": "Exceptionally good post. This remins me of ~~\"don't write classes\"~~ \"Stop writing classes\" presentation. Going extreme in any python feature is a bad decision.\n\nEdit: name\n\nThe presentation is 1https://youtu.be/o9pEzgHorH0\n\nIt is called Stop Writing Classes because the title \"stop writing classes when it isn't necessary because you've come from Java and don't know any better\" isn't as pithy. No one, especially Jack dieterich means that you should never write classes, that would be silly.\n\n[deleted]\n\nOh, that's not that I meant. What I mean was, don't go extreme on neither subclassing, nor typing.\n\nSure other comment posted it.\n\nThat is the wise point to be made. Sorry that I misinterpreted you.", "id": "j83akrn", "owner_tier": 0.5, "score": 0.020979020967365966}, {"content": "Yes, exactly. As soon as you try to push python into statically typed realm, you find that python is not that good at type expressions.", "id": "j8375ow", "owner_tier": 0.5, "score": 0.006993006981351982}, {"content": "I think the trick here is to consider introducing type hints to be a breaking change. If you have them in from the start, awesome! If you're retrofitting them later, expect suffering.", "id": "j833mao", "owner_tier": 0.5, "score": 0.0023310023193473194}, {"content": "Awesome post OP.  Quite funny.  \n\nWhich users run mypy against other people's code though?  That's fine, and I could support that, but if a customer asked for it, as a freelancer I would require an extra work package or milestone ($$$).\n\nA huge benefit of type hinting is to catch bugs early at the source code stage, precisely by stopping otherwise addable things like tuples being passed to arithmetic functions.  \n\nSo you should've just pushed back against the request to support tuples.  Or at the very least, if a valuable customer requests that a clearly numeric type hinted function support tuples, then that's not the language's fault, it's your job to find a work around for them.", "id": "j83f4m8", "owner_tier": 0.1, "score": 0.0023310023193473194}, {"content": "Fuck these users. Who do they think they are, making you do all these changes while they could just fix their code.", "id": "j83f8ow", "owner_tier": 0.5, "score": -1.165501158417866e-11}, {"content": "As an old-school python programmer who remembers when built-in types and classes were a different thing, I fully understand the sentiment.\n\nTyping is a  path that eventually takes you to a bad state (Java) or to a place of mathematical correctness, a path that has been taken and you can see the results in Haskell, Rust, StandardML (my favourite somewhat).\n\nSo I'd rather have Python without types, and if I think I need types pick Haskell or something.\n\nThat being said, a primary reason for type annotations being added was that JetBrains  wanted to provide better code-completion.  This is probably a level where type annotations kind of make sense (could have been deduced from the docstrings though). That we have now type checkers and have TypeErrors on the static-analysis level is IMHO taking things a little too far. and Type Errors at runtime never were rare in production. Much rarer than any kind of logic error.", "id": "j83ic5q", "owner_tier": 0.5, "score": 0.001165501153846154}], "link": "https://www.reddit.com/r/Python/comments/10zdidm/why_type_hinting_sucks/", "question": {"content": "Type hints are great! But I was [playing Devil's advocate](https://www.reddit.com/r/Python/comments/10vh1v5/mypy_10_released/j7igi8q/?context=3) on a thread recently where I claimed actually type hinting can be legitimately annoying, especially to old school Python programmers.\n\nBut I think a lot of people were skeptical, so let's go through a made up scenario trying to type hint a simple Python package. Go to the end for a TL;DR.\n\n# The scenario \n\nThis is completely made up, all the events are fictitious unless explicitly stated otherwise (also editing this I realized attempts 4-6 have even more mistakes in them than intended but I'm not rewriting this again):\n\n**You** maintain a popular third party library `slowadd`, your library has many supporting functions, decorators, classes, and metaclasses, but your main function is:\n\n    def slow_add(a, b):\n        time.sleep(0.1)\n        return a + b\n\nYou've always used traditional Python duck typing, if a and b don't add then the function throws an exception. But you just dropped support for Python 2 and your users are demanding type hinting, so it's your next major milestone.\n\n# First attempt at type hinting\n\nYou update your function:\n\n    def slow_add(a: int, b: int) -> int:\n        time.sleep(0.1)\n        return a + b\n\nAll your tests pass, mypy passes against your personal code base, so you ship with the release note \"Type Hinting Support added!\"\n\n# Second attempt at type hinting\n\nUsers immediately flood your GitHub issues with complaints! MyPy is now failing for them because they pass floats to `slow_add`, build processes are broken, they can't downgrade because of internal Enterprise policies of always having to increase type hint coverage, their weekend is ruined from this issue.\n\nYou do some investigating and find that MyPy supports [Duck type compatibility](https://mypy.readthedocs.io/en/latest/duck_type_compatibility.html) for `ints -> floats -> complex`. That's cool! New release:\n\n    def slow_add(a: complex, b: complex) -> complex:\n        time.sleep(0.1)\n        return a + b\n\nFunny that this is a MyPy note and not a PEP standard...\n\n# Third attempt at type hinting\n\nYour users thank you for your quick release, but a couple of days later one user asks why you no longer support `Decimal`. You replace `complex` with `Decimal` but now your other MyPy tests are failing.\n\nYou remember Python 3 added [Numeric abstract base classes](https://docs.python.org/3/library/numbers.html), what a perfect use case, just type hint everything as `numbers.Number`.\n\nHmmm, MyPy doesn't consider any of integers, or floats, or Decimals to be numbers :(.\n\nAfter reading through [typing](https://docs.python.org/3/library/typing.html) you guess you'll just `Union` in the Decimals:\n\n    def slow_add(\n        a: Union[complex, Decimal], b: Union[complex, Decimal]\n    ) -> Union[complex, Decimal]:\n        time.sleep(0.1)\n        return a + b\n\nOh no! MyPy is complaining that you can't add your other number types to Decimals, well that wasn't your intention anyway...\n\nMore reading later and you try overload:\n\n    @overload\n    def slow_add(a: Decimal, b: Decimal) -> Decimal:\n        ...\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\n    def slow_add(a, b):\n        time.sleep(0.1)\n        return a + b\n\nBut MyPy on strict is complaining that `slow_add` is missing a type annotation, after reading [this issue](https://github.com/python/mypy/issues/3360) you realize that `@overload` is only useful for users of your function but the body of your function will not be tested using `@overload`. Fortunately in the discussion on that issue there is an alternative example of how to implement:\n\n\n    T = TypeVar(\"T\", Decimal, complex)\n\n    def slow_add(a: T, b: T) -> T:\n        time.sleep(0.1)\n        return a + b\n\n# Fourth attempt at type hinting\n\nYou make a new release, and a few days later more users start complaining. A very passionate user explains the super critical use case of adding tuples, e.g. `slow_add((1, ), (2, ))`\n\nYou don't want to start adding each type one by one, there must be a better way! You learn about Protocols, and Type Variables, and positional only parameters, *phew*, this is a lot but this should be perfect now:\n\n\n    T = TypeVar(\"T\")\n\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    def slow_add(a: Addable, b: Addable) -> Addable:\n        time.sleep(0.1)\n        return a + b\n\n\n# A mild diversion\n\nYou make a new release noting \"now supports any addable type\".\n\nImmediately the tuple user complains again and says type hints don't work for longer Tuples: `slow_add((1, 2), (3, 4))`. That's weird because you tested multiple lengths of Tuples and MyPy was happy.\n\nAfter debugging the users environment, via a series of \"back and forth\"s over GitHub issues, you discover that pyright is throwing this as an error but MyPy is not (even in strict mode). You **assume** MyPy is correct and move on in bliss ignoring there is actually a fundamental mistake in your approach so far.\n\n(**Author Side Note** - It's not clear [if MyPy is wrong](https://github.com/python/mypy/issues/14679) but it defiantly makes sense for Pyright to throw an error here, I've filed issues against both projects and a pyright maintainer has [explained the gory details](https://github.com/microsoft/pyright/issues/4613/) if you're interested. Unfortunately this was not really addressed in this story until the \"Seventh attempt\")\n\n\n# Fifth attempt at type hinting\n\nA week later a user files an issue, the most recent release said that \"now supports any addable type\" but they have a bunch of classes that can *only* be implemented using `__radd__` and the new release throws typing errors.\n\nYou try a few approaches and find this seems to best solve it:\n\n    T = TypeVar(\"T\")\n\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: T, other: Any, /) -> T:\n            ...\n\n    @overload\n    def slow_add(a: Addable, b: Addable) -> Addable:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> RAddable:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\nAnnoyingly there is now no consistent way for MyPy to do anything with the body of the function. Also you weren't able to fully express that when b is \"RAddable\" that \"a\" should not be the same type because Python type annotations don't yet support being able to exclude types.\n\n# Sixth attempt at type hinting\n\nA couple of days later a new user complains they are getting type hint errors when trying to raise the output to a power, e.g. `pow(slow_add(1, 1), slow_add(1, 1))`. Actually this one isn't too bad, you quick realize the problem is your annotating Protocols, but really you need to be annotating Type Variables, easy fix:\n\n    T = TypeVar(\"T\")\n\n    class Addable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    A = TypeVar(\"A\", bound=Addable)\n\n    class RAddable(Protocol):\n        def __radd__(self: T, other: Any, /) -> T:\n            ...\n\n    R = TypeVar(\"R\", bound=RAddable)\n\n    @overload\n    def slow_add(a: A, b: A) -> A:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: R) -> R:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\n\n# Seventh attempt at type hinting\n\nTuple user returns! He says MyPy in strict mode is now complaining with the expression `slow_add((1,), (2,)) == (1, 2)` giving the error:\n\n> Non-overlapping equality check (left operand type: \"Tuple[int]\", right operand type: \"Tuple[int, int]\")\n\nYou realize you can't actually guarantee anything about the return type from some arbitrary `__add__` or `__radd__`, so you starting throwing `Any` Liberally around:\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\n\n# Eighth attempt at type hinting\n\nUsers go crazy! The nice autosuggestions their IDE provided them in the previous release have all gone! Well you can't type hint the world, but I guess you could include type hints for the built-in types and *maybe* some Standard Library types like Decimal:\n\nYou think you can rely on some of that MyPy duck typing but you test:\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\nAnd realize that MyPy throws an error on something like `slow_add(1, 1.0).as_integer_ratio()`. So much for that nice duck typing article on MyPy you read earlier.\n\nSo you end up implementing:\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    @overload\n    def slow_add(a: int, b: int) -> int:\n        ...\n\n    @overload\n    def slow_add(a: float, b: float) -> float:\n        ...\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\n    @overload\n    def slow_add(a: str, b: str) -> str:\n        ...\n\n    @overload\n    def slow_add(a: tuple[Any, ...], b: tuple[Any, ...]) -> tuple[Any, ...]:\n        ...\n\n    @overload\n    def slow_add(a: list[Any], b: list[Any]) -> list[Any]:\n        ...\n\n    @overload\n    def slow_add(a: Decimal, b: Decimal) -> Decimal:\n        ...\n\n    @overload\n    def slow_add(a: Fraction, b: Fraction) -> Fraction:\n        ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\nAs discussed earlier MyPy doesn't use the signature of any of the overloads and compares them to the body of the function, so all these type hints have to manually validated as accurate by you.\n\n# Ninth attempt at type hinting\n\nA few months later a user says they are using an embedded version of Python and it hasn't implemented the Decimal module, they don't understand why your package is even importing it given it doesn't use it. So finally your code looks like:\n\n    from __future__ import annotations\n\n    import time\n    from typing import TYPE_CHECKING, Any, Protocol, TypeVar, overload\n\n    if TYPE_CHECKING:\n        from decimal import Decimal\n        from fractions import Fraction\n\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    @overload\n    def slow_add(a: int, b: int) -> int:\n        ...\n\n    @overload\n    def slow_add(a: float, b: float) -> float:\n        ...\n\n    @overload\n    def slow_add(a: complex, b: complex) -> complex:\n        ...\n\n    @overload\n    def slow_add(a: str, b: str) -> str:\n        ...\n\n    @overload\n    def slow_add(a: tuple[Any, ...], b: tuple[Any, ...]) -> tuple[Any, ...]:\n        ...\n\n    @overload\n    def slow_add(a: list[Any], b: list[Any]) -> list[Any]:\n        ...\n\n    @overload\n    def slow_add(a: Decimal, b: Decimal) -> Decimal:\n        ...\n\n    @overload\n    def slow_add(a: Fraction, b: Fraction) -> Fraction:\n        ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b\n\n\n# TL;DR\n\nTurning even the simplest function that relied on Duck Typing into a Type Hinted function that is useful can be painfully difficult.\n\nPlease always put on your empathetic hat first when asking someone to update their code to how you think it should work.\n\nIn writing up this post I learnt a lot about type hinting, please try and find edge cases where my type hints are wrong or could be improved, it's a good exercise.\n\n**Edit:** Had to fix a broken link.\n\n**Edit 2:** It was late last night and I gave up on fixing everything, some smart people nicely spotted the errors!\n\nI have a \"tenth attempt\" to address these error. But pyright complains about it because my overloads overlap, however I don't think there's a way to express what I want in Python annotations without overlap. Also Mypy complains about some of the user code I posted earlier giving the error [comparison-overlap](https://mypy.readthedocs.io/en/stable/error_code_list2.html#check-that-comparisons-are-overlapping-comparison-overlap), interestingly though pyright seems to be able to detect here that the types don't overlap in the user code.\n\nI'm going to file issues on pyright and mypy, but fundamentally they might be design choices rather than strictly bugs and therefore a limit on the current state of Python Type Hinting:\n\n    T = TypeVar(\"T\")\n\n    class SameAddable(Protocol):\n        def __add__(self: T, other: T, /) -> T:\n            ...\n\n    class Addable(Protocol):\n        def __add__(self: \"Addable\", other: Any, /) -> Any:\n            ...\n\n    class SameRAddable(Protocol):\n        def __radd__(self: T, other: Any, /) -> T:\n            ...\n\n    class RAddable(Protocol):\n        def __radd__(self: \"RAddable\", other: Any, /) -> Any:\n            ...\n\n    SA = TypeVar(\"SA\", bound=SameAddable)\n    RA = TypeVar(\"RA\", bound=SameRAddable)\n\n\n    @overload\n    def slow_add(a: SA, b: SA) -> SA:\n        ...\n\n    @overload\n    def slow_add(a: Addable, b: Any) -> Any:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RA) -> RA:\n        ...\n\n    @overload\n    def slow_add(a: Any, b: RAddable) -> Any:\n        ...\n\n    def slow_add(a: Any, b: Any) -> Any:\n        time.sleep(0.1)\n        return a + b", "id": "10zdidm", "title": "Why Type Hinting Sucks!", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "Ummm ... if a function returns a collection of rows matching a criteria, and finds none that match, should it not return an empty collection?\n\n\n\nYes, in the case of a collection returned, the empty collection seem to be the best choice when nothing has been found, but what to do if you ask for a unique value, and no value found is a normal case that you prefer to handle without exception catching, like with a *get_me_user_if_exists(id)* function? Then None seem to be the correct return value, but its meaning overlaps with other None result.\n\nReturning a *no_user* singleton would make it not so obvious to handle, especially in a \"if not user:\" context, or would you use  **__non_zero__** black magic?\n\nEdit, sorry for the boldface, not very used to reddit markup and didn't find a <tt> equivalent.\n\n[deleted]\n\nYour problem seems to be that you're overloading `None`. You want it to mean \"a value of `None` was put into the cache\", but you *also* want it to mean \"no value exists in the cache corresponding to what you asked for\". So the first thing you need to decide is what you want a value of `None` from the cache to mean; then you can see if you need to change what you're putting into it or change the way you handle that value when it comes from the cache.\n\n(also, don't be afraid of exceptions! Raising some sort of \"you asked for something I can't give you\" exception is *not* a bad thing)\n\nYour function name is wrong, it should just be *get_me_user()* and return an *exception* if the user does not exist.\n\n    try:\n        user = get_me_user(id)\n    except:\n        pass # Whatever you do if the user does not exist.\n\nPython has a very efficient way of dealing with exceptions, no stack trace overhead like most other languages. In Python, exceptions are usually the way to go.\n\nBackticks are the <tt> equivalent: \\`\\_\\_nonzero\\_\\_\\` produces `__nonzero__`.\n\n\nErm ... what was getting at is if you say to the database \"give me back a list of all the guys named Steve\", then if there isn't anyone called Steve, it should give you back an empty list, not an unexpected thing like None or False or 0.\n\nOf course, there are some situations, like looking up a user by a user_id which is a primary key, where you might want the function to return just a single user rather than a list of users with length 1.  But it might be appropriate in those circumstances to throw an exception because you that magic primary key you got from *somewhere* turned out to be *wrong*.\n\n\n... There, I said it, Django gets something right :-)\n\n\n\nAlternatively, if the function is returning an arbitrary number of collections (including zero) with arbitrary results (including `None`), it could be implemented as a generator. This allows the code to use Pythonic constructs like\n\n    for result in function(arguments):\n         operate(result)\n    else:\n         no_results_found_handler()\n\nAnd most importantly, because generators hold state, it might be possible to handle cache/memoization implicitly (depending on whether OP's use case allows it), rather than having an explicit variable holding it.\n\nI'm sure you just left it out for tge eake of brevity, but I feel it is important to mention: always catch a specific exception.  Eg:\n\n    try:\n        user = get_user(user_id)\n    except KeyError:     # or whatever\n        do_something()\n\nBecause consider what happens here:\n\n    try:\n        user = get_uesr(user_id)\n    except:\n         do_something()\n\nHint: did you miss a NameError?\n\nI think in this context raising an exception is the correct thing to do if (and only if) finding no user is a special case or an abnormal result. If it is expected and normal, for instance if this user id is coming from some user input, then returning something that has the meaning of \"no user\" seem better.\n\nIn fact it comes to collapsing two functions, user_exists() and get_user(), into a single get_user() that tells you nicely that if the result is not a user, then, well, there is no user at this number.\n\nThe code becomes as simple as it can be:\n\n    u = get_user(123)\n    if not u:\n        return 'oh no!, no user'\n    # do something with this user\n    return 'you got it'\n\nRaising an exception in this context and having to catch specifically an exception seem to be hindering a bit the readability and simplicity.\n\nwrong use of for/else\n\n    >>> for a in [1]:\n    ...     print a\n    ... else:\n    ...     print 2 \n    1\n    2\n", "id": "c59kez3", "owner_tier": 0.5, "score": 0.8428571427142857}, {"content": "One trick is that you can create cheap singletons via...\n\n    NO_RESULT = object()\n\nAnd then import that singleton everywhere, and use it as the special cache return value. If needed you can even use a class type which evaluates to False. \n\nThe one thing is that you have to use this very sparingly, as you can easily get tangled up in a mess of special singletons, not knowing which ones you can return where, and under what conditions. When I use something like that, I try to get it out of the way as fast as possible, minimizing the number of functions in a chain which might return weird values. \n\nThe other option is to change the cache return value to be a tuple `(True,value)` or `(False,None)` so you can distinguish the cases... though I've found this is slightly more annoying to use, but it does save the need to always import NO_RESULT from whereever it was defined.\n\n[deleted]\n\nI like to use this trick for default arguments, when you want to distinguish between None and no argument being given.\n\nThe other option for return values, of course, is to raise a KeyError.\n\nYes, that's a possibility.\n\nBut it would mean that client code should always check a returned value against such a singleton, so it would need to import explicitely the caching module, and this would add quite some lines in the code base.\n\nExceptions are for exceptional conditions only IMO, depending on context, \"NO_RESULT\" may not be \"exceptional\"\n\nAs pointed out later a cache miss is a much more valid \"exceptional\" behaviour than a no result (again I suppose that depends on context).\n\nI don't think this is accurate. Look at [iterators](http://docs.python.org/py3k/library/stdtypes.html#iterator-types). When you call \\_\\_next\\_\\_() on an iterator with no items remaining, it raises a StopIteration exception.\n\nWhat if, for whatever reason, you want to be able to cache the value NO_RESULT? Then you have the same problem you had before. Exceptions are the only way to completely avoid this.\n\nIf you try to read a value from a cache given its key, and that key does not exist in the cache, that sounds like an exceptional case to me-- the function reaches a state in which it can not possibly provide coherent output for its input.\n\nYou seem to have other languages' ideas of exceptions deeply ingrained in the way you're thinking. Which, when applied to Python, may not be a good thing -- there are languages where you bend over backwards and do everything you can imagine, including over-complicating your code, in order to avoid using an exception, but Python *isn't one of those languages*.\n\nIn Python, it's OK to use exceptions to signal something other than \"program is crashing now\". In Python, exceptions *are* used, frequently, to do precisely that sort of signalling. This is not a bad thing, just a *different* thing from what you're probably used to.\n\nMaybe infinull comes from the Java or C++ world where, commonly, exception handling was implemented very poorly and/or poorly understood, leading to a desire to avoid its use. \n\nAnd that kind of rubs me the wrong way, but I understand why that design decision was made., I dunno Exceptions & sentinels are both kind of terrible in their own way.\n\nExceptions stop execution if they aren't handled, then again, a sentinel could cause some sort of `TypeError` and the point would be moot.\n\nFor something like a query, returning an empty collection on no result, feels like \"the right thing\" a cache miss, is pretty exceptional, and I can dig that.\n\nStop iteration is a pretty unusual case, there's basically no way to determine whether what it returns is exceptional, unless you use the tuple return method, and that's clearly bad, so I can dig exceptions there.\n\nCache miss has similar properties. A Query doesn't have these properties IMO, but there are clearly some judgement calls here.\n\nI dunno on the one hand, I have a hard time calling sentinels unequivocally bad, they seem to have a lot of the same bad properties that exceptions have, on the other, I can't think of a valid use of sentinels in an interface (w/i a function fine, but not as return values/arguments).\n\nI think you missed my ninja edit, but that's OK.", "id": "c59kamz", "owner_tier": 0.5, "score": 0.9999999998571429}, {"content": "Perhaps it would be more useful for the caching function to return a tuple or an object, and pass the status along with the value, so you can check if the item was found or not. Of course, this assumes that you wrote the caching function, which might not be the case. That's just my initial thought. Something along the lines of:\n\n    status, obj = cache.get('my item')\n\nAlso, instead of your functions returning None, you could write them to return an empty instance of whichever data type it's using. So {} for dict, [] for list, etc.\n\nHaving a return code sounds like like a very C-ish solution. Surely, raising `KeyError` (or another exception provided by the caching module) upon a cache miss would be more Pythonic?\n\nwhile i've read on python.org that raising errors are Pythonic, I never understood why.  i only raise errors when there's been a problem.  in this case there's no problem; it's just a special case.  can you explain why you would use error handling to deal with this case?\n\nI'm surprised no one has suggested this yet. Raising KeyError (or a new exception such as CacheError) seems like a good way to do it, but then you have to wrap all the function calls in try except statements, which (depending on the size of the codebase) could be a ballache.\n\nThe use of exceptions for \"special cases\" rather than \"problems\" is mirrored in the standard library, for instance the use of `StopIteration` in iterators. It's more of a \"problem\" if `StopIteration` **isn't** raised, yet `StopIteration` is used to indicate the special case that the iterator is done.\n\nI usually think of a Python exception not as meaning \"something is broken\", but rather meaning \"I'm doing something different to what you expected me to do for some reason\" (or more specifically, in some cases including this one, \"I can't give you a meaningful return value\").\n\nIn this case, `cache.get()` is expected to get something from the cache; it raises `KeyError` or some other exception (say `CacheMissException`) to tell the calling code that it couldn't do that because of the special case that the key isn't in the cache. In the iterator example, `iterator.next()` is expected to return the next item to iterate over; `StopIteration` indicates the special case that the iteration is done.\n\nOne could probably argue that the words \"exception\" and \"special case\" are close to synonymous.\n\nI think that's the difference between \"special case\" and \"something is brokenn\" is the difference between exceptions called `SomethingException` and `SomethingError` in the standard library, although I haven't studied the names of the stdlib exceptions in depth.\n\nAlso of note: Pythonicness of using exceptions here aside, the alternative - error codes - would probably be considered un-Pythonic. (Or, at least, I think so.)\n\nIt's always going to be a PITA changing the behaviour of the cache in any way (return values or exceptions); I just think raising an exception is the better way to do it.\n\nPlus, if you forget something, \"unhandled KeyError on line x: cache.get(foo)\" is going to be a hell of a lot easier to debug than \"SomeRandomError on line some-unrelated-line: can't contatenate str with tuple\"\n\nWell every time this is called you'd need to be checking its return value anyway, so it isn't *more* code, just different code. It sounds like since new behaviour is being added, changes will be needed to the codebase no matter what.\n\nI think the idea of \"I can't give you a meaningful return value\" sums up exceptions perfectly.\n\nThat makes sense especially with the differentiation between SomethingException and SomethingError.  I always had in my mind that the they were synonymous, but they don't need to be used that way.\n\nthanks!\n\nAnytime. As I said, though, I haven't really looked at them in depth so I could be wrong and it could be completely arbitrary.", "id": "c59kff2", "owner_tier": 0.3, "score": 0.2428571427142857}, {"content": "I'm not clear why you don't write a class and/or function which encapsulates all the involved steps.\n\n    def query_db(arg):\n        cached = existing_cache_system.get_cached_query(arg)\n        if cached is not None:\n            return cached\n        # run query manually\n        # cache query if appropriate\n        # return result\n\nAny reason something like this wouldn't work?\n\nIf the result of existing_cache_system.get_cached_query() is None (for whatever reason), you would end up running existing_cache_system.get_cached_query() every time you used that value.\n\nMore pythonic, have the cache raise an exception if nothing was found, no *None* needed.\n\n    def query_db(arg):\n        try:\n            cached = existing_cache_system.get_cached_query(arg)\n            return cached\n        except:\n            # run query manually\n            # cache query if appropriate\n            # return result\n\n\nOP wants to cache None in some cases... if None is the empty cache value, then one cannot cache it.", "id": "c59krvd", "owner_tier": 0.1, "score": 0.07142857128571428}, {"content": "Return a tuple rather than \"Sometimes status, some times cached value\". Silly non-object oriented example:\n\n    import time\n    _cache = {}\n\n    def cached(key):\n        if key in _cache:\n            return _cache[key]\n        return (None, None)\n    \n    def expire(key):\n       del _cache[key]\n    \n    def cache(key, value):\n        _cache[key] = (value, time.time())\n    \n    \n    def example():\n        cache(\"fred\", 1337)\n        (v,t) = cached(\"fred\")\n        if not t: # assumes cache can't be populated on 1970-01-01 00:00:00.000Z !\n            print \"It was not cached\"\n        else:\n            print \"Value \", v, \" cached at \", t\n        (v,_) = cached(\"bob\")\n        if not v:\n            print \"Not here in any form\"\n\n\n\nThat way, users who care about the None-ness vs. not-cached-ness can inspect the time. If you don't care, just use the first value of the tuple, v.  You can customize this to do expiry, etc.", "id": "c59o1tk", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "That's broken.  Can you change what you send into the cache?  That is, always, always, always make a tuple on sending the value into the cache, and unpack it?\n\n(None,)\n\nNone\n\n    def cache(function, *args, **kwargs):\n        cached_value = get_cache(function, args, kwargs)\n        if cached_value is None:\n            return_value = function(*args, **kwargs)\n            set_cache( (return_value,) , function, args, kwargs)\n        else:\n            (return_value,) = cached_value\n        return return_value\n", "id": "c59opoh", "owner_tier": 0.7, "score": 0.028571428428571428}, {"content": "My instinct here is to say the cache code is badly written: it doesn't seem pythonic to represent failure with a return code, if that's how you get your data out. Instead of returning None if the cache is empty, you should throw an exception.  Over the lifetime of the program, if it needs caching, misses are going to be the exceptional event.  That way, there's no value at all your cache can't handle.", "id": "c59osxg", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "ubernostrum suggested exceptions which was my first idea, but I have another one: return a tuple of two-items, one being the actual value and the second a boolean representing whether that value was cached or not.\n\nthen `(None, False)` would mean \"cache is empty\" and `(None, True)` would mean \"the value None is cached\"", "id": "c59xkif", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "Your cache should just raise KeyError when there is nothing, as None and [] are valid values that can be cached.", "id": "c59xwrb", "owner_tier": 0.7, "score": 0.014285714142857142}, {"content": "If you are wondering, this sort of problem is called the semipredicate problem\n\nhttp://en.wikipedia.org/wiki/Semipredicate_problem", "id": "c59zt0k", "owner_tier": 0.3, "score": 0.014285714142857142}, {"content": "If your cache is usually not empty (or if you're not worried about speed), you could raise an exception when the cache is empty, leaving you free to return None where there are no results.", "id": "c5arwat", "owner_tier": 0.5, "score": 0.014285714142857142}, {"content": "can use Ellipsis object as sentinel\n\nSounds like an odd use - if anything its interpretation is \"More\", not \"None\"!", "id": "c59lvxh", "owner_tier": 0.7, "score": 0.014285714142857142}, {"content": "That's why you can also do `if foo is None`.", "id": "c59mqh2", "owner_tier": 0.3, "score": -1.4285714285714285e-10}], "link": "https://www.reddit.com/r/Python/comments/w23rn/none_false_0_or_as_returned_values/", "question": {"content": "I noticed in our project many issues arise from a gray blurry zone over null values, especially when returned from function or method that are cahed or memoized.\n\nA concrete issue: our caching cannot cache \"None\", because it returns \"None\" when cache is empty. So when we cache a function querying the database, if the result of the select is empty, we need to return \"0\", \"[]\", \"False\" or any other \"no result found\" value, but we can't use the most obvious one, which is \"None\" and is used to mean this exact \"no result found\" value in many other similar contexts.\n\nDid you meet this kind of issues? How did you solve them?", "id": "w23rn", "title": "None, False, 0 or []  as returned values", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "You would often see this used like this: \n\n    names = ['James', 'David', 'Terence', 'Steve', \n        'Pam', 'Pat', 'Stewart', 'Frederick']\n    names_with_a = sum( 'a' in n for n in names)\n\nAlso, newline escapes are ugly and you usually don't need them.\n\nI would argue that `['a' in n for n in names].count(True)` is a much more efficient and Pythonic solution.\n\nThanks, I actually don't use newline escapes in lists like this normally, but I do use them all the damned time (import statements, long strings outside of docstrings, with a good example of that being in assert statement error strings, actually luckily that's it), to maintain a width of 78 characters in my code. What do you recommend for long code lines? As a result of that response I checked the two most recent modules I've worked on and I only found one exception, where I was making a tuple without using parentheses, which I thereafter edited to include the parentheses, which I do like better, so, thanks for that. :)\n\nIt's been a long time since I've used comprehensions due to readability, how common are they in professional settings?\n\nIt's really not though. `sum()` over a generator is going to be far better here, especially if your list of strings is large.\n\nHow is that more efficient? You are making a list (memory cost) and then iterating over it (CPU cost) for no reason. \n\nPythonic is subjective. I'd argue my code could be just as pythonic by adding a few comments.\n\n> What do you recommend for long code lines?\n\nOption 1: use variables. They double as comments. \n\nOption 2: use brackets, like parenthesis. In most cases, like your example, you already have them there. \n\nOption 3: just go over. PEP8 is not a law. You can choose to disagree with it. \n\n> It's been a long time since I've used comprehensions due to readability, how common are they in professional settings?\n\nExtremely common, but technically this is a generator, not a comprehension.\n\nBTW a triple quoted string is not the same as a docstring. \n    \n    def func():\n        \"any string in this position is a docstring\"\n        print(\"\"\"the only thing special about a triple quote string\n            is that newlines are included\"\"\")\n        print(\"but it's usually better \"\n            \"to simply concat normal strings like this\")\n\n`count` is definitely faster than `sum` and is much more explicit about the process being carried out.\n\n    names = ['James', 'David', 'Terence', 'Steve', 'Pam', 'Pat', 'Stewart', 'Frederick'] * 100\n    print(timeit(\"sum('a' in n for n in names)\", globals=globals(), number=10))\n    print(timeit(\"['a' in n for n in names].count(True)\", globals=globals(), number=10))\n\n`sum`: `0.06602010000005976`  \n`count`: `0.05176459999995586`\n\n> Best: use variables. They double as comments. \n\nDeclarative variables are great, and yeah I'm using a CLI for my program so I have \"prompt\" as a lot of my string variables, but even so, sometimes the 78 limit doesn't fit, especially when I'm using f strings and/or (logical or?) it's deeply nested. :)\n\nThanks for the response on the comprehension/generator thing.\n\nI think the main problem with using the triple quotes like that is the whitespace on the left, correct? But yeah, by concatenating the strings that seems pretty solid, though it only works inside parenthesis. If instead of a print function you were assigning that string to a variable, would you wrap in in a str() function, or use the continuation symbol (\\).\n\nWow that's significant. I never knew count was that much faster than sum. Thanks.", "id": "h03mhqp", "owner_tier": 0.7, "score": 0.9999999995238095}, {"content": "I think this is what I'm using:\n\n    sum(1 for i in <container> if <condition>)", "id": "h055fte", "owner_tier": 0.9, "score": 0.14285714238095237}, {"content": "I\u2019d be hesitant in using tricks. If you can\u2019t understand it by skimming, you shouldn\u2019t use it imo.\n\nDamn, I honestly do this (bool to int math) a lot. :(", "id": "h04vecm", "owner_tier": 0.3, "score": 0.14285714238095237}, {"content": "That said, True is not 1 and False is not 0.  They fixed that in Python 3 and thank goodness.\n\nHmm, is it an object with an `__add__` method or something?\n\nIn python, everything is an object including integers, floats, and strings.  Simply checking equality doesn't check if they're the same.\n\n       1.0 == 1\n       True\n       1.0 == True\n       True\n       1 == True\n       True\n       # they're not the same object though\n       1.0 is 1\n       False\n       1.0 is True\n   False\n   1 is True\n   False", "id": "h05kqkk", "owner_tier": 0.7, "score": 0.19047619}, {"content": "What? I get it's a loop that counts the number of a in the items of a list and adds it to a variable but i don't get the title or what makes this particularly noteworthy.\n\nI understand the syntax but it seems i am missing the bigger picture, last time i used python was many months ago.", "id": "h05j2ro", "owner_tier": 0.9, "score": 0.04761904714285714}, {"content": "Wait, this has blown my mind. Does the 'in' cancel out the need for an if statement here? As a newcomer I would typically use the same syntax but:\n\n    for n in names:\n        if 'a' in n[0]:\n            names_with_a += n\n\nI also find this to be much more readable code. Not sure if I am just completely overlooking this or not lol\n\n&#x200B;\n\nEDIT: Typo\\*\\*\n\nI hope I'm correct here.\n\nin is an operator, and like a logical operator, it returns true or false, which can be numerically interpreted as 1 or 0.\n\nn[0] is just the first element of n. I should have written `'a' in n.lower()` instead, though, just in case the name was all caps or a was the first letter, etc.\n\nedit: I called in a logical operator, that's not correct.\n\nLOL Absolute Facepalm. \n\nI just realised what this code is even doing and my comment is absolutely rendered null and void at this stage. I retract all statements.\n\nIts been a long day\n\nSorry my code was incorrect and it should\u2019ve been if \u2018a\u2019 in n[0] == True: \n\nThat\u2019s my bad it\u2019s been a long long day\n\nAlso, usually in best practice it\u2019s best to convert your strings into lower or upper case, usually lower, when using them but for readability you should do this outside of a conditional statement so you have one singular instance of the lower case variable. If you\u2019re only using and converting it once it\u2019s okay but for multiple use-cases you should definitely always declare new_variable = old_variable.lower()", "id": "h04wlyj", "owner_tier": 0.3, "score": -4.761904761904762e-10}], "link": "https://www.reddit.com/r/learnpython/comments/np7vpl/psa_true_1_false_0_you_can_use_it_in_addition/", "question": {"content": "I assume some other languages have this but I never used it until I learned some python and it's amazing. Some example code (edited (in reddit) to cut the list width):\n\n    names = ['James', 'David', 'Terence', 'Steve', \n        'Pam', 'Pat', 'Stewart', 'Frederick']\n    names_with_a = 0\n    for n in names:\n        names_with_a += 'a' in n\n\nEdit to remove that `\\` for good reason.\n\nEdit part deux: Just want to say this thread has just a ton of awesome stuff in it, thanks very much everyone!", "id": "np7vpl", "title": "PSA True == 1, False == 0, you can use it in addition", "traffic_rate": 153.13018518518518}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "You'll likely need to format your code properly.\n\n`str(score)'/10'` is invalid though. Did you mean `str(score) + '/10'`?", "id": "hjywj08", "owner_tier": 0.9, "score": 0.9999999966666667}, {"content": "1. Format your code by indenting it with 4 spaces.\n\n2. You likely need a + sign between `str(score)` and the string that follows.\n\nEdit: here's how [friendly](https://friendly-traceback.github.io/docs/index.html) might be able to help you:\n\n\n     print(str(10)'/10')\n\n      Code block [4], line 1\n        print(str(10)'/10')\n                 ^\n    SyntaxError: invalid syntax\n\n        Did you forget something between `)` and `'/10'`?\n\n\n    [5]: why()\n\n    Python indicates that the error is caused by `'/10'` written immediately after `)`.\n    It is possible that you forgot a comma between items in a tuple,\n    or between function arguments,\n    before the position indicated by ^.\n    Perhaps you meant to insert an operator like `+, -, *`\n    between `)` and `'/10'`.\n    The following lines of code would not cause any `SyntaxError`:\n\n        print(str(10), '/10')\n        print(str(10) + '/10')\n        print(str(10) - '/10')\n        print(str(10) * '/10')\n    Note: these are just some of the possible choices and that\n    some of them might raise other types of exceptions.", "id": "hjywid7", "owner_tier": 0.5, "score": 0.33333333000000004}, {"content": "This is the problem:\n\n    str(score)'/10'\n\nIn a nutshell you need to add a `+`\n\n    str(score) + '/10'\n\nor, preferably, you'll want to use string formatting instead, like an f-string:\n\n    f'{score}/10'\n\nYou *can* add string literals next to each other as Python joins them automatically, but `str(score)` is not a literal.\n\n    print(\n        \"This will be printed, \"\n        \"and this comes right after on the same line.\"\n    )", "id": "hk1xrhd", "owner_tier": 0.7, "score": -3.3333333130750966e-09}], "link": "https://www.reddit.com/r/learnpython/comments/qqagza/syntax_error_but_it_seems_fine_yea_i_know_the/", "question": {"content": "Here is my code:\n        if score < 1:\n\t        print(str(score)'/10')\n\t        print('---')\n\t        print('You could improve!')\n\t        print(' ')\n\t        option = input('[1]- Submit score [2]- Exit')\n\nI dont get what\u2019s wrong with it? It says syntax error by line 2/the print score part. Any help?", "id": "qqagza", "title": "Syntax error but it seems fine! (Yea I know the answer is probably gonna be obvious af lol)", "traffic_rate": 153.17203703703703}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "> I thought s += b is the same as s = s + b, no?\n\nDepends on what `s` is. \n\nFor lists, no. `+` will add and return a new object, while `+=` will extend (mutate) the existing object.\n\nFor integers (and most immutable types) yes, it is exactly the same thing.\n\nbut apparently, += changes the type of string to array. Why doesn't \"+\" behave the same way?\n\nThis is interesting . Need to email Guido\n\nAgain, it depends on what `s` is and what the programmer that wrote the code for that type made it do. For lists, it will loop over `b` and adds each element to the existing list. For lists, \n\n    s += b \n\nis equivalent to \n\n    s.extend(b)\n\nOr\n\n    for item in b:\n        s.append(item)\n\nThat's why `b` can be any iterable, including strings.\n\n---\n\n> Why doesn't \"+\" behave the same way?\n\nIn short, because the person who invented python wanted it that way. I don't see the logic in it either.\n\nIn python, everything is overloadable. When you do `a + b`, you're actually calling `a.__add__(b)` or `b.__radd__(a)` (depending on how they're defined).\n\n`+=` uses the method `__iadd__`, which, again, any class can implement how they want. So `a += b` becomes `a.__iadd__(b)`, which may or may not be equivalent to `a = a + b` (i.e. `a = a.__add__(b)`).\n\nThis page has all the details: https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types\n\n> but apparently, += changes the type of string to array.\n\nto a list, strictly speaking.\n\n> Why doesn't \"+\" behave the same way?\n\nBecause '+' for sequence types represents concatenation, so forming a new sequence from the two operands (s and b). That isn't possible because the types are different.\n\n+= however means 'extend', so keep the left operand as-is, add the items from the right operand. That's possible because the b-string is iterable. \n\nI know, it's one perspective that can be argued and I would agree there's something to be said to keep + consistent in both cases (either they both work or they both don't), but I wouldn't see much benefit from it over the current implementation. Sometimes perfect stands in the way of good enough.\n\n>s += b \n\n>is equivalent to \n\n>s.extend(b) \n\nYou sure coz I have been very consciously avoiding += and using extend coz I didn't want it to discard and create objects for teeny tiny insertion.\n\nYes.  We tend to forget, but the combined operators like \\`+=\\` were not part of the language originally, because Guido valued simplicity.  They were added later (in Python 2.x?), and the team who added them chose a path that allowed it to work with any iterable.  It was not worth the trouble to modify the basic addition operator.\n\nJust tested it. Seems like it. \na = [1,2]; b = a\n\nIf I use \"b = b +\"2\" \", a would still be [1,2] while b is [1,2,\"2\"]. \n\nBut if I use \"b +=\"2\" \", a would change along with b to [1,2,\"2\"]. (This has the same results as extend)\n\nFunctionally, += at least doesn't recreate a new array and assign it to the variable, but extends the current array object with the new elements.\n\nOh great. Thank you.", "id": "jw8orxz", "owner_tier": 0.7, "score": 0.9999999998039215}, {"content": "`s += b` means `s.__iadd__(b)`.*\n\n\n`s = s + b` means `s = s.__add__(b)` (assuming `s` supports `__add__`, which it does, but not for other types).\n\n\nIn this case `s` is a `list`, so `__iadd__` winds up extending `s` with each element of the iterable `b`. `extend` accepts any iterable to append all its items to the existing list, and a string is an iterable of characters.\n\n\n`__add__` is valid for concatenating two lists into a new list, but it is not for concatenating a list and a non-list iterable, so we get a `TypeError`.\n\n\nhttps://docs.python.org/3/reference/datamodel.html#object.__iadd__\n\n____\n\n\\* See minor correction below\n\nSmall correction: `s += b` is `s = s.__iadd__(b)`\n\nThis is the real answer.\n\nTrue, for those wondering what you're talking about, `__iadd__` returns `self` in this case, so the object gets mutated, then `s` gets assigned to refer to the same object it already referred to.", "id": "jw96dbj", "owner_tier": 0.5, "score": 0.19607843117647059}, {"content": "> I thought s += b is the same as s = s + b, no?\n\nNot always. If s is a list, it's actually the same as `.extend`. It depends on the type of s.", "id": "jw8zyjv", "owner_tier": 0.5, "score": 0.01960784294117647}, {"content": "    __iadd__ = <method-wrapper '__iadd__' of list object>\n    Implement self+=value.\n\nIn Python, `+=` implements an object's `__iadd__` method. This is an augmented assignment operator and acts on iterables. In Python, Strings are iterable.\n\nWhen the object is a list and is passed an iterable, the iterable is appended to the list (added in-place):\n\n    mylist = []\n    mylist += \"A\"\n    print(mylist)  # Prints ['A']\n\nThe same as:\n\n    mylist = []\nmylist.__iadd__(\"A\")\nprint(mylist)  # Prints ['A']\n\nWhen passed an iterable with more than one element, \\_\\_iadd\\_\\_ iterates through the elements and appends them to the list:\n\n    mylist = ['a', 'b', 'c']\n    another_list = [1, 2, 3]\n    mylist +=  another_list\n    print(mylist)  # Prints ['a', 'b', 'c', 1, 2, 3]\n\nNote that this does not work because numbers are not iterable:\n\n    a = []\n    b = 3\n    a += b\n    Traceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'int' object is not iterable\n\n\nIf you want to append a non-iterable, such as a number, to a list, you can do so like this:\n\n    my_list += (7,)\n\nNote the comma after the number literal which means that we have a tuple  with one element, and tuples are iterable.\n\nThere is also an equivalent `operator` function: [iadd](https://docs.python.org/3/library/operator.html#in-place-operators)\n\n(The link goes to the docs).\n\n\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\n\nAn expression like `x += 1` is roughly equivalent to `x = x + 1` but not exactly the same. \n\nWhen using the augmented assignment operator `+=`, then `x` is only evaluated once, and if `x` is a mutable object, the value `1` is assigned in place (appended) to `x`.\n\nWhen using x = x + 1, then x is evaluated twice (each time it occurs).", "id": "jw9dfy6", "owner_tier": 0.3, "score": -1.9607843018088803e-10}], "link": "https://www.reddit.com/r/learnpython/comments/15rhl4l/why_is_it_the_case/", "question": {"content": "s = \\[\\] b = \"abc\"  \nI can do s += b, which makes s to be \\['a', 'b', 'c'\\]  \nBut if I do s = s + b, it throws exception  \nI thought s += b is the same as s = s + b, no?  \n", "id": "15rhl4l", "title": "why is it the case?", "traffic_rate": 153.17203703703703}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "Hard pass on #4. If I see someone popping exceptions left and right as a signal of \"I didn't find what you asked for\" that code does not make it past code review.  A try/except is cheap (as long as the exception is rare) but code littered with these every time it tries to call another function is ugly and painful to refactor.\n\nA function with a return type of Optional[some_normal_return_type] is fine and the resulting code is usually cleaner and easier to read/understand.\n\n[deleted]\n\nAgree that it is certainly not an absolute rule, but the opposite is also not always best practice.\n\nThe most important thing is to have clearly defined semantics / a clear interface contract. In many cases, returning None is perfectly acceptable, while in other cases an error makes more sense.\n\nNote that in the standard library both approaches are also taken: `d[key]` gives an error if key cannot be found, while e.g. `d.get(key)` and `re.match` return None. In frequently used libraries both choices also exist, e.g. Django `model.objects.get` raises an `NotFoundError` if no objeect is found, while `requests.get` returns an object with a non-OK status code, and then have a `raise_for_status` method to raise an Exception anyway... In all these cases the opposite choice would also make perfect sense.\n\nAnd ironically, 5 is a direct violation of 4, as dict.get (without default) returns None when the key could not be found, while rule #4 claims that it should raise an exception instead :)\n\nI defer to returning None, which is semantically similar to returning null on a database query.\n\nOne thing I find odd about point #4 is that in general the rule (don't return more than one object type in function call) makes sense but the specific example is not the best illustration. I would look very askance at a function that could return either an `int` or a `str`.\n\nThat said, I have mixed feelings about Python's `Optional[Foo]` effectively meaning `Foo|None`. I program in multiple languages and and after experience true `Optional` objects such as in Haskell or Java8 I'm less of a fan of returning None to indicate failure/missing/whatever.\n\nCould you give an example for the second paragraph? Clarity on what you mean by  Optional[some_normal_return_type]?\n\nI came to say the same thing.\n\nI agree. Also I think in the example provided by the author it would be even better to return values of correct type but where I am certain this is not feasible output, e.g. returning None, -1 instead of just None, or None, NAN\n\nThis keeps not only the consistence of the output but also makes it easy to check if something went wrong.\n\nAnd using the base exception class, no less, to make sure that you can't just catch this exception without catching every possible exceptions...\n\nYep, it annoys the hell out of me that None is somehow a type all of its own. It's absolutely fine for a function to either return something or return None, I don't see that as returning different types.\n\nSuggesting that the function should raise an exception instead isn't helpful either. That means the caller needs to use a `try..except` block instead of just checking whether the function returned None. The latter is fewer lines and easier to read.\n\nI actually like exceptions everywhere.\n\nCould you make a post explaining what you think is too much exceptions with some examples or just dm me some stuff.\n\nI'm out here always trying to learn. What's wrong with duck typing", "id": "gjc3o6t", "owner_tier": 0.3, "score": 0.9999999999781182}, {"content": "These aren't even anti patterns, just like random syntatic sugar stuff for python.  stop posting crap like this\n\nHey, if you follow all these best practices you can take the runtime of a 20 second script down to 20 seconds\n\nBarely even that. Most of these have cases for them. It's just \"here's things I like more and don't know how to use\"\n\nB-but my micro-optimizations!\n\nLike that fact that number 7 is literally wrong, as the only way to create an empty set is by using `set()`. There's no empty literal for a set.\n\n\\#7 really bothered me because I've come from a different mindset, that the `list` and `dict` functions are like constructors, returning a new instance of the object, where using a literal reads as \"set the value equal to this specific object\". I have always recommended people use `list()` instead of `[]`\n\nHonestly, it doesn't matter. Useb whatever you want in your project, just be consistent.", "id": "gjclt1h", "owner_tier": 0.5, "score": 0.49015317284463894}, {"content": "**#7** There is no literal syntax for an empty set :(\n\n[deleted]\n\nYeah, 7 makes absolutely no sense\n\nYeah I noticed that too. I think the author meant to write tuple instead of set.\n\nI wish the syntax for an empty set was \n    \n    s = {}\n\nand for an empty dict\n\n    d = {:}\n\nI ran this on an old 2011 mbp, but the results surprised me:\n\n    $ python -m timeit '[]'\n    5000000 loops, best of 5: 44.2 nsec per loop\n\n    $ python -m timeit 'list()'\n    2000000 loops, best of 5: 126 nsec per loop\n\n    $ python -m timeit '{}'\n    5000000 loops, best of 5: 44.9 nsec per loop\n\n    $ python -m timeit 'dict()'\n    2000000 loops, best of 5: 166 nsec per loop\n\nhttps://images.app.goo.gl/vdCdv84G9pPGUrMC8\n\nThis is actually pretty good. Not as readable, but still good.\n\nWouldn\u2019t \n    s = {,}\nFor empty sets make more sense to not break existing code?\n\nMaybe we can push for it in py40 (or the macros PEP gets adopted and someone releases a package to change the syntax)\n\nThe use of {} for empty set makes more sense in terms of classical representations of it, and it should have been the empty set literal from the start.  I personally agree that {:} would make more sense as an empty dict literal with that history considered, but {,} as the empty set literal is probably the best solution for backwards compatibility.  \n\n\nAlternatively we introduce \u00d8 as the empty set icon and request that all python developers get a Norwegian keyboard or get REALLY good with their alt-codes.\n\nit would break way too much existing code.", "id": "gjcn4iq", "owner_tier": 0.5, "score": 0.24945295402625822}, {"content": "    comma_seperated_numbers = ','.join(name for name in my_fav_superheroes)\n\nHow is that good practice? It's totally equivalent to\n\n    comma_seperated_numbers = ','.join(my_fav_superheroes)\n\nassuming that `my_fav_superheroes` is an iterable &mdash; as it must be, for the first form to work.\n\nProbably meant to do something more like this instead:\n\n`comma_seperated_numbers = ','.join(superhero.name for superhero in my_fav_superheroes)`\n\n[deleted]\n\nYeah. that would make more sense.\n\nA generator is an iterable too.\n\nThat's right, thanks for correcting me. I thought it was reverse.", "id": "gjcfjvr", "owner_tier": 0.3, "score": 0.12472647700218818}, {"content": "\\#7 looks like a premature optimization.\n\nI would say that using literals for initializing empty collections because it's more performant is unnecessary. Do it because it's the more standard style. On the other hand, I'd really enjoy seeing this empty set literal the author mentioned.\n\nIt's premature micro-optimization. Which in 99% cases (anywhere other than loop doing little else and run a massive number of times) savings will be insignificantly miniscule.\n\nIt's also just clearer and more consistent (works like set, like all the other thing that doesn't have special literal syntax) to use full names int() list()  set() dict(), etc.\n\nHow about the empty immutable tuple. Very useful when you need nothing but a tuple.\n\nIt looks like there isn't\n\nbut you can do this \\^^ :\n\n    In [1]: s = {0}-{0}\n    \n    In [2]: type(s)\n    Out[2]: set\n\nhttps://stackoverflow.com/questions/6130374/empty-set-literal\n\n[deleted]\n\nSnazzy for default arguments.\n\n    def f(items=()):\n        s = set(items)\n\nFinally, some common sense. Myself, I prefer `{*()}`.\n\nI know less about python than I already knew I didn't know.\n\nIs this a true Singleton or just an optimization in the reference implementation like small integers?\n\n    a = 1 + 1\n    b = 2\n    c = 750 + 750\n    d = 1500\n    print(a is b)\n    print(c is d)\n\nWow that's quite something. Although it doesn't look as a shocked emoji face as emoji like as `{0}-{0}`", "id": "gjc4dei", "owner_tier": 0.5, "score": 0.16630196934354488}, {"content": "What is #8 about ... \"pushing debugger\"? What does that mean?\n\nShipping code littered with `breakpoint()` calls.\n\nLeftover `print()` or `logger.warning/info/debug()` from during debugging?\n\nYeah, not particularly helpful to show no examples for that one.\n\nThanks!\n\nWhat is the pro of debugging like this instead of setting breakpoints in the GUI in an IDE?\n\nCalls to `logger.debug` are fine as long as you have an appropriate logging level set to production and you aren't interpolating strings yourself in the call. Calls to info/warning/error is just normal course of business.\n\nI'm definitely not a seasoned python programmer but are \n\n    if __debug__:\n            print(\"you're so wrong\")  \n\nok?\n\n`pdb` is in the standard library and works in a terminal, so you can use it to debug python code *anywhere*. Also, some folks don't use an IDE. Many people do all their coding in a text editor like (neo)vim, emacs, or sublime text. In these cases, a terminal debugger may be your only option. Graphical debuggers are very nice, but there isn't really anything you can do in most graphical debuggers you can't also do in `pdb` if you know what you're doing and prefer a terminal interface.", "id": "gjchyuf", "owner_tier": 0.7, "score": 0.10065645512035011}, {"content": "Missed an opportunity to call out all those people who try/except, catching all exceptions and then silently pass them.\n\n@#$&\n\nEdit:\n\nAnyone who doesn't know what I'm talking about: https://realpython.com/the-most-diabolical-python-antipattern/. You also see warnings about it when you 'import this'.\n\nThis should be number 1 indeed. I would also add  \"put kwargs in every function\" (just in case) + pass half of the arguments through\n\nAnd #4 is great because his fix *requires you to catch all exceptions* if you want to safely run the function!", "id": "gjcu8gw", "owner_tier": 0.7, "score": 0.03719912470459518}, {"content": "Is #7 really an anit-pattern? I think thats perfectly fine. And \"relatively slower\" is completely over-the-top. It is *trivially* slower. Slower, yes. But of any importance, no.\n\nAlso, you lose the symmetry with sets since `{}` is an empty dict, not an empty set (which I understand why but still)\n\nAlso, #8 is not an \"anti-pattern\". It's a mistake (or bug)", "id": "gjd64y7", "owner_tier": 0.7, "score": 0.02188183805251641}, {"content": "> 1. Not using with to open files\n\nWith is a godsend but can get messy with complex setups.  While you can use commas for two I would suggest using an ExitStack for more than one.\n\n    from contextlib import ExitStack\n    \n    with ExitStack() as cm:\n        res1 = cm.enter(open('first_file', 'r'))\n        # do stuff with res1\n        res2 = cm.enter(open('second_file', 'r'))\n        # do stuff with res1 and res2\n \nExitStack can also add non-context cleanup functions to the stack.  If any entry fails it will unwind all of them in reverse order.  There are a lot of options and it really helps to cleanup messy `with` statements.\n\nhttps://www.rath.org/on-the-beauty-of-pythons-exitstack.html", "id": "gje5zvy", "owner_tier": 0.7, "score": 0.013129102822757113}, {"content": "\\#4 and #5 back to back is pretty ironic, given that Dict.get() returns None if you don't find the element :|\n\nYou can provide a default value though", "id": "gjdl40a", "owner_tier": 0.3, "score": 0.006564551400437637}, {"content": "Generally a nice article, but ...\n\nI disagree with #4. I find that using a `None` return to flag an error is a very reasonable practice, and often one that results in simpler and more maintainable code than we would get by using exceptions.\n\nAlso, #7 is just wrong. You can't initialize an empty `set` with `{ }`, as that's an empty `dict`. Use `set()` for that. So the mention of `set` in the title for #7 needs to go.\n\nEDIT. /u/Halkcyon mentions `{*()}`. Yeah, interesting. I'd even say cool. Now don't do that. :-)", "id": "gjdf2jq", "owner_tier": 0.7, "score": 0.004376367592997812}, {"content": "I just learned file manipulation in Python last night. The only way they taught me was the method without with... I'm nervous that other things they teach me will also be ineffective. I learn on SoloLearn, just so people know who teaches the wrong way.\n\npoint (1) is questionable in general and is clearly irrelevant in your case\n\nA. cpython WILL close files for you even without with (AND, even if it did not, leaving files open is not a big deal for a lot of code)\n\nB. if you are learning about files, then you absolutely should start without \"with\": .close() is fundamental file operation and there are plenty of situations when \"with\" does not work at all (e.g. for long lived file objects)\n(and \"with\" is a language construct with fairly complicated semantics not directly related to file IO)", "id": "gjcv42r", "owner_tier": 0.3, "score": 0.002188183785557987}, {"content": "> It is recommended to return only one type of object from a function.\n\nIf only there was a feature in programming languages that could ensure this.", "id": "gjd1s8j", "owner_tier": 0.3, "score": -2.1881837941412013e-11}, {"content": "Disagree with #4, it's a pain to deal with exceptions (and if used everywhere for everything they lose their value). I've also heard (and I agree more with) \"Exceptions should be fore exceptional conditions.  Not expected conditions. Like person not being in db is common/expected.  db connection timing out is exceptional.\n\n\nStrongly disagree with #7 The tiny amount of speed is so not important. And that is the important lesson to learn, don't pre-optimize, and micro-optimizations should not influence code structure etc.\n\nMany of the others are caught by flake8", "id": "gjdaez7", "owner_tier": 0.5, "score": -2.1881837941412013e-11}, {"content": "Disagree with some of #7 too. Using {} for a dict and [] for a list works well and is easy to read. However an empty set is {} ... a dict, and an empty tuple is (,) ... which has never really looked like correct code to me. \n\nThough, in general, I\u2019ve never been satisfied with significant comma use.  More than once I\u2019ve spent too much time hunting down why a string was now a tuple due to a stray comma.\n\n    my_string = (\u2018this is a long string, \u2019\n        \u2018that can span several lines \u2019\n        \u2018and may have punctuation too.\u2019)\n    another_string = \u2018Hi there,\u2019\n\n    my_bad_string = (\u2018this is a long string \u2019,\n        \u2018that can span several lines \u2019\n        \u2018and may have punctuation too.\u2019)\n    another_bad = \u201cHi there\u2019,", "id": "gjdb03u", "owner_tier": 0.5, "score": -2.1881837941412013e-11}, {"content": "The Ansible code base uses `dict()` everywhere. IIRC it's in their style guide.\n\nI prefer the literal syntax for style. But if you're worrying about the performance impact of a single variable lookup, Python is probably the wrong language for your project.", "id": "gjeh7md", "owner_tier": 0.7, "score": -2.1881837941412013e-11}], "link": "https://www.reddit.com/r/Python/comments/kxsnvv/common_antipatterns_in_python/", "question": {"content": "", "id": "kxsnvv", "title": "Common anti-patterns in Python", "traffic_rate": 207.97108193451885}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "reddit"}, {"answers": [{"content": "\r\n    Yay! A chance to use Regular Expressions without summoning the elder gods! :)\n\r\nStart with a structure to convert a string to a bad word, taking the \"bonus points\" rules into account:\nC#\n\r\npublic struct BadWord\r\n{\r\n    public BadWord(string word)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(word)) throw new ArgumentNullException(nameof(word));\r\n        \r\n        int startIndex = 0;\r\n        int length = word.Length;\r\n        \r\n        // Skip leading / trailing white-space:\r\n        while (length > 0 && char.IsWhiteSpace(word[startIndex]))\r\n        {\r\n            startIndex++;\r\n            length--;\r\n        }\r\n        while (length > 0 && char.IsWhiteSpace(word[startIndex + length - 1]))\r\n        {\r\n            length--;\r\n        }\r\n        \r\n        // If the word ends with \"!\", then it's a case-sensitive match:\r\n        if (length > 0 && word[startIndex + length - 1] == '!')\r\n        {\r\n            CaseSensitive = true;\r\n            length--;\r\n        }\r\n        else\r\n        {\r\n            CaseSensitive = false;\r\n        }\r\n        \r\n        // If the word ends with \"*\", filter anything starting with the word:\r\n        if (length > 0 && word[startIndex + length - 1] == '*')\r\n        {\r\n            Suffix = \"(?=\\\\w*\\\\b)\";\r\n            length--;\r\n        }\r\n        else\r\n        {\r\n            Suffix = \"\\\\b\";\r\n        }\r\n        \r\n        // If the word starts with \"*\", filter anything ending with the word:\r\n        if (length > 0 && word[startIndex] == '*')\r\n        {\r\n            Prefix = \"(?<=\\\\b\\\\w*)\";\r\n            startIndex++;\r\n            length--;\r\n        }\r\n        else\r\n        {\r\n            Prefix = \"\\\\b\";\r\n        }\r\n        \r\n        Word = length != 0 ? word.Substring(startIndex, length) : null;\r\n    }\r\n    \r\n    public string Word { get; }\r\n    public string Prefix { get; }\r\n    public string Suffix { get; }\r\n    public bool CaseSensitive { get; }\r\n    \r\n    public Regex ToRegularExpression()\r\n    {\r\n        if (string.IsNullOrWhiteSpace(Word)) return null;\r\n        \r\n        string pattern = Prefix + Regex.Escape(Word) + Suffix;\r\n        var options = CaseSensitive ? RegexOptions.ExplicitCapture : RegexOptions.ExplicitCapture | RegexOptions.IgnoreCase;\r\n        return new Regex(pattern, options);\r\n    }\r\n}\r\nThen a class to represent a single bad word and its replacement:\nEDIT: Now with the part of the spec the \"customer\" forgot to mention! :)\nC#\n\r\npublic sealed class WordReplacement\r\n{\r\n    public WordReplacement(BadWord word, string replacement)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(word.Word)) throw new ArgumentNullException(nameof(word));\r\n        \r\n        Pattern = word.ToRegularExpression();\r\n        CaseSensitive = word.CaseSensitive;\r\n        Replacement = replacement;\r\n        \r\n        if (CaseSensitive || replacement == null || replacement.Any(char.IsUpper))\r\n        {\r\n            Replacer = (Match m) => Replacement;\r\n        }\r\n        else\r\n        {\r\n            Replacer = (Match m) => MatchCase(m.Value, Replacement);\r\n        }\r\n    }\r\n    \r\n    public WordReplacement(string word, string replacement) : this(new BadWord(word), replacement)\r\n    {\r\n    }\r\n    \r\n    public Regex Pattern { get; }\r\n    public string Replacement { get; }\r\n    public bool CaseSensitive { get; }\r\n    public MatchEvaluator Replacer { get; }\r\n    \r\n    public static string MatchCase(string wordToReplace, string replacement)\r\n    {\r\n        if (null == replacement) return string.Empty;\r\n        if (wordToReplace.All(char.IsLower)) return replacement;\r\n        if (wordToReplace.All(char.IsUpper)) return replacement.ToUpperInvariant();\r\n        \r\n        char[] result = replacement.ToCharArray();\r\n        bool changed = false;\r\n        \r\n        if (wordToReplace.Length == replacement.Length)\r\n        {\r\n            for (int index = 0; index < result.Length; index++)\r\n            {\r\n                if (char.IsUpper(wordToReplace[index]))\r\n                {\r\n                    char c = result[index];\r\n                    result[index] = char.ToUpperInvariant(c);\r\n                    if (result[index] != c) changed = true;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (char.IsUpper(wordToReplace[0]))\r\n            {\r\n                char c = result[0];\r\n                result[0] = char.ToUpperInvariant(c);\r\n                if (result[0] != c) changed = true;\r\n            }\r\n            if (char.IsUpper(wordToReplace[wordToReplace.Length - 1]))\r\n            {\r\n                int index = result.Length - 1;\r\n                char c = result[index];\r\n                result[index] = char.ToUpperInvariant(c);\r\n                if (result[index] != c) changed = true;\r\n            }\r\n        }\r\n        \r\n        return changed ? new string(result) : replacement;\r\n    }\r\n    \r\n    public string Replace(string input) => Pattern.Replace(input, Replacer);\r\n}\r\nAnd finally, a class to represent a list of bad word replacements:\nC#\n\r\npublic sealed class Clbuttifier2000\r\n{\r\n    public Clbuttifier2000(IEnumerable<KeyValuePair<string, string>> replacements)\r\n    {\r\n        Replacements = replacements.Select(p => new WordReplacement(p.Key, p.Value)).ToList().AsReadOnly();\r\n    }\r\n    \r\n    public IReadOnlyList<WordReplacement> Replacements { get; }\r\n    \r\n    public string Clbuttify(string message)\r\n    {\r\n        if (!string.IsNullOrWhiteSpace(message))\r\n        {\r\n            foreach (var replacement in Replacements)\r\n            {\r\n                message = replacement.Replace(message);\r\n            }\r\n        }\r\n        \r\n        return message;\r\n    }\r\n}\r\nSample usage:\nC#\n\r\nvar filter = new Clbuttifier2000(new Dictionary<string, string>\r\n{\r\n    [\"poop*\"] = \"p**p\",\r\n    [\"PHB!\"] = \"boss\",\r\n    [\"gotten\"] = \"become\",\r\n});\r\n\r\nstring input = \"My PHB has gotten started on his new blog phblog.com. He's SUCH A MISBEGOTTEN Poophead!\";\r\nstring expected = \"My boss has become started on his new blog phblog.com. He's SUCH A MISBEGOTTEN P**phead!\";\r\nstring actual = filter.Clbuttify(input);\r\nDebug.Assert(actual == expected);\n", "id": "2_1157811_3", "owner_tier": 0.7, "score": 2.5}, {"content": "\r\n    I was reading up on Python online, then chanced upon this pooping oops I mean coding challenge, thought why not try this out on Python. Here it is fresh from the loo oops again I mean oven.\nPython\n\r\n\"\"\"\r\npoop.py\r\n\r\nby Peter Leow the pooper\r\n\r\n\"\"\"\r\n\r\nimport re\r\n\r\ndef functionStartWithPoop(m):\r\n    wordFound = m.group(0)\r\n\r\n    if wordFound[:5].lower()=='poop*':\r\n        wordRepl = wordFound[0] + '**' + wordFound[3] + wordFound[5:]\r\n    else: #wordFound[:4].lower()=='poop':\r\n        wordRepl = wordFound[0] + '**' + wordFound[3] + wordFound[4:] \r\n\r\n    return wordRepl\r\n\r\ndef functionEndWithPoop(m):\r\n    wordFound = m.group(0)\r\n\r\n    if wordFound[-5:].lower()=='*poop':\r\n        wordRepl = wordFound[:-5] + wordFound[-4] + '**' + wordFound[-1]\r\n    else: #wordFound[-4:].lower()=='poop':\r\n        wordRepl = wordFound[:-4] + wordFound[-4] + '**' + wordFound[-1]\r\n\r\n    return wordRepl\r\n\r\ndef main():\r\n    originalSentence = '''\r\n    poop*ing is in front of make*poop.\r\n    Whether poop* or *poop, there are just pOoP!\r\n    A POOPHEAD cannot change but an exclaimed POOPHEAD! can.'''\r\n\r\n    print('Before:')\r\n    print(originalSentence)\r\n    print()\r\n    print('After:')\r\n    \r\n    # Without ! ending\r\n    patternStartWithPoop=r'(?<!\\S)poop\\*?[\\S]*'\r\n    patternEndWithPoop=r'[\\S]*\\*?poop(?=[?!,.;]?$|[?!,.;]?\\s+)'\r\n\r\n    # with ! ending\r\n    patternStartWithPoopEndWithExclamation = r'(?<!\\S)poop\\*?[\\S]*!(?=\\s|$)'\r\n    patternEndWithPoopAndExclamation=r'[\\S]*\\*?poop!(?=[?!,.;]?$|[?!,.;]?\\s+)'\r\n\r\n    # Case sensitive\r\n    filteredSentence = re.sub(patternStartWithPoop, functionStartWithPoop, originalSentence, flags=0)\r\n    #print(filteredSentence)\r\n    filteredSentence = re.sub(patternEndWithPoop, functionEndWithPoop, filteredSentence, flags=0)\r\n    #print(filteredSentence)\r\n\r\n    # Case ignorance\r\n    filteredSentence = re.sub(patternStartWithPoopEndWithExclamation, functionStartWithPoop, filteredSentence, flags=re.IGNORECASE)\r\n    #print(filteredSentence)\r\n    filteredSentence = re.sub(patternEndWithPoopAndExclamation, functionEndWithPoop, filteredSentence, flags=re.IGNORECASE)\r\n    print(filteredSentence)\r\n  \r\nmain()\r\nTry this out at Coding challenge bad word filter | Python Fiddle[^] and you should see the following OUTPOOP:\n \n\r\nBefore:\r\n\r\n    poop*ing is in front of make*poop.\r\n    Whether poop* or *poop, there are just pOoP!\r\n    A POOPHEAD cannot change but an exclaimed POOPHEAD! can.\r\n\r\nAfter:\r\n\r\n    p**ping is in front of makep**p.\r\n    Whether p**p or p**p, there are just p**P!\r\n    A POOPHEAD cannot change but an exclaimed P**PHEAD! can.\r\nI have ignored 'PHB' and 'gotten' as they are simply too trivial.\r\n", "id": "2_1157928_5", "owner_tier": 0.5, "score": 2.0}, {"content": "\r\n    Not sure on the rules, just wanted to add this for fun.  I love code challenges.\n\r\nThis solution, in contrast to my other one, reduces the number of strings nuked during processing.  It also uses only a single Regex call to process all bad words.  Even though I construct an additional dictionary, my diagnostic tool shows me coming in at less memory consumed than my previous solution.  This solution does everything the previous did, plus adds optional casing.\n\nC#\n\r\npublic class BadWordFilter\r\n{\r\n    public static string Replace(string input, \r\n        IDictionary<string, string> badWordMap)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(input))\r\n            throw new ArgumentException(nameof(input),\r\n                \"String cannot be null, empty, or whitespace.\");\r\n\r\n        Dictionary<string, string> idMap = new Dictionary<string, string>();\r\n        StringBuilder pattern = new StringBuilder();\r\n        int idCounter = 0;\r\n        //For each bad word pair, create an ID mapped to the value and construct the match pattern using the ID and key\r\n        foreach (KeyValuePair<string, string> badWord in badWordMap)\r\n        {\r\n            string id = \"ID\" + idCounter++;\r\n            idMap.Add(id, badWord.Value);\r\n            ConstructMatchPattern(badWord.Key, id, pattern);\r\n        }\r\n        //Remove the first | from the pattern\r\n        pattern.Remove(0, 1);\r\n\r\n        Regex filter = new Regex(pattern.ToString(), RegexOptions.IgnoreCase);\r\n        string[] groupNames = filter.GetGroupNames();\r\n        MatchEvaluator evaluator = match =>\r\n        {\r\n            string replacement = \"\";\r\n            //Find which group was matched and retrieve the replacement value\r\n            for (int i = 1; i < groupNames.Length; i++)\r\n                if (match.Groups[groupNames[i]].Success)\r\n                {\r\n                    replacement = idMap[groupNames[i]];\r\n                    break;\r\n                }\r\n\r\n            //Handle casing\r\n            if (replacement.StartsWith(\"!\"))\r\n            {\r\n                replacement = replacement.Remove(0, 1);\r\n                //All caps check\r\n                if (match.Value == match.Value.ToUpper())\r\n                    replacement = replacement.ToUpper();\r\n                //First letter caps check\r\n                else if (match.Value[0] == char.ToUpper(match.Value[0]))\r\n                    replacement = char.ToUpper(replacement[0]) + replacement.Substring(1);\r\n            }\r\n            return replacement;\r\n        };\r\n\r\n        return filter.Replace(input, evaluator);\r\n    }\r\n\r\n    private static void ConstructMatchPattern(string badWord, string id, \r\n        StringBuilder pattern)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(badWord))\r\n            return;\r\n        int patternLength = pattern.Length;\r\n        pattern.Append($@\"|(?<{id}>(?:\\b){badWord.Trim('*')}\");\r\n        if (badWord.StartsWith(\"*\"))\r\n            pattern.Insert(patternLength + id.Length + 11, @\"\\w*\", 1);\r\n        if (badWord.EndsWith(\"*\"))\r\n            pattern.Append(@\"\\w*\");\r\n        pattern.Append(')');\r\n    }\r\n}\n\r\nUsed the same way as the previous example, with the inclusion of the \"!\" option.\n\nC#\n\r\nstatic void Main(string[] args)\r\n{\r\n    Dictionary<string, string> badWords = new Dictionary<string, string>()\r\n    {\r\n        {\"poop*\", \"p**phead\"},\r\n        {\"*HB\", \"boss\"},\r\n        {\"gotten\", \"become\"},\r\n        {\"*crap*\", \"taco supreme\"}\r\n    };\r\n    string input = \"My PHB is such a poophead. It's gotten worse since his promotion. In fact you might call him a supercraphead.\";\r\n    string filteredInput = BadWordFilter.Replace(input, badWords);\r\n    Console.WriteLine(filteredInput);\r\n    Console.ReadKey();\r\n}\r\n\n\r\nReplacing  {\"*HB\", \"boss\"} with {\"*HB\", \"!boss\"} will yield BOSS instead of boss since it cases to its key's match.\r\n", "id": "2_1157969_2", "owner_tier": 0.3, "score": 3.0}, {"content": "\r\n    Actually, stating that this challenge is easy is misleading. Handling text is never easy, if you want to work with Unicode. Here is a my take on it.\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nclass WordFilter\r\n{\r\n    private static Dictionary<string, string> badWords = null;\r\n\r\n    private static List<KeyValuePair<string, string>> badWordsStart = new List<KeyValuePair<string, string>>();\r\n    private static List<KeyValuePair<string, string>> badWordsEnd = new List<KeyValuePair<string, string>>();\r\n    private static List<KeyValuePair<string, string>> badWordsMiddle = new List<KeyValuePair<string, string>>();\r\n    private static Dictionary<string, string> badWordsCaseSensitive = new Dictionary<string, string>();\r\n    private static Dictionary<string, string> badWordsCaseInsensitive = new Dictionary<string, string>();\r\n        \r\n    private static void Init()\r\n    {\r\n        if (badWords != null)\r\n        {\r\n            return;\r\n        }\r\n\r\n        badWords = new Dictionary<string, string>()\r\n        {\r\n            {\"poop*\", \"p**p\"},\r\n            {\"PHB!\", \"boss\"},\r\n            {\"gotten\", \"become\"},\r\n            {\"*crap*\", \"taco supreme\"}\r\n        };\r\n\r\n        foreach (var item in badWords)\r\n        {\r\n            bool startWord = item.Key.EndsWith(\"*\");\r\n            bool endWord = item.Key.StartsWith(\"*\");\r\n            bool caseSensitive = item.Key.EndsWith(\"!\");\r\n\r\n            if (startWord && endWord)\r\n            {\r\n                badWordsMiddle.Add(new KeyValuePair<string, string>(item.Key.Trim('*').ToLower(CultureInfo.InvariantCulture), item.Value));\r\n            }\r\n            else if (startWord)\r\n            {\r\n                badWordsStart.Add(new KeyValuePair<string, string>(item.Key.TrimEnd('*').ToLower(CultureInfo.InvariantCulture), item.Value));\r\n            }\r\n            else if (endWord)\r\n            {\r\n                badWordsEnd.Add(new KeyValuePair<string, string>(item.Key.TrimStart('*').ToLower(CultureInfo.InvariantCulture), item.Value));\r\n            }\r\n            else if (caseSensitive)\r\n            {\r\n                badWordsCaseSensitive.Add(item.Key.TrimEnd('!'), item.Value);\r\n            }\r\n            else\r\n            {\r\n                badWordsCaseInsensitive.Add(item.Key.ToLower(CultureInfo.InvariantCulture), item.Value);\r\n            }\r\n        }\r\n    }\r\n\r\n    public WordFilter()\r\n    {\r\n        Init();\r\n    }\r\n\r\n    public string Filter(string s)\r\n    {\r\n        var word = new StringBuilder();\r\n        var sout = new StringBuilder();\r\n\r\n        foreach (var c in s.GetUTF32Chars())\r\n        {\r\n            if (c.IsLetter)\r\n            {\r\n                word.Append(c);\r\n            }\r\n            else \r\n            {\r\n                if (word.Length > 0)\r\n                {\r\n                    var niceWord = Replace(word.ToString());\r\n                    word.Clear();\r\n                    sout.Append(niceWord);\r\n                }\r\n                sout.Append(c);\r\n            }\r\n        }\r\n        return sout.ToString();\r\n    }\r\n\r\n    private string Replace(string word)\r\n    {\r\n        string newWord;\r\n        if (badWordsCaseSensitive.TryGetValue(word, out newWord)) return newWord;\r\n\r\n        var lword = word.ToLower(CultureInfo.InvariantCulture);\r\n        if (badWordsCaseInsensitive.TryGetValue(word, out newWord)) return newWord;\r\n\r\n        newWord = badWordsStart.Where(it => word.StartsWith(it.Key)).Select(it => word.Replace(it.Key, it.Value)).FirstOrDefault();\r\n        if (newWord != null) return newWord;\r\n\r\n        newWord = badWordsEnd.Where(it => word.EndsWith(it.Key)).Select(it => word.Replace(it.Key, it.Value)).FirstOrDefault();\r\n        if (newWord != null) return newWord;\r\n\r\n        newWord = badWordsMiddle.Where(it => word.Contains(it.Key)).Select(it => word.Replace(it.Key, it.Value)).FirstOrDefault();\r\n        if (newWord != null) return newWord;\r\n\r\n        return word;\r\n    }\r\n}\r\n\r\npublic static class StringExtensions\r\n{\r\n    public static System.Collections.Generic.IEnumerable<UTF32Char> GetUTF32Chars(this string s)\r\n    {\r\n        var tee = System.Globalization.StringInfo.GetTextElementEnumerator(s);\r\n\r\n        while (tee.MoveNext())\r\n        {\r\n            yield return new UTF32Char(s, tee.ElementIndex);\r\n        }\r\n    }\r\n}\r\n\r\npublic struct UTF32Char\r\n{\r\n    private string s;\r\n    private int index;\r\n\r\n    public UTF32Char(string s, int index)\r\n    {\r\n        this.s = s;\r\n        this.index = index;\r\n    }\r\n\r\n    public override string ToString()\r\n    {\r\n        return char.ConvertFromUtf32(this.UTF32Code);\r\n    }\r\n\r\n    public int UTF32Code {  get { return char.ConvertToUtf32(s, index); } }\r\n    public double NumericValue { get { return char.GetNumericValue(s, index); } }\r\n    public UnicodeCategory UnicodeCategory { get { return char.GetUnicodeCategory(s, index); } } \r\n    public bool IsControl { get { return char.IsControl(s, index); } }\r\n    public bool IsDigit { get { return char.IsDigit(s, index); } }\r\n    public bool IsLetter { get { return char.IsLetter(s, index); } }\r\n    public bool IsLetterOrDigit { get { return char.IsLetterOrDigit(s, index); } }\r\n    public bool IsLower { get { return char.IsLower(s, index); } }\r\n    public bool IsNumber { get { return char.IsNumber(s, index); } }\r\n    public bool IsPunctuation { get { return char.IsPunctuation(s, index); } }\r\n    public bool IsSeparator { get { return char.IsSeparator(s, index); } }\r\n    public bool IsSurrogatePair { get { return char.IsSurrogatePair(s, index); } }\r\n    public bool IsSymbol { get { return char.IsSymbol(s, index); } }\r\n    public bool IsUpper { get { return char.IsUpper(s, index); } }\r\n    public bool IsWhiteSpace { get { return char.IsWhiteSpace(s, index); } }\r\n}\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        var wf = new WordFilter();\r\n\r\n        var rawSentence = \"My PHB is such a poophead. It's gotten worse since his promotion.  In fact you might call him a supercraphead!\";\r\n        var niceSentence = wf.Filter(rawSentence);\r\n        Console.WriteLine(rawSentence);\r\n        Console.WriteLine(niceSentence);\r\n    }\r\n}\n", "id": "2_1158227_1", "owner_tier": 0.1, "score": 5.0}, {"content": "\r\n    Not sure if my Excel VBA solution posted, so I'm trying again\nVB.NET\n\r\nPublic Function noBad(ByVal badstr As String) As String\r\n    Dim badWords As Variant, goodWords As Variant\r\n    Dim i As Integer, bw As String\r\n    badWords = Array(\"poop*\", \"PHB\", \"gotten\", \"POOP*\")\r\n    goodWords = Array(\"p**p\", \"boss\", \"become\", \"P**P\")\r\n    For i = 0 To UBound(badWords)\r\n        bw = badWords(i)\r\n        With CreateObject(\"VBScript.RegExp\")\r\n            .Pattern = \"\\b\" & bw & IIf(InStr(bw, \"*\"), \"\", \"\\b\")\r\n            .Global = True\r\n            badstr = .Replace(badstr, goodWords(i))\r\n        End With\r\n    Next i\r\n    noBad = badstr\r\nEnd Function\n\r\nWorth a go, I thought.  Okay so the case thing isn't so good, but I only get a short lunch\r\n", "id": "2_1158254_1", "owner_tier": 0.1, "score": 2.5}, {"content": "\r\n    COBOL has awesome string handling:\n\nC#\n\r\nidentification division.\r\nprogram-id. FixBadWords.\r\n\r\ndata division.\r\n  \r\nworking-storage section.\r\n   \r\n\t01 wsData.\r\n\t    03 wsComment occurs 5 times pic a(255).\r\n\t01 i         pic 9(1).\r\n\r\nprocedure division. \r\n\t\r\n\tmove \"My PHBis such a poophead. It's gotten worse since his promotion\" \r\n            to wscomment(1)\r\n\tmove \"My PHB is such a POOPHEAD!\" to wscomment(2)\r\n\r\n\tperform varying i from 1 by 1 until i > 5\r\n\t    \r\n\t\tinspect wsComment(i) \r\n\t\t\treplacing all 'poophead' by 'p**phead'\r\n\t\t\t\t      'POOPHEAD' BY 'P**PHEAD'\r\n\t\t\t\t      'PHB'      BY 'boss'\r\n\t\t\t\t      'gotten'   BY 'become'\r\n\t\t\r\n\t\tdisplay wsComment(i)\r\n\r\n\tend-perform\r\n\r\nstop run\r\n.\n", "id": "2_1158571_2", "owner_tier": 0.1, "score": 5.0}, {"content": "\r\n    EDIT:\r\n* Figured out way to make 'poopoopoop' become 'p**p**p**p' (without recursion) and keep other design constraints.\n\r\n* Figured out an 'Oh Duh - that's so simple!' way to keep 'nincompoop' as 'nincompoop' - just replace it with itself!\n\r\n* Made class static, which resulted in about 8% inprovement.  But the additional 'p**p**p**p' routine (replaceRepeatingStrings) dropped speed from 0.24ms to 0.37ms.  Still 7 times faster than Solution 10 on my machine.\r\n-END EDIT\n\nQuote:The point is to make the question a little loose to allow ... pointless religious warsGood, I'll use some 'goto's :)\n\r\nI'm not very familiar with regex, but believe it doesn't allow you to change the case of a word based on the cases of the surrounding words.  (If I'm wrong, please enlighten me.)  If that is the case, 'PHB' will always become 'boss' in the regex solutions, regardless of whether the input 'shouted' the phrase.\n\r\nThe following solution is C++ all the way, and is about 7 times faster than Solution 10 on my machine using Grant's newest timing routine.  It does take the capitalization of the surrounding words into effect.  It will also change 'pooppoop' to 'p**pp**p', which doesn't seem to have been specified by the specifications, although logically should occur.  Additionally, it changes 'poopoopoop' into 'p**p**p**p' without recursion.\n\nQuote:A weekly simple programming problem that should take no more than half an hour or soYeah, right Chris... :rolleyes: This logic was a friggin' pain!\n\nC++\n\r\n#include <map>\r\n#include <string>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <tuple>\r\n#include <ctime>\r\n#include <iostream>\r\n#include \"windows.h\" //For QueryPerformanceCounter\r\nusing namespace std;\r\n\r\n//I am going to use a tuple of: the input word, the small case output word, and the\r\n//capped case output word, so they don't have to be calculated each time.\r\n//So some defines are just for additional clarity:\r\n#define GetTupleWord      get<0>\r\n#define GetTupleSmallCase get<1>\r\n#define GetTupleCapCase   get<2>\r\n\r\n\r\n//Utility class for the timing...\r\nclass TimerLowRes {\r\n   private:\r\n      std::clock_t begC;\r\n      std::clock_t avgTotC;\r\n      std::clock_t diffC;\r\n      int numTimesC;\r\n   public:\r\n      TimerLowRes() : avgTotC(0), numTimesC(0) { }\r\n\r\n      void start() { begC = std::clock(); }\r\n\r\n      std::clock_t stop() {\r\n         diffC = std::clock() - begC;\r\n         avgTotC = avgTotC + diffC;\r\n         numTimesC++;\r\n         return diffC;\r\n         }\r\n\r\n      std::clock_t getAvg() {\r\n         if (numTimesC == 0) return 0;\r\n         return avgTotC / numTimesC;\r\n         }\r\n\r\n      void reset() {\r\n         numTimesC = 0;\r\n         avgTotC = 0;\r\n         }\r\n\r\n      std::clock_t getLapTime() { return std::clock() - begC; }\r\n   };\r\n\r\n\r\n\r\n\r\n//High precision timer utility class for the timing.\r\n//Derived from https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx\r\nclass TimerHighRes {\r\n   private:\r\n      LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds, Frequency;\r\n      int numTimesC;\r\n   public:\r\n      TimerHighRes() : numTimesC(0) {\r\n         QueryPerformanceFrequency(&Frequency);\r\n         }\r\n\r\n      void start() {\r\n         QueryPerformanceCounter(&StartingTime);\r\n         }\r\n\r\n      LARGE_INTEGER stop() {\r\n         QueryPerformanceCounter(&EndingTime);\r\n         ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;\r\n         ElapsedMicroseconds.QuadPart *= 1000000;\r\n         ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;\r\n         numTimesC++;\r\n         return ElapsedMicroseconds;\r\n         }\r\n   };\r\n\r\n\r\nclass Reformatter {\r\n   private:\r\n      //Good chance that the implied design requirements involve UNICODE text, but for quick\r\n      //prototype of similar design use wstring:\r\n\r\n      typedef tuple<wstring, wstring, wstring> WordTuples;\r\n      vector<WordTuples> repeatingStringsC;     //This will address items like 'poopoopoop'\r\n      vector<WordTuples> caseSensitiveSubsC;    //This means that the inputted word must be\r\n                                                //matched on exact case.\r\n      vector<WordTuples> nonCaseSensitiveSubsC; //By this, it is meant that the inputted word\r\n                                                //can be either caps or small case in the text.\r\n      vector<WordTuples> asteriskSubsC;         //The CapCase will be ignored - only the\r\n                                                //asterisks in the small case will be modified.\r\n\r\n      wstring resultC;\r\n      size_t  strLenC;\r\n      wstring::const_iterator beginLocC;\r\n      wstring::const_iterator curLocC;\r\n      wstring::const_iterator endLocC;\r\n\r\n      bool replaceAsterisks();\r\n      bool replaceNonCaseSensitiveBegin();\r\n      bool replaceCaseSensitive();\r\n      bool replaceRepeatingStrings();\r\n      bool previousWordIsCapitalized(wstring::const_iterator & thisWord, wstring::const_iterator & prevWord);\r\n      bool nextWordIsCapitalized(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord);\r\n      void findBeginningOfPrevious(wstring::const_iterator & thisWord, wstring::const_iterator & prevWord);\r\n      void findBeginningOfNext(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord);\r\n\r\n      bool isWhiteSpaceOrPunctuation(const wstring::const_iterator & temp);\r\n\r\n   public:\r\n      Reformatter() {\r\n         repeatingStringsC.push_back(make_tuple(L\"poo\", L\"p**\", L\"p\"));\r\n\r\n         caseSensitiveSubsC.push_back(make_tuple(L\"PHB\", L\"boss\", L\"BOSS\"));\r\n\r\n         //The following 'gotten to be' must be defined before 'gotten':\r\n         nonCaseSensitiveSubsC.push_back(make_tuple(L\"gotten to be\", L\"become\", L\"BECOME\"));\r\n         nonCaseSensitiveSubsC.push_back(make_tuple(L\"gotten\", L\"become\", L\"BECOME\"));\r\n\r\n         asteriskSubsC.push_back(make_tuple(L\"nincompoop\", L\"nincompoop\", L\"nincomp##p\"));\r\n         asteriskSubsC.push_back(make_tuple(L\"poop\", L\"p**p\", L\"P**P\"));\r\n         asteriskSubsC.push_back(make_tuple(L\"p##p\", L\"p**p\", L\"P**P\"));\r\n         asteriskSubsC.push_back(make_tuple(L\"ass\", L\"a**\", L\"A**\"));\r\n         }\r\n\r\n      void reformat(const wstring & str);\r\n      void outputResult();\r\n   };\r\n\r\n\r\nvoid Reformatter::outputResult() {\r\n   wcout << L\"OUTPUT: \" << resultC << endl << endl;\r\n   }\r\n\r\n\r\nbool Reformatter::isWhiteSpaceOrPunctuation(const wstring::const_iterator & it) {\r\n   if (*it == L' ' || *it == L'\\t' || *it == L'.' || *it == L'!' || *it == L'_' ||\r\n               *it == L'\\r' || *it == L'\\n') return true;\r\n   return false;\r\n   }\r\n\r\n\r\nvoid Reformatter::findBeginningOfNext(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord) {\r\n   //There is the possibility that there is no next word, but there is whitespace.\r\n   //If that is the case, return prevWord = thisWord = curLocC.\r\n\r\n   //Go to the whitespace at the end of the current word:\r\n   while (thisWord != endLocC && !isWhiteSpaceOrPunctuation(thisWord)) ++thisWord;\r\n   //Move 'thisWord' back to the beginning of the whitespace:\r\n   nextWord = thisWord;\r\n   //Now skip any additional whitespace:\r\n   while (nextWord != endLocC && isWhiteSpaceOrPunctuation(nextWord)) ++nextWord;\r\n   if (nextWord == endLocC) {\r\n      nextWord = endLocC;\r\n      thisWord = endLocC;\r\n      return;\r\n      }\r\n   }\r\n\r\n\r\nvoid Reformatter::findBeginningOfPrevious(wstring::const_iterator & thisWord, wstring::const_iterator & prevWord) {\r\n   //There is the possibility that there is no previous word, but there is whitespace.\r\n   //If that is the case, return prevWord = thisWord = (beginning of word).\r\n\r\n   //Go to the whitespace before the current word:\r\n   while (thisWord != beginLocC && !isWhiteSpaceOrPunctuation(thisWord)) --thisWord;\r\n   //Move 'thisWord' back to the beginning (one space forward), and set 'prevWord' current pos:\r\n   prevWord = thisWord;\r\n   ++thisWord;\r\n   //Now skip any additional whitespace:\r\n   while (prevWord != beginLocC && isWhiteSpaceOrPunctuation(prevWord)) --prevWord;\r\n   if (prevWord == beginLocC) {\r\n      if (isWhiteSpaceOrPunctuation(prevWord)) prevWord = thisWord;\r\n      return;\r\n      }\r\n   //We are now on the last character of the previous word.  Iterate to the beginning of it:\r\n   while (prevWord != beginLocC && !isWhiteSpaceOrPunctuation(prevWord)) --prevWord;\r\n   //Check for the case where the user starts the input with a space character:\r\n   if (isWhiteSpaceOrPunctuation(prevWord)) ++prevWord;\r\n   }\r\n\r\n\r\nbool Reformatter::previousWordIsCapitalized(wstring::const_iterator & thisWord,\r\n               wstring::const_iterator & prevWord) {\r\n\r\n   //We are working from the 'curLocC' position in the string.\r\n   //Create a temporary iterator and find the beginning of the previous word.\r\n   //If it reaches the beginning of the string, return 'true' so the 'shouting'\r\n   //routines only rely on the following word.\r\n   findBeginningOfPrevious(thisWord, prevWord);\r\n   if (thisWord == prevWord) return true; //We will default to 'true' for the previous word\r\n               //and 'false' for the next word, so next word processing can occur.\r\n   //Now find the case of each letter until the next whitespace:\r\n   while (!isWhiteSpaceOrPunctuation(prevWord)) {\r\n      wchar_t temp = *prevWord;\r\n      if (iswlower(*prevWord)) return false;\r\n      ++prevWord;\r\n      }\r\n   return true;\r\n   }\r\n\r\n\r\nbool Reformatter::nextWordIsCapitalized(wstring::const_iterator & thisWord, wstring::const_iterator & nextWord) {\r\n   //We are working from the 'curLocC' position in the string.\r\n   //Create a temporary iterator and find the beginning of the previous word.\r\n   //If it reaches the beginning of the string, return 'true' so the 'shouting'\r\n   //routines only rely on the following word.\r\n   findBeginningOfNext(thisWord, nextWord);\r\n   if (thisWord == nextWord) return false;   //We are defaulting to 'true' for previous word\r\n               //processing, and 'false' for this, so if there isn't any text before or\r\n               //after the word, both processings will occur.\r\n   //Now find the case of each letter until the next whitespace:\r\n   while (nextWord != endLocC && !isWhiteSpaceOrPunctuation(nextWord)) {\r\n      wchar_t temp = *nextWord;\r\n      if (iswlower(*nextWord)) return false;\r\n      ++nextWord;\r\n      }\r\n   return true;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceCaseSensitive() {\r\n   //This returns true if a replacement has been made.\r\n   bool found = false;\r\n   wstring::const_iterator inputIterator;\r\n   for (auto it = caseSensitiveSubsC.begin(); it != caseSensitiveSubsC.end(); ++it) {\r\n      const wstring & str = GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str.length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || *inputIterator != str[pos]) {\r\n            //The string doesn't match the criteria\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) {\r\n         //There is a non-specified scenario to take care of.  If the user inputs something\r\n         //like 'PHBblog.com', in reality we may not want this to substitute 'boss'.  Here\r\n         //is logic to take care of that scenario:\r\n         if (inputIterator == endLocC || !isWhiteSpaceOrPunctuation(inputIterator)) {\r\n            return false;\r\n            }\r\n         //We now know that we need to replace the string, but we don't know if it needs to\r\n         //be 'shouted'.\r\n         //curLocC is still at the beginning of the text being checked against.  This can\r\n         //only be at the beginning of a word.\r\n         wstring::const_iterator thisWord = curLocC;\r\n         wstring::const_iterator prevWord = curLocC;\r\n         wstring::const_iterator nextWord = curLocC;\r\n         //If someone has different length words for cap and small, this will need to be changed in the cases:\r\n         if (previousWordIsCapitalized(thisWord, prevWord) && nextWordIsCapitalized(thisWord, nextWord)) {\r\n            resultC.append(GetTupleCapCase(*it));\r\n            }\r\n         else {\r\n            resultC.append(GetTupleSmallCase(*it));\r\n            }\r\n         //Now append any whitespace after the string:\r\n         curLocC += str.length();\r\n         while (curLocC != endLocC && isWhiteSpaceOrPunctuation(curLocC)) {\r\n            resultC.append(1, *curLocC);\r\n            ++curLocC;\r\n            }\r\n         return found;\r\n         }\r\n      }\r\n   return found;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceNonCaseSensitiveBegin() {\r\n   //By 'non-case-sensitive', it is meant that the routine will check for either capped or\r\n   //non-capped matches.\r\n   bool found;\r\n   vector<tuple<wstring, wstring, wstring>>::iterator it;\r\n   wstring::const_iterator inputIterator;\r\n   const wstring * str;\r\n\r\n   //If there isn't a character before 'curLocC' we don't need to look any further.\r\n   if (curLocC == beginLocC) return false;\r\n   if (!(curLocC-1==beginLocC || isWhiteSpaceOrPunctuation(curLocC-1))) return false;\r\n   if (!isWhiteSpaceOrPunctuation(curLocC-1)) return false;\r\n\r\n   for (it = nonCaseSensitiveSubsC.begin(); it != nonCaseSensitiveSubsC.end(); ++it) {\r\n      str = &GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str->length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || towlower(*inputIterator) != (*str)[pos]) {\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) break;\r\n      }\r\n   if (found) {\r\n      //We need to see if it is capped, and if so, cap the output:\r\n      inputIterator = curLocC;\r\n      bool isCapped = true;\r\n      for (int pos=0, len=(*str).length(); pos<len; ++pos) {\r\n         if (iswlower(*inputIterator)) {\r\n            isCapped = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (isCapped) {\r\n         resultC.append(GetTupleCapCase(*it));\r\n         }\r\n      else {\r\n         resultC.append(GetTupleSmallCase(*it));\r\n         }\r\n      curLocC += GetTupleWord(*it).length();\r\n      return true;\r\n      }\r\n   return false;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceAsterisks() {\r\n   bool found;\r\n   vector<tuple<wstring, wstring, wstring>>::iterator it;\r\n   wstring::const_iterator inputIterator;\r\n   const wstring * str;\r\n\r\n   for (it = asteriskSubsC.begin(); it != asteriskSubsC.end(); ++it) {\r\n      str = &GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str->length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || towlower(*inputIterator) != (*str)[pos]) {\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) break;\r\n      }\r\n   if (found) {\r\n      //Go through the small cap tuple and if a character is an asterisk, replace\r\n      //the corresponding character with an asterisk:\r\n      str = &GetTupleSmallCase(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=(*str).length(); pos<len; ++pos) {\r\n         if ((*str)[pos] == L'*') {\r\n            resultC.append(L\"*\");\r\n            }\r\n         else {\r\n            resultC.append(1, *curLocC);\r\n            }\r\n         ++curLocC;\r\n         ++inputIterator;\r\n         }\r\n      return true;\r\n      }\r\n   return false;\r\n   }\r\n\r\n\r\nbool Reformatter::replaceRepeatingStrings() {\r\n   bool found;\r\n   vector<tuple<wstring, wstring, wstring>>::iterator it;\r\n   wstring::const_iterator inputIterator;\r\n   const wstring * str;\r\n\r\n   for (it = repeatingStringsC.begin(); it != repeatingStringsC.end(); ++it) {\r\n      str = &GetTupleWord(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=str->length(); pos<len; ++pos) {\r\n         found = true;\r\n         if (inputIterator == endLocC || towlower(*inputIterator) != (*str)[pos]) {\r\n            found = false;\r\n            break;\r\n            }\r\n         ++inputIterator;\r\n         }\r\n      if (found) {\r\n         //The inputIterator is pointing to the letter right after the initial string\r\n         //(ie, the final 'p' in 'poop')\r\n         str = &GetTupleCapCase(*it);\r\n         if (*inputIterator != (*str)[0]) found = false;\r\n         }\r\n      if (found) break;\r\n      }\r\n   if (found) {\r\n      //Go through the small cap tuple and if a character is an asterisk, replace\r\n      //the corresponding character with an asterisk:\r\n      str = &GetTupleSmallCase(*it);\r\n      inputIterator = curLocC;\r\n      for (int pos=0, len=(*str).length(); pos<len; ++pos) {\r\n         if ((*str)[pos] == L'*') {\r\n            resultC.append(L\"*\");\r\n            }\r\n         else {\r\n            resultC.append(1, *curLocC);\r\n            }\r\n         ++curLocC;\r\n         ++inputIterator;\r\n         }\r\n      return true;\r\n      }\r\n   return false;\r\n   }\r\n\r\n\r\nvoid Reformatter::reformat(const wstring & str) {\r\n   resultC.reserve(str.length()+1);\r\n   resultC.clear();\r\n   beginLocC = str.begin();\r\n   curLocC = beginLocC;\r\n   strLenC = str.length();\r\n   endLocC = str.end();\r\n   while (curLocC != endLocC) {\r\n      //Skip processing on whitespace:\r\n      while (curLocC != endLocC && isWhiteSpaceOrPunctuation(curLocC)) {\r\n         resultC.append(1, *curLocC);\r\n         ++curLocC;\r\n         }\r\n      if (curLocC == endLocC) return;\r\n      //Now do the non-whitespace processing:\r\n      if (!(replaceCaseSensitive() || replaceNonCaseSensitiveBegin() ||\r\n                  replaceRepeatingStrings() || replaceAsterisks())) {\r\n         resultC.append(1, *curLocC);\r\n         ++curLocC;\r\n         }\r\n      }\r\n   }\r\n\r\n\r\nint main() {\r\n   static Reformatter reformatter;\r\n\r\n   //First, some tests to show that it is working:\r\n   wstring str = L\"I GOTTEN PHB lettuce!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   str = L\"I GOTTEN phb lettuce!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   str = L\"Not Poopoop, and PoopPoop nInComPoop!!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   str = L\"My PHB is such a poophead. It's gotten worse since his promotion\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   //Changed the following to 'phb.com', so that program checks for more general case.\r\n   //phb.com redirects to another site in reality, but there is no reason not to check\r\n   //against being a URL in the implied design requirements.\r\n   cout << \"NOTE THAT 'boss' BECOMES CAPPED OR NON-CAPPED DEPENDING ON THE SURROUNDING WORDS:\"\r\n               << endl << \"ALSO, 'PHB' BECOMES 'boss' DEPENDING UPON WHETHER 'PHB' IS BY ITSELF.\"\r\n               << endl;\r\n   str = L\"MY PHB HAS started his new BLOG PHB_BLOG.com. And PHBBlog.com! \"\r\n               \"He's GOTTEn TO BE SUCH A MISBEGOTTEN POOPHEAD!\";\r\n   reformatter.reformat(str);\r\n   wcout << L\"INPUT:  \" << str << endl;\r\n   reformatter.outputResult();\r\n\r\n   //Now do an timing run:\r\n   TimerLowRes timerLowRes;\r\n   TimerHighRes timerHighRes;\r\n   LARGE_INTEGER timeRighRes;\r\n   vector<float> timeList;\r\n   int numIterations = 100;\r\n   int totalTests = 10;\r\n   for (int numTimes=0; numTimes<totalTests; ++numTimes) {\r\n      timerLowRes.start();\r\n      timerHighRes.start();\r\n      for (int x=0; x<numIterations; ++x) {\r\n         //reformatter.reformat(L\"MY PHB HAS started his new BLOG PHB_BLOG.com. And PHBBlog.com! He's gotten TO BE \"\r\n         //            \" SUCH A MISBEGOTTEN POOPHEAD!\");\r\n         reformatter.reformat(L\"My PHB is such a poophead. It's gotten worse since his promotion\");\r\n         //reformatter.reformat(L\"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\");\r\n         //reformatter.reformat(L\"I GOTTEN PHB lettuce!\");\r\n         //reformatter.reformat(L\"Not Poopoop, but PoopPoop!!\");  //Note that this will handle subsequent 'poops' correctly if 2 'p's together at end.\r\n         }\r\n      timeRighRes = timerHighRes.stop();\r\n      clock_t timeLowRes(timerLowRes.stop());\r\n      cout << \"low res time: \" << timeLowRes << \" milliseconds\" << endl;\r\n      cout << \"high res time: \" << timeRighRes.QuadPart/(float)1000 << \" milliseconds\" << endl;\r\n      timeList.push_back(timeRighRes.QuadPart/(float)1000);\r\n      }\r\n   float avg = 0.0;\r\n   for (int i=0; i<totalTests; ++i) avg += timeList[i];\r\n   avg = avg/totalTests;\r\n   cout << endl << \"Average = \" << avg << \" milliseconds\";\r\n   cout << endl << \"Enter any key, then an 'Enter' to exit: \";\r\n   cin >> timeRighRes.QuadPart; //Junk way to exit console, but good enough!\r\n   return 0;\r\n   }\n\r\nDidn't use any goto's, for those who are counting, but wouldn't have given a crap if I did.\n\r\nIt might be possible to streamline the logic in the replaceCaseSensitive and other replacement routines.  All the 'found' checking and setting seemed excessive, but it worked and I moved on.\n\r\nDavid\r\n", "id": "2_1158872_2", "owner_tier": 0.3, "score": 5.0}, {"content": "\r\n    EDIT: Ah, the wonders sleep can do.  Even though a solution was already chosen, I had an idea to improve my solution.\n\r\nThis was fun.  I don't get to use regex too much in my day to day sadly.\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\n\r\npublic class BadWordFilter\r\n{\r\n    public static void Replace(ref string input,\r\n        IDictionary<string, string> badWordMap)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(input))\r\n            throw new ArgumentException(nameof(input),\r\n                \"String cannot be null, empty, or whitespace.\");\r\n\r\n        foreach (KeyValuePair<string, string> badWord in badWordMap)\r\n            ReplaceBadWord(ref input, badWord);\r\n    }\r\n\r\n    private static void ReplaceBadWord(ref string input,\r\n        KeyValuePair<string, string> badWord)\r\n    {\r\n        if (string.IsNullOrWhiteSpace(badWord.Key))\r\n            throw new ArgumentException(nameof(badWord.Key),\r\n                \"Key cannot be null, empty, or whitespace.\");\r\n\r\n        string pattern = GetReplacementPattern(badWord.Key);\r\n        MatchEvaluator evaluator = match =>\r\n        {\r\n            string replacement = badWord.Value;\r\n            if (match.Value == match.Value.ToUpper())\r\n            {\r\n                if (badWord.Key != badWord.Key.ToUpper())\r\n                    replacement = badWord.Value.ToUpper();\r\n            }\r\n            else if (match.Value[0] == char.ToUpper(match.Value[0]))\r\n                replacement = char.ToUpper(badWord.Value[0]) + badWord.Value.Substring(1);\r\n            return replacement;\r\n        };\r\n        input = Regex.Replace(input, pattern, evaluator, RegexOptions.IgnoreCase);\r\n    }\r\n\r\n    private static string GetReplacementPattern(string badWordKey)\r\n    {\r\n        StringBuilder pattern = new StringBuilder(\r\n            $@\"(?:\\b){badWordKey.Trim('*')}\"\r\n        );\r\n        if (badWordKey.StartsWith(\"*\"))\r\n            pattern.Insert(6, @\"\\w*\", 1);\r\n        if (badWordKey.EndsWith(\"*\"))\r\n            pattern.Append(@\"\\w*\");\r\n        return pattern.ToString();\r\n    }\r\n}\n\r\nYou use it like this:\nC#\n\r\nstatic void Main(string[] args)\r\n{\r\n    Dictionary<string, string> badWords = new Dictionary<string, string>()\r\n    {\r\n        {\"poop*\", \"p**phead\"},\r\n        {\"*HB\", \"boss\"},\r\n        {\"gotten\", \"become\"},\r\n        {\"*crap*\", \"taco supreme\"}\r\n    };\r\n    string input = \"My PHB is such a poophead. It's gotten worse since his promotion.  In fact you might call him a supercraphead!\";\r\n    BadWordFilter.Replace(ref input, badWords);\r\n    Console.WriteLine(input);\r\n    Console.ReadKey();\r\n}\r\n//Output:\r\n//My boss is such a p**phead.  It's become worse since his promotion.  In fact you might call him a taco supreme!\n\r\nHandles *text, text*, and *text* wildcards.  Will not capitalize a replacement for a word that is by default capitalized (ex. PHB -> boss). Maintains first-letter capitalization when appropriate.  Also support any regex code you'd like to put in the key since I directly inject it.  For example {\"p[oO0]+p*\", \"p**phead\"} will catch poop, poOp, p0OPhead, or even PoO0o0Ophead.\r\n", "id": "2_1157850_7", "owner_tier": 0.3, "score": 0}, {"content": "\r\n    After a little more refactoring and such:\n\nC#\n\r\nPIEBALD.Type.ReplaceOmatic replacer = \r\n  new PIEBALD.Type.ReplaceOmatic\r\n  (\r\n    new System.Tuple<string,string> ( \"PHB!\"        , \"boss!\"  ) \r\n  ,\r\n    new System.Tuple<string,string> ( \"gotten\"      , \"become\" ) \r\n  ,\r\n    new System.Tuple<string,string> ( \"*p[o0]{2}p*\" , \"p**p\"   ) \r\n  ) ;\r\n\r\nstring intext = \"My PHB is such a poophead. It's gotten worse since his promotion. My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\" ;\r\n\r\nstring outtext = intext ;\r\n\r\nint total = replacer.Replace ( ref outtext ) ;\r\n\r\nSystem.Console.WriteLine ( \"{0}\\n{1}\\n{2}\" , intext , total , outtext ) ;\n\r\nProduces: \n\n \n\r\nMy PHB is such a poophead. It's gotten worse since his promotion. My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\r\n5\r\nMy boss is such a p**phead. It's become worse since his promotion. My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\n\n\nThis just in (2016-11-27): ReplaceOmatic[^]\n\n\nLate breaking news (2016-11-28):\r\nI now have it tracking how many characters were replaced in each section, so it will stop applying replacements once the entire section has been replaced.\r\nThis is a reason to sort the more-frequently-hit replacements to the front of the List.\n\r\nAnd I've tightened up the code for copying characters to a StringBuilder.\n\r\nPart of the change:\nC#\n\r\nint r = 0 ;\r\n\r\n/* Apply ReplacementSpecs to the section until we run out of them or we've replaced the entire section. */\r\nfor ( int i = 0 ; ( i < this.rep.Count ) && ( r < Candidate.Length ) ; i++ )\r\n{\r\n  /* Track how many characters have been replaced so far. */\r\n  r += this.rep [ i ].Replace ( ref temp ) ;\r\n}\r\n\n\n\nNews flash! (2016-11-30):\r\nAdded Sorting and updated the Article and uploaded the latest code (I hope).\r\n", "id": "2_1157869_9", "owner_tier": 0.7, "score": 0}, {"content": "\r\n    I saw that no one addressed JavaScript jet...\r\nI did...\nJavaScript\n\r\nfunction Bad2Good(text)\r\n{\r\n\tvar T = {\r\n\t\t'poophead': 'p**phead',\r\n\t\t'PHB!': 'boss',\r\n\t\t'gotten': 'become',\r\n\t\t'poop*': 'p**p',\r\n\t\t'*poop': 'p**p'\r\n\t};\r\n\r\n\tfor (var prop in T)\r\n\t{\r\n\t\tvar flags = 'ig';\r\n\r\n\t\t// starts with\r\n\t\tif (prop[prop.length-1] == '*')\r\n\t\t{\r\n\t\t\tprop = /(\\s|[!?.,])poop(\\w*)/;\r\n\t\t}\r\n\r\n\t\t// ends with\r\n\t\tif (prop[0] == '*')\r\n\t\t{\r\n\t\t\tprop = /(\\w*)poop(\\s|[!?.,])/;\r\n\t\t}\r\n\r\n\t\t// case sensitive\r\n\t\tif (prop[prop.length - 1] == '!')\r\n\t\t{\r\n\t\t\tflags = 'g';\r\n\t\t\tprop = prop.substr(0, prop.length - 1);\r\n\t\t}\r\n\r\n\t\ttext = text.replace(new RegExp(prop, flags), function (match, p1, p2, p3, p4)\r\n\t\t{\r\n\t\t\tif (Number.isInteger(p1))\r\n\t\t\t{\r\n\t\t\t\tif (match.toUpperCase() == match)\r\n\t\t\t\t{\r\n\t\t\t\t\t// case sensitive\r\n\t\t\t\t\tif (T[match.toLowerCase()] == undefined)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (T[match + '!']);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// shouting\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (T[match.toLowerCase()].toUpperCase());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// normal\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (T[match]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// starts with\r\n\t\t\t\tif(/(\\s|[!?.,])/.test(p1))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatch = match.substr(p1.length, match.length - p1.length - p2.length);\r\n\r\n\t\t\t\t\treturn (p1 + ((match.toUpperCase() == match) ? T[match.toLowerCase() + '*'].toUpperCase() : T[match.toLowerCase() + '*']) + p2);\r\n\t\t\t\t}\r\n\t\t\t\t// ends with\r\n\t\t\t\telse if (/(\\s|[!?.,])/.test(p2))\r\n\t\t\t\t{\r\n\t\t\t\t\tmatch = match.substr(p1.length, match.length - p1.length - p2.length);\r\n\r\n\t\t\t\t\treturn (p1 + ((match.toUpperCase() == match) ? T['*' + match.toLowerCase()].toUpperCase() : T['*' + match.toLowerCase()]) + p2);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (match);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn (text);\r\n}\n\r\nGot home. Got time. Saw some of my bugs and smashed them...\nJavaScript\n\r\nfunction Bad2Good(text)\r\n{\r\n\tvar T = {\r\n\t\t'PHB!': 'boss',\r\n\t\t'gotten': 'become',\r\n\t\t'poop*': 'p**p',\r\n\t\t'*poop': 'p**p'\r\n\t};\r\n\r\n\tfor (var prop in T)\r\n\t{\r\n\t\tvar flags = 'ig';\r\n\r\n        // case sensitive\r\n\t\tif (prop[prop.length - 1] == '!')\r\n\t\t{\r\n\t\t\tflags = 'g';\r\n\t\t\tprop = prop.substr(0, prop.length - 1);\r\n\t\t}\r\n\r\n\t\t// starts with\r\n\t\tif (prop[prop.length - 1] == '*')\r\n\t\t{\r\n\t\t\tprop = '(\\\\b)' + prop.substr(0, prop.length - 1) + '(\\\\w*)(\\\\b)';\r\n\t\t} \r\n        \r\n        // ends with\r\n\t\tif (prop[0] == '*')\r\n\t\t{\r\n\t\t\tprop = '(\\\\b)(\\\\w*)' + prop.substr(1, prop.length) + '(\\\\b)';\r\n\t\t}\r\n\r\n\t\ttext = text.replace(new RegExp(prop, flags), function (match, len, p1)\r\n\t\t{\r\n            var lookup;\r\n            var replace;\r\n            var good;\r\n\r\n            if(Number.isInteger(len))\r\n            {\r\n                replace = match;\r\n                lookup = match;\r\n            }\r\n            else \r\n            {\r\n                if(match.startsWith(p1)) \r\n                {\r\n                    replace = match.replace(p1, '');\r\n                    lookup = '*' + replace;\r\n                }\r\n                else\r\n                {\r\n                    replace = match.replace(p1, '');\r\n                    lookup = replace + '*';\r\n                }\r\n            }\r\n\r\n            good = T[lookup.toLowerCase()] || T[lookup + '!'];\r\n\r\n            if(T[lookup + '!'] == undefined)\r\n            {\r\n                if((replace.toUpperCase() == replace))\r\n                {\r\n                    good = good.toUpperCase();\r\n                }\r\n                else if((replace.toLowerCase() == replace))\r\n                {\r\n                    good = good.toLowerCase();\r\n                }\r\n            }\r\n\r\n            return(match.replace(replace, good));\r\n\t\t});\r\n\t}\r\n\r\n\treturn (text);\r\n}\n", "id": "2_1158031_3", "owner_tier": 0.5, "score": 0}, {"content": "\r\n    Quick and dirty Javascript\n\nJavaScript\n\r\nvar bad = [\"poop*\", \"PHB!\", \"gotten\"];\r\nvar replacement = [\"p**p\", \"boss\", \"become\"];\r\nfunction escapeRegExp(str) {\r\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\nfunction replaceBad(sentence){\r\n\treturn sentence.split(/\\b/).map(w => {\r\n\t\tfor(var i=0, m=bad.length; i<m; i++){\r\n\t\t\tvar badToken = bad[i];\r\n\t\t\tif(badToken.slice(-1)==='*') { // ends with *\r\n\t\t\t\treturn w.replace(new RegExp('^' + escapeRegExp(badToken.slice(0,-1)) + '(.*)$', 'i'), replacement[i]+'$1');\r\n\t\t\t}\r\n\t\t\tif(badToken.slice(0)==='*') { // starts with *\r\n\t\t\t\treturn w.replace(new RegExp('^(.*)'+ escapeRegExp(badToken.slice(1)) + '$', 'i'), '$1' + replacement[i]);\r\n\t\t\t}\r\n\t\t\tif(badToken.slice(-1)==='!') { // ens with !\r\n\t\t\t\treturn w.replace(new RegExp('^'+ escapeRegExp(badToken.slice(0,-1)) + '$', ''), replacement[i]);\r\n\t\t\t}\r\n\t\t\treturn w.replace(new RegExp('^'+badToken+'$', 'i'), replacement[i]);\r\n\t\t}\r\n\t}).join('');\r\n}\r\n\r\nvar test=['Hello poophead; glad your PHB has \"gotten\" less rotten',\r\n'Hi poopheadpoop; glad your PhB has \"undergotten\" less NOPHB'\r\n];\r\n\r\ntest.forEach(s => {\r\n\tconsole.log(s + ' => ' + replaceBad(s)); \r\n})\n", "id": "2_1158222_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    Only spotted this 20 min ago, so hopefully not too late to the tea party!\n\r\nC# code allows for individual word case sensitivity + shortcut override (in bonus requirement). All cases use the same bad word replacement extension methods. ReplaceWords string extension for a set of words or ReplaceText string extension for single word granularity.\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\n\r\nnamespace BadWordFilter\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            FirstTest();\r\n            BonusTest();\r\n\r\n            Console.WriteLine(\"-- Press any key to exit --\");\r\n            Console.ReadKey();\r\n        }\r\n\r\n        private static void FirstTest()\r\n        {\r\n            var badWords = new Dictionary<string, tuple<string, bool>>()\r\n            {\r\n                {\"poophead\", new Tuple<string, bool>(\"p**phead\", false)},\r\n                {\"PHB\", new Tuple<string, bool>(\"boss\", false)},\r\n                {\"gotten\",new Tuple<string, bool>(\"become\", false) }\r\n            };\r\n\r\n            string badMessage = \"My        PHB is such a poophead. It's gotten worse since his promotion\";\r\n            string goodMessage = badMessage.ReplaceWords(badWords, filtered: false);\r\n\r\n            Console.WriteLine(\"First Test\");\r\n            Console.WriteLine(\"==========\");\r\n            Console.WriteLine($\"Before: {badMessage}\");\r\n            Console.WriteLine($\"After:  {goodMessage}\");\r\n            Console.WriteLine();\r\n\r\n            badWords = new Dictionary<string, tuple<string, bool>>()\r\n            {\r\n                {\"POOPHEAD\", new Tuple<string, bool>(\"P**PHEAD\", true)},\r\n                {\"poophead\", new Tuple<string, bool>(\"p**phead\", false)},\r\n                {\"PHB\", new Tuple<string, bool>(\"boss\", true)}\r\n            };\r\n\r\n            badMessage = \"My PHB is such a POOPHEAD!\";\r\n            goodMessage = badMessage.ReplaceWords(badWords, filtered: false);\r\n\r\n            Console.WriteLine($\"Before: {badMessage}\");\r\n            Console.WriteLine($\"After:  {goodMessage}\");\r\n            Console.WriteLine();\r\n\r\n        }\r\n\r\n        private static void BonusTest()\r\n        {\r\n            var badWords = new Dictionary<string, tuple<string, bool>>()\r\n            {\r\n                {\"POOP*\", new Tuple<string, bool>(\"P**P\", true) },\r\n                {\"poop*\", new Tuple<string, bool>(\"p**p\", false) },\r\n                {\"PHB!\", new Tuple<string, bool>(\"boss\", true) },\r\n                {\"gotten\",new Tuple<string, bool>(\"become\", true) }\r\n            };\r\n\r\n            string badMessage = \"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\";\r\n            string goodMessage = badMessage.ReplaceWords(badWords, filtered: true);\r\n\r\n            Console.WriteLine(\"Bonus Test\");\r\n            Console.WriteLine(\"==========\");\r\n            Console.WriteLine($\"Before: {badMessage}\");\r\n            Console.WriteLine($\"After:  {goodMessage}\");\r\n            Console.WriteLine();\r\n        }\r\n    }\r\n\r\n    public static class StringExtension\r\n    {\r\n        private static readonly string[] spaceSplitChar = { \" \" };\r\n        private static readonly char[] wordSplitChars = @\"?<=[\\.!\\?])\".ToCharArray();\r\n\r\n        public static string ReplaceWords(this string input, Dictionary<string, tuple<string, bool>> badWords, bool filtered = false, bool trimWhitespaces = true)\r\n        {\r\n            if (string.IsNullOrEmpty(input))\r\n                return input;\r\n\r\n            foreach (var word in badWords)\r\n                input = input.ReplaceText(word.Value.Item1, word.Key, filtered: filtered, isCaseSensitive: word.Value.Item2, trimWhitespaces: trimWhitespaces);\r\n\r\n            return input;\r\n        }\r\n\r\n        public static string ReplaceText(this string input, string replaceText, string findText = \"\", bool filtered = false, bool isCaseSensitive = false, bool trimWhitespaces = true)\r\n        {\r\n            if (string.IsNullOrEmpty(input))\r\n                return input;\r\n\r\n            var sb = new StringBuilder();\r\n            bool isMatchStart = false, \r\n                 isMatchEnd = false;\r\n            StringComparison compareMode = isCaseSensitive ? StringComparison.InvariantCulture : StringComparison.InvariantCultureIgnoreCase;\r\n\r\n            if (filtered)\r\n            {\r\n                isMatchStart = findText.EndsWith(\"*\");\r\n                isMatchEnd = findText.StartsWith(\"*\");\r\n                compareMode = findText.EndsWith(\"!\") ? StringComparison.InvariantCulture : compareMode;\r\n                findText = findText.Trim(new[] { '*', '!' });\r\n            }\r\n\r\n            int lenOldValue = findText.Length,\r\n                curPosition = 0,\r\n                idxNext = input.IndexOf(findText, compareMode);\r\n\r\n            while (idxNext >= 0)\r\n            {\r\n                if (isMatchStart || !isMatchEnd)\r\n                {\r\n                    if (input.Substring(idxNext - 1, 1).Equals(\" \"))\r\n                        sb.Append(input, curPosition, idxNext - curPosition)\r\n                          .Append(replaceText);\r\n                }\r\n                else if (isMatchEnd)\r\n                {\r\n                    sb.Append(input, curPosition, idxNext - curPosition)\r\n                      .Append(curPosition < input.Length && input.Substring(curPosition, curPosition + 1)[0].IsEndChar() ? findText : replaceText);\r\n                }\r\n\r\n                curPosition = idxNext + lenOldValue;\r\n                idxNext = input.IndexOf(findText, curPosition, compareMode);\r\n            }\r\n            sb.Append(input, curPosition, input.Length - curPosition);\r\n\r\n            input = sb.ToString();\r\n            if (trimWhitespaces)\r\n                input= input.TrimCharacter(' ');\r\n\r\n            return input;\r\n        }\r\n\r\n        public static bool IsEndChar(this char c)\r\n            => wordSplitChars.Contains(c);\r\n\r\n        public static string TrimCharacter(this string input, char c)\r\n            => string.Join(c.ToString(), input.Split(c).Where(str => str != string.Empty).ToArray());\r\n\r\n    }\r\n}\n\r\nOutput from execution:\n \n\r\nFirst Test\r\n==========\r\n\r\nBefore: My        PHB is such a poophead. It's gotten worse since his promotion\r\nAfter:  My boss is such a p**phead. It's become worse since his promotion\r\n\r\nBefore: My PHB is such a POOPHEAD!\r\nAfter:  My boss is such a P**PHEAD!\r\n\r\n\r\nBonus Test\r\n==========\r\n\r\nBefore: My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\r\nAfter:  My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\r\n\r\n-- Press any key to exit --\n\r\nThis code is built for efficiency, so no RegEx used! ;)\n\r\n[edit: hopefully I have fixed all the weird stuff when code pasted in...]\r\n", "id": "2_1158266_12", "owner_tier": 0.5, "score": 0}, {"content": "\r\n    VISUAL PROLOG 7.5 Solution.\n\r\nNote:  the bad_nice/2 clauses can be moved to an external file for maintenance independent of the rest of the code.\n\r\nThis could be tidied up more, but I considered speed of submission to be the priority here.\n\r\nHarrison Pratt\n\n\n\n\r\nclass predicates\r\n    badWordFix : ( string TextToFilter ) -> string FixedText.\r\nclauses\r\n    badWordFix( Text ) = FixedText :-\r\n        Splitters = \" .,:!\",\r\n        FixedText = fixText ( Text, Splitters, \"\" ).\r\n\r\n        class predicates\r\n            fixText : ( string, string Separators, string Temp ) -> string.\r\n        clauses\r\n            fixText( \"\",_,S ) = S :-!.\r\n            fixText( S, Separators, Temp ) = FixedText :-\r\n                string::splitStringBySeparators(S,Separators,HeadStr,CurrSep,Rest ),\r\n                !,\r\n                FixedText = fixText( Rest, Separators, string::concat( Temp, filteredWord(HeadStr), string::charToString(CurrSep) )).\r\n            fixText( S, Separators, Temp ) = FixedText :-\r\n                FixedText = fixText(\"\",Separators,string::concat(Temp,S )).\r\n\r\n    class predicates\r\n        filteredWord : ( string ) -> string .\r\n    clauses\r\n        filteredWord( S ) = NiceWord :-\r\n            CleanS = stripPrefix( stripSuffix(S,\"*\"), \"*\" ),\r\n            bad_nice( CleanS, NiceWord ), !.\r\n        filteredWord( S ) = S.\r\n\r\n    class predicates\r\n        bad_nice : ( string, string [out] ) determ.\r\n    clauses\r\n        bad_nice( \"poophead\", \"p***head\" ).\r\n        bad_nice( \"PHB\", \"boss\" ).\r\n        bad_nice( \"gotten\", \"become\" ).\r\n\r\n    class predicates\r\n        stripPrefix : ( string, string ) -> string.\r\n    clauses\r\n        stripPrefix( S, Pre ) = StripStr :-\r\n            string::hasPrefix(S,Pre,StripStr), !.\r\n        stripPrefix( S, _ ) = S.\r\n    \r\n    class predicates\r\n        stripSuffix : ( string, string ) -> string.\r\n    clauses    \r\n        stripSuffix( S, Suff ) = StripStr :-\r\n            string::hasSuffix(S,Suff,StripStr), !.\r\n        stripSuffix( S, _ ) = S.\n", "id": "2_1158270_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    I'm a fan of clean code.\r\nWhich for me is at least:\r\n    - It should be expressive-> meaningful names\r\n    - Smaller is better -> methods should be short\r\n    - Can be easily extended by any other developer -> if requiremets changes easy to adapt\r\n    - Reading the code should be pleasant -> because you can follow the logic without overstress your brain\n\r\nHere it is (BadWordsMatch.cs):\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\n\r\nnamespace BadWords\r\n{\r\n    public enum eHow { easy, hard };\r\n\r\n    public class BadWordsMatchAndReplace\r\n    {\r\n            public enum eMatchMode { startsWith, Endswith, Equals };\r\n            public struct sWildCardAndCase\r\n            {\r\n                public eMatchMode matchMode;\r\n                public bool respectCase;\r\n                public string key;\r\n            }\r\n\r\n            public static Dictionary<sWildCardAndCase, string> dictBadWordsEasy = new Dictionary<sWildCardAndCase, string>(){\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key =\"poophead\"}, \"p**phead\"},\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key =\"PHB\"}, \"boss\"},\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key =\"gotten\"} , \"become\"}\r\n            };\r\n\r\n            public static Dictionary<sWildCardAndCase, string> dictBadWordsHard = new Dictionary<sWildCardAndCase, string>(){\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.startsWith, respectCase = false, key = \"poop\" }, \"p**p\" },\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = true, key = \"PHB\" }, \"boss\" },\r\n                {new sWildCardAndCase() { matchMode = eMatchMode.Equals, respectCase = false, key = \"gotten\" }, \"become\" }\r\n\r\n           };\r\n\r\n            // shouting is retrieved by allowing an exclamation mark in words and later on compared to last char therein\r\n            public static Regex r = new Regex(@\"([!\\w])+\", RegexOptions.None);\r\n            public static bool shouting = false;\r\n\r\n            /// <summary>\r\n            /// checks an input sentence for bad words and replaces them by safer expressions\r\n            /// </summary>\r\n            /// <param name=\"input\">sentence to check</param>\r\n            /// <param name=\"how\">easy or hard substitution rule</param>\r\n            /// <returns>corrected string</returns>           \r\n            /// \r\n            public static string MatchAndReplace(string input, eHow how)\r\n            {\r\n\r\n                string output = input;\r\n                string s = string.Empty;\r\n                shouting = false;\r\n\r\n                Dictionary<sWildCardAndCase, string> baseDict = (how == eHow.easy ? dictBadWordsEasy : dictBadWordsHard);\r\n                Match m = r.Match(input);\r\n\r\n                while (m.Success)\r\n                {\r\n                    s = m.Value;\r\n                    bool found = false;\r\n\r\n                    foreach (KeyValuePair<sWildCardAndCase, string> kvp in baseDict)\r\n                    {\r\n                        bool respectCase = kvp.Key.respectCase;\r\n                        if ( s.EndsWith(\"!\"))\r\n                        {\r\n                            // case insensitive and make replacement uppercase\r\n                            shouting = true;\r\n                            respectCase = false;\r\n                        }\r\n                        // looks for matches under given constraints and updates output accordingly\r\n                        found = ProcessWord(s, kvp.Key.key, respectCase, kvp.Key.matchMode, kvp.Value, ref output);\r\n                        if (found) break;\r\n                    }\r\n                    m = m.NextMatch();\r\n                }\r\n                return output;\r\n \r\n\r\n            }\r\n\r\n            /// <summary>\r\n            /// looks for a match of word under given constraints and updates output accordingly\r\n            /// </summary>\r\n            /// <param name=\"word\">word from input string</param>\r\n            /// <param name=\"key\">bad word</param>\r\n            /// <param name=\"respectCase\">match only case exactly</param>\r\n            /// <param name=\"matchMode\">wildcard specifier</param>\r\n            /// <param name=\"value\">replacement</param>\r\n            /// <param name=\"output\">output -> output with replacement</param>\r\n            /// <returns>no match -> false else true</returns>\r\n            ///             \r\n            private static bool ProcessWord(string word, string key, bool respectCase, eMatchMode matchMode, string value, ref string output)\r\n            {\r\n                if (respectCase && !word.Contains(key)) return false;\r\n                if (!respectCase && !word.ToLower().Contains(key.ToLower())) return false;\r\n                if (!ConstraintsMet(  word,  key,  respectCase,  matchMode)) {\r\n                    return false;\r\n                }\r\n                if (respectCase)\r\n                {\r\n                    output = output.Replace(key, value);\r\n                }\r\n                else\r\n                {\r\n                    if (word.Any(char.IsUpper))\r\n                        output = output.Replace(key.ToUpper(), value.ToUpper());\r\n                    else if (shouting)\r\n                        output = output.Replace(key, value.ToUpper());\r\n                    else\r\n                        output = output.Replace(key, value);\r\n                }\r\n                return true;\r\n\r\n            }\r\n\r\n            /// <summary>\r\n            /// checks for constraints\r\n            /// </summary>\r\n            /// <param name=\"word\">word from input string</param>\r\n            /// <param name=\"key\">bad word</param>\r\n            /// <param name=\"respectCase\">match only case exactly</param>\r\n            /// <param name=\"matchMode\">wildcard specifier</param>\r\n            /// <returns>constraints met -> true else false</returns>\r\n            ///              \r\n            private static bool ConstraintsMet( string word, string key, bool respectCase, eMatchMode matchMode)\r\n            {\r\n                string wordToCompare = word;\r\n                if (shouting) { wordToCompare = wordToCompare.TrimEnd('!'); };\r\n                switch (matchMode)\r\n                {\r\n                    case eMatchMode.Equals:\r\n                        if (respectCase && !wordToCompare.Equals(key)) { return false; }\r\n                        else if (!respectCase && !wordToCompare.ToLower().Equals(key.ToLower())) { return false; }\r\n                        break;\r\n                    case eMatchMode.startsWith:\r\n                        if (respectCase && !wordToCompare.StartsWith(key)) { return false; }\r\n                        else if (!respectCase && !wordToCompare.ToLower().StartsWith(key.ToLower())) { return false; }\r\n                         break;\r\n                    case eMatchMode.Endswith:\r\n                        if (respectCase && !wordToCompare.EndsWith(key)) { return false; }\r\n                        else if (!respectCase && !wordToCompare.ToLower().EndsWith(key.ToLower())) { return false; }\r\n                        break;\r\n                }\r\n                return true;\r\n\r\n            }\r\n\r\n    }\r\n}\n\n\r\nIt should be self explaining.\r\nMost important is: I concentrate the requirements about case sensitivity and wildcard rules in a data structure which relieves me from looking for *s before or\r\nafter the search key.\r\nFor the 'Easy part' I would not had a need for this but once I made it for the hard\r\npart it's nice to have it for this part too, because the code can be one for both \r\n(C#\n\r\nDictionary<sWildCardAndCase, string> baseDict = (how == eHow.easy ? dictBadWordsEasy : dictBadWordsHard);\n\r\nFor Testing my Code I have provided a little Console Main, which is here (Program.cs):\n\nC#\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\n\r\nnamespace BadWords\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {        \r\n            string input = string.Empty;\r\n            string s = string.Empty;\r\n            string output = string.Empty;\r\n\r\n            while (!(s.Equals(\"q\")))\r\n            {\r\n                while (!(s = Console.ReadLine()).Equals(\".\"))\r\n                {\r\n                    input = input + s;\r\n                }\r\n                Console.WriteLine(\"------------- Easy Match ---------------\"); \r\n                Console.WriteLine(input);\r\n                output = BadWordsMatchAndReplace.MatchAndReplace(input, eHow.easy);\r\n                Console.WriteLine(output);\r\n                Console.WriteLine(\"------------- Bonus Match ---------------\");\r\n                Console.WriteLine(input);\r\n                output = BadWordsMatchAndReplace.MatchAndReplace(input, eHow.hard);\r\n                Console.WriteLine(output);\r\n                Console.WriteLine(\"-------------- Next Input ---------------\");\r\n                s = Console.ReadLine();\r\n                input = s;\r\n\r\n            }\r\n        }\r\n    }\r\n}\n\nUsage: Paste your input (multiline allowed), then type <return>.<return>\r\n        If you want to stop the program then type <return>q<return>\n", "id": "2_1158317_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    I decided to use F#\u2026\n\r\nEach filter specification is converted to a closure that takes a string, potentially sanitises it and returns the good string. To process all words in a string, use Regex.Replace with a MatchEvaluator that runs the filter list over the matched word.\n\nF#\n\r\nopen System\r\nopen System.Text.RegularExpressions\r\n\r\n// Define an active pattern to match a string starting with a prefix and return the remnant of the string\r\nlet (|Prefix|_|) (ignoreCase:bool) (prefix:string) (s:string) =\r\n   let maybePrefix = s.Substring(0, (min prefix.Length s.Length))\r\n   match String.Compare(maybePrefix, prefix, ignoreCase) with\r\n   | 0 -> Some(maybePrefix, s.Substring(prefix.Length))\r\n   | _ -> None\r\n\r\n// Define an active pattern to match a string ending with a suffix and return the remnant of the string\r\nlet (|Suffix|_|) (ignoreCase:bool) (suffix:string) (s:string) =\r\n   let maybeSuffix = s.Substring((max 0 (s.Length - suffix.Length)))\r\n   match String.Compare(maybeSuffix, suffix, ignoreCase) with\r\n   | 0 -> Some(maybeSuffix, s.Substring(0, s.Length - suffix.Length))\r\n   | _ -> None\r\n\r\n// Adjust case of a good word to reflect how the bad word's been used\r\nlet AdjustCase (suffix:string) (badBit:string) (goodWord:string) (ignoreCase:bool) =\r\n   if not ignoreCase then\r\n      goodWord\r\n   else if badBit = suffix.ToUpper() then\r\n      goodWord.ToUpper()\r\n   else if badBit = suffix.ToLower() then\r\n      goodWord.ToLower()\r\n   else\r\n      goodWord\r\n\r\n// Create a filter (a closure of string -> string) from a filter spec (pair of strings, \r\n// first = bad word, second = replacement). Applying the closure to a string will sanitise it.\r\nlet createFilter (spec:string*string) =\r\n   let rec createFilterHelper (badWord:string) (goodWord:string) (ignoreCase:bool) =\r\n      match badWord with\r\n      // Case sensitive?\r\n      | Suffix true \"!\" (_, prefix) -> createFilterHelper prefix goodWord false\r\n      // badWord is a prefix (<string>*)\r\n      | Suffix true \"*\" (_, prefix) ->\r\n         fun (word:string) ->\r\n            match word with\r\n            | Prefix ignoreCase prefix (badBit, restOfWord) -> (AdjustCase prefix badBit goodWord ignoreCase) + restOfWord\r\n            | anyOtherWord -> anyOtherWord\r\n      // badWord is a sufffix (*<string>)\r\n      | Prefix true \"*\" (_, suffix) ->\r\n         fun (word:string) ->\r\n            match word with\r\n            | Suffix ignoreCase suffix (badBit, restOfWord) -> restOfWord + (AdjustCase suffix badBit goodWord ignoreCase)\r\n            | anyOtherWord -> anyOtherWord\r\n      // badWord is fixed\r\n      | anyOtherWord -> \r\n         fun (word:string) ->\r\n            match String.Compare(word, badWord, ignoreCase) with\r\n            | 0 -> AdjustCase badWord word goodWord ignoreCase\r\n            | _ -> word\r\n   // Invoke createFilterHelper\r\n   createFilterHelper (fst spec) (snd spec) true\r\n\r\n// Create a filter list from a spec list\r\nlet createFilters specs = specs |> List.map createFilter\r\n\r\n// Apply a sequence of filters to a word\r\nlet filterAWord filters word = filters |> Seq.fold (fun word filter -> filter word) word\r\n\r\n// Apply a sequence of filters to each word in a string\r\nlet filterWords filters text = Regex.Replace(text, \"\\w+\", MatchEvaluator(fun regexMatch -> filterAWord filters regexMatch.Value))\r\n\r\n// These are my test filter specs\r\nlet filterSpecs = [ (\"poop*\", \"p**p\"); (\"PHB!\", \"boss\") ; (\"gotten\", \"become\") ]\r\n\r\n// And my test filters\r\nlet compiledFilters = createFilters filterSpecs\r\n\r\nlet tests = \r\n   printfn \"Poophead -> p**phead = %b\" ((filterAWord compiledFilters \"Poophead\") = \"p**phead\")\r\n   printfn \"PHB -> boss = %b\" ((filterAWord compiledFilters \"PHB\") = \"boss\")\r\n   printfn \"Phb -> Phb = %b\" ((filterAWord compiledFilters \"Phb\") = \"Phb\")\r\n   printfn \"gotten -> become = %b\" ((filterAWord compiledFilters \"gotten\") = \"become\")\r\n   printfn \"<long string=\"\"> - %b\" ((filterWords compiledFilters \"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\") = \"My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\")\r\n</long></string></string>\n", "id": "2_1158506_1", "owner_tier": 0.3, "score": 0}, {"content": "\nNOTE: This is a performance summary comparison of the above C# solutions only\n\r\n** Updated 2/12/16: Stuart Dootson supplied test project, so timings updated.\n\r\nI was curious to see how the other C# solutions compared performance wise to my own, so I build a test bed that you can download[^] and try yourself. I balanced out all the solutions so they ran equally against the same test strings.\n\nDisclaimer: I did not check each solution to see if they all gave the same output or not. I have now run tests on each of the solutions and 3 of them fail the benchmark set. (I suggest that the authors of solutions 3, 5 & 12 download the link above and check for errors.)\n\r\nHere are the results (best to worse ranked by average) on my dev machine compiled in Release Mode and run from the command line.\n\r\n(Note: Results will differ for you based on your system configuration)\n\r\nAfter the initial positioning of results and tweaks to all the tests (v2), I felt that I could improve my results a little, so I've made some minor changes (can be found in the download link above), and the revised results are now:\n\n \n\r\n-----------------------------------------------------------------------------------\r\n \r\nTests run:        10\r\nIterations/test:  100\r\nTotal executions: 1,000\r\n \r\nBasic Test\r\n \r\n   Solution 10   : MIN:  0.72670 ms | MAX:  0.96770 ms | AVG:  0.75483 ms\r\n   Solution 1    : MIN:  1.17980 ms | MAX:  2.08300 ms | AVG:  1.30762 ms\r\n   Solution 3    : MIN:  2.92230 ms | MAX:  3.71300 ms | AVG:  3.03632 ms\r\n   Solution 8    : MIN:  3.97410 ms | MAX:  4.34740 ms | AVG:  4.06542 ms\r\n   Solution 12   : MIN:  4.97950 ms | MAX:  5.31250 ms | AVG:  5.04871 ms\r\n   Solution 13*2 : MIN:  7.2594 ms  | MAX: 10.2251 ms  | AVG:  8.18209 ms\r\n   Solution 2    : MIN:  7.33320 ms | MAX:  8.42080 ms | AVG:  7.63468 ms\r\n   Solution 13*1 : MIN:  8.4053 ms  | MAX: 14.0585 ms  | AVG: 10.4869 ms\r\n   Solution 5    : MIN: 14.79730 ms | MAX: 17.29360 ms | AVG: 15.54762 ms\r\n \r\nBonus Test\r\n \r\n   Solution 10   : MIN:  1.08750 ms | MAX:  1.13540 ms | AVG:  1.10539 ms\r\n   Solution 1    : MIN:  1.09130 ms | MAX:  1.35580 ms | AVG:  1.15636 ms\r\n   Solution 3    : MIN:  2.95310 ms | MAX:  3.38000 ms | AVG:  3.04058 ms\r\n   Solution 8    : MIN:  5.37370 ms | MAX:  5.74020 ms | AVG:  5.46218 ms\r\n   Solution 12   : MIN:  7.44160 ms | MAX:  7.72250 ms | AVG:  7.50184 ms\r\n   Solution 13*2 : MIN:  7.4998 ms  | MAX: 12.9918 ms  | AVG:  8.99166 ms\r\n   Solution 13*1 : MIN:  8.2866 ms  | MAX: 11.5506 ms  | AVG:  9.42119 ms\r\n   Solution 2    : MIN:  8.54510 ms | MAX:  8.86510 ms | AVG:  8.64252 ms\r\n   Solution 5    : MIN: 16.79520 ms | MAX: 17.75920 ms | AVG: 17.19089 ms\r\n \r\n*1 F#Solution\r\n*2 PreCompiledF#Solution\r\n-----------------------------------------------------------------------------------\r\n \r\nTests run:        10\r\nIterations/test:  1000\r\nTotal executions: 10,000\r\n \r\nBasic Test\r\n \r\n   Solution 10   : MIN:   7.24660 ms | MAX:   7.52710 ms | AVG:   7.35793 ms\r\n   Solution 1    : MIN:  10.38490 ms | MAX:  10.72050 ms | AVG:  10.53257 ms\r\n   Solution 3    : MIN:  29.32480 ms | MAX:  29.52170 ms | AVG:  29.41673 ms\r\n   Solution 8    : MIN:  39.87840 ms | MAX:  40.39850 ms | AVG:  40.05387 ms\r\n   Solution 12   : MIN:  49.83420 ms | MAX:  50.64540 ms | AVG:  50.08076 ms\r\n   Solution 2    : MIN:  73.15800 ms | MAX:  74.28660 ms | AVG:  73.62445 ms\r\n   Solution 13*2 : MIN:  78.6023 ms  | MAX:  93.5715 ms  | AVG:  83.0625 ms\r\n   Solution 13*1 : MIN:  88.4249 ms  | MAX:  93.8609 ms  | AVG:  90.9543 ms\r\n   Solution 5    : MIN: 140.52420 ms | MAX: 148.83820 ms | AVG: 143.44404 ms\r\n \r\n\r\nBonus Test\r\n \r\n   Solution 1    : MIN:   9.54210 ms | MAX:  10.12520 ms | AVG:   9.72796 ms\r\n   Solution 10   : MIN:  10.84060 ms | MAX:  11.22680 ms | AVG:  10.94738 ms\r\n   Solution 3    : MIN:  29.66310 ms | MAX:  30.13180 ms | AVG:  29.79657 ms\r\n   Solution 8    : MIN:  54.05920 ms | MAX:  59.03390 ms | AVG:  56.43869 ms\r\n   Solution 12   : MIN:  74.48620 ms | MAX:  75.41370 ms | AVG:  74.66223 ms\r\n   Solution 13*2 : MIN:  78.3943 ms  | MAX:  98.3158 ms  | AVG:  83.7617 ms\r\n   Solution 2    : MIN:  87.62770 ms | MAX:  92.20400 ms | AVG:  91.17817 ms\r\n   Solution 13*1 : MIN:  87.9642 ms  | MAX:  99.3946 ms  | AVG:  91.8193 ms\r\n   Solution 5    : MIN: 168.75850 ms | MAX: 201.33640 ms | AVG: 175.94069 ms\r\n\r\n*1 F#Solution\r\n*2 PreCompiledF#Solution\r\n-----------------------------------------------------------------------------------\n\nNOTE: with a small adjustment to the test to better reflect real-world examples, many of the solutions received a performance gain.\n\r\nLastly, if I have not correctly used a solution, please let me know so that I can update results. If any authors make changes, also please let me know and I will make sure that the tests are re-run and results published.\n\r\n* old test: download[^]\r\n* old v2 test: download[^]\r\n", "id": "2_1158646_6", "owner_tier": 0.5, "score": 0}, {"content": "\r\n    A Haskell solution\u2026 Essentially a rough translation of my F# one!\n\n\n\r\n{-# LANGUAGE OverloadedStrings, TemplateHaskell, QuasiQuotes #-}\r\n\r\nmodule Main where\r\n\r\nimport Criterion.Main\r\nimport Data.CaseInsensitive (mk, CI)\r\nimport Data.Char as C\r\nimport Data.List (find)\r\nimport Data.Maybe (fromJust, isJust)\r\nimport Data.Stringable\r\nimport Data.Text (Text)\r\nimport qualified Data.Text as T\r\nimport Text.Regex.PCRE.Heavy\r\n\r\ndata FilterSpec = FilterSpec { badPattern::Text, goodWord::Text }\r\ntype FilterSpecs = [FilterSpec]\r\ntype Filter = Text -> Maybe Text\r\ntype Filters = [Filter]\r\n\r\ndouble :: Text -> Text\r\ndouble match = (match `T.append` match)\r\n\r\nwordRegex = [re|\\w+|]\r\n\r\nstringsAreEqual ignoreCase left right\r\n  | ignoreCase && (mk left) == (mk right) = True\r\n  | (not ignoreCase) && left == right = True\r\n  | otherwise = False\r\n\r\nadjustCase badBit actualBit goodWord ignoreCase\r\n  | not ignoreCase = goodWord\r\n  | actualBit == (T.toUpper badBit) = T.toUpper goodWord\r\n  | actualBit == (T.toLower badBit) = T.toLower goodWord\r\n  | (T.head actualBit) == (C.toUpper $ T.head badBit) = makeFirstCharUpper\r\n  | otherwise = goodWord\r\n  where\r\n    upperFirstChar = C.toUpper $ T.head goodWord\r\n    makeFirstCharUpper = T.cons upperFirstChar (T.tail goodWord)\r\n\r\nprefixFilter :: Text -> Text -> Bool -> Text -> Maybe Text\r\nprefixFilter badWord goodWord ignoreCase word\r\n  | stringsAreEqual ignoreCase prefix badWord = Just $ T.append caseAdjusted rest\r\n  | otherwise = Nothing\r\n  where\r\n    (prefix, rest) = T.splitAt (T.length badWord) word\r\n    caseAdjusted = adjustCase badWord prefix goodWord ignoreCase\r\n\r\nsuffixFilter :: Text -> Text -> Bool -> Text -> Maybe Text\r\nsuffixFilter badWord goodWord ignoreCase word\r\n  | stringsAreEqual ignoreCase suffix badWord = Just $ T.append rest caseAdjusted\r\n  | otherwise = Nothing\r\n  where\r\n    (rest, suffix) = T.splitAt (T.length word - T.length badWord) word\r\n    caseAdjusted = adjustCase badWord suffix goodWord ignoreCase\r\n    \r\nwordFilter :: Text -> Text -> Bool -> Text -> Maybe Text\r\nwordFilter badWord goodWord ignoreCase word\r\n  | stringsAreEqual ignoreCase word badWord = Just goodWord\r\n  | otherwise = Nothing\r\n  where\r\n    caseAdjusted = adjustCase badWord word goodWord ignoreCase\r\n\r\nnullFilter :: Text -> Maybe Text\r\nnullFilter = Just\r\n\r\ncreateFilter :: FilterSpec -> Filter\r\ncreateFilter spec = createFilterHelper (badPattern spec) (goodWord spec) True\r\n  where\r\n    createFilterHelper spec goodWord ignoreCase\r\n      | (T.last spec) == '!' = createFilterHelper (T.init spec) goodWord False\r\n      | (T.last spec) == '*' = prefixFilter (T.init spec) goodWord ignoreCase\r\n      | (T.head spec) == '*' = suffixFilter (T.tail spec) goodWord ignoreCase\r\n      | otherwise = wordFilter spec goodWord ignoreCase\r\n\r\ncreateFilters specs = (map createFilter specs) ++ [nullFilter]\r\n\r\napplyFilters :: Filters -> Text -> Text\r\napplyFilters filters word = fromJust activeFilter\r\n  where\r\n    filteredWords = map ($ word) filters\r\n    activeFilter = fromJust $ find isJust filteredWords \r\n\r\nfilterWords :: Filters -> Text -> Text\r\nfilterWords filters text = gsub wordRegex sanitiseWord text\r\n  where\r\n    sanitiseWord word = applyFilters filters word\n", "id": "2_1159104_1", "owner_tier": 0.3, "score": 0}], "link": "https://www.codeproject.com/Questions/1157796/Coding-challenge-bad-word-filter", "question": {"content": "\nThis is the first of our weekly coding challenges. Once a week we'll post a simple programming problem and the person who posts the best answer wins a T-shirt. The winner is decided by votes, or be comments, or be the audacity of their answer. Use any language in your answer except profanity.\n\r\nImagine that you allow users of your website to post comments, but some users, mainly the Australians, get a little colourful with their language. You decided to implement a Bad Word Filter that will replace certain words in a sentence with safer versions of that word.\n\r\nThe list of bad words and their replacements is\n\r\nBad: \"poophead\", \"PHB\", \"gotten\"\r\nReplacement: \"p**phead\", \"boss\", \"become\"\n\r\nSo \"My PHB is such a poophead. It's gotten worse since his promotion\" should be \"My boss is such a p**phead. It's become worse since his promotion\".\n\r\nWe also have to allow shouting. So \n\r\n\"My PHB is such a POOPHEAD!\" should become \"My boss is such a P**PHEAD!\"\n\nBonus points:\n\r\nLet's make it harder. If the \"bad\" word starts with \"*\" then it means any word that ends with that word. If it ends with a star then any word starting with that. If it ends with an \"!\" then it means that it should do the match case sensitive.\n\r\nBad words: \"poop*\", \"PHB!\", \"gotten\"\r\nReplacement: \"p**p\", \"boss\", \"become\"\n\r\n\"My PHB has started his new blog phblog.com. He's SUCH A MISBEGOTTEN POOPHEAD!\"\n\r\nshould become\n\r\n\"My boss has started his new blog phblog.com. He's SUCH A MISBEGOTTEN P**PHEAD!\"\n\nWhat I have tried:\n\r\nRemember: any programming language can be used.\r\n\t\t    ", "id": "1157796", "title": "Coding challenge: bad word filter", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:57:27 GMT", "source": "codeproject", "tags": ["code-challenge"]}]}