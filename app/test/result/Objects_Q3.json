{"result": [{"answers": [{"content": "I would recommend Method #2, but you're better off using a metaclass than a base class. Here is a sample implementation: Or in Python3 If you want to run __init__ every time the class is called, add to the if statement in Singleton.__call__. A few words about metaclasses. A metaclass is the class of a class; that is, a class is an instance of its metaclass. You find the metaclass of an object in Python with type(obj). Normal new-style classes are of type type. Logger in the code above will be of type class 'your_module.Singleton', just as the (only) instance of Logger will be of type class 'your_module.Logger'. When you call logger with Logger(), Python first asks the metaclass of Logger, Singleton, what to do, allowing instance creation to be pre-empted. This process is the same as Python asking a class what to do by calling __getattr__ when you reference one of its attributes by doing myclass.attribute. A metaclass essentially decides what the definition of a class means and how to implement that definition. See for example http://code.activestate.com/recipes/498149/, which essentially recreates C-style structs in Python using metaclasses. The thread What are some (concrete) use-cases for metaclasses? also provides some examples, they generally seem to be related to declarative programming, especially as used in ORMs. In this situation, if you use your Method #2, and a subclass defines a __new__ method, it will be executed every time you call SubClassOfSingleton() -- because it is responsible for calling the method that returns the stored instance. With a metaclass, it will only be called once, when the only instance is created. You want to customize what it means to call the class, which is decided by its type. In general, it makes sense to use a metaclass to implement a singleton. A singleton is special because its instance is created only once, and a metaclass is the way you customize the creation of a class, allowing it to behave differenly than a normal class. Using a metaclass gives you more control in case you need to customize the singleton class definitions in other ways. Your singletons won't need multiple inheritance (because the metaclass is not a base class), but for subclasses of the created class that use multiple inheritance, you need to make sure the singleton class is the first / leftmost one with a metaclass that redefines __call__ This is very unlikely to be an issue. The instance dict is not in the instance's namespace so it won't accidentally overwrite it. You will also hear that the singleton pattern violates the \"Single Responsibility Principle\" -- each class should do only one thing. That way you don't have to worry about messing up one thing the code does if you need to change another, because they are separate and encapsulated. The metaclass implementation passes this test. The metaclass is responsible for enforcing the pattern and the created class and subclasses need not be aware that they are singletons. Method #1 fails this test, as you noted with \"MyClass itself is a a function, not a class, so you cannot call class methods from it.\" Writing something that works in both Python2 and 3 requires using a slightly more complicated scheme. Since metaclasses are usually subclasses of type type, it's possible to use one to dynamically create an intermediary base class at run time with it as its metaclass and then use that as the baseclass of the public Singleton base class. It's harder to explain than to do, as illustrated next: An ironic aspect of this approach is that it's using subclassing to implement a metaclass. One possible advantage is that, unlike with a pure metaclass, isinstance(inst, Singleton) will return True. On another topic, you've probably already noticed this, but the base class implementation in your original post is wrong. _instances needs to be referenced on the class, you need to use super() or you're recursing, and __new__ is actually a static method that you have to pass the class to, not a class method, as the actual class hasn't been created yet when it is called. All of these things will be true for a metaclass implementation as well. I originally was writing a comment but it was too long, so I'll add this here. Method #4 is better than the other decorator version, but it's more code than needed for a singleton, and it's not as clear what it does. The main problems stem from the class being its own base class. First, isn't it weird to have a class be a subclass of a nearly identical class with the same name that exists only in its __class__ attribute? This also means that you can't define any methods that call the method of the same name on their base class with super() because they will recurse. This means your class can't customize __new__, and can't derive from any classes that need __init__ called on them. Your use case is one of the better examples of wanting to use a singleton. You say in one of the comments \"To me logging has always seemed a natural candidate for Singletons.\" You're absolutely right. When people say singletons are bad, the most common reason is they are implicit shared state. While with global variables and top-level module imports are explicit shared state, other objects that are passed around are generally instantiated. This is a good point, with two exceptions. The first, and one that gets mentioned in various places, is when the singletons are constant. Use of global constants, especially enums, is widely accepted, and considered sane because no matter what, none of the users can mess them up for any other user. This is equally true for a constant singleton. The second exception, which get mentioned less, is the opposite -- when the singleton is only a data sink, not a data source (directly or indirectly). This is why loggers feel like a \"natural\" use for singletons. As the various users are not changing the loggers in ways other users will care about, there is not really shared state. This negates the primary argument against the singleton pattern, and makes them a reasonable choice because of their ease of use for the task. Here is a quote from http://googletesting.blogspot.com/2008/08/root-cause-of-singletons.html: Now, there is one kind of Singleton which is OK. That is a singleton where all of the reachable objects are immutable. If all objects are immutable than Singleton has no global state, as everything is constant. But it is so easy to turn this kind of singleton into mutable one, it is very slippery slope. Therefore, I am against these Singletons too, not because they are bad, but because it is very easy for them to go bad. (As a side note Java enumeration are just these kind of singletons. As long as you don't put state into your enumeration you are OK, so please don't.) The other kind of Singletons, which are semi-acceptable are those which don't effect the execution of your code, They have no \"side effects\". Logging is perfect example. It is loaded with Singletons and global state. It is acceptable (as in it will not hurt you) because your application does not behave any different whether or not a given logger is enabled. The information here flows one way: From your application into the logger. Even thought loggers are global state since no information flows from loggers into your application, loggers are acceptable. You should still inject your logger if you want your test to assert that something is getting logged, but in general Loggers are not harmful despite being full of state.", "id": 6798042, "owner_tier": 0.9, "score": 0.9999999999912359}, {"content": "It is slightly similar to the answer by fab but not exactly the same. The singleton pattern does not require that we be able to call the constructor multiple times.  As a singleton should be created once and once only, shouldn't it be seen to be created just once?  \"Spoofing\" the constructor arguably impairs legibility. So my suggestion is just this: This does not rule out the use of the constructor or the field instance by user code: ... if you know for sure that Elvis has not yet been created, and that King has*. But it encourages users to use the the method universally: ... particularly (though not exclusively) if there is doubt concerning the pre-existence of Elvis and/or of that building. To make this complete you could also override __delattr__() to raise an Exception if an attempt is made to delete instance, and override __del__() so that it raises an Exception (unless we know the program is ending...) * some ontological issues here: could one singleton ever be another singleton? Subclassing a singleton class seems fraught with problems. And even then you'd probably be asking isinstance(), not is. My thanks to those who have helped with comments and edits, of which more are welcome. While I use Jython, this should work more generally, and be thread-safe. Points of note:", "id": 35534104, "owner_tier": 0.5, "score": 0.004382120937773883}, {"content": "Pros How does it work? __new__ is overwritten after the first call to __init__ so the constructor is essentially single-use. The lambda is used to return a reference to self using a closure which makes everything very anonymous.", "id": 72246576, "owner_tier": 0.3, "score": 0.0061349693163891324}, {"content": "You don't need it. Python's imported objects are already \"singletons\". When you have a file mymodule.py defining and you write from mymodule import myobject in multiple places, the code is imported/executed only the first time. All subsequent imports will use the same instance, that is cached in sys.imports. So, you don't need that pattern in the way you need it eg. Java, where you can't import already instantiated objects.", "id": 78139747, "owner_tier": 0.9, "score": -8.764241839811823e-12}, {"content": "This seems to be lightweight solution that has not been mentioned yet: Using an Enum class as a singleton class is also suggested in PEP 484 -- Type Hints. Unfortunately, if the Enum-based singleton needs to inherit from some abstract class, you need to jump through some hoops:", "id": 78015133, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "I used this: The output is so:", "id": 77433887, "owner_tier": 0.1, "score": 0.0035056967484662577}, {"content": "I know I am probably late to the party, but I think the metaclass approach can be improved. We don't need a dictionary to map the class to its singleton instance. We can simply have the singleton instance as an attribute of the class. Remember that instances of a metaclass are classes, so instance attributes of a metaclass are class attributes (static attributes for anyone coming from Java or C#). Here's the implementation: This code prints: As you can see, each class gets its own single _instance which needs to be instantiated as normal and can later be accessed with a get() class method. Trying to create another instance will raise a RuntimeError. Of course, you can modify the code to return the existing instance if already been created instead of raising an error, and you can implement __new__(cls, *args, **kwargs) to create the instance immediately when the class is defined instead of lazily when the constructor is first called, but these are easy modifications you can do to suit your needs. This removes the need for a dictionary that maps classes to their singleton instance like in the question and in the first answer. This results in a simpler implementation and probably a slightly faster one since we use simple attribute access instead of dictionary access (I didn't run any benchmarks so don't quote me on that).", "id": 77264282, "owner_tier": 0.5, "score": 0.002629272559158633}, {"content": "I don't know if I'm missing something here, but what about using undecorated static methods? By referring to Is @staticmethod decorator needed for declaring a Static Method in Python? and @staticmethod vs @classmethod in Python it seems that not having any decorator, which would fail if called on an object, is the desired behavior here for a singleton: This gives me the desired output:", "id": 77262132, "owner_tier": 0.3, "score": 0.002629272559158633}, {"content": "Honestly, I found a very simple solution: This does make ClassA an instance of ClassA and makes the uninstanciated class inaccessible. If you want something a bit more flexible you can define a method like so: Althogh I can't imagine why you'd add arguments to your init class if you want a singleton, so let's simplify this to this function, which is the same as the lambda but cleaner:", "id": 76944612, "owner_tier": 0.1, "score": 0.0035056967484662577}, {"content": "You just need a decorator, depending on the python version: Implementation Usage Output Notice how foo got printed only once Implementation:", "id": 73988733, "owner_tier": 0.3, "score": 0.021034180534618755}, {"content": "Few caveats I would want to highlight is,", "id": 72849869, "owner_tier": 0.3, "score": 0.0035056967484662577}, {"content": "As @Staale mentions here, the simplest way to make a singleton in python is to use a module with global variables (as 'attributes' & global functions as 'methods'). BUT I would like to add something very important to this already amazing answer: inheritance works here too! All you need to do to make a 'singleton module' B.py that inherits from another 'singleton module' A.py is start B.py with the line: from A import *, this respects private variables (by not importing them by default).", "id": 72439478, "owner_tier": 0.3, "score": 0.002629272559158633}, {"content": "By overriding the __new__ method to return the same instance of the class. A boolean to only initialize the class for the first time:", "id": 69259814, "owner_tier": 0.3, "score": 0.00964066607361963}, {"content": "I want to point out that the first method defines a dictionary for lookup, which I until today do not understand, and I see this solution spreading all over the place, so I guess everyone just copy pastes it from here. I am talking about this one: It makes sense for metaclass solutions, but with the one-off decorator solution, each time the decorator is called, a new function gets defined, as well as a new instances variable, so each \"instances\" will always only have one entry, except if you make it global. It will also not work with inheritance anyway. A similar, but simpler, and also better adjustable solution: adding a simple as well also allows inheritance or mocking, by accessing __wrapped__, which is also not possible with the inner dict lookup. (Of course pardon me, if I simply did not understand the mystery behind the dictionary lookup. Maybe it is my fault for not understanding the particular intent behind it)", "id": 71943034, "owner_tier": 0.1, "score": 0.002629272559158633}, {"content": "Here's my own implementation of singletons. All you have to do is decorate the class; to get the singleton, you then have to use the Instance method. Here's an example: And here's the code:", "id": 7489659, "owner_tier": 0.9, "score": 0.00964066607361963}, {"content": "You probably never need a singleton in Python. Just define all your data and functions in a module and you have a de facto singleton: To use: If you really absolutely have to have a singleton class then I'd go with: To use: where mysingleton.py is your filename that MySingleton is defined in. This works because after the first time a file is imported, Python doesn't re-execute the code.", "id": 27412017, "owner_tier": 0.3, "score": 0.06573181418930762}, {"content": "I prefer to use a static method GetInstance() to create a singleton object (also not allow any other method to do that) to emphasize that I am using a singleton design pattern.", "id": 70906745, "owner_tier": 0.3, "score": 0.002629272559158633}, {"content": "Here is simple implementation combining @agf and @(Siddhesh Suhas Sathe) solutions, where it uses metaclass and take into consideration the constructor args so you can return the same instance if you created the foo class with the exact same args", "id": 70007900, "owner_tier": 0.5, "score": 0.002629272559158633}, {"content": "Dead easy and works!", "id": 69830623, "owner_tier": 0.5, "score": 0.007887817695004382}, {"content": "One liner (I am not proud, but it does the job):", "id": 49144365, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "I just made a simple one by accident and thought I'd share it...", "id": 68673587, "owner_tier": 0.1, "score": 0.004382120937773883}, {"content": "I also prefer decorator syntax to deriving from metaclass. My two cents: This has some benefits above other decorators provided: Cons: If you need a different instance based on constructor parameters this solution needs to be improved (solution provided by siddhesh-suhas-sathe provides this). Finally, as other suggested, consider using a module in python. Modules are objects. You can even pass them in variables and inject them in other classes.", "id": 65183531, "owner_tier": 0.1, "score": 0.004382120937773883}, {"content": "You can use a metaclass if you want to use instance as a property. For example;", "id": 66568744, "owner_tier": 0.3, "score": 0.004382120937773883}, {"content": "Pros It's a true class Auto-magically covers inheritance Uses metaclass\nfor its proper purpose (and made me aware of it) Cons Are there any? This will be problem with serialziation. If you try to deserialize object from file (pickle) it will not use __call__ so it will create new file, you can use base class inheritance with __new__ to prevent that.", "id": 66509752, "owner_tier": 0.1, "score": 0.004382120937773883}, {"content": "I prefer this solution which I found very clear and straightforward.\nIt is using double check for instance, if some other thread already created it.\nAdditional thing to consider is to make sure that deserialization isn't creating any other instances.\nhttps://gist.github.com/werediver/4396488", "id": 64545504, "owner_tier": 0.3, "score": 0.00964066607361963}, {"content": "I will recommend an elegant solution using metaclasses Output: As you can see from the output, only one object is instantiated", "id": 63483209, "owner_tier": 0.3, "score": 0.00964066607361963}, {"content": "Using a function attribute is also very simple", "id": 62693309, "owner_tier": 0.5, "score": 0.01139351445223488}, {"content": "", "id": 57307127, "owner_tier": 0.3, "score": 0.01139351445223488}, {"content": "After struggling with this for some time I eventually came up with the following, so that the config object would only be loaded once, when called up from separate modules.  The metaclass allows a global class instance to be stored in the builtins dict, which at present appears to be the neatest way of storing a proper program global.", "id": 58452814, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "Maybe I missunderstand the singleton pattern but my solution is this simple and pragmatic (pythonic?). This code fullfills two goals This is the code. Output", "id": 57548242, "owner_tier": 0.5, "score": 0.0052585451270815075}, {"content": "If you don't need lazy initialization of the instance of the Singleton, then the following should be easy and thread-safe: This way A is a singleton initialized at module import.", "id": 53998434, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "This solution causes some namespace pollution at the module level (three definitions rather than just one), but I find it easy to follow. I'd like to be able to write something like this (lazy initialization), but unfortunately classes are not available in the body of their own definitions. Since that isn't possible, we can break out the initialization and the static instance in Eager Initialization: Lazy initialization: Eager Initialization:", "id": 40351307, "owner_tier": 0.5, "score": 0.0008764241805433831}, {"content": "This answer is likely not what you're looking for. I wanted a singleton in the sense that only that object had its identity, for comparison to. In my case it was being used as a Sentinel Value. To which the answer is very simple, make any object mything = object() and by python's nature,  only that thing will have its identity.", "id": 39777706, "owner_tier": 0.5, "score": 0.004382120937773883}, {"content": "I'll toss mine into the ring. It's a simple decorator. Benefits I think it has over some of the other solutions: One downside does occur to me: classmethods and staticmethods of the real class are not transparently callable via the factory class hiding it. I've used this rarely enough that I've never happen to run into that need, but it would be easily rectified by using a custom metaclass on the factory that implements __getattr__() to delegate all-ish attribute access to the real class. A related pattern I've actually found more useful (not that I'm saying these kinds of things are required very often at all) is a \"Unique\" pattern where instantiating the class with the same arguments results in getting back the same instance. I.e. a \"singleton per arguments\". The above adapts to this well and becomes even more concise: All that said, I do agree with the general advice that if you think you need one of these things, you really should probably stop for a moment and ask yourself if you really do. 99% of the time, YAGNI.", "id": 39186313, "owner_tier": 0.5, "score": 0.0061349693163891324}, {"content": "Method 3 seems to be very neat, but if you want your program to run in both Python\u00a02 and Python\u00a03, it doesn't work. Even protecting the separate variants with tests for the Python version fails, because the Python\u00a03 version gives a syntax error in Python\u00a02. Thanks to Mike Watkins: http://mikewatkins.ca/2008/11/29/python-2-and-3-metaclasses/. If you want the program to work in both Python\u00a02 and Python\u00a03, you need to do something like: I presume that 'object' in the assignment needs to be replaced with the 'BaseClass', but I haven't tried that (I have tried code as illustrated).", "id": 17840539, "owner_tier": 0.1, "score": 0.0061349693163891324}, {"content": "How about this: Use it as a decorator on a class that should be a singleton. Like this: This is similar to the singleton = lambda c: c() decorator in another answer. Like the other solution, the only instance has name of the class (MySingleton).  However, with this solution you can still \"create\" instances (actually get the only instance) from the class, by doing MySingleton(). It also prevents you from creating additional instances by doing type(MySingleton)() (that also returns the same instance).", "id": 23717235, "owner_tier": 0.3, "score": 0.004382120937773883}, {"content": "Code based on Tolli's answer. Explanation: Create new class, inheriting from given cls\n(it doesn't modify cls in case someone wants for example singleton(list)) Create instance. Before overriding __new__ it's so easy. The function returns instance only when it's what the caller expects, otherwise raises TypeError.\nThe condition is not met when someone attempts to inherit from decorated class. If __new__() returns an instance of cls, then the new instance\u2019s __init__() method will be invoked like __init__(self[, ...]), where self is the new instance and the remaining arguments are the same as were passed to __new__(). instance is already initialized, so function replaces __init__ with function doing nothing. See it working online", "id": 27713039, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "I can't remember where I found this solution, but I find it to be the most 'elegant' from my non-Python-expert point of view: Why do I like this?  No decorators, no meta classes, no multiple inheritance...and if you decide you don't want it to be a Singleton anymore, just delete the __new__ method.  As I am new to Python (and OOP in general) I expect someone will set me straight about why this is a terrible approach?", "id": 26858284, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "Here's a one-liner for you: Here's how you use it: Your object gets instantiated eagerly.  This may or may not be what you want.", "id": 19467267, "owner_tier": 0.5, "score": 0.01840490796669588}, {"content": "Well, other than agreeing with the general Pythonic suggestion on having module-level global, how about this: Output is:", "id": 6810621, "owner_tier": 0.5, "score": 0.004382120937773883}, {"content": "Use a module. It is imported only once. Define some global variables in it - they will be singleton's 'attributes'. Add some functions - the singleton's 'methods'.", "id": 6760821, "owner_tier": 0.9, "score": 0.08676599473269063}, {"content": "Modules are imported only once, everything else is overthinking. Don't use singletons and try not to use globals.", "id": 6760726, "owner_tier": 0.9, "score": 0.1384750219018405}], "link": "https://stackoverflow.com/questions/6760685/what-is-the-best-way-of-implementing-singleton-in-python", "question": {"content": "This question is not for the discussion of whether or not the singleton design pattern is desirable, is an anti-pattern, or for any religious wars, but to discuss how this pattern is best implemented in Python in such a way that is most pythonic. In this instance I define 'most pythonic' to mean that it follows the 'principle of least astonishment'. I have multiple classes which would become singletons (my use-case is for a logger, but this is not important). I do not wish to clutter several classes with added gumph when I can simply inherit or decorate. Best methods: Pros Cons While objects created using MyClass() would be true singleton objects, MyClass itself is a function, not a class, so you cannot call class methods from it. Also for then x == y but x != t && y != t Pros Cons Pros Cons Pros Cons a module file singleton.py Pros Cons", "id": 6760685, "title": "What is the best way of implementing singleton in Python", "traffic_rate": 156}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "singleton", "decorator", "base-class", "metaclass"]}, {"answers": [{"content": "Keys must be hashable - that's all that's forced upon you. In particular, you can have a user-defined class whose instances are hashable but also mutable - but this is generally a bad idea. By not sharing values between the two dicts. It's generally OK to share the keys, because they should be immutable (and will be, for built-in types). Copying the dictionary, in the sense of the copy standard library module, is definitely safe. Calling the dict constructor here works, too: b = dict(a). You could also use immutable values. All built-in immutable types are hashable. All built-in mutable types are not hashable. The constraint on dict keys simply requires that the built-in hash function works on the key, which in turn requires that its class implements the __hash__ magic method. However, the code may break subtly or unexpectedly if an object's hash could ever change during its lifetime. For a pathological example: This is why trying to make a mutable, hashable type is ill-advised: the hash is expected not to change, but is also expected to reflect the state of the object. No. A type is mutable if it is not immutable. A type is immutable if it is a built-in immutable type: str, int, long, bool, float, tuple, and probably a couple others I'm forgetting. User-defined types are always mutable. An object is mutable if it is not immutable. An object is immutable if it consists, recursively, of only immutable-typed sub-objects. Thus, a tuple of lists is mutable; you cannot replace the elements of the tuple, but you can modify them through the list interface, changing the overall data.", "id": 4374075, "owner_tier": 0.9, "score": 0.9999999996875}, {"content": "you can easily check if datatype is mutable or immutable by print an id or address of memory location of that datatype if datatype is immutable the address of memory location will change as you update the variable for example: you will get address of memory location of that variable stn but when you concatenate that variable with some value and then go ahead print an address of memory location you will get different output from the first one likewise for sure you will get another address of memory location from the first one but when you do it to mutable datatype an address of memory location will stay the same for example here you will get an address of memory location and also also if you go ahead and append some numbers to that lists an address of memory location will continue to be the same and you have notice that an address of memory location is not the same to all computers\nso you couldn't check the same datatype to different computers and get same result", "id": 62760382, "owner_tier": 0.5, "score": 0.1249999996875}, {"content": "There's really no guarantee that a type which is hashable is also immutable, but at very least, correctly implementing __hash__ requires that the type is immutable, with respect to its own hash, and to equality.  This is not enforced in any particular way.   However, we are all adults.  It would be unwise to implement __hash__ unless you really meant it.  Roughly speaking, this just boils down to saying that if a type actually can be used as a dictionary key, then it is intended to be used in that way. If you're looking for something that is like a dict, but also immutable, then namedtuple might be your best bet from what's in the standard library.  Admittedly it's not a very good approximation, but it's a start.", "id": 4374097, "owner_tier": 0.9, "score": 0.2187499996875}, {"content": "dict keys must be hashable, which implies they have an immutable hash value.  dict values may or may not be mutable; however, if they are mutable this impacts your second question. \"Changes to the keys\" will not be reflected between the two dicts.  Changes to immutable values, such as strings will also not be reflected.  Changes to mutable objects, such as user defined classes will be reflected because the object is stored by id (i.e. reference). I think this is explained by the first two answers. Not that I know of in this respect. some additional thoughts: There are two main things to know for understanding the behavior of keys: keys must be hashable (which means they implement object.__hash__(self)) and they must also be \"comparable\" (which means they implement something like object.__cmp__(self)).  One important take-away from the docs: by default, user-defined objects' hash functions return id(). Consider this example: Values are much easier to understand, the dict stores references to objects.  Read the sections on hashable.  Things like strings are immutable, if you \"change\" them, the dict you changed it in now references a new object.  Objects which are mutable can be \"changed in-place\", hence the value of both dicts will change. Anyway, here are the main points of all this: I do not think there is a general way to test either of those points.  The tests for suitability would depend on your use-case.  For instance, it may be sufficient to check that an object does or does not implement __hash__ and comparison (__eq__ or __cmp__) functions.  Like-wise, you might be able to \"check\" an object's __setattr__ method in some way to determine if it is mutable.", "id": 4374114, "owner_tier": 0.5, "score": 0.1562499996875}, {"content": "There isn't actually any such thing as mutability or immutability at the language level in Python.  Some objects provide no way to change them (eg. strings and tuples), and so are effectively immutable, but it's purely conceptual; there's no property at the language level indicating this, neither to your code nor to Python itself. Immutability is not actually relevant to dicts; it's perfectly fine to use mutable values as keys.  What matters is comparison and hashing: the object must always remain equal to itself.  For example: Here, example is not immutable; we're modifying it with a.data = 2.  Yet, we're using it as a key of a hash without any trouble.  Why?  The property we're changing has no effect on equality: the hash is unchanged, and example(1) is always equal to example(1), ignoring any other properties. The most common use of this is caching and memoization: having a property cached or not doesn't logically change the object, and usually has no effect on equality. (I'm going to stop here--please don't ask five questions at once.)", "id": 4374978, "owner_tier": 0.9, "score": 0.6249999996875}, {"content": "There are MutableSequence, MutableSet, MutableMapping in module collections. Which can be used to check mutability of premade types. If you want use this on user defined types, the type must be either inherited from one of them or registered as a virtual subclass. or", "id": 4374362, "owner_tier": 0.5, "score": 0.3437499996875}, {"content": "Dicts are unordered sets of key:value pairs. The keys must be immutable, and therefore hashable. To determine if an object is hashable, you can use the hash() function: The values, on the other hand, can be any object. If you need to check if an object is immutable, then I would use hash().", "id": 4374102, "owner_tier": 0.5, "score": -3.124999981007903e-10}], "link": "https://stackoverflow.com/questions/4374006/check-for-mutability-in-python", "question": {"content": "Consider this code: How do I check if a type is mutable in Python?", "id": 4374006, "title": "Check for mutability in Python?", "traffic_rate": 5}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "immutability", "hashable"]}, {"answers": [{"content": "Slots are very useful for library calls to eliminate the \"named method dispatch\" when making function calls.  This is mentioned in the SWIG documentation.  For high performance libraries that want to reduce function overhead for commonly called functions using slots is much faster. Now this may not be directly related to the OPs question.  It is related more to building extensions than it does to using the __slots__ syntax on an object.  But it does help complete the picture for the usage of slots and some of the reasoning behind them.", "id": 13547906, "owner_tier": 0.5, "score": 0.008375209374651032}, {"content": "In addition to the myriad advantages described in other answers herein \u2013 compact instances for the memory-conscious, less error-prone than the more mutable __dict__-bearing instances, et cetera \u2013 I find that using __slots__ offers more legible class declarations, as the instance variables of the class are explicitly out in the open. To contend with inheritance issues with __slots__ declarations I use this metaclass: \u2026 which, if declared as the metaclass of the base class in an inheritance tower, ensures that everything that derives from that base class will properly inherit __slots__ attributes, even if an intermediate class fails to declare any. Like so:", "id": 73677355, "owner_tier": 0.5, "score": 0.0016750418704634283}, {"content": "In addition to the other answers, __slots__ also adds a little typographical security by limiting attributes to a predefined list. This has long been a problem with JavaScript which also allows you to add new attributes to an existing object, whether you meant to or not. Here is a normal unslotted object which does nothing, but allows you to add attributes: Since Python is case sensitive, the two attributes, spelled the same but with different case, are different. If you suspect that one of those is a typing error, then bad luck. Using slots, you can limit this: This time, the second attribute (Name) is disallowed because it\u2019s not in the __slots__ collection. I would suggest that it\u2019s probably better to use __slots__ where possible to keep more control over the object.", "id": 72282322, "owner_tier": 0.5, "score": 0.004466778330541597}, {"content": "Beginning in Python 3.9, a dict may be used to add descriptions to attributes via __slots__. None may be used for attributes without descriptions, and private variables will not appear even if a description is given.", "id": 71730153, "owner_tier": 0.5, "score": 0.004466778330541597}, {"content": "The special attribute __slots__ allows you to explicitly state which instance attributes you expect your object instances to have, with the expected results: The space savings is from Small caveat, you should only declare a particular slot one time in an inheritance tree. For example: Python doesn't object when you get this wrong (it probably should), problems might not otherwise manifest, but your objects will take up more space than they otherwise should. Python 3.8: This is because the Base's slot descriptor has a slot separate from the Wrong's. This shouldn't usually come up, but it could: The biggest caveat is for multiple inheritance - multiple \"parent classes with nonempty slots\" cannot be combined. To accommodate this restriction, follow best practices: Factor out all but one or all parents' abstraction which their concrete class respectively and your new concrete class collectively will inherit from - giving the abstraction(s) empty slots (just like abstract base classes in the standard library). See section on multiple inheritance below for an example. To have attributes named in __slots__ to actually be stored in slots instead of a __dict__, a class must inherit from object (automatic in Python 3, but must be explicit in Python 2). To prevent the creation of a __dict__, you must inherit from object and all classes in the inheritance must declare __slots__ and none of them can have a '__dict__' entry. There are a lot of details if you wish to keep reading. The creator of Python, Guido van Rossum, states that he actually created __slots__ for faster attribute access. It is trivial to demonstrate measurably significant faster access: and The slotted access is almost 30% faster in Python 3.5 on Ubuntu. In Python 2 on Windows I have measured it about 15% faster. Another purpose of __slots__ is to reduce the space in memory that each object instance takes up. My own contribution to the documentation clearly states the reasons behind this: The space saved over using __dict__ can be significant. SQLAlchemy attributes a lot of memory savings to __slots__. To verify this, using the Anaconda distribution of Python 2.7 on Ubuntu Linux, with guppy.hpy (aka heapy) and sys.getsizeof, the size of a class instance without __slots__ declared, and nothing else, is 64 bytes. That does not include the __dict__. Thank you Python for lazy evaluation again, the __dict__ is apparently not called into existence until it is referenced, but classes without data are usually useless. When called into existence, the __dict__ attribute is a minimum of 280 bytes additionally. In contrast, a class instance with __slots__ declared to be () (no data) is only 16 bytes, and 56 total bytes with one item in slots, 64 with two. For 64 bit Python, I illustrate the memory consumption in bytes in Python 2.7 and 3.6, for __slots__ and __dict__ (no slots defined) for each point where the dict grows in 3.6 (except for 0, 1, and 2 attributes): So, in spite of smaller dicts in Python 3, we see how nicely __slots__ scale for instances to save us memory, and that is a major reason you would want to use __slots__. Just for completeness of my notes, note that there is a one-time cost per slot in the class's namespace of 64 bytes in Python 2, and 72 bytes in Python 3, because slots use data descriptors like properties, called \"members\". To deny the creation of a __dict__, you must subclass object. Everything subclasses object in Python 3, but in Python 2 you had to be explicit: now: Or subclass another class that defines __slots__ and now: but: To allow __dict__ creation while subclassing slotted objects, just add '__dict__' to the __slots__ (note that slots are ordered, and you shouldn't repeat slots that are already in parent classes): and Or you don't even need to declare __slots__ in your subclass, and you will still use slots from the parents, but not restrict the creation of a __dict__: And: However, __slots__ may cause problems for multiple inheritance: Because creating a child class from parents with both non-empty slots fails: If you run into this problem, You could just remove __slots__ from the parents, or if you have control of the parents, give them empty slots, or refactor to abstractions: and now: So with '__dict__' in slots we lose some of the size benefits with the upside of having dynamic assignment and still having slots for the names we do expect. When you inherit from an object that isn't slotted, you get the same sort of semantics when you use __slots__ - names that are in __slots__ point to  slotted values, while any other values are put in the instance's __dict__. Avoiding __slots__ because you want to be able to add attributes on the fly is actually not a good reason - just add \"__dict__\" to your __slots__ if this is required. You can similarly add __weakref__ to __slots__ explicitly if you need that feature. The namedtuple builtin make immutable instances that are very lightweight (essentially, the size of tuples) but to get the benefits, you need to do it yourself if you subclass them: usage: And trying to assign an unexpected attribute raises an AttributeError because we have prevented the creation of __dict__: You can allow __dict__ creation by leaving off __slots__ = (), but you can't use non-empty __slots__ with subtypes of tuple. Even when non-empty slots are the same for multiple parents, they cannot be used together: Using an empty __slots__ in the parent seems to provide the most flexibility, allowing the child to choose to prevent or allow (by adding '__dict__' to get dynamic assignment, see section above) the creation of a __dict__: You don't have to have slots - so if you add them, and remove them later, it shouldn't cause any problems. Going out on a limb here: If you're composing mixins or using abstract base classes, which aren't intended to be instantiated, an empty __slots__ in those parents seems to be the best way to go in terms of flexibility for subclassers. To demonstrate, first, let's create a class with code we'd like to use under multiple inheritance We could use the above directly by inheriting and declaring the expected slots: But we don't care about that, that's trivial single inheritance, we need another class we might also inherit from, maybe with a noisy attribute: Now if both bases had nonempty slots, we couldn't do the below. (In fact, if we wanted, we could have given AbstractBase nonempty slots a and b, and left them out of the below declaration - leaving them in would be wrong): And now we have functionality from both via multiple inheritance, and can still deny __dict__ and __weakref__ instantiation: You may be able to tease out further caveats from the rest of the __slots__ documentation (the 3.7 dev docs are the most current), which I have made significant recent contributions to. The current top answers cite outdated information and are quite hand-wavy and miss the mark in some important ways. I quote: \"You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class.\" Abstract Base Classes, for example, from the collections module, are not instantiated, yet __slots__ are declared for them. Why? If a user wishes to deny __dict__ or __weakref__ creation, those things must not be available in the parent classes. __slots__ contributes to reusability when creating interfaces or mixins. It is true that many Python users aren't writing for reusability, but when you are, having the option to deny unnecessary space usage is valuable. When pickling a slotted object, you may find it complains with a misleading TypeError: This is actually incorrect. This message comes from the oldest protocol, which is the default. You can select the latest protocol with the -1 argument. In Python 2.7 this would be 2 (which was introduced in 2.3), and in 3.6 it is 4. in Python 2.7: in Python 3.6 So I would keep this in mind, as it is a solved problem. The first paragraph is half short explanation, half predictive. Here's the only part that actually answers the question The proper use of __slots__ is to save space in objects. Instead of having a dynamic dict that allows adding attributes to objects at anytime, there is a static structure which does not allow additions after creation. This saves the overhead of one dict for every object that uses slots The second half is wishful thinking, and off the mark: While this is sometimes a useful optimization, it would be completely unnecessary if the Python interpreter was dynamic enough so that it would only require the dict when there actually were additions to the object. Python actually does something similar to this, only creating the __dict__ when it is accessed, but creating lots of objects with no data is fairly ridiculous. The second paragraph oversimplifies and misses actual reasons to avoid __slots__. The below is not a real reason to avoid slots (for actual reasons, see the rest of my answer above.): They change the behavior of the objects that have slots in a way that can be abused by control freaks and static typing weenies. It then goes on to discuss other ways of accomplishing that perverse goal with Python, not discussing anything to do with __slots__. The third paragraph is more wishful thinking. Together it is mostly off-the-mark content that the answerer didn't even author and contributes to ammunition for critics of the site. Create some normal objects and slotted objects: Instantiate a million of them: Inspect with guppy.hpy().heap(): Access the regular objects and their __dict__ and inspect again: This is consistent with the history of Python, from Unifying types and classes in Python 2.2 If you subclass a built-in type, extra space is automatically added to the instances to accomodate __dict__ and __weakrefs__. (The __dict__ is not initialized until you use it though, so you shouldn't worry about the space occupied by an empty dictionary for each instance you create.) If you don't need this extra space, you can add the phrase \"__slots__ = []\" to your class.", "id": 28059785, "owner_tier": 0.9, "score": 0.9999999999944166}, {"content": "You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class. __slots__ only exists as a memory optimization tool. It's highly discouraged to use __slots__ for constraining attribute creation. Pickling objects with __slots__ won't work with the default (oldest) pickle protocol; it's necessary to specify a later version. Some other introspection features of python may also be adversely affected.", "id": 472017, "owner_tier": 0.5, "score": 0.08375209379676159}, {"content": "Another somewhat obscure use of __slots__ is to add attributes to an object proxy from the ProxyTypes package, formerly part of the PEAK project. Its ObjectWrapper allows you to proxy another object, but intercept all interactions with the proxied object. It is not very commonly used (and no Python 3 support), but we have used it to implement a thread-safe blocking wrapper around an async implementation based on tornado that bounces all access to the proxied object through the ioloop, using thread-safe concurrent.Future objects to synchronise and return results. By default any attribute access to the proxy object will give you the result from the proxied object. If you need to add an attribute on the proxy object, __slots__ can be used.", "id": 42099854, "owner_tier": 0.5, "score": 0.0027917364544946957}, {"content": "Quoting Jacob Hallen: The proper use of __slots__ is to save space in objects. Instead of having\n  a dynamic dict that allows adding attributes to objects at anytime,\n  there is a static structure which does not allow additions after creation.\n  [This use of __slots__ eliminates the overhead of one dict for every object.] While this is sometimes a useful optimization, it would be completely\n  unnecessary if the Python interpreter was dynamic enough so that it would\n  only require the dict when there actually were additions to the object. Unfortunately there is a side effect to slots. They change the behavior of\n  the objects that have slots in a way that can be abused by control freaks\n  and static typing weenies. This is bad, because the control freaks should\n  be abusing the metaclasses and the static typing weenies should be abusing\n  decorators, since in Python, there should be only one obvious way of doing something. Making CPython smart enough to handle saving space without __slots__ is a major\n  undertaking, which is probably why it is not on the list of changes for P3k (yet).", "id": 472024, "owner_tier": 0.5, "score": 0.15745393634282523}, {"content": "A very simple example of __slot__ attribute. If I don't have __slot__ attribute  in my class, I can add new attributes to  my objects. If you look at example above, you can see that obj1 and obj2 have their own x and y attributes and python has also created  a dict attribute for each object (obj1 and obj2). Suppose if my class Test has thousands of such objects? Creating an additional attribute dict for each object will cause lot of overhead (memory, computing power etc.) in my code. Now in the following example my class Test contains __slots__ attribute. Now I can't add new attributes to my objects (except attribute x) and python doesn't create a dict attribute anymore. This eliminates overhead for each object, which can become significant if you have many objects.", "id": 40376229, "owner_tier": 0.5, "score": 0.007258514790619765}, {"content": "You have \u2014 essentially \u2014 no use for __slots__.   For the time when you think you might need __slots__, you actually want to use Lightweight or Flyweight design patterns. These are cases when you no longer want to use purely Python objects. Instead, you want a Python object-like wrapper around an array, struct, or numpy array. The class-like wrapper has no attributes \u2014 it just provides methods that act on the underlying data. The methods can be reduced to class methods. Indeed, it could be reduced to just functions operating on the underlying array of data.", "id": 472570, "owner_tier": 0.9, "score": -5.583472920156337e-12}, {"content": "The original question was about general use cases not only about memory.\nSo it should be mentioned here that you also get better performance when instantiating large amounts of objects - interesting e.g. when parsing large documents into objects or from a database. Here is a comparison of creating object trees with a million entries, using slots and without slots. As a reference also the performance when using plain dicts for the trees (Py2.7.10 on OSX): Test classes (ident, appart from slots): testcode, verbose mode:", "id": 34751434, "owner_tier": 0.3, "score": 0.0016750418704634283}, {"content": "In addition to the other answers, here is an example of using __slots__: So, to implement __slots__, it only takes an extra line (and making your class a new-style class if it isn't already). This way you can reduce the memory footprint of those classes 5-fold, at the expense of having to write custom pickle code, if and when that becomes necessary.", "id": 30613834, "owner_tier": 0.7, "score": 0.017867113338916805}, {"content": "An attribute of a class instance has 3 properties: the instance, the name of the attribute, and the value of the attribute. In regular attribute access, the instance acts as a dictionary and the name of the attribute acts as the key in that dictionary looking up value. instance(attribute) --> value In __slots__ access, the name of the attribute acts as the dictionary and the instance acts as the key in the dictionary looking up value. attribute(instance) --> value In flyweight pattern, the name of the attribute acts as the dictionary and the value acts as the key in that dictionary looking up the instance. attribute(value) --> instance", "id": 24048447, "owner_tier": 0.5, "score": 0.007258514790619765}, {"content": "Each python object has a __dict__ atttribute which is a dictionary containing all other attributes. e.g. when you type self.attr python is actually doing self.__dict__['attr']. As you can imagine using a dictionary to store attribute takes some extra space & time for accessing it. However, when you use __slots__, any object created for that class won't have a __dict__ attribute. Instead, all attribute access is done directly via pointers. So if want a C style structure rather than a full fledged class you can use __slots__ for compacting size of the objects & reducing attribute access time. A good example is a Point class containing attributes x & y. If you are going to have a lot of points, you can try using __slots__ in order to conserve some memory.", "id": 472899, "owner_tier": 0.5, "score": 0.04187604689558906}], "link": "https://stackoverflow.com/questions/472000/usage-of-slots", "question": {"content": "What is the purpose of __slots__ in Python \u2014 especially with respect to when I would want to use it, and when not?", "id": 472000, "title": "Usage of __slots__?", "traffic_rate": 73}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "oop", "python-internals", "slots"]}, {"answers": [{"content": "I think you are overcomplicating this. Car.__init__ should perform initialization that is common to any Car, regardless of the specific subclass used to instantiated the object. Each subclass will define an __init__ method that first calls its inherited __init__ method, then does any subclass-specific intialization. civic.id, civic.created_at, and civic.modified_at are defined by Car.__init__; civic.something_else is defined by Honda.__init__.", "id": 76218593, "owner_tier": 0.9, "score": 0.9999999900000001}, {"content": "In Python you will rarely need to touch __new__ - and usually only when you really know what you are doing. Which means: when in doubt, use __init__. :-) But seriously, the tasks you mention are typical, and meant to be done on __init__. There are a few semantic and historic reasons for it - but actually, also, very practical reasons few people are aware of: Among other things Python can do, there is out-of-the box support for serializing and de-serializing almost any object created by a user-defined class - out of the box, without the class author never worrying about it. And one of the reasons that works in such a fine way is this separation of the construction of an object in the __new__ and __init__  methods: __new__ is supposed to build the object as an \"empty shell\", and __init__ to \"fill in any attributes needed at object initialization\" (not quotes, I am wording these now). The de-serialization mechanism uses that to create a new object, and them just filling in the attributes of the originally serialized objects into the new instance, without calling __init__. In your example, if __new__ would create an ID (which might be backed up in some registry or DB at creation, or be an immutable attribute), this mechanism would not work.", "id": 76218211, "owner_tier": 0.9, "score": -9.99999993922529e-09}], "link": "https://stackoverflow.com/questions/76218135/using-parent-class-new-or-init-method-to-assign-default-attributes-f", "question": {"content": "I am trying to create a parent class - Car that would be able to automatically assign a unique id (using uuid.uuid4()), a created_at attribute and an updated_at attribute (both using the datetime and dateutil modules) to any object that would be created through the sub-classes of my parent class. For example: When an object (honda_civic()) of my sub-class Honda, which inherits from my Car parent class, is created, honda_civic would be automatically assigned a unique id, then it will also have a time created and time updated, as well as the other attributes and methods defined in the Honda sub-class. Based on my research so far, I know that I would need to define these attributes inside either of the __new__ or __init__ methods of my parent class Car (I stand to be corrected). However, I'm struggling to figure out exactly which of them should have the definitions. I know that the __new__ method controls object creation while the __init__ method controls object instantiation. My confusion now is that if I define the attributes under the __init__ method, would that not mean that each time the object is created the attributes would have to be passed as arguments? (which is definitely not ideal). What I need help with now is figuring out the syntax of defining the attributes under the __new__ method because I am a bit confused by the def __new__(cls, *args, **kwargs) prototype definition of the __new__ method and how it can accommodate the definitions; can I pass the attributes to the __new__ prototype? like so: def __new__(cls, id, created_at, updated_at)", "id": 76218135, "title": "Using parent class `__new__` or `__init__` method to assign default attributes for every object/instance of a sub-class", "traffic_rate": 116}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "class", "oop", "inheritance", "magic-methods"]}, {"answers": [{"content": "I intend to show you what happens roughly. By the way I over simplified this. first think about implementing __call__ inside your class. It enables the instance of the class to be callable. Now we know that classes are instances themselves -> of type type: So there has to be a __call__ method in \"their\" class(better to say metaclass) and of course there is one in type. When you put parentheses in front of you class, you are actually calling this method with the given argument (here 8). What it does, first(here some another things happens but we ignored) calls the __new__ method with the argument you passed to the __call__, this method returns an instance of int, then __init__ will get called as an instance method on the newly created int object. So the way your class works is because of this: You inherited this __new__ from int and so yes, as @johnrsharpe pointed out in the comment, \"Immutable types in Python generally do the work in __new__, not __init__", "id": 67662112, "owner_tier": 0.5, "score": 0.9999999966666667}], "link": "https://stackoverflow.com/questions/67661671/inheriting-from-int-object", "question": {"content": "I have a class that inherits from int, in my class init function I am not calling the parent init function, but still somehow there is a value when I use the parent (int) methods, which means I think that the parent init was also called? for example: will return 8 I thought that maybe the parent constructor is called implicitly, but in this code I saw it is not: will return: in son init", "id": 67661671, "title": "Inheriting from int object", "traffic_rate": 1203}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "inheritance"]}, {"answers": [{"content": "While you can handle initialization in the __new__ method, because it's always called before __init__ (or even instead of, if __new__'s returned object is other than an instance of the class), it's best practice decoupling object initizalization in __init__ and leaving __new__ only for object creation. For instance, in that way you would be able to subclass Foo. (Furthermore, passing *args, **kwargs to __new__ will allow the subclass have any number of positional or named arguments.) However, if you handle initialization in __new__ you will inherit object's __init__ which hasn't more arguments than the instance itself. And you won't be able to subclass it by the common way.", "id": 59023077, "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "You can do this without implementing __init__ at all: In use:", "id": 55722422, "owner_tier": 0.9, "score": 0.03703703666666667}, {"content": "Both @cgogolin and @qvpham provide working answers. However, I reckon that float.__init__(value) within the __init__ method is irrelevant to the initialization of Foo. That is, it does nothing to initialize attributes of Foo. As such, it rather causes confusion on the necessity of the operation toward subclassing the float type. Indeed, the solution can be further simplified as follows:", "id": 52307860, "owner_tier": 0.3, "score": 0.407407407037037}, {"content": "the solution of cgogolin is right. it's like so with another immutable classes like int, str, ... But i will write:", "id": 35944874, "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "As float is immutable you have to overwrite __new__ as well. The following should do what you want: See also Sub-classing float type in Python, fails to catch exception in __init__()", "id": 35944423, "owner_tier": 0.5, "score": 0.9999999996296296}], "link": "https://stackoverflow.com/questions/35943789/python-can-a-subclass-of-float-take-extra-arguments-in-its-constructor", "question": {"content": "In Python 3.4, I'd like to create a subclass of float -- something that can be used in math and boolean operations like a float, but has other custom functionality and can receive an argument at initialization that controls that functionality. (Specifically, I wanted to have a custom __str__ and a parameter that is used in that method.) However, I can't seem to get a subclass of float to have a functional two-argument constructor. Why? Is this simply a limitation on extending built-in types? Example: Now if I try Foo(1,2) I get: Surprisingly, my new __init__'s arguments are enforced too, so if I do Foo(1) I get: What's the deal here? I've done similar things with subtypes of list and was surprised it didn't work on float.", "id": 35943789, "title": "Python: Can a subclass of float take extra arguments in its constructor?", "traffic_rate": 4}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "python-3.x", "types", "subclass", "built-in"]}, {"answers": [{"content": "Per Dunes' suggestion, I simply dropped the entire int concept entirely. As he pointed out, any vanilla object can implicitly be used as a unique key! In fact MyId could be defined as simply: class MyId: pass. Often, that would be it - a perfectly usable, implicitly unique key! For my use case, however, I need to pass these keys back and forth across sub processes (via multiprocessing queues).  I ran into trouble with that ultra light weight approach, as the hash value would change when the objects where pickled and pushed across processes.  A minor secondary concern was that I wanted to make these objects easy to log and manually read / match up through logs.  As such, I went with this: As you can see, I wrapped the short and sweet approach into a more comprehensive/verbose one. When I create the MyId object, I create a _MyIdPrivate member, and take the hash of that at that moment of creation.  When pickling, and pushing across sub projects, that _MyIdPrivate hash will change - but it doesn't matter because I captured the initial value, and everything ends up pivoting off of that.   The main benefit of this approach over the original int plan is that I get a unique key without \"calculating\" or assigning it directly.   As Dunes' suggested I could have also used a uuid. I can see pros and cons to that vs this...", "id": 53564100, "owner_tier": 0.5, "score": -3.3333333333333334e-09}, {"content": "That's because you need to override the __add__ method. If you don't override this method, it will use the builtin int __add__ method which returns a new integer object. See this topic which explains this behavior as mentioned by @martineau in comments.  Prints: isinstance True", "id": 53561712, "owner_tier": 0.5, "score": 0.9999999966666667}, {"content": "It sounds like what you're after is being able to check that values being passed around have been created in a specific way. In Python 3.5.2+ there is the typing module that provides NewType. This allows you to do static analysis of your code to make sure it's doing the things you expect it to do. The example given in the documentation is: The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors: No actual type checking is performed at runtime, and the value returned by NewType is just a pass-through function that returns its argument unchanged. This also means you cannot do things like isinstance(obj, UserId), since UserId is not an actual class. What is does mean is, as mentioned by the documentation, static type checkers will help uncover logical errors -- which seems like what you're after.", "id": 53562091, "owner_tier": 0.9, "score": 0.33333333}, {"content": "Instead of subclassing int just check that your instance variable is an int.", "id": 53561740, "owner_tier": 0.5, "score": -3.3333333333333334e-09}], "link": "https://stackoverflow.com/questions/53561517/how-to-subclass-int-and-use-isinstance-to-identify-instances-of-it", "question": {"content": "I want to subclass int (or some other analogous builtin numerical type), that I can explicitly type check.   This q&a is similar, but didn't answer what I'm seeing exactly:\nSub-classing a built-in Python type such as int Here's a rough example of what I'm trying to achieve:  Unfortunately, my invocation of isinstance returns False. How do I make it succeed (ideally with this same basic concept)? It's obvious how to achieve is this by giving MyId class a \"has a\" rather than \"is a\" relationship with int... but I thought it be nicer to just make it an int with a specific \"name\". Currently, I'm writing this in Py2, but any cross version answers are appreciated if applicable. ", "id": 53561517, "title": "How to subclass int and use isinstance to identify instances of it?", "traffic_rate": 917}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "subclass", "python-2.x", "isinstance"]}, {"answers": [{"content": "See __new__: __new__() is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation. It is also commonly overridden in custom metaclasses in order to customize class creation.", "id": 5693958, "owner_tier": 0.9, "score": 0.9999999988888888}], "link": "https://stackoverflow.com/questions/5693942/subclassing-int-and-overriding-the-init-method-python", "question": {"content": "Possible Duplicate:\ninheritance from str or int  Hi folks, I'm trying to subclass the int class without any success. Here is my attempt: If I perform the following: I get this error: Any ideas? :)", "id": 5693942, "title": "Subclassing int and overriding the __init__ method - Python", "traffic_rate": 5051}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "int", "subclassing", "built-in"]}, {"answers": [{"content": "You're nearly there, you just need to move your __setattr__ method up to the metaclass: Note that although the metaclass __setattr__ stops you changing attributes in the class it doesn't stop you hiding them with instance attributes: if that's what you want then you need to define __setattr__ in both places. Edit: updated to use Python 3.x syntax instead of ancient Python 2.x", "id": 12913628, "owner_tier": 0.9, "score": -3.3333333130750966e-09}, {"content": "Yep! You do it exactly the same way. A __setattr__ method on a class controls setting attributes on instances of that class. In Python, everything is an object. And objects have classes. So you just need to arrange for your class to be an instance of some class that has a __setattr__ method, exactly as you do when you want to prevent instances having their attributes modified! The class of a class is called a metaclass. The default metaclass is type: the \"type of types\", or \"class of classes\". You want to make a subclass of type that doesn't allow its instances attributes to be set (exactly as you make a subclass of object that doesn't allow its instances attributes to be set when you're doing this at the instance level). Note carefully the distinction between the base class(es) of SomeClass, and the class of SomeClass. SomeClass is a subclass of object. It is an instance of CantTouchThis. Almost everything else that works at instance level can be similarly applied to the class level with metaclasses; classes are simply instances like everything else. They only have their distinctive classy behaviour because of the methods and implementation of type (exactly as ... etc, etc).", "id": 12913833, "owner_tier": 0.9, "score": 0.9999999966666667}], "link": "https://stackoverflow.com/questions/12359707/prevent-alter-access-to-class-variables", "question": {"content": "Is there a way to prevent or alter access to class variables in Python as one can via overriding __setattr__ for instance variables? Note that this question is mistitled and actually refers to instance variables, not class variables. Based on reading multiple posts about the (apparent) deathtrap that is __slots__, I'd prefer not to go that route (and I haven't looked into it enough to know if it does what I'm asking). Example:", "id": 12359707, "title": "Prevent / alter access to class variables", "traffic_rate": 3}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python", "class-variables"]}, {"answers": [{"content": "This kinda works:", "id": 35973132, "owner_tier": 0.9, "score": 0.0}], "link": "https://stackoverflow.com/questions/35970121/allow-super-to-control-setattr-on-subclasses", "question": {"content": "This question is about the read-only problem for objects that are based on a super() and if/how super can/should control __setattr__ on subclasses. Context: Is there a way to write a meta class or a descriptor such that all classes that are subclasses of a class containing the attribute self.read_only = True cannot execute subclassed functions where getattr is starting with \"set_\", but where self.read_only = False can? I'm thinking that an override of object.__setattr__(self, name, value):  Called when an attribute assignment is attempted. This is called\n  instead of the normal mechanism (i.e. store the value in the instance\n  dictionary). name is the attribute name, value is the value to be\n  assigned to it. ...is the right direction, but am in doubt whether my interpretation of the documentation is correct. Example: Super as intended by the system designer: Sub made by the system-extender who has limited understanding of all consequences: Commentary to example In the MutableMessage the system-extender explicitly declares that read_only is False and is knowingly aware that of the consequences of adding the function set_topic.  In the ImmutableMessage (below), the system-extender forgets to declare that message should be read_only=False which should result in supers __setattr__ to raise AttributeError: Core question:\nWill a usage as shown in the example below suffice to apply consistently to all classes who are based on the BaseMessage class?  Think of me as new to meta-programming. Therefore an explanation of any misunderstandings and/or extension and correction of my example would be supreme. I understand the hierarchy [1] but do not have insight to what python does behind the curtains during the inheritance process. Thanks... [1]: The hierarchy The search order that Python uses for attributes goes like this: Since __setattr__ is first in line, if you have one you need to make it smart unless want it to handle all attribute setting for your class. It can be smart in either of two ways. a. Make it handle a specific set attributes only, or,  b. make it handle all but some set of attributes.  For the ones you don't want it to handle, call super().__setattr__. Related questions:", "id": 35970121, "title": "Allow super to control __setattr__ on subclasses", "traffic_rate": 2074}, "saved_time": 1721102370, "source": "stackoverflow", "tags": ["python-3.x", "inheritance", "setattr"]}, {"answers": [{"content": "The most likely reason is just simplicity. Why are TypedDict's not able to be generic? Because initial pep/implementation skipping that case made it easier to start with. There's some ongoing discussion to fix that and it's only like a hundred line change to support in cpython. The current variadic types pep is intentionally avoiding a lot of useful variadic features to get some implementation working with expectation of future peps to improve it.\n\n&#x200B;\n\nFrozen at dataclass level is useful in that it makes hashing safe. Mix of frozen and unfrozen fields would not give you that, but it can still be of value and I don't see any technical issue with it. If this is something you want I'd recommend bringing it up in python-ideas mailing list, https://mail.python.org/archives/list/python-ideas@python.org/. If there's general support for the idea you'd most likely want to make a small edit to dataclass pep updating definition, pr cpython for dataclass change, and some updates to documentation. Type checkers + linters will also be impacted but responsibility would be on them and I expect it to be fairly doable for them to support this. I doubt this would require a new pep/whole pep process.\n\n>Frozen at dataclass level is useful in that it makes hashing safe. Mix of frozen and unfrozen fields would not give you that, but it can still be of value and I don't see any technical issue with it.\n\nI normally would agree, but even with frozen dataclasses, you get to choose which attributes actually participate in generating a hash, so I don't see why it shouldn't be able to be mutable if it's not participating in the hashing process...\n\nI think the biggest thing is just simplicity. That frozen is related to hashing makes current rule simple too, but yes you could define hash as valid if all fields used are frozen. It's perfectly fine to ask for it to be extended. Most likely outcome I'd guess is neutral/weakly positive and if you do the implementation after discussion likely to pass.", "id": "hd1mgkm", "owner_tier": 0.5, "score": 0.8823529408823529}, {"content": "In 2018 I opened an issue to add this feature. I\u2019ve spent a lot of time with the implementation, and as others have said and you intuited it has to do with hashing and being able to use a frozen data class as a key in a dictionary, and not really to do with adding immutability to Python.\n\nThe current implementation (if memory serves) replaces the delattr and setattr to throw exceptions. I\u2019m not intending to work on the feature, but if you want to carry the torch that would be great!\n\nhttps://bugs.python.org/issue33474\n\nThis isn't as hard as this bug report makes it out to be.\n\nFrozen=true overrides setattr on the class. The behavior of the hash method depends on the class flag.\n\nThe descriptor object that represents a single field could very easily have the setter defined to throw an exception, without interacting at all with either of those attributes.", "id": "hd2ft5n", "owner_tier": 0.1, "score": 0.29411764676470586}, {"content": "That is the role of the named tuple. Immutable fields but you can still change them in a albeit painful way\n\n> That is the role of the named tuple.\n\nNot so.  All fields of a namedtuple are immutable.  OP just wants _some_ fields to be immutable.\n\nThe _replace method allows you to replace values in the named tuple. Note that the NamedTuple and namedtuple from typing and collections respectively are the same thing.\n\n`_replace` returns a new instance so it does not change anything regarding mutability.\n\n\\`dataclasses.replace\\` does the same thing.", "id": "hd1vq1f", "owner_tier": 0.3, "score": 0.9999999997058824}, {"content": "[attrs](https://www.attrs.org/en/stable/overview.html) (which is the library dataclasses is based upon / a stripped down copy of) supports individual frozen fields.", "id": "hd4kn25", "owner_tier": 0.5, "score": -2.9411764527133206e-10}], "link": "https://www.reddit.com/r/Python/comments/pp68bk/why_dont_dataclasses_allow_for_immutability_at/", "question": {"content": "As the title suggests, dataclasses in Python have the option of being set `frozen=True`, but when looking at the attibutes, if the object is mutable, there still is no option or possibility of making some fields mutable, while others are immutable? What was the reason for this design choice, because it seems valuable being able to have some immutable and some mutable properties...", "id": "pp68bk", "title": "Why don't dataclasses allow for immutability at the field level?", "traffic_rate": 207.942496260595}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "This has been talked about a lot but I don't see one specific point addressed:\n\nState.\n\nIf you need to store state and behavior, a class is, most of the time, what you're looking for. Even if it's only one piece of state and one behavior, a class is likely going to be a good choice.\n\nNow, if the class is _literally_ just a constructor and a method, then, yes, there's no state, and, thus, no need for a class.\n\nIn other languages, there's the concept of a _static_ class, which is a class that, basically, has no actual instances. Very often, static classes are used to store constants and some behavior related to them. More rarely, there may actually be state associated with these static classes in the form of static members.\n\nPython does have \"static\" members, sort of, and a static method could just be \"any method that doesn't affect the `self` of a class\". But that's not really \"pythonic\". \n\nBut importantly, using a static class to define one or two bits of behavior is generally better achieved through things like function pointers or their equivalent.\n\nAnd so, I think the safe takeaway here is this:\n\nIf you have at least some state, but also maybe some behavior, tie it to a class. If you have _just_ behavior, you probably don't need a class.\n\nAs always, be pragmatic, not dogmatic. If you find a reason to use a class with no state and a single method, by all means, do it.\n\nI think in this case it would probably be useful to base your class on some variant of dataclass to both get the benefit and to indicate why you did it that way.\n\nCounterpoint: if it's just one method, accept the state as a function argument, and return the new state. It's going to be a lot easier to test.\n\nI agree with your point on state. I have such classes to run heavy computations on chunks from data files and I need to keep track of the computation between chunks. Only other way would be to have sixteen return values passed to the next function call\n\n> Now, if the class is literally just a constructor and a method, then, yes, there's no state, and, thus, no need for a class.\n\nAnd also no real point of a constructor.\n\n> If you have just behavior, you probably don't need a class.\n\nI disagree here btw. There are several patterns that represent behavior. Sure, for many things you can just pass functions around, but sometimes it makes sense to accept behavior according to an interface.\n\nEven if there is state, a class is usually overkill. Putting them together often leads to weird practices that can be very un-ergonomic when you can often just put data into a list or a dict and get on with processing it as needed in separate functions.\n\nIsn't @classmethod basically a static function?\n\nWhy do you write: \"Now, if the class is literally just a constructor and a method, then, yes, there's no state, and, thus, no need for a class.\"?\n\nInitial state is typically set in the constructor.\n\n    class SomeClass:\n        def __init__(self):\n            self.state = 1\n\nThat's a class with just a constructor and it has state.\n\nNow, a class like  that doesn't make sense but saying it has no state is incorrect.\n\nMy first question was literally\n\n\"What if the constructor is used to initialize data and there's just one function tomanipulate it?\"\n\nA good example is a simple timer, your constructor saves the current time and a single function exists to calculate the difference, report it, and delete itself (if you wanted to do that, you could obviously implement a stop/start function into the clock if you wanted).\n\nWas gonna write a comment if there wasn\u2019t an answer like this. Yup, state is the answer and nothing else.\n\nIt is worth mentioning that functions with state can be done via closures. It's rare that this is a readability win for the \"class with a constructor and one method\" use case, but a closure is more or less the canonical way to implement a stateful decorator.", "id": "i16jeke", "owner_tier": 0.7, "score": 0.9999999999721448}, {"content": "May be talking about [Stop Writing Classes.](https://youtu.be/o9pEzgHorH0) \n\nI generally agree with the sentiment as I see them very overused, especially from people switching from Java. \n\nHowever don't shoot yourself in the foot trying to avoid them and start using globals or some garbage. They have their place and when you need clean namespaces, inheritance, etc don't avoid them.\n\nYeah I think this was the one. Thanks! There was also another guy who was a vim wizard coding in a live presentation and similarly talking about being able to refactor huge libraries into a few functions.\n\nI forgot exactly who said it, but object-oriented programming is supposed to be about messaging. Getting a piece of data from A to B. This, I think, helps distinguish the need for a class versus a function. In some languages, the tree of communication can be visualized by nested trees of logic in a function, where each block could be represented by a data class that encapsulates the operation.\n\nWhat I've typically done is, if I find myself sharing similar arguments between functions, I choose to move them into a class with a constructor, and either use the new data class as an argument, or I bind methods to the class that represent the individual work items, and perhaps even add a static constructor that unifies the workflow.\n\nEdit: [StackExchange comment thread relevant to my referenced quote](https://softwareengineering.stackexchange.com/questions/46592/so-what-did-alan-kay-really-mean-by-the-term-object-oriented)\n\nJust don't take it as dogma.\n\nBut yes, many problems out there doesn't *need* OOP classes. Arguably the latest \"best practise\" is to avoid OOP and the mess that you get from it, unless the problem is really helped by it.\n\nUsing dataclasses or Pydantic BaseModels and simple functions that manipulate them (without mutation!) often leads to a much simpler and straight forward solution than classes. Technically dataclasses and BaseModels are classes (as that's how they're implemented), but they're essentially used as dumb holders of state.\n\nIn some other languages you have \"structs\" and \"classes\", where structs are dumb while classes is a combination of a struct and a set of functions. In Python you can simulate structs by using classes without methods.\n\n---\n\nI've written quite a few production codebases in Python with tens of thousands of lines, where 97% of the business logic was implemented with dumb data structures (dataclasses/pydantic BaseModels) and functions. It's much nicer to work with than OOP codebases, that tend to be much harder to reason about or write tests for.\n\n>similarly talking about being able to refactor huge libraries into a few functions.\n\nYeah, making functions tends to improve your ability to create composable and re-usable functions, which often leads to much less code being needed to fulfill the same result. This is especially true when writing extremely abstract functions, though you should be careful not going too far in that direction as that can make the actual implementation a bit too opaque at times.\n\n> vim wizard coding in a live presentation and similarly talking about being able to refactor huge libraries into a few functions.\n\nmaybe [The Mental Game of Python - Raymond Hettinger](https://www.youtube.com/watch?v=UANN2Eu6ZnM)?\n\nalthough I think its emacs, not vim.\n\nThe bread and butter of my niche is messaging, and OOP is typically a suboptimal choice. It works well if you want to communicate state (and maybe some other situations I just haven\u2019t encountered) but usually you just need  functions to do whatever transforms.\n\nOOP is about logic, and being able to use programming idioms that map to the concepts in your problem.  I have seen OOP implemented poorly, with massive classes that try to do everything.  But small clean classes are often a thing of beauty.\n\n\"Just don't take it as dogma\"\n\nIf programmers at large internalize this one statement things would be so much better.\n\n>although I think its emacs, not vim\n\nThe idea that anyone could mistake one for the other. Horrific.j\n\nI added a link in my original comment, but messaging is meant more abstractly, as the modus operandi of a language, and why it works the way it does, not the problem it's trying to solve.", "id": "i16h2bp", "owner_tier": 0.5, "score": 0.44011142058495817}, {"content": "I agree to this statement.\n\nI only use a class where information and behavior is tightly coupled (or if a framework forces me to write a class). If there is only behavior, a function is better. For only data, there are a few better options in Python like dataclasses or even just a plain dict.\n\nThis makes code easier to understand and easier to test.\n\nDataclasses are amazing. Would highly recommend that over a dict.\n\nI see this misunderstanding everywhere. People make reasonable arguments about classes being overused as a way to tie together data abstraction and functionality abstraction. But then people take it to mean don't make data abstractions. Please for the love of all things make more data abstractions.\n\nAnd ideally not dict. Dicts are nameless. Use dataclasses or named tuples or even just classes with only \\_\\_inti\\_\\_ functions.\n\nA lack of data abstractions is so much worse of a problem in the average code base than too much coupling of data and functions. Both can be a problem but one is far far more prevalent.\n\nPlease stop using plain dicts to store data, 8 months later, a poor sap will get hired and will have an onboarding task that will require him to modify something that\u2019s using your dict and by god he will curse you because he will home no insight into your data structure\u2026 so for the love of all is sacred use dataclasses / pydantic models \ud83e\udd72", "id": "i16hgyf", "owner_tier": 0.7, "score": 0.20612813367688024}, {"content": "I believe you misunderstood the statement.\n\nClass - amid other thing - may serve to preserve a state. So, it may have `__init__` method to create the (initial) state - and any number of methods (even one) to combine processing of the initial state with the arguments of the function. The initial state may remain the same - or be changed.\n\nWhat is wrong it to have a stateless class just wrapping one - or more - functions, Java-style.\n\nI may hazard a guess that you meant [Stop Writing Classes](https://youtu.be/o9pEzgHorH0) talk.", "id": "i16mx2r", "owner_tier": 0.1, "score": 0.06685236766016713}, {"content": "Yes, anything that has the form\n\n```\nclass ABC:\n   def __init__(self, stuff):\n       self.__stuff = stuff\n\n   def do_thing(self, args):\n       ... do something with args and self.__stuff ...\n```\n\nCan be expressed as\n\n```\ndef do_thing(stuff, args):\n    ...\n\nabc = functools.partial(do_thing, stuff)\n```\n\nor\n\n```\ndef abc(stuff)\n   def do_thing(args):\n      ... # maybe \"nonlocal stuff\"\n   return do_thing\n```\n\nBut it is a judgement call as to whether the generic function call syntax conveys enough information for your purposes `f()` or whether you think the added method name adds enough value `f.do_thing()`\n\nI think its important to recognize the equivalence though, and I think for library design taking a plain function is often better design. Thats just my thought though\n\nImo you should always accept a callable and let the user of your library decide how that callable is implemented (class, function, lambda\u2026)\n\nYeah that makes sense. I just learned about partials today and looking at functional patterns and it made me think of all the dozens of classes I've written that have that form you mentioned.\n\nAre there other reasons (like performance / overhead) for choosing between the two patterns? I know that I've head problems before for having too many classes and abstractions.\n\nTriple backticks doesn't work with most reddit implementations (including old.reddit.com which plenty of people still use), you need to prepend every \"code\" line with four spaces instead.\n\nI found a very good academic paper on OOP design principles and when to use classes vs functions years ago and I cannot find it anymore\n\n> Are there other reasons (like performance / overhead) for choosing between the two patterns?\n\nArguably neither are best. OOP does reduce performance, but then so does writing functional immutable code. But if you're using Python, speed shouldn't need to be an issue anyway, as Python is very slow.\n\nThe problem with purely functional approaches is that some things gets more complicated, and some people tend to write functions that are too abstract, which makes it harder for humans to reason about what's actually happening. And there are some problems that are much easier to solve by using encapsulation and/or mutation.\n\nThe great thing about Python is that it's a multi-paradigm language: you can use whatever patterns that best fit your problem. You can write 95% of your code base in an immutable functional way, and use OOP for the 5% that fits it best.\n\nFor example, at work, I work with a ~20k lines-of-code codebase where almost all of it consists of dumb classes (pydantic BaseModels) and functions, but I use a few classes to manage state like database connections, messaging queue connections or shared caches. But most of the core business logic is written as simple functions, that are easy to write tests for.\n\nIn the code pattern that the rule actually is about (and not the what-if-we-make-it-do-10-things hypotheticals that get thrown around) replacing the class with just the inner method that takes the parameters explicitly adds no \"functional\" overhead. In fact passing them to a constructor, stuffing them on a class instance, taking them back out is a more owrk than just passing them to the function directly. \n\nThis is not about \"functional\" programming, its about .. when you have a plain old function, not unnecessarily chopping it in 2 and adding 0-value OOP cruft.", "id": "i16glhs", "owner_tier": 0.5, "score": 0.0612813370194986}, {"content": "The purpose of `class` is to give you the ability to define your own types. If you don't need that kind of abstraction, then it's generally better to go with a simpler construct, like a function or even a closure.\n\nHere's an example of a `class` with one method that I would consider a valid use:\n```python\nclass Settings:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def to_dict(self):\n        return {\n            \"a\": self.a\n            \"b\": self.b\n        }\n```\nyes we could store this as a dict. But the abstraction tells us something about what this type of object is, instead of just being a collection of `key: value` pairs.\n\nAnd as I eluded to, closures are how you would store state given a functional approach. Python has a `nonlocal` keyword which can override the scope of an enclosed function to include variables from outside the inner functions scope.\n\n```python\ndef counter(value=0):\n    def _count():\n        nonlocal value\n        value += 1\n        return value\n    return _count\n\n>>> c = counter()\n>>> c()\n1\n>>> c()\n2\n```\n\n>example of a class with one method that I would consider a valid use:\n\nFor something like that, I'd consider `TypedDict` or maybe `NamedTuple` to be a better fit.", "id": "i16n4u4", "owner_tier": 0.5, "score": 0.05571030637883008}, {"content": "It makes sense if you're just looking for that one bit of functionality but I wouldn't take this as a hard rule to apply to all one-method classes as often you want to make a class to inherit from which might make sense to have only one method, particularly if it's planned to expand in the future. \n\nWithout seeing what the guy in the video is actually saying it sounds quite rash and I wouldn't blindly start implementing that. \n\nTry to use the right thing for the right functionality, I would guess that's what the presenter is also trying to say\n\nThis right here.  All my one method classes are because it's the base class for a tree of happy horseshit to follow.", "id": "i16g2da", "owner_tier": 0.5, "score": 0.027855153175487462}, {"content": "I frequently use dataclasses without any methods as a replacement for named tuples.  \n\nHow would I replace a class with a function? Got any examples?\n\nSame here.  I like the clear and simple syntax.\n\nNamed tuple - after a \"higher-level\" initialization - creates a class. Like\n\n    Point = namedtuple('Point', 'x, y')\n\nCreates a class `Point` that may be later instantiated with values for attributes.\n\nNothing wrong with `dataclass` without methods.\n\nA dataclass is just fine for carrying around a bag of data. The rule of thumb being discussed is about a case where behavior is being represented as a class and yet the intermediate storage of data in the class adds no value as it could have just as easily been passed as function parameters to the method that implements the useful behavior.\n\nYou don't replace the class with a function. You replace the single method with a function and pass in the data structure (even if it is some small custom class based on a named tuple, but with no methods).", "id": "i16g5ku", "owner_tier": 0.5, "score": 0.016713091894150416}, {"content": "Here is a simple class I use for CLIs that have a `verbose` option.  In the main function you can set the option in class and use it in place of print.\n\n\n    class VerbosePrint:\n        def __init__(self, verbose: bool):\n            self.verbose = verbose\n    \n        def __call__(self, *args, **kwargs):\n            if self.verbose:\n                print(*args, **kwargs)\n\n\nIn the main function you can set :\n\n\n    def main(a, b, c, verbose):\n        vprint = VerbosePrint(verbose)\n        ...\n    \n        vprint('Some message')\n\nThis prevents having to make a bunch of if-blocks, and from referencing an out of local scope variable.\n\nBut you could just do:\n\n    def verbose_print(verbose):\n        def wrapper(*args, **kwargs):\n            if verbose:\n                print(*args, **kwargs)\n        return wrapper\n\nAnd then just have:\n\n    vprint = verbose_print(verbose=True)\n    vprint(\"Some message\")\n\nOr:\n\n    from functools import partial\n    \n    def verbose_print(verbose, *args, **kwargs):\n        if verbose:\n            print(*args, **kwargs)\n    \n    vprint = partial(verbose_print, True)\n    vprint(\"Some message\")\n\nYup", "id": "i17g9bu", "owner_tier": 0.7, "score": 0.03899721445682451}, {"content": "I disagree because you can store attributes such as variable in it.\n\nLike having multiple objects of a Dog class where you store info about them.\n\nDog1.colour\n\nIn that case, its not just a class with an init and multiple methods, its a class with one method and some publicly available properties. It doesn't fit the heuristic\n\nNot that you should do it, but you can also do it with a function.\n\n    def test():\n        return\n    test.x =  3\n    print(test.x)\n    >>> 3\n\nThat seems like a good example. Imagine a base class with a dozen attributes, and five subclasses that all need them. The alternative approach would be to define all dozen attributes in all five subclasses, which violates DRY.\n\nYou could just use a dictionary in that case. \n\nThe point being that unless you have a bunch of functions to mutate the state of the instance in different ways (or render state in different ways, or need to compare them etc.), then the mutations you would make are simple enough that you can just update a dictionary instead, or pass the dict or whatever to a function for that single mutation you are performing on the object.\n\nThen better write dataclass with methods needed\n\nSo when faed with \"if you have a class with a constructor and a single method\" you substitue for \"if you have a class with a constructor, a single method and a random assortment of other things\" and base your critique on that?\n\nThe rule of thumb is specifically about the pattern where you have a constructor that captures a couple of parameters and a method that makes use of them, and the class does nothing else. In essence Foo(a,b).do\\_it(c) is just an awkward way to write do\\_foo(a,b,c).\n\nIf you have other fields or the class does other things apart from being a place to temporarily park function parameters then it does not match the rule.\n\nIf you just want to capture function parameters in 2 (or more) stages for whatever reason, there is functools.partial for that, no need to create an ad-hoc class.\n\nWoa, I've never seen this.\n\n>  base class with a dozen attributes, and five subclasses\n\nThen it's not a class with just a constructor and one method.\n\nIt's a class with a constructor, one method, and five subclasses and this rule no longer applies.\n\nDRY?\n\nA dictionary is a garbage choice for that. At least use a dataclass.", "id": "i16ftit", "owner_tier": 0.1, "score": 0.10863509746518106}, {"content": "> > \"If a class is just a constructor and one method, then it shouldn't be a class at all. It should be a function.\"\n\nI don't think it's quite right to look at a class with just a single method and think \"that's wrong\" or that it's a misuse of OOP. It's a minor design detail, really. \n\nThe existence of and use cases for things like `SimpleNamespace` and `dataclasses` would probably also serve as decent counter-examples to that statement.\n\nI tend to favor classes as they are more mailable (useful to users of my code) than functions.\n\n>The existence of and use cases for things like SimpleNamespace and dataclasses would probably also serve as decent counter-examples to that statement.\n\nDataclasses didn't exist at the time the \"Stop Writing Classes\" presentation was made.   Jack Deiderick is a core python developer, so he does know a thing or two.  \n\nIMO, a dataclass isn't a class, so you're not even writing a class.  You're writing a bag of data that could have been a dictionary or a tuple or namedtuple or whatever.  It just has a name, which is useful (ever try to decode a list of lists of lists of 18 floats?).  It's ever so slightly faster than a namedtuple and doesn't equal to a an unlike bag of data (date=(2022,3,18) vs. xyz=(2022,3,18)).\n\nReally depends. Do you need something that changes state and do you need multiple instance of that state. Think of any class that might do a interview coding problem like get all the primes and you need to make a method next_prime(). Of course you could do it some other way as well.\n\nThe point of a dataclass is to contain data. The pattern being advocated against is a class whose primary purpose is that one method, and any state is just function parameters (perhaps captured earlier) in disguise.\n\n> Dataclasses didn't exist at the time the \"Stop Writing Classes\" presentation was made. Jack Deiderick is a core python developer, so he does know a thing or two.\n\nSure. I don't think I ever implied anything different. \n\nFunny enough, the exact same year at PyCon, in fact _just_ before Jack's talk, Raymond Hettinger gave a talk on [The Art of Subclassing](https://www.youtube.com/watch?v=miGolgp9xq8) which makes almost the opposite argument (which Raymond points out at the beginning of the talk).\n\nJust so far as to say, reasonable people can disagree; it's a design decision.\n\nYeah, I think it should go without saying that, like most things, _it depends_. It would be a bit silly to say you should always do one or the other.\n\nOn balance, if I have a tossup in my mind about what decision to make, I tend to lean towards making classes. Maybe because I've been burned too many times by (others) choosing functions.\n\nAs an attempt to illustrate: I hate it whenever I need to change the behavior of some module that's just a collection of inter-related functions.\n\n\n\n    # annoying_module.py\n    def foo(...):\n        ...  # like 10 lines of code\n        x = bar(...)\n        ... # another 10 or 15 lines of code\n        return baz(x)\n\n\nNow, imagine I'm a user of `annoying_module.foo`. I really like this module, it does a lot of things really well. Though, I want to modify the process of one of its dependent functions, `bar`, so that when I call `annoying_module.foo` it will use _my_ function instead of `annoying_module.bar`. \n\n\nIf `annoying_module` had used a class to define its functionality, it would be relatively simple to subclass and alter the behavior of the `bar` member. Unless you're willing/able to resort to monkey-patching, there's no easy way for me, as a user, to minimally alter `annoying_module`'s behavior when it uses functions.\n\nThat's hilarious.  I haven't seen that one.  I'll give it a watch.\n\nI definitely disagree with Jack's simplification.  I think it's a bit too obtuse, but it's not my codebase.  How \"obtuse\" something is depends entirely on your skill as a programmer and the strength of your team.  If you're the best person on your team or writing something for people that aren't as good as you, be a bit more explicit.\n\nI dislike functional programming, which is what Jack was pushing for, but it does have it's place.  It's a tool at the end of the day.", "id": "i16h2lv", "owner_tier": 0.7, "score": 0.013927576573816157}, {"content": "I love how this is implemented with react hooks. Makes whole web pages into functions, how useful.", "id": "i16i4n3", "owner_tier": 0.5, "score": -2.7855153034053735e-11}, {"content": "Hey OP, is this the video that you mention?\nhttps://youtu.be/5ZKvwuZSiyc\nIt's quite old actually and pretty hard to find. Fortunately I've had it in my YouTube history :)", "id": "i16k4w9", "owner_tier": 0.1, "score": -2.7855153034053735e-11}, {"content": "1) You might want a functor\n2) You might want to track some class attributes rather than just instance ones\n3) You might want to leave room for it to become more complicated later in production\n\n\nI know it's trendy right right now to try and avoid OOP, but a nice neat OOP that your whole team can maintain easily is a million times better than a bunch of function factories that you have to explain to every new dev who looks at it", "id": "i17aevi", "owner_tier": 0.5, "score": -2.7855153034053735e-11}, {"content": "I don\u2019t agree. Currying initial state into a first-class function and then passing it around, is less readable than just using the classic Command design pattern (which is, you guessed it, a class with a constructor and one method).\n\nThe first one is more common in languages that don\u2019t really support OOP. Liked LISP, Scheme, Haskell and JavaScript. Python has better OOP support than those languages.", "id": "i17aqaw", "owner_tier": 0.7, "score": -2.7855153034053735e-11}, {"content": "If a class only inits itself with one method, it is just a function by output. But the methods are still classify-able. This extends its utility, beyond the scope of a function, however, it may appear to act like a function by execution alone. \n\nKinda falls under the headache-inducing paradox of schrodingers box. \u201cIf there is py script running and inside that file there are functions , you won\u2019t know if the function is within a single method class until debugged upon\u201d \n\n\nSince a class is an abstract data class and essentially a blueprint, yes the blueprint could act like a function by being self-initiated with one method. In fact it would just be a blueprint or container that contains a defined function. \n\nImagine for a minute, \n\nyou are examining a dog, you have never seen a dogs paw before, you point to the paw of the dog and you ask your dim friend, \n\n\u201c what is this?!\u201d \n\nand they said, \u201cit\u2019s a dog\u201d.", "id": "i17o4js", "owner_tier": 0.1, "score": -2.7855153034053735e-11}, {"content": "It kinda is true. Unless your stuff purely has to do with data like a NamedTuple or something along those lines, there really isn't much of a reason to have a separate class.", "id": "i17vwca", "owner_tier": 0.5, "score": -2.7855153034053735e-11}, {"content": "ive seen some classes where the method doesnt even make use of self. OOP for the sake of OOP makes me want to toaster bath", "id": "i18z4ug", "owner_tier": 0.5, "score": -2.7855153034053735e-11}], "link": "https://www.reddit.com/r/Python/comments/th6ztt/ive_heard_that_if_a_class_is_just_a_constructor/", "question": {"content": "I watched a seminar a few years ago about someone talking about the misuses of OOP in python and talked extensively about the case where people write a class, implement the `__init__()` method and one extra method and that's it.\n\nHe provided examples and showed functional code that simplifies the solution to a few lines and he said:\n\n> \"If a class is just a constructor and one method, then it shouldn't be a class at all. It should be a function.\"\n\nI can't find the video anymore, but I was just wondering what reddit thinks about this statement and if you have any counter examples or in what cases it could be useful.\n\nI'm also interested in the cases where if it is true, how would that functional implementation look like when I need some sort of a state to persist.\n\n\nEDIT: Awesome discussion in the comments. Thanks for everyone's input!", "id": "th6ztt", "title": "I've heard that \"if a class is just a constructor and one method, then it should be a function\". What is your opinion on this and what are counter examples?", "traffic_rate": 207.942496260595}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "That\u2019s what happens when you let Java devs do python?\n\nI worked in a team like that, we had multiple empty classes", "id": "jdo97e1", "owner_tier": 0.3, "score": 0.6470588235076252}, {"content": "Okay dumbass moment, but the hell is the point of \"factory\" classes anyways?\n\nLike even in Java, it seems like abstraction for the point of abstraction\n\nFactory classes are a design pattern that is used when you don't know what subclass will be called beforehand.\n\nFor example: You have a Tetronimo() class, with each Tetris piece being a subclass.  The game knows that every time you add a piece to the board, it will be a Tetronimo(), but it could be an LPiece(), a TPiece(), an IPiece() or so on.  So you make a Tetronimo.generate() method that returns a Tetronimo() subclass when you ask for one.\n\nYou can read more [here](https://refactoring.guru/design-patterns/factory-method), hope this helps!\n\nI've found the factory pattern useful when creating unit tests to abstract away creation details of classes for objects from a database ORM (e.g. I don't want to have to specify first name, last name, signup date etc for every User I create in a test if it's only relevant that they have different Usernames). If done well it can help minimise code duplication in the setups for your tests and allow changes to be more easily made to the class without fear of having to fix 100 broken tests.\n\nAllows other people to write tests faster using those class instances as well assuming you have good defaults and parameters.\n\nAnother simple use case is just when you need to create a bunch of the same object all over the place, but want to keep your code DRY. So instead of repeating\n\n    var client = new HttpClient(baseAddress);\n    client.DefaultRequestHeaders.Add(\"apiKey\", apiKey);\n    client...\n\nall over the place, you can use\n\n    HttpClientFactory.CreateClient();\n\nAnd only have to define the basics once\n\nThere are some answers here: https://softwareengineering.stackexchange.com/questions/200647/why-is-the-factory-method-design-pattern-more-useful-than-having-classes-and-cal\n\nI feel most heavy OOP codebases (whether by decision or language) end up with lots of this kind of garbage in them.\n\nYour question has been answered but just would like to add that it's good to know your design patterns, get asked alot on interviews as well in my experience\n\nAs people other already mentioned, it\u2019s to aid unit testing. I want to also chime in that static methods are in general bad for unit testing. They create hard wired dependencies which makes it difficult to isolate the code you actually want to test.\n\nA constructor is a form of a static method. Using them creates hard wired dependencies, which makes your code less testable. With factories you convert the bad static method (the constructor) to a class method, which makes it more easy to isolate your tests with e.g. mocking.\n\nHowever, it doesn\u2019t look like that was the intention with OP\u2019s code. I don\u2019t see what\u2019s to gain with this factory. OP\u2019s code is just a terrible abstraction for the sake of abstraction.\n\nThere are two cases there:\n\n1) You just want a function that encapsulates few steps needed to build an object. This could be a free function, but you language does not support free functions, so just make it a static function in an otherwise dummy class.\n\n2) You need to abstract other different ways of constructing an object. Maybe you want different implementations with same interface/base class. Or it can be just one specific class, but you still want to abstract over which parameters are passed to the initializer. And you can\u2019t just pass an instance, because you want control over when and how many instances are created to be in the callee. So you pass a factory object. If factory interface has a single method, it many languages you can pass anonymous function without declaring separate interface and writing implementation as a class. But Java has its own limitations.\n\nFactory classes are also useful to enforce immutability.  Many OO practitioners consider immutability of instances to be a Good Thing, ie, you should never really have 'setters', and all of the object's dependencies should be provided at object creation time.  So if you need an object of type X that has N dependencies, but one of those dependencies isn't available just yet, you can instead work with an (immutable) XFactory object that has the N-1 dependencies and can create an instance of X once given that last dependency.  Then everything is nice and immutable.  \n\nCompare this to the non factory situation where you would have a mostly-constructed X and then you would still need to call setProperty() later to provide that final missing dependency.  This is a design smell because you can't always guarantee that all instances of X are valid or well-formed, etc...\n\nOh, so runtime decisions.\n\nEvery time I've seen this it's always a SomeRandomClassBuilderFactory that makes a SomeRandomClassBuilder, which itself makes a SomeRandomClass\n\nNone of which have any real logic in them. Like, that's just `new` with extra steps", "id": "jdoob2f", "owner_tier": 0.7, "score": 0.9999999999782135}, {"content": "What's so bad about this? This ensures that ff_value and string is never mistyped\n\nMaking it an enum would be better. They could have also saved the factory and just put the make in the pseudo enum class they already have but that\u2019s mostly semantics.\n\nLike many things in programming horror, this isn\u2019t actually that horrible just kind of a small over sight if it was made ground up like this. That said it could have easily been far more complicated at one time justifying a factory and changing requirements could have lead to this design.\n\nI think it's honestly not that bad.\n\nProbably would be better to actually use a class instead of a dict though. Then you could just write a constructor instead of a weird factory.\n\nThe function is fine, but putting it in a class achieves nothing\n\nJunior devs being junior devs\n\nEnums are a fairly recent addition to Python.\n\nThat's what I would do. But everyone here seems to be talking about how you could just instantiate the direct directly.\n\nNah, this is senior java developer trying to write Python.\n\nSource: Am senior java dev that writes shitty Python code like this.\n\nAdded in 3.4, just 9 years ago.\n\nlol! thank you for the one honest and funny answer.\n\nI think in \u201cPython years\u201d that\u2019s recent. I know some Python folks who still have yet to migrate from 2.x", "id": "jdovxt8", "owner_tier": 0.5, "score": 0.42919389976034855}, {"content": "lol, this code is fine.  I don't know python but I can read and comprehend what it's doing.  One day, you will discover that writing clear code is much more important than whatever code you think would be better, here.\n\n>  One day, you will discover that writing clear code is much more important than whatever code you think would be better, here\n\nThere is absolutely nothing \"clear\" about this code lmao. And this says everything:\n\n> I don't know python\n\nThere you go. If you don't even know python -one of the easiest languages in the world- what in the world makes you think you are qualified to leave your comment?\n\n<-- Spotted the one who doesn't code on their phone very often.\n\nThe code is clear enough for me to get the gist without knowing the syntax.\n\nAnd what makes me qualified is the 40 years I have spent writing software professionally up till and including today.\n\nTry that gatekeeper shit on someone else.\n\nWho on earth voluntarily codes on their phone\n\nyou caught me.  I am definitely not going to code on a phone.\n\nI feel for the other programmers who had to deal with your trash code. \n\n>Try that gatekeeper shit on someone else.\n\nGatekeeping? Lmao. If you LITERALLY don't know python then what in the hell makes you think you can talk back to real programmers about the matter? You aren't some innocent beginner being denied help (what gatekeeping actually would be)- you are an arrogant snob who sucks at programming. Keep your idiotic comments to yourself.\n\nI wouldn\u2019t do anything real, but little one off scripts or very small personal projects when I have nothing else on me? It\u2019s reasonably doable.\n\n\nI\u2019m not sure how it was on topic though?\n\nI don't know python because I get paid.\n\nThat makes zero sense whatsoever. Which figures.\n\nYou'll understand when you start to get paid.\n\nYou're obviously a jr dev, at best, and you haven't spent any time working to maintain software over years of time.  Clear code is always better than clever shortcuts.", "id": "jdoz3dg", "owner_tier": 0.3, "score": 0.03267973854030501}, {"content": "How would you improve it?\n\n    from typing import NamedTuple\n    class ProxyType(NamedTuple):\n        ff_value: str\n        string: str\n\n    class Proxies:\n        DIRECT = ProxyType(0, 'DIRECT')\n        MANUAL = ProxyType(1, 'MANUAL')\n        #...\n\nRemove the Factory class and just keep the function.\n\nhttps://youtube.com/watch?v=o9pEzgHorH0\n\nThanks! I don't know Python very well so was curious about it.\n\nIs it possible `NamedTuple` didn't exist when the code was written, and the code was fine back then?\n\nnamedTuple has existed in some form since Python 2.6 (2008) and this version since 3.6 (2016). \n\nBut it's possible that most Python developers simply aren't aware of it or prefer not to use it, since Python is a very flexible language.", "id": "jdp1vba", "owner_tier": 0.7, "score": 0.08714596947712418}, {"content": "Mfw he probably saved 30 minutes of work that equates to $300", "id": "jdpshbq", "owner_tier": 0.7, "score": 0.010893246165577342}, {"content": "\"Clean code\"", "id": "jdqut8y", "owner_tier": 0.3, "score": 0.0043572984531590414}, {"content": "when you wanna do OOP but you forget to KISS it \ud83d\ude18", "id": "jdouskk", "owner_tier": 0.5, "score": 0.0021786492156862748}, {"content": "I always wanted to have a factory. Now i am complete, i used all the GOF patterns", "id": "jdqhbuz", "owner_tier": 0.3, "score": 0.0021786492156862748}, {"content": "Should have been a data class instead, but this was probably done before that existed.", "id": "jebva00", "owner_tier": 0.3, "score": -2.1786492242320894e-11}, {"content": "Better yet:\n\n```py\nclass ProxyType:\n    def __init__(self) -> None:\n        strings = enumerate([\n            \"DIRECT\",\n            \"MANUAL\",\n            \"PAC\",\n            \"RESERVED1\",\n            \"AUTODETECT\",\n            \"SYSTEM\",\n            \"UNSPECIFIED\"\n        ], 0)\n\n        [(self.__dict__.update({x: {\"ff_value\": i, \"string\": x}})) for i, x in strings]\n```\n\nEven better yet:\n\n    import enum\n\n    class ProxyType(enum.Enum):\n        DIRECT = 0\n        MANUAL = 1\n        PAC = 2\n        RESERVED1 = 3\n        AUTODETECT = 4\n        SYSTEM = 7\n        UNSPECIFIED = 8\n\n(I like to make code maintenance impossible)\n\nuntil you need to ever add another field with more information about a proxy type\n\nNice, however the amount of down votes is honestly crazy \ud83e\udd69\ud83d\udeb2\n\nI forget the details but you can create enums with extra attributes just for that situation. Like if you made enums for different colors, you can give each one multiple attributes so you can do things like Color.RED.hex and Color.RED.rgb\n\ngiven that the value it's representing is patently an enum, I don't see an issue. And in case there's another property you'd want to uniquely associate per variant, you'd just have a getter function that switches on it/does a dict lookup (or maybe there are decorators that can do this or something)\n\nYAGNI", "id": "jdorucy", "owner_tier": 0.1, "score": 0.07625272328976035}], "link": "https://www.reddit.com/r/programminghorror/comments/121zydc/found_in_the_python_selenium_code_base_imagine/", "question": {"content": "", "id": "121zydc", "title": "Found in the Python Selenium code base. Imagine how much time was saved with this abstraction", "traffic_rate": 76.3728362183755}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "I can't say that I know the answer to your question, but I can give you my perspective.  \n\nI am an astrophysicist who works with simulations and simulation data.  Most of my work is fairly linear in nature meaning that I do A then B to get to C.  I then proceed to plot C or do further data manipulation/reduction/etc.  Early in grad school I picked up *C* as it was the language my adviser used; but that quickly got tiresome as I was always writing new code to output ASCII files for plotting.  \n\nOnce I started using python all of that changed since I could do the calculations and the plotting in the same place with simple scripts (no compilation) and results started to come a lot quicker.  However, I was still doing things in a linear fashion and storing large arrays with multiple indexes to represent different properties.  And it ended up that if I wanted to plot data from multiple simulations I had to save those arrays to a file (npz in my case) and remember all of my indexes and naming conventions.  This became a pain when I started changing or adding things to those modules and the indexes/names changed.\n\nIt wasn't until recently (August) that I discovered object-oriented programming and how to use it in python.  I have since rewritten my entire analysis suite (that I spent the previous 6 months working on) to be object-oriented.  Not only is my code cleaner, shorter, and easier to read/maintain/edit/add/subtract - it's much more user friendly.  I can now plot multiple datasets with ease, and access information much quicker without having to write entire new scripts.  I personally don't use methods very often in each of my classes, but having individual objects each with their own set of attributes has proved immensely helpful in my work.  I like to think of the classes as python's structures.\n\nAnyway, hope that helps!\n\n[deleted]\n\nhow did you learn? I've been trying to find resources but I can't find anything. I think I've been using the wrong keywords\n\nI'm guessing something along the lines of[ another example](http://www.reddit.com/r/Python/comments/1qvoop/ive_been_using_python_for_3_years_and_ive_never/cdh2enm) in this thread.\n\nIt's difficult to cite specific examples because the code has changed so drastically (was completely rewritten).  What I've built now is more of a 'framework' rather than just a set of functions.\n\nOne thing we can look at is data handling and the convenience of keeping track of it all.  My simulations typically have thousands of galaxies with an array of different properties.  Each has a gas mass, stellar mass, radius, star formation rate, metallicity just to name a few properties.  To store this data in a non-object oriented python way I simply created large arrays for each of these properties.  To get access to this data I just cycled through the galaxy indexes and all was well.  The problem comes when I want to expand upon this.  For example, I'd like to know exactly what gas & star particles belong to each galaxy, or I'd like to know what dark matter halo each galaxy resides in, and maybe even the properties of that halo as well.  This could probably be done with an array of lists or some other fancy method, but things were already starting to get messy.\n\nThe real question is: which approach is more appealing to you?  In my case the choice was between:\n\n1. Creating a large array for each galaxy property\n2. Creating an object for each galaxy\n\nFor me the second choice has turned out to be far more productive.  I can easily list and access the attributes of each individual galaxy without having to remember much about the structure of the arrays.  \n\nAnother benefit for me has turned out to be in my plotting routines.  I would read in data from a dataset, plot it, read in another dataset overwriting the variables from the previous dataset, plot it, etc etc.  Now I simply create a new object that holds all datasets of interest, and cycle through that; basically my plotting scripts have become more general and dynamic.\n\nI think what it all boils down to in my example is working with actual variable names as opposed to indexes.  So if I want to get the radius of galaxy 10 I can get it via approach 1 or 2:\n\n1. `radius[10]`\n2. `galaxies[10].radius`\n\nWhich I find the second to be far more intuitive to think about, especially when each galaxy has 10-20 properties associated with it.  Additionally, I could have galaxy specific functions (methods), create a class for each type of galaxy that inherits from the parent class, use polymorphism to redefine those galaxy specific methods, and all kinds of other stuff I don't know how to use very efficiently =)  I think the benefits of using classes even in the simplest cases speak for themselves once you start to use them.\n\n*All of what I have done is certainly doable without having to invoke classes, but I find using them to much cleaner and far more convenient*.  Hope that helps, if not let me know and I'll see about posting some code somewhere.\n\nI don't know about his case, but I can provide an useful example extrapolated from my work.   Part of my work involves using mixtures  of a large number of multi-dimensional Gaussians to describe my data.  I'll stick to single univariate Gaussians/Normals to illustrate my points though.   I've found one of the easiest ways to introduce object oriented programing is to describe it as a way to encapsulate data collections and common operations on that data into a single 'entity'.\n\nA normal distribution is parameterized by it's mean an variance.  And you'll typically want to evaluate things like the PDF or CDF of a normal, or calculate the likelihood or log-likelihood, or even perform affine transformations.  In a functional style each of those would be a function, that operates on the mean and variance ie:\n\ndef normalPDF(x,mean,var) ...\n\ndef normalCDF(x,mean,var) ...\n\n...\n\nwhich isn't so bad, unless you're dealing with large numbers of them, in which case you'll need some bookkeeping to keep your means and covariances paid up correctly.  And lets get back to the affine transform of a normal.  Functionally it'd probably look like:\n\ndef affineNormal(A,b,mean,var)\n\n...\n\nand return the new mean and variance of the transformed normal, but if you started using that in a bunch of places in the code, it'd probably get a little awkward as you'd be having to bookkeep two new values.\n\nWhat if we defined an object to represent our normal instead?  Recall we're describing a single distribution, that is parameterized by two values, so wouldn't it be nice to just treat it as a single thing (a distribution) as opposed to the two things that parameterize it?\n\nClass Normal:\n\n    def __init__(self, mean, var):\n        self.mean = mean\n        self.var = var\n...\n\nthis makes this easier for bookkeeping, as the object keeps the mean and variance together for us.  Heck if we've already written the functional version of the PDF or CDF we can exploit them as methods in our object:\n\n    def pdf(x):\n        return NormalPDF(x,self.mean,self.var)\n\n\nBut real saving comes from functions like our affine transform, as we can overload the arithmetic operators (+/- etc).\n\n    def __add__(self, k):\n        new_mean = self.mean + k\n        return Normal(new_mean, self.var)\n\nthis way we can make our affine transformations of normals much easier to read as we can directly say:\n\nX = Normal(0,1)\n\nnew_X = X+4\n\nwhich can be a lot clearer than walking through the rules for transforms of normals.\n\n\nI had a difficult time wrapping my head around the concept of object-oriented programming at first.  It took a few Lynda tutorials my buddy had to convince me it was worth putting some time into, but I'm glad I did.  The best way to learn something IMO is to actually do it.  Sit down with [an example such as this site](http://www.tutorialspoint.com/python/python_classes_objects.htm),  try it for yourself and experiment.\n\nI'd use named tuples for this use case. Sets of data with named properties are perfect for named tuples. Unless these guys are changing state and have lots of methods associated with them, I'd use named tuples with some functional programming style\n\nTo expand on that, classes arent used just for having named properties. If that's the only reason, even dicts ~~are~~ might be better for that.\n\nConsider classes for design patterns but not simply for the sake of having named properties and a method or two.\n\nEdit: \"stateful\" is a keyword that hints towards using classes too.\n\nCan you post an example of the work you do with the data you get? I was gonna get some instructions from a professor doing research in gravitational waves\n\nNoob here. Are tuples mutable?", "id": "cdh1oil", "owner_tier": 0.3, "score": 0.5714285713392857}, {"content": "What kind of data structures do you find yourself using usually?  Are you just implementing your own ad-hoc \"classes\" via dicts or lists?\n\n\n\n \n\nThis is the question that came to my mind, also.  Do you end up with lots of arrays or dicts that share the same keys, so that one data point is a key with values in different tables?  If so, classes would let you instead have a single array of data points, each of which has several named fields:\n\n    cat_colors[12] = 'orange' // color of cat 12\n    cat_weights[12] = 13 // weight of cat 12\n\nvs.\n\n    cats[12].color = 'orange' // color of cat 12\n    cats[12].weight = 13 // weight of cat 12\n\nThat can be convenient, but it is more about c-style structs than classes.  \n\nMy typical data structure consists of large textual documents, so I use lots of flat files for storage. For smaller pieces of text, like user reviews, I generally use CSV files for each item where every row in the CSV file relates to a user review for that item.\n\nI also have a couple TB of metadata related to the large text documents. This includes statistics about the document (ngrams, tf-idf, sentiment, and other related NLP stuff) along with quantitative and qualitative metadata. For this I typically use lists of tuples before storing it in the SQL database (MariaDB) used by the APIs to access it. Most of the memory on the database server is used for in-memory tables which make things really fast.\n\nWhen analyzing the metadata I typically load things in pandas/numpy/statsmodels to do my statistical analyses.\n\nSo my data structures are not very interesting. I would be curious if anyone had a better solution for storing ~700k large textual documents (avg size is about 6MB) other than flat files.\n\nNamedtuple has replaced those for me. \n\nPersonally, I've never had any great need for my own classes in data processing, I find myself just using higher dimensional numpy ndarrays. Only needing to store numerical values kinda helps.\n\nFor large possibly multi-d (text) files I usually reach for hdf5. I've found it strikes a pleasant balance between simplicity, speed and interoperability.\n\nFor high volumes of structured metadata I often use a  BSON format. With a good implementation it is highly compact and screaming fast. \n\nI try to avoid kv stores and other in mem databases unless I need concurrent connections and/or good indexing. \n :-)\n\nSame. Using `__new__` isn't a big deal, and the forced immutability makes functional-style programming easier. Usually I find myself using this pattern:\n\n    class Foo(namedtuple('Foo', ('foo', 'bar'))):\n        #Foo methods\n\nSo the data layout is fixed, but I can still have some basic methods or properties.\n\n... or a dotdict\n\ncute. i'll have to remember that. i guess you can't have anything in __init__ that would set attributes, though, right?\n\nnamedtuples also have a `_source` attribute that contains the source code for the namedtuple.\n\nWhat's wrong with \\_\\_slots\\_\\_", "id": "cdh16vx", "owner_tier": 0.5, "score": 0.9999999999107143}, {"content": "Post an example of your code?\n\nOr, post this question and an example of your code to http://codereview.stackexchange.com .\n\nNeat! How long has that site been available?\n\nSince [Jan 20, 2011](http://area51.stackexchange.com/proposals/11464/code-review).", "id": "cdh2p1j", "owner_tier": 0.3, "score": 0.37499999991071425}, {"content": "I use classes very sparingly in Python. Really, I mostly use them to wrap complex state, like C libraries or GUI objects or Test Suites. I also use classes to mimic other types using magic methods such as `__index__` and `__next__` and `__enter__`.\n\nBut all those are very specific use cases. Outside of these things, I prefer to organize my code around functions and modules. Those magic methods can be used to great effect, though. \n\nI use a lot of modules. I like breaking my code up into many modules that contain only the functions/libs used by that logical chunk. Often the script I actually run is maybe 10-20 lines of code because  everything that that's more static (like a function or logical procedure) is defined in another module which I import in.\n\nThen you're already practicing a rudimentary form of object oriented programming.  \n\nNow imagine that your \"module\" can have a lifetime of its own with some private data that only it should modify and see, and some public data that any other class can use, and that new modules can be based on the old one through inheritance, and you'll start to get an idea of what OO brings to the table.  Throw in polymorphism, which is just a fancy way of saying that we can treat all objects of a certain category the same even though the actual behavior for each object might vary according to its sub-type (and without using a bunch of if statements), and you find that you'll be able to simplify your code in some surprising ways.\n\nDon't get me wrong - I think structured programming is just fine for a large category of problems, especially the linear analytical problems you seem to be dealing with, but OOP can help organize to help you solve the problem.\n\nDo you have any suggestions for guides on Python classes? I do a lot of data churning and I often find myself thinking that while my code gets the job done, that I'm probably doing things far from the best way possible.\n\nI generally don't have to share my code but I sometimes feel like it takes more effort than it should for me to dissect what the hell I was doing in a script if I don't look at it for a few months.\n\nThe next time you're working with a module, pay attention to how you group your functions.  Most programmers tend to put the related functions all in one module.  Notice how those functions all tend to operate on that same kind of data.  Now, you might be passing around big tuples of stuff right now where you have to remember what data is in each slot.  That works fine, but wouldn't it be nice to have a name for each of those instead?  Voila!  You've just discovered some fields or properties you can make for your first class.\n\nSo, for example, if you have employee_data.py module, make it an Employee.py class instead.  What are the functions of that?  What are the fields of that?  Now you can \"re-phrase\" your module as a class.  Then you need to discover how you use that class; where do you start?  With a module of course!  But instead of just importing the module, you have to create a new object based on your class.  Then you can use it.  You would create a new object for each Employee you would have in memory at one time.  All of the functions in your Employee module would be functions that operate on that specific Employee.  \n\nIn short, the best way to learn it is to just try it.  Start small and don't pay attention to fancy language, or complicated patterns, etc.  Just go with whatever makes sense.  Once you have your ah-ha moment around polymorphism, you will pretty much have arrived.\n\nThere are some half-decent Python OO examples here: http://www.tutorialspoint.com/python/python_classes_objects.htm\n", "id": "cdh0a2i", "owner_tier": 0.5, "score": 0.24999999991071428}, {"content": "\nAs soon as you have different kinds of data that should be worked upon the same way, and you make conditions\n\n    if foo.kind == \"widget\":\n       widget_doer(foo)\n    else:\n       general_doer(foo)\n\nyou should be using classes with the doer function in the class.\n\n    foo.doer()\n\nwhere the General.doer() does one thing and you extend General and make Widget.doer() do something else.\n\nConditions on kinds of data should be embedded in the kind of data it is, not in many places in your code.", "id": "cdh3sqw", "owner_tier": 0.7, "score": 0.08928571419642857}, {"content": "Good on you for asking!\n\nClasses aren't an ends in themselves, but object oriented programming can be a means to better interfaces and therefore testability, something that's hard to appreciate until you've seen it in the wild.\n\nTesting your code will give you and (maybe I'm giving them too much credit) peer reviewers more faith in your research.  *It will also make you a faster and more effective programmer.*\n\nIn much the same way that functions let you abstract groups of logical statements from what would otherwise be a giant piece of spaghetti code, classes will help you abstract data types and even some methods relevant to that data type.\n\nExample*: Imagine you're working with medical records and have two files.  One containing demographic information and another describing every single outpatient procedure.  You could pipe everything through scripts and end up with two giant variables that contain all the data so you can cross reference them using whatever functions you've got.  Or, you could have one set of \"people\" objects.  Each person object contains its own outpatient records so you can call person.has_heart_disease() or person.has_mental_health_condition() and get a boolean back.  You could read person.age and person.height and person.weight.  It's cleaner and more readable to use an object-oriented (class based) approach.\n\nNot only can you design small simple test cases, you can do fun stuff like:\n\n    visits_per_person = sum([person.emergency_room_visits for person in all_people])/len(all_people)\n\nWhich is oh-so-more-readable than most any set of functions.\n\nEven if you don't ever write a single automated test (write automated tests!!!) classes can help you decouple the \"what does this code do\" from the \"how does it do it?\".  (e.g. When you go to refactor your code as in the iterator instead of read-to-memory example you gave)\n\n*Real example from my own experience as a researcher.  I wish I had known in grad school what I know now.  I wrote a pile of functions (thousands of lines of code) and I could have done so much better.\n\nAny guides you can recommend on this? For the data I deal with it sounds like classes would potentially be helpful. \n\nI don't know that I have any guides I can recommend.  You might try looking for MOOCs or Open CourseWare courses that teach \"object oriented\" programming.\n\nI'm sure there are also dozens of good sources that are a bit lighter weight than a full course, but I don't know of any off the top of my head.", "id": "cdh3jy5", "owner_tier": 0.1, "score": 0.10714285705357142}, {"content": "I'd say if you do not need classes there is no real reason to use them. Python is great for scripting and writing small programs, which you usually don't need classes for. \n\nI'm not sure you are aware of it but when it comes to multi-processing python is a bit special, which can be read here: http://stackoverflow.com/questions/4496680/python-threads-all-executing-on-a-single-core\n\nI've had many situations where I have used classes in python, but most often I do not. In a sense your programming is more functional than object-oriented, which also can answer for why you do not use classes.\n\nBut I do not think you miss out on something though :)", "id": "cdh02lo", "owner_tier": 0.5, "score": 0.08035714276785713}, {"content": "Whether or not you use classes will depend a lot on what task you're trying to achieve. Right now I work as a research assistant in a psychology lab, and my time is split between creating experiments and analysing the results.\n\nCreating experiments (which you can think of as really simple, fairly shitty computer games) generally requires classes out the wazoo.\n\nData analysis, on the other hand, often just ends up being done with long scripts full of single expressions, one after the other. This is especially true for the simple analyses that are needed to analyse the results of a psychology experiment, where your main goal is to split the means of the different conditions up. Almost 0 classes, and often very few functions, apart from simple one line lambdas.\n\nI don't find it particularly odd that you've used no classes for the statistical side of things, but my limited knowledge of web dev leads me to think you might find some use for them there.\n\nOff-topic, but does your lab use Python-based experimental presentation software?  I'd love to, but I haven't found anything that meets my needs.\n\nipython notebook with reveal.js support\n\nMy lab mostly uses PsychToolbox for MATLAB. Right now I'm putting together an experiment using Pygame, since this experiment is more game-like than your average experiment and it helps to have concepts like sprites available. It seems like most of the presentation software for Python uses Pygame as a backend anyway, so I figured I might as well just use it directly.\n\nI've briefly poked around with PsychoPy, enough to see that it seems roughly on par with PsychToolbox, but haven't actually run any experiments with it yet. One thing I did see recently that I've been meaning to try out is [Expyriment](http://www.expyriment.org/), which seems to have a nice design,\n\nHave you tried psychopy?\n\nNow that's an interesting idea.  I've used reveal.js before, but I wouldn't have thought of knitting it together with iPython.\n\nCool, I'm also most comfortable with PsychToolbox.  Have to take a look at Expyriment, too.\n\nPerhaps this could be tweaked to fit your experiments: http://econwillow.sourceforge.net/\n\nI helped an economist doing experimental economics and game theory setup an experiment using willow in my final year of grad school and it was super intuitive. The interface is kind of bland, but so are most interfaces in social science experiments. :)\n\nNot yet, although that's the one that everyone mentions.  Any thoughts?\n\nYou don't have to do anything. nbconvert does it for you.\n\nhttp://ipython.org/ipython-doc/rel-1.0.0/interactive/nbconvert.html\n\nI used it for my undergrad thesis a while ago. I liked it back then. Lots of similar functionality to psychtoolbox. In the last two years they've put a lot of work into it and an experimental GUI that's supposed to be easy to use for novice programmers. It actually is pretty easy to use and will generate code for you. But if you want to make any non-standard stimuli or complicated animations you have to get into the nitty gritty and I think this scares some novices off. GUI aside, I found psychopy to be a pretty good replacement for psychtoolbox (which I'm back to using now because that's what we use in my current lab). ", "id": "cdh0gxs", "owner_tier": 0.1, "score": 0.16071428562499998}, {"content": "> So my question is: Given that I know how to get stuff done quickly, what am I really missing out on or shorting myself on by never using classes?\n\nIn traditional languages classes have a number of roles including\n\n* encapsulation\n\n* modelling objects with similar but non identical properties\n\nLets consider encapsulation first. Now obviously if you are collaborating you don't want to randly set variables inside someone else's module, but consider this:\n\n    class Walrus\n\n        def __enter__(): \n            print (\"enter\")\n            self.x = get_thing_from_shared_store()\n\n        def use ():\n            # do stuff with the shared thing\n            print (\"use\", self.x)\n\n        def __exit__():\n            print (\"exit\")\n            return_thing_to_shared_store (x)\n\nNow:\n    \n    >>> with Walrus () as p:\n    >>>    p.use ()\n    enter\n    use\n    exit\n\nWhy was this good? Well we automatically allocated and returned a shared resource, without chance of forgetting to put it back and causing a \"leak\"\n\nNow considiering similar but unrelated objects:\n\nFor example \"car\" and \"truck\" are both really types of vehicle. One has \"load cargo\" function and one has a \"load people\" function. All share drive. Without classes you'd have to store the type of each and you need to check what abilities it had before you loaded it. With classes you would define car and truck as child classes of vehicle, both with their own load function, then you could then just call load without needing to know if you had a car or truck.\n\n    class Vehicle:\n        def load (self):\n            print ( loading unknown type\")\n        def drive (self):\n            print (\"VROOOM\")\n\n    class Car (Vehicle):\n        def load (self):\n            print (\"loading passengers\")\n\n    class SportCar (Vehicle):\n        def load (self):\n            print (\"loading golf clubs\")\n        def drive (self):\n            print (\"moar vroom!\")\n\n    class Truck (Vehicle):\n        def load (self):\n            print (\"loading cargo\")\n\n    things = [Car(), Car(), Truck(), SportCar()]\n    for t in things:\n        t.load ()\n        t.drive()\n\nHow do we *easily* and *robustly* do this without classes? Note how tere 2 different drives (sport car has a faster one), otherwise it defaults to the base. Also everyone has a different cargo. Now in python the language is dynamic and you don't need classes to do this. However it's bit of a pain to do; you would probably  pass a function or a function name, and that makes debugging a lot harder.\n\nI'm guessing this is an unpopular topic and I don't want to be that guy, but your use of spaces is inconsistent. You seem to prefer using a space before a parenthesis, but on two lines you don't.\n\n[PEP8 also disagrees](http://www.python.org/dev/peps/pep-0008/#whitespace-in-expressions-and-statements) with your whitespace strategy and to add an argument to that: it makes it seem like (what's inside) the parentheses and the object's name aren't related while they are.\n\nThis is doable without classes as well.\n\ndefine functions that operate on stuff.  e.g.\n\n    def drive(d, ....):\n        print \"I'm driving %d mph\" % d\n\nDefine some data structures.  I realize namedtuple constructs classes without behaviours.\n\n    Car = namedtuple('Car','speed')\n    Truck = namedtuple('Truck','speed')\n\nbut you can do it with dicts too though the syntax changes.\n\n    car = dict{'speed'}\n\nIntegrate.\n\n    drive(foo, foo.speed)\nor \n    drive(foo, foo['speed'])\n\nOf the two, plus one you gave, one will be uglier.  Which one it is, is up to personal taste.  They both arrive at the same algorithm with different checks and balances, e.g. namedtuple is immutable, using Class new methods can be added and it's directly available per structure, , one has less state etc..\n\nAll we're doing is reordering the receiver and its data.\n\nYour first example can be done without explicitly defining a class:\n\n    from contextlib import contextmanager\n\n    @contextmanager\n    def walrus_use():\n        x = get_thing_from_shared_store()\n        print(\"use\", x)\n        yield x\n        print(\"exit\")\n        return_thing_to_shared_store(x)\n    \n\nYour second example could probably be done with [single dispatch generic functions](http://www.python.org/dev/peps/pep-0443/), but that will not be in python until 3.4 is released - you would need to use a third party library for now.  \n\nYou're right to mention it. However I just type stuff in and the code formatter in Pycharm's IDE deals with all of that. I don't even know where I am supposed or not supposed to put spaces in. BTW your spelling of parenthesis / parentheses is inconsistent :-)\n\n> Of the two, plus one you gave, one will be uglier.\n\nDon't care. Which is easier to maintain? That's important! :-)\n\nNot saying classes are the only correct way, but it's a good model for this kind of thing.\n\nOh come on. Is that easier and more robust (readable and maintainable) than just using plain classes? And we could *probably* use some kind of niche future feature?\n\nWhat would you do if you needed to supply multiple use functions? Repeat the boiler plate, pass a function, use a dict as a case/switch?\n\nI agree, nothing REQUIRES classes, just that the context manager pattern is a nice, safe way to do this, and it's fairly robust especially when others start tinkering with your code.\n\nActually, my spelling is correct, I just forgot an \"a\". Parentheses is the plural for of parenthesis (AFAIK). \n\nUsing classes as a namespacing mechanism where no state in a language like python doesn't buy you too much.  There are mechanisms such as dispatch tables which aren't only useful for class design.\n\ne.g. \n\n    if foo == 'foo':\n        foo()\n    elif foo == 'bar':\n        bar()\n         \nvs\n\n     stuff_to_do = {'foo': foo, 'bar': bar }\n     stuff_to_do[foo]()\n\nThe one big pitfall in OOP is the attn/love an OOP hierarchy needs.\n\ne.g. A car is a vehicle, as much as a plane.  Some helicopters have wheels, some don't.  But they both can fly.  Boats can float, as do some planes and helicopters etc.  You can go on and on and on.  Same with modelling shapes such as squares, circles, cones and so on.\n\nFor simple hierarchies where state exists, OOP is friggin AWESOME.  When it starts getting complex, keeping your hierarchies really shallow or non existent is key.  A fun example of a hierarchy that went wrong, but there's no backing out of it now without breaking source compatability, are mutable and immutable lists in scala.  Some methods do zilch.  In java, the same applies. Functions that throw stating these methods aren't used.\n\n\nDamn, you're right.", "id": "cdh2yae", "owner_tier": 0.1, "score": 0.24107142848214286}, {"content": "I guess the main things I'd ask are:\n\n1. How often do you end up with global variables?\n2. Do you find your functions end up with lots of arguments?\n3. When you use libraries, do you appreciate it when you get objects back? How would you deal with xml without classes, for instance?\n\nOne of the nice things about a class is that you get a namespace to track some little bits of state, but you can keep the state under control, so that you don't have to keep a note of what code touches that global variable. You know the variable can only be touched within the class.\n\nHere's a simple implementation of the Averaged Perceptron algorithm, a surprisingly okay way to learn a linear model for thousands or millions of features: https://github.com/sloria/textblob-aptagger/blob/master/textblob_aptagger/_perceptron.py\n\nThe gist of the algorithm is, we want to predict some class variable given some features. During training, we iteratively predict the training instances, and if we're wrong we'll tweak the weights, so that next time the correct class gets a higher score than it did this time.\n\nWithout a class, we have to thread the \"weights\" data structure through all the logic, passing it as a parameter. And during training, we need auxiliary data structures as well, for various book-keeping.", "id": "cdh40fk", "owner_tier": 0.3, "score": 0.026785714196428573}, {"content": "The main strength of object oriented program is polymorphism (aka message passing): you could have a list with multiple types of objects in it, call a method of each object, and have it behave differently depending on its type. You could also implement this with a list of functions with the same indexes, or by defining a list of dictionaries where each dictionary has some members that are functions (pretty much how Python implements classes), but then you're just avoiding the cleaner class syntax.\n\nA good example of this is the world wide web.  Each server is an object.  We have (evolving) standards that define what messages (methods) you can send to a server with what parameters, But each server decides how (and if) to respond to any messages it receives.  This would be infeasible to implement in a functional paradigm.\n\nObject oriented programing is extremely useful anytime you want to organize your code around different **types** of data structure, with each type having a whole suite of behavior for different situations.  **tl;dr:** OOP organizes code by type, instead of by situation. If you frequently have to edit one case in many different switch statements, OOP might have helped.  If you have simulated this, you simulated OOP.\n\nThe problem with most people's arguments for when to use object oriented code is that they always go straight to web and server examples. No one can give a good example that is directly applicable to scientific computing. The typical scientific computer is not worried about passing information across a server or reading some specialized stream. They have some physical system that needs to be manipulated in some way, usually with operations like passing it through an equation. How does one use object oriented code when they don't care about dealing with  servers, transfer protocols, etc. via objects? That is the answer to OP's question.\n\n\n\n\nYou stated that \n>Object oriented programing is extremely useful anytime you want to organize your code around different types of data structure\n\nThe issue with this from the standpoint of a scientific computing individual is that short of making objects for physical things (this wave is an object, that wave is an object, that car is an object, etc. and all of them will be acted on by forces of some sort), it typically doesn't make sense to do anything with objects. Or, to rephrase, it is typically more intuitive to not use the object paradigm and just design whatever operation you want to happen. I would love to be proven wrong because then I could justify OO programming with respect to scientific computing. But short of the above scenario, I cannot see any good reason why it is needed for scientific computing. It obviously has uses in other paradigms. But that is beyond the scope of this discussion. \n\nHow often do you actually do that? I use classes plenty, but that basically just...never happens.\n\n\nThe term \"scientific computing\" is quite broad. Perhaps you don't find much use for OOP in *your* corner of scientific computing, but to extrapolate that to all scientific computing is ridiculous. For example, I make a ton of use of OOP concepts in my research, which is based around protein fragment libraries.\n\nI don't think anyone can argue that OOP is essential to any computing algorithms and it does NOT enable new classes of solutions that I've seen.  It's purely there for the programmer so that we, as humans, have a better chance of understanding what is going on in the system at a given point in time.  If it's not going to do that for you in your situation, then don't use it.\n\nOn the other hand, we could argue much the same point about structured programming.  A long time ago, there were very passionate arguments about all the computing time and memory that would be \"wasted\" with all of this horribly stupid jumping around in memory, continually shifting things on and off the stack to registers, and all of that just so you can call a \"function\" instead of just setting a register or two and jumping to the relevant set of instructions?!  \n\nThe problem with OOP though is that the benefits aren't always as clear cut; especially when someone has used it to create a design that defeats understanding by mere mortals.  Sometimes it's a good idea; sometimes not.  \n\nI really tried to explain the virtues of OOP in a way that wouldn't sound right for every case.  Scientific programming often requires doing identical operations to very large sets of data - OOP is especially bad at that, because it usually means less efficient memory layouts (every field of a struct is in the cache) and lots of virtual function lookups.  Might be useful in some subset of problems, though.\n\nDo message passing, you mean?  In game development I exploit polymorphism very often: call the .update() method of every object in the world, etc.  Also very handy for GUI work.  In other situations it might be a good idea less often, but if you default to hammer paradigm, everything looks like a nail I guess.\n\nWhat's a protein fragment? It's an object with properties which is the exact use case I said computational scientist would use it for. My argument was merely that it was the only case that a computational scientist would use if for. Thus, there is no reason for you to think we are in disagreement at all.\n\nI think I will just trust my intuition. So far I have determined the use that OOP would have for me in my line of work and searching the web has shown that intuition to be true. OOP has its place. It can have its place in scientific computing, but it is more likely that a functional paradigm is more appropriate in most cases.\n\nThere are some examples (like www servers) where OOP allows a division of code that makes new things feasible.\n\nI was taking issue with your use of the word \"typical.\" You claimed that OO is useless in scientific computing save for some \"marginal\" cases. My point is that perhaps they aren't marginal.\n\nI also suspect OO could be used to great benefit for modelling physical systems. I would love to prove you wrong, but I claim that evidence would require a constructive proof (e.g., code samples). Since I'm not involved in that type of research, I don't have the evidence required, unfortunately.", "id": "cdh2gg9", "owner_tier": 0.3, "score": 0.1339285713392857}, {"content": "Whatever works for you is fine, but have you tried using classes for any particular cases? I also use Python in a scientific environment, usually for scripting/automation or converting or processing data sets, so I tend to write a lot of short to-the-point scripts and one-offs. I had never used classes until quite recently. I had to expand a webscraping script so that it could scrape multiple pages instead of one. I ended up converting all the code for dealing with a webpage into a class and then starting using lists of pages. It ended up being very clean and I would guess that the code is much easier for someone else to use.", "id": "cdh37f3", "owner_tier": 0.3, "score": 0.008928571339285716}, {"content": "http://lucumr.pocoo.org/2013/2/13/moar-classes/\n\n[this](http://me.veekun.com/blog/2013/03/03/the-controller-pattern-is-awful-and-other-oo-heresy/) is a fairly good wrap-up:\n\n> Stop writing *stupid* classes.", "id": "cdh28u9", "owner_tier": 0.5, "score": 0.017857142767857142}, {"content": "Custom exceptions.\n\n    class MoreSpecificValueError(ValueError): pass\n\n\n:o cool!!", "id": "cdh3t3t", "owner_tier": 0.7, "score": 0.008928571339285716}, {"content": "I too avoid writing classes but I do love namespaces. Do you use them?", "id": "cdh4f81", "owner_tier": 0.3, "score": -8.928571374308295e-11}, {"content": "Most of what classes give you, you can get from other constructs. A class is really just a way of defining a data structure, and coupling it with the behaviors that operate on that data structure.\n\nWriting lots of little functions that mutate data and can then be strung together is a perfectly legitimate way to structure and aggregate code. That's the \"functional programming\" way, and it's very powerful and very extensible. There's a down side -- it can be very hard to read and debug -- but the up sides are fantastic in problem domains where your program's raison d'etre is to calculate a result.\n\nContrast that -- the focus on *calculating a result* with a typical desktop application's focus, which is on *entering and manipulating data objects*. In the latter case, you frequently have many different types of data objects, and you want to be able to mutate those specific data objects in response to application events -- button pushed, text typed, timer expired, whatever. Until the event occurs, you're not sure which manipulation you will want to perform.\n\nIn a program designed to calculate a result, an input gets heavily processed through several phases of computation. It might be useful to define classes here, and it might not: I could see cases where heterogenous input needed to be processed along a common axis, but with the heterogenous identity preserved. Named tuples or classes might serve this goal well. But the concept of the program is essentially a stream or blob of data that moves through a processing pipeline until an intermediate or final result is produced.\n\nIn a program designed to provide a set of interactive workflows, you can envision the data instead as a set of related data objects -- documents perhaps, or account credentials, or card catalog records, or all of the above -- upon which the program performs operations at the request of the user. The objects are like a lattice of interrelated data, waiting to be tickled or touched in exactly the right way. Classes fit this paradigm perfectly.\n\nMany problem domains can be conceived in either way, depending on the vision of the architect. That's why both OOP and FP are general-purpose paradigms. But I think some fit one style better than others. It sounds to me like OP's problem space orients strongly to the functional side of things. Classes might be useful there, but they might not be, too.", "id": "cdh6c79", "owner_tier": 0.1, "score": -8.928571374308295e-11}], "link": "https://www.reddit.com/r/Python/comments/1qvoop/ive_been_using_python_for_3_years_and_ive_never/", "question": {"content": "I consider myself a nearly advanced-level Python programmer. From data processing and statistical analysis to web development and systems administration of large clusters, I do it all regularly.\n\nI started using it in grad school for my research and now use it everyday in my job as a computational scientist. However, I simply do not use classes. I use functions for everything, often many small functions whose output I feed into another. For large highly parallel data processing tasks, I'll have one main worker function that does the heavy lifting on each item that I'll pass to a multiprocessing Pool. \n\nSo my question is: Given that I know how to get stuff done quickly, what am I really missing out on or shorting myself on by never using classes?", "id": "1qvoop", "title": "I've been using Python for 3 years and I've never defined a Class", "traffic_rate": 207.942496260595}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "On July 1st, a [change to Reddit's API pricing](https://www.reddit.com/r/reddit/comments/12qwagm/an_update_regarding_reddits_api/) will come into effect. [Several developers](https://www.reddit.com/r/redditisfun/comments/144gmfq/rif_will_shut_down_on_june_30_2023_in_response_to/) of commercial third-party apps have announced that this change will compel them to shut down their apps. At least [one accessibility-focused non-commercial third party app](https://www.reddit.com/r/DystopiaForReddit/comments/145e9sk/update_dystopia_will_continue_operating_for_free/) will continue to be available free of charge.\n\nIf you want to express your strong disagreement with the API pricing change or with Reddit's response to the backlash, you may want to consider the following options:\n\n1. Limiting your involvement with Reddit, or\n2. Temporarily refraining from using Reddit\n3. Cancelling your subscription of Reddit Premium\n\nas a way to voice your protest.\n\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*", "id": "k1e5qec", "owner_tier": 0.1, "score": 0.01851851833333333}, {"content": "List. Of() is immutable in java. Since java 11\n\n[deleted]\n\nlike?\n\nIts not deeply immutable. Its shallow immutable and its deep mutability depends on the mutability of the objects contained therein.\n\nJava cannot enforce deep immutability on mutable classes, so this is as immutable as it gets in Java.\n\nThere is a difference, but List.of returns a immutable list. You are probably thinking of methods in the Collections class that are doing that\n\nEdit: Corrected mutable to immutable (typo)\n\nunmodifiable list can be thought as a view of a collection.. you cannot change the collection itself through this view, but the original collection can be changed and that change reflected via the view so you can still observe adding or removing elements to or from the unmodifiable collection (given you still have the reference to the original one)\non the other hand immutable collection are standalone instances meaning they jave their own inner representation.\n\nconsider Arrays.asList(...), which wraps the incoming parameter array and that array cannot be changed  through the returned instance but you are free to change the elements of the array as you have full control over it.\nhope this answers your question\n\nIn oracles java lingo Immutable list would be something that would have also it's content elements not be modified(and it's basically up to you to not modify the objects in there).  \n\n\nHowever in most java like languages that have immutable named lists you can also modify the data in the objects that are in the 'immutable' list, and it just seems to be used as a substitute word for unmodifiable.\n\nNo, it is immutable. [Google is a hell if a thing](https://docs.oracle.com/javase/9/docs/api/java/util/List.html#of-E...-). The variable itself maybe mutable, the list is not\n\ni use both terms for the same thing: immutable lists (because i always talk about things from the \"owner's perspective\" of the variable) - i think the when talking about code, precision and clarity matter, so i call the other thing \"a view\". then it's always clear what i mean.\n\nIt was a typo, we talked about immutable vs unmodifiable\n\nNo, it's unmodifable.\n\nEdit: What's the difference? Unmodifiable collections are just wrappers that disallow mutation on this instance, but the underlying mutable collection can still be modified:\n\n    List<String> arrayList = new ArrayList<>();\n    List<String> unmodifiableList = Collections.unmodifiableList(arrayList);\n    arrayList.add(\"test\");\n    System.out.println(unmodifiableList); // [\"test\"]\n    unmodifiableList.add(\"test\"); // Exception java.lang.UnsupportedOperationException", "id": "k1ehck5", "owner_tier": 0.3, "score": 0.9999999998148148}, {"content": "There is  the .copyOf static methods on them for copying into an immutable collections, as well as Collections.unmodifiable<collectiontype> for unmodifiable views.\n\nThese still expose the full api though and will throw exceptions if you try to modify. There is no way to add them with out making a separate immuutable interface which was decided to not be worth the comparability issues of having a new  separate interface for all collection types.\n\nGood implementations of immutable collections are usually persistent, though. They do not copy the full structure of the collections during modifications.\n\nI think it should be the other way around. I mean how an interface for an immutable collection would look like? Would be something that simply omits the add and remove methods and supports only the enumeration, would it not? Then we would use such interface accessing the data, then would need to have a MutableCollection or similarly named interface for performing modifications.\n\nYeah its not the most preferable implementation, though I understand the reason behind not making a separate interface for immutability and just making implementations of the existing apis. I normally work around this by creating then wrapping with Collections.unmodifiable at the creation and making sure the original modifiable reference falls out of scope. If that is not possible then encapsulating any access/getting of them via wrapping. Though with the second option there is still the chance someone later makes an edit not honoring this \"weak\" contract. Not really a problem with personal code, but in an environment where immutable is not an established norm and preferable I could see how this could go wrong and be a source of hard to find errors.\n\nThere's a fundamental problem of having an immutable collection interface: if the collection could be directly instantiated as immutable, how are you getting the elements into the list in the first place? Given that, it does make sense that you need to create the collection as modifiable and then make the immutable copy from it.\n\nYes. This is pretty much what kotlin does.\n\nThe issue your mention already exist with or without a super interface for the immutability anyway. That's the way currently it works in the JDK or am I missing something?", "id": "k1e7blf", "owner_tier": 0.5, "score": 0.8518518516666667}, {"content": "[Why don't they just... introduce ImmutableCollecton!?](https://youtu.be/ZN9bgpBdxAE?feature=shared&t=1812) by Nicolai Parlog.\n\nThe interface explosion was also mentioned by others.\n\nI have a hard time taking the argument seriously.\n\nFirst of all, there doesn't have to be any explosion of interfaces. You can introduce an independent system of persistent collections. Mutable and persistent collections sharing common ancestor interfaces provides almost no value.\n\nSecond, the argument that we can't have nice things because it would fragment the community could be applied to almost anything, even the features that have already been introduced to Java over the years. Virtual threads, records, sealed types, pattern matching, generics or non-nullable types via Valhalla. They all, at least in some sense, divide the community and libraries into those that utilize them and those that solve the problem at hand differently. And yet, it's very much worth it to have these features.\n\nDude in the video here. A more detailed version of these arguments can be found in [this blog post](https://nipafx.dev/immutable-collections-in-java/).\n\n> First of all, there doesn't have to be any explosion of interfaces. You can introduce an independent system of persistent collections.\n\nAs a single data point: [Vavr's `collection` package](https://www.javadoc.io/doc/io.vavr/vavr/latest/index.html) contains 45 public types. We can probably argue whether that counts as an \"explosion\" but I invite you to count how often Java added APIs that contain that many new, non-trivial types. As a reference for that: [`java.util.stream`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/package-summary.html) contains 16 (arguably, minus 9 that are conceptually identical to 3 others). Heck, even [`java.util.function`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html) has fewer than 45 public types and those are all conceptual one-liners.\n\n> Second, the argument that we can't have nice things because it would fragment the community could be applied to almost anything, even the features that have already been introduced to Java over the years. Virtual threads, records, sealed types, pattern matching, generics or non-nullable types via Valhalla.\n\nTL;DR: Unless you can explain how to introduce these types as seamlessly as all the other features you mentioned as reference, you're arguing for an unprecedented fragmentation of the ecosystem.\n\nNow, on to the long version...\n\n----\n\nYou could apply that argument, but you would be (mostly) wrong \ud83d\ude09:\n\n* If your code uses virtual threads but my library uses platform threads, they would still work together just fine (although with lower scalability than could be hoped for).\n* If you use pattern matching with sealed types and records, but I don't, that's ok and everybody can benefit from their choice in their code (although there's synergy left on the table from both using the same approach in similar situations).\n* It's interesting that you bring up generics because they were specifically designed to _not_ fragment the ecosystem (which is probably why you think that can't happen). Your code can use them while mine doesn't and it works together swimmingly (although you'd get more out of them, if I followed suit).\n\nThe pattern should be obvious: Every project can use the features they think work best for them without (too much of) a burden if their dependencies didn't adopt them yet. And while there's added benefit in all projects adopting new features, that can happen over time in a decentralized way because old and new can conveniently be used side by side (usually).\n\n----\n\nNow let's talk about introducing a persistent collection API that's unrelated to the existing interface hierarchy. Yes, your code can use the new API internally while my code doesn't and all will work great. But will it work great *together*? Because with the exception of generics, the features you mention are not particularly present at the boundary between projects. But collections are and that presents a big problem because you'd want to migrate from old to new (where suitable) without requiring a flag day where everybody updates.\n\nAs I see it (and please correct me if I'm wrong), for the JDK to use those types in its own public APIs at all, it would have to duplicate _all_ methods that accept or return a collection. That's bonkers. The other option I see is to add `toPersistent()` and `toClassic()` (or whatever) to the old and new types, respectively, which gives you an additional method call on every boundary between projects that use / don't use them yet. Maybe there's some compiler magic akin to (un)boxing that could be applied here, but that doesn't sound great, either. And all of that ignores that these collections work very differently and a transformation at the boundary might not even be correct because of that.\n\nThat means that every boundary that doesn't want to make a hard cut needs to exist in two versions and for projects that value backwards compatibility (like the JDK) both would live forever. Or version X of my library uses the old and version Y uses the new API and users have to migrate in one swoop while still having to deal with other projects that don't provide a new API yet. All this would require an amount of churn that is unprecedented in the Java community.\n\nRemember I said \"with the exception of generics\" earlier? One thing that stands out in their design is that a `List<String>` is a `List`. That is their saving grace! Without that, all the same logic would apply to them but (soon) 20 years earlier with billions of lines of code that would have to be changed fewer.\n\n>First of all, there doesn't have to be any explosion of interfaces. You can introduce an independent system of persistent collections.  \n>  \n>...  \n>  \n>Second, the argument that we can't have nice things because it would fragment the community could be applied to almost anything, even the features that have already been introduced to Java over the years.\n\nAgreed in order to do it \"right\" would essentially require a second Collections framework.  But Collections aren't just another library in Java, they are foundational to almost every project ever created.  With all features that create a \"new\" vs \"old\" dichotomy, the pros and cons of implementing that feature need to be considered.  In this case it's not at all clear that the pros of a second Collections framework provide all the much benefit over what is already available (e.g. `List.of()`, `Set.of()`, `Collections.unmodifiable...()`, etc.).  However, it's fairly trivial to see the cons of such an approach and how massive of a negative impact it would be.\n\nThere would probably have at least as many new interfaces and implementations as we have now (e.g. [vavr](https://docs.vavr.io/images/vavr-collections.png)). You don't want these types to live in a vacuum but want to use them with existing JDK API's so many of these would need overloads because conversions to and from classic Collection's all the time would be a real pita.\n\nIt's not impossible to do - Stuart Marks just mentioned yesterday that they could think about adding persistent collections someday or not - but it would be a monumental undertaking making it retrofit into the existing JDK without it looking nailed on.\n\nHello Nicolai, thank you for such a detailed response.\n\nThe points you raise are valid. Yes, there are challenges to introducing a whole new collections library to JDK.\n\nBut my point is more higher-level: I bet that Persistent collections will be added to Java simply because they're just so damn useful. Sooner or later, it will happen. They will find a way to make it work. Maybe even in the next-next LTS, which is 4 years. And I'm here complaining that if there were more enthusiasm regarding Persistent collections in JDK from the Java authors now, we may have them sooner, let's say next LTS, which is 2 years.\n\nObviously, I don't have a crystal ball. But I see the trajectory that Java has been going for the last years and I can guess where it leads. When Java 8 was released, almost 10 years ago, having immutable product types (records) and sum types (sealed interfaces) with pattern matching would have seemed totally alien and unfeasible, just like Persistent collections today. But they did arrive. It's just a bit pity they didn't arrive _sooner_.\n\n>it's not at all clear that the pros of a second Collections framework provide all the much benefit over what is already available (e.g. List.of(), Set.of(), Collections.unmodifiable...(), etc.).\n\nSorry, but no. The benefits of Persistent collections are very much clear. Persistent collections provide a totally new dimension of functionality compared to the currently existing examples `.of()` that you've mentioned.\n\nYou can read more about them here https://en.m.wikipedia.org/wiki/Persistent_data_structure\n\nThe \"concern about new vs old\" could be had about any significant improvement to Java over the last 10 years (or ever). I just don't find such an argument very convincing.\n\n\"monumental undertaking\" is the part that I disagree with. Persistent collections could be added relatively soonish if there were enough will on the part of Oracle.\n\nBut if I had to guess, it will probably be added unnecessarily late, just like other Java features...\n\n> They will find a way to make it work.\n\nMaybe they will but unless you yourself see a way to make it work, I recommend to take the arguments of the people who tell you why there might be no way, more seriously.\n\n> And I'm here complaining that if there were more enthusiasm regarding Persistent collections in JDK from the Java authors now, we may have them sooner, let's say next LTS, which is 2 years.\n\nBut that complaint entirely hinges on your belief in the existence of a solution that you yourself can't see. What if there isn't one?\n\n> When Java 8 was released, almost 10 years ago, having immutable product types (records) and sum types (sealed interfaces) with pattern matching would have seemed totally alien and unfeasible, just like Persistent collections today. \n\nThat's just plain wrong - records and sealed types didn't seem \"unfeasible\" back then (if you disagree, I challenge you to find quotes from OpenJDK members to support that claim) and it's not like it just needed more complaints for the feature to arrive sooner.\n\nIf they do it, they do it so it doesn't look tacked on, as if it were there from the start, integrated into the JVM. If you just want a persistent collection library, you can use [vavr](https://www.vavr.io/), [pcollections](https://pcollections.org/), [cyclopsx](https://github.com/aol/cyclops) or any other now.\n\nWe'll see in 4 years. I'm optimistic.", "id": "k1eb3c6", "owner_tier": 0.5, "score": 0.7407407405555555}, {"content": "`List.of(..)`, `Set.of(..)` and `Map.of(..)` are all immutable.\n\nI hate that `EnumSet.of` is mutable", "id": "k1ejxxh", "owner_tier": 0.3, "score": 0.5370370368518519}, {"content": "List.copyOf(xxx) is shallow immutable. Same with Set.\n\nYou also have Collections.unmodifiableList and Collections.unmodifiableSet if you wish to decorate instead of copy, that assumes the internal collection is not changed at the source.\n\nUnmodifiable is not the same as immutable.\n\nThe decorator is just a view onto an underlying collection. The underlying collection can still change and that will be reflected in the view.\n\nThe decorator version could be effectively immutable if the underlying collection is only referenced by the view.\n\nIf we mean pure immutability, then this is not something you can directly enforce at a language level anyway, because there isn't a true concept of \"deep immutability\" in Java. It is simply a best effort contract. This is converse to, say, C++ which has the concept of constness. The JVM itself only provides the concept of constness on specific value-like types.\n\n> Unmodifiable is not the same as immutable.\n\nI dispute this claim. Immutable is the same as unmodifiable. I can cite some authoritative sources:\n\nFrom the Cambridge dictionary (https://dictionary.cambridge.org/us/dictionary/english/immutable):\n\n> not changing, or unable to be changed:\n\nFrom Merriam-Webster (https://www.merriam-webster.com/dictionary/immutable):\n\n> not capable of or susceptible to change\n\nFrom wikipedia (https://en.wikipedia.org/wiki/Immutable_object):\n\n> In object-oriented (OO) and functional programming, an immutable object (unchangeable[1] object) is an object whose state cannot be modified after it is created.\n\nWhy are you talking about language level? Everything we talked about is not language-level. They are part of the standard library.\n\n\"*Unmodifiable* is actually a different concept\" - Stuart Marks\n\n[https://www.youtube.com/watch?v=q6zF3vf114M&t=2522s](https://www.youtube.com/watch?v=q6zF3vf114M&t=2522s)\n\nBut I'm sure two general-purpose dictionary definitions and wikipedia are \"more authoritative\".\n\nEven by this definition Java's unmodifiable lists are not immutable because their internal state can be mutated (without reflection): https://www.reddit.com/r/java/comments/16ngn2l/why_there_is_no_immutablecollectionlistset_in_jre/k1hjrhg/\n\n> I can cite some authoritative sources:\n\nNot a one of these is an authoritative source on programming terminology.\n\nBecause reflection exists that can bypass any form of immutable design. Likewise if you use a language like Scala with immutable patterns and then integrate with this code from another language that doesn't' support those specific patterns at the language level, then you risk breaking that contract.\n\nThe standard library provides no mechanism for true deep immutability, only shallow immutability and referential immutability which is what I addressed in the original comment that I made.\n\nWith runtime and language level features like reflection that can violate immutability, the concept in Java itself is not as relevant. You can follow good patterns, sure, but it isn't a guaranteed contract that is impossible to work around.\n\nThere are implementation differences in the Java standard library between collection types named \"Unmodifiable\" versus the collection types named \"Immutable\". Stuart Marks is talking about these and he's correct.\n\nThe dictionary is talking about the general definitions. An immutable collection has the same meaning as an unmodifiable collection. The dictionaries aren't even attempting to describe specific implementation issues within the Java standard library.\n\nThe Java standard library collection classes named unmodifiable, do let you modify them via modifying the underlying collection. Conceptually, you can't modify an unmodifiable collection. That would be a contradiction.\n\nSure. I agree. I'd still say the terms immutable and unmodifiable have the same meaning this context and Java's unmodifiable lists aren't really unmodifiable in the sense that you can modify them.", "id": "k1eebnx", "owner_tier": 0.7, "score": 0.48148148129629625}, {"content": "Java has immutable collections with `List.of` and similar.\n\nI believe you want persistently immutable collections, or just persistent collections, not merely immutable collections, where you can add/remove, but they give new references to new versions of the collection, while any old references continue to work and reference the old state before the changes.\n\nhttps://en.wikipedia.org//wiki/Persistent_data_structure", "id": "k1ejzsx", "owner_tier": 0.3, "score": 0.2037037035185185}, {"content": "Collections API has an old FAQ doc - first question addresses this design\n\n* [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-designfaq.html#a1](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-designfaq.html#a1)\n\nBasically, addressing different expectations leads to a combinatorial explosion of new abstractions. It was considered a sound engineering compromise to trade the problem of \"many competing abstractions\" for the problem of \"few abstractions, but don't assume you can mutate\".", "id": "k1euotk", "owner_tier": 0.1, "score": 0.16666666648148146}, {"content": "List.of(), Map.of(), Set.of()\n\nThis", "id": "k1ex4bf", "owner_tier": 0.1, "score": 0.12962962944444445}, {"content": "The problem would be how to retrofit the existing collections API.\n\nIf you would completely redesign java.util.Collections as well java.util.Iterable and java.util.Iterator, you would probably want to start with immutable collections.\n\nI will only use sets in the following for ease of writing, but it applies to lists, maps etc. analoguous.\n\nFirst things first: It doesnt make sense to have a *mutable* `Set` and an `ImmutableSet`. You simply cannot build a sensible class hierachy/subtyping relationship from this.\n\nIf `Set` is mutable and has an `add` method, `ImmutableSet` cannot be a subclass. Or well it could be, but you would need to make the `add` method no-op or throwing. Not a good solution. The other way round you could have `Set` inherit from `ImmutableSet`, and have `Set` add *mutation*. But then a `if (s instanceof ImmutableSet)` would succeed despite the set being mutable. not good either.\n\nSo you'd start with `Set` being *immutable* and then adding a `MutableSet` subclasss. That way round it works ok.\n\nThen you would need to make `Iterator` immutable anf remov the mutations from it, and add a `MutableIterator`.\n\nBut changing all this requires extensive, incompatblie rework of `java.util.collection`.\n\nJava does have immutable Collections, but they all just throw when you call their mutating operations. That the best you can do without bricking all existing code. And since Java is *heavily* invested in backward compatibility, I don't see the status quo change any time soon.\n\nThat being said, I'd be delighted so see a new Collections API akin to `java.nio` which supplants the old API. but that would require maintaining two APIs, which I don't see happening, either.\n\n>So you'd start with `Set` being *immutable* and then adding a `MutableSet` subclasss. That way round it works ok.\n\nHow do I indicate then that I want an immutable set as parameter?  Asking for `Set` won't work because `MutableSet` would qualify.\n\nOr I could return `Set` and you would be under the mistaken impression that it will never change, as it may be a `MutableSet` internally.\n\nThere are always two viewpoints here; what the owner of the collection wants you to be able to do, and what guarantees the receiver would like.\n\nThats an absolutely valid point. It surely depends what *contracts* you want these classes to have. You always have to bite *some* bullet because we don't have intersection types or type negations in Java.", "id": "k1fxac7", "owner_tier": 0.7, "score": 0.16666666648148146}, {"content": "Actually they talked about it why yesterday at the live stream event: [https://www.youtube.com/watch?v=E8NV68ihJyY](https://www.youtube.com/watch?v=E8NV68ihJyY&t=1s) \n\nTo help you avoid watching the 8 hours, it's at around 6h48min.\n\n6:52\n\nWhy in a far off distant future? We could have Persistent collections in the standard Java library in the next release, if there were a political will for it. I'm exaggerating, but only a little bit.", "id": "k1egx51", "owner_tier": 0.1, "score": 0.09259259240740741}, {"content": "List.of, Set.of is immutable by default.", "id": "k1en972", "owner_tier": 0.1, "score": 0.09259259240740741}, {"content": "They weren't added when collections where introduced and adding them niw wouldn't make sense as existing code is already built to work with the current system where mutability is an optional feature.\n\ninmutable is a new trend and has no real uses, because you can do the same and just not modify your list.\npeople use it because a trend on youtube\n\nImmutability by default has some real benefits. It offers more safety, preventing many bugs earlier. If you know that you have an immutable collection then you can safely store it without risking some other code changing it. It's also often possible to accidentally mutate things when you don't mean to in some cases (not so much for collections tho).", "id": "k1e72ha", "owner_tier": 0.3, "score": 0.05555555537037037}, {"content": "One thing that Java has going for it that Python, Javascript, etc. do not is that the built in collections are not that privileged.\n\n  \nYes, built in methods accept and return `java.util.List`. But all of\n\n* Eclipse Collections\n* Guava Collections\n* Vavr collections\n* Pcollections\n* ...etc\n\ncan be just as ergonomic or more so than the built-ins.\n\nIf you want your system to have clear delineation between Immutable and Mutable collections, that is very doable. It just comes at the cost of an API tradeoff that the core libraries did not want to make.", "id": "k1feifh", "owner_tier": 0.5, "score": 0.037037036851851855}, {"content": "don\u2019t know and don\u2019t care. i\u2019m sure the people in charge have encountered this question. it\u2019s probably a huge pain to implement", "id": "k1h4t3h", "owner_tier": 0.7, "score": 0.037037036851851855}, {"content": "One trick I use is to code things, wherever possible as Iterable.  This does not work everywhere (for example, if you know it is an ArrayList and want to access by index efficiently), but for the vast majority of cases where folks are simply going to stream or iterate over the items in a loop, it works.  Be sure you have a backing collection that is already itself immutable (ala List.of()).", "id": "k1er09b", "owner_tier": 0.5, "score": -1.8518518518518518e-10}, {"content": "I don't understand what is the interest of an immutable list? In this case you can replace it with an immutable array and this is quite better. This is just to show that immutable data structure is often a weird structure at the end. Data structures without modificators are very limited. Instead of immutable data structure in general, ask for some new immutable data structures that are a kind of view that you will build on request and after the initialization they have no more relation with the initial data structure", "id": "k1jfpc7", "owner_tier": 0.5, "score": -1.8518518518518518e-10}, {"content": "java has no immutable reference ;-)", "id": "k1jpjxs", "owner_tier": 0.1, "score": -1.8518518518518518e-10}], "link": "https://www.reddit.com/r/java/comments/16ngn2l/why_there_is_no_immutablecollectionlistset_in_jre/", "question": {"content": "Those are super useful as seen in Scala/Kotlin/Guava library. Are there any reasons against having it in JRE?", "id": "16ngn2l", "title": "Why there is no ImmutableCollection/List/Set in JRE?", "traffic_rate": 55.9755525787006}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "Absolutely use data classes when they do the job. Cases when this is not true (or it's awkward):\n\n- custom init method\n- custom new method\n- various patterns that use inheritance\n- if you want different names for the attributes,. including implementing encapsulation \n- probably more things :)\n\n\nChanging later might have some cost, so use dataclasses when you are fairly certain you won't need those things. This is still a lot of cases, I use them often.\n\nCustom init method is handled by \n\n    post_init\n\nLast I checked it doesn't work for inherited classes - i.e. post_init won't run in the parent class, unless added in the child class as well.\n\n>various patterns that use inheritance\n\nNot true for immutable (frozen) dataclasses.\n\nYou can activate it with super(), same as a regular class init.\n\nThere is also a (admittedly hacky) way to use it with frozen data classes\n\nOh, true! Although it's still a bit hacky: https://stackoverflow.com/questions/59986413/achieving-multiple-inheritance-using-python-dataclasses\n\nI feel like `admittedly hacky` is part of the question here though.\n\nAs long as you're comfortable bending so far backward that you can lick your own anus, you can use anything to achieve anything in Python. But that doesn't make it a good idea.\n\nI think the question here is basically \"how hacky is too hacky?\" \"How far from the intent of dataclasses can you go before it becomes a bad use case for dataclasses?\" Etc.\n\nI don't have the answer myself - especially since my work rarely has a need for dataclasses - but am interested to follow the discusion.\n\nI appreciate the way you phrased this, yes that's pretty much it ![gif](emote|free_emotes_pack|joy)", "id": "itn7h6i", "owner_tier": 0.7, "score": 0.9999999998181818}, {"content": "The data class is, well, data class. It's ideal for purely data storage and transfer. By default, it gives you the \"value semantics\". For anything else, eg when you need to add (any significant) behaviors, just regular classes are more suitable.\n\nCan you elaborate on what makes them \"more suitable\"? Is there a performance difference? I've been using data classes in this way for a few weeks and haven't noticed any difference.\n\nPerformance is negligible, if you need performance, use `__slots__`... or don't use python. In your example, all you're really doing it getting `__init__` for free. But a dataclass has value semantics and anyone using it would expect that. Values don't usually have methods besides those that are pure transformations, like math.\n\n> or don't use python\n\n\ud83e\udd23", "id": "itn5jap", "owner_tier": 0.3, "score": 0.5272727270909091}, {"content": "When I don't control the storage or need primitive types for any reason, I use named tuples. They're also great\n\nWhy prefer named tuples to data classes?\n\nI'm also curious, not that it's wrong.\n\nI use named tuples specifically when I want my class not to be immutable. idk otherwise\n\nNot the original commenter, but for one thing, less overhead.\n\nThat's the fundamental problem with classes IMHO, it's just more code to write and maintain. By contrast, named tuples are *almost* like simple classes, but can be defined on just a single line.\n\nThey are a lot faster\n\nHashable immutable extremely lightweight without any decorator shenanigans. Use typing.NamedTuple for the convenient object-oriented declaration style.\n\nI often use named tuples to encapsulate types I feed through an old API that requires undocumented tuple (looking at you, Sphinx). Named tuples behave exactly the same as tuples, and you can add your own methods like classmethods for factory functions (a.k.a. named constructors).\n\nSince named tuples are not configurable, you can't mess with its API or misuse it, and even quite old type checkers can analyze them.\n\nWell, unless I specifically require features not in named tuples I might use dataclasses. If I need any validation or schema generation I'll go with pydantic models.\n\nWell... I don't think I have much use cases remaining for dataclasses, and I am not a huge fan of it's API. It is also a matter of personal preference I guess.\n\nYou can do frozen data classes\n\nSource? What I'm reading online seems to indicate a minute difference in speed.", "id": "itnpb03", "owner_tier": 0.3, "score": 0.418181818}, {"content": "`third_input` should be:\n\n    third_input: datetime = field(default_factory=datetime.now)\n\nOtherwise all instances will have the same date.\n\nBut didn't they mess it up in the \\_\\_init\\_\\_ as well? There's an `or` so we get an evaluation for truth right? And as long as datetime.now() is True third_input will have the value True.\n\ncommy2 is right, I made an assumption in the 2nd example when I should have kept them functionally identical.\n\nTo your question, it's a little bit of an operator trick but actually it's correct! https://stackoverflow.com/a/4978745\n\nEveryone on stackoverflow says it's bad practice. I don't think I've ever seen 82 upvotes on a comment before.\n\nBut apparently it does the thing. I'm mortified.", "id": "itoxt90", "owner_tier": 0.5, "score": 0.1999999998181818}, {"content": "Data classes are great when every attribute of the class is public.  In contrast, they're not meant for classes that have private attributes.  Most of the time, my reason for making a class is to hide some information from the outside world, so I don't use data classes that often.   \n When I do use them, I basically treat them like more well-defined dicts/tuples.\n\nPython doesn't have private attributes. If you're looking for that you're using the wrong language.", "id": "ito6yy5", "owner_tier": 0.1, "score": 0.1272727270909091}, {"content": "Why not Pydantic?\n\nI'm looking to introduce either, or something else, in my own code and seems like Pydantic is more powerful. It has built-in validation methods, and those can easily be extended and customized.\n\nIn my case I'm hoping to do elaborate payload handling. Upstream system submits JSON that contains a request for service to be provisioned. To do so, numerous validation steps need to be completed. And queries made, which then need to be validated and then best selection made. Finally resulting in the payload containing the actual details to use to build the thing. Device names, addresses, labels, etc. Payload sent through template generators to build actual config, and template uploaded to device to do the work.\n\ndepends on OP's use-case. validation has a performance cost, which if you're doing some kind of high-throughput data processing that would involve instantiating many of these objects, the overhead can be killer. here's a small test that shows instantiating a data class is about 20x faster than using pydantic (at least in this specific case).\n\n```python\n$ python -m timeit -s '\nfrom pydantic import BaseModel\nclass Test(BaseModel):\n    x: float\n    y: int\n    z: str\n' 't = Test(x=1.0, y=2, z=\"3\")'\n50000 loops, best of 5: 7 usec per loop\n```\n\n```python\n$ python -m timeit -s '\nfrom dataclasses import dataclass\n@dataclass\nclass Test:\n    x: float\n    y: int\n    z: str\n' 't = Test(x=1.0, y=2, z=\"3\")'\n1000000 loops, best of 5: 386 nsec per loop\n```\n\nof course there are always pros and cons. if you're handling a small amount of data, the processing of that data takes much longer than deserializing it, or the data could be fairly dirty/irregular (as is typically the case with API requests), then pydantic is probably fine (or preferred) for the job.\n\nIf pydantic is too much you could give a try to chili [http://github.com/kodemore/chili](http://github.com/kodemore/chili). I am author of the lib and build it because pydantic was either too much or too slow. Also I didnt like the fact that my code gets polluted by bloat code provieded by 3rd party libraries because this keeps me coupled to whathever their author decides to do with them. I like my stuff to be kept simple and as much independant as possible from the outside world.  \n\n\nSo you have 4 functions:  \n\\- asdict (trasforms dataclass to dict)  \n\\- init\\_dataclass, from\\_dict (transforms dict into dataclass)  \n\\- from\\_json (creates dataclass from json)  \n\\- as\\_json (trasforms dataclass into json)  \n\n\nEnd :)\n\nHi, if one of your usecases is to map & convert json data to existing python structures also have a look at the [DictGest module](https://github.com/bmsan/DictGest) .\n\nI created it some time ago to due to finding myself writing constantly translation functions( field X in this json payload should go to the Y field in this python strucure)\n\nThe usecases that I wanted to solve were the following:\n\n* The dictionary might have extra fields that are of no interest\r\n* The keys names in the dictionary do not match the class attribute names\r\n* The structure of nested dictionaries does not match the class structure\r\n* The data types in the dictionary do not match data types of the target class\n* The data might come from multiple APIs(with different structures/format) and I wanted a way to map them to the same python class\n\nSee this analysis by a co-author of attrs\n\nhttps://threeofwands.com/why-i-use-attrs-instead-of-pydantic/\n\nThey suggest attrs for class building ( no magic)\n\nAnd cattrs for structuring unstructuring data eg json", "id": "itowumc", "owner_tier": 0.7, "score": 0.418181818}, {"content": "Dataclasses are nice and better in many ways, but you kind of hurt your own argument by providing an example where the two classes are not functionally equivalent, because you messed up the call to *field*.\n\nFair, I made an assumption in the 2nd when I should have made it a default\\_factory to keep it functionally identical. Hopefully that typo in my 2-minute scratch example doesn't invalidate the idea though!", "id": "itp7ddn", "owner_tier": 0.7, "score": 0.09090909072727273}, {"content": "IMHO dataclasses are meant primarily for DTOs. I use them in this capacity and they work well.", "id": "itqs5hc", "owner_tier": 0.3, "score": 0.018181818000000002}, {"content": "Last data project I did we used pandas extensively and every time we introduced a dataclass i found that it clashed with pandas quite a lot.  The vast majority of the time it was more convenient and more efficient to refer to data column-wise instead of row-wise, although for the latter case automatic conversion to and from dataclasses would have been handy.  (Turns out pandas supports something similar with named tuples and itertuples though.). We did use dataclasses for configs and stuff but it felt unnecessary to me vs just using dicts, an extra conversion step just to help the linter, basically, and removing some flexibility in the process.  So overall while i liked the idea of dataclasses, I didn't find them that useful in practice.\n\nThe purpose of this post was more about their utility compared to normal classes, but coincidentally I'm just starting into a similar project and am very interested in your experience! Could you share a link to the namedtuples/itertuples feature you mentioned?\n\nSure, basically if you're iterating over a Pandas dataframe (something to be avoided but sometimes necessary), then you can use [iterrows](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html) or [itertuples](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html).\n\nFor a long time I was only using the former, which gives you a Series for each row. (Or column, you can choose which way you are iterating.)\n\nThe latter gives you a namedtuple for each row, where the attributes of the tuple are the table column names.  It's not a huge difference in practice but it can be handy.  However, as this object is dynamically generated based on the contents of the table, it doesn't help much with type hinting.  It would be nice if itertuple accepted a dataclass class name as input., and just errored out if things didn't match.  This would require some complicated type hints for `itertuple`, not sure if it's even feasible with Python's type system.", "id": "itra1y0", "owner_tier": 0.5, "score": 0.07272727254545455}, {"content": "Can you explain data classing briefly? I do a lot of database ETL, as in, I query a database and create new data from the queried data within Python. Will using data classing help me?\n\nIt's relatively typical to pull data from a database and store it in python in the form of a dictionary (with column names as keys, and the corresponding value)\n\nThis is annoying for large/complex sets of data ( or even small but unfamiliar sets of data, like if you're a new hire being onboarded) since you don't know the types of the data.  Each database column could be a string, an integer, raw image data.. but to the programmer interacting with it, you can't tell immediately. If you hover over my_row[\"column_1\"] in your editor, it will just say \"unknown\" or \"Any\". Could be a number, or a string, or none..\n\nIn my opinion the best part about data classes (although there's lots of other stuff!) Is that it provides a great interface to declare the types of each field in your data. You directly tell python (and therefore your editor) that column_1 is an integer, and column_2 is a list of strings, etc.\n\nNow, your editor can auto-complete your code for you based on that information, and if you ever forget, you can just hover over the variable to see what the type is.\n\nYou get better and more accurate errors in your editor, faster onboarding of new hires, it's great.\n\nYou can also do this other ways, like with a TypedDict, but dataclasses provide a lot of other useful tools as well.\n\nIf you're doing a lot of ETL, and you're looking at one record at a time (rather than running big sql queries or just launching a loader), then yes, it's the way to go.\n\n[Here's the doc](https://docs.python.org/3/library/dataclasses.html). Conventionally they're meant to simplify the construction of classes just meant to store data. I don't know your setup, but speaking in general they are definitely handy for adding structure to data transfer objects if you don't already use an ORM.\n\n\n>In my opinion the best part about data classes (although there's lots of other stuff!) Is that it provides a great interface to declare the types of each field in your data.\n\nInterface is good for scalar types but not for collections. Traitlets provides a uniform interface to both. Not only that but you can configure Traitlets objects from the command line and configuration files once you define the objects.\n\nNamedTuples are probably much more efficient and give you 90% of the functionality. In an ETL context I'd probably prefer them.\n\nWhen doing ETL, how much time are you really spending looking at individual records instead of aggregating? Is it not like 0.001% of the time?\n\nGreat consideration - since ETL may so often involve gobs of records.\n\nBut I think performance only favors namedtuples on constructing a record, but retrieval, space and transforming the record are faster with the dataclass.\n\nGoing from memory on this however.\n\nWhen I write the transformation layer in python then typically my programs will read 100% of the records.  The Python code may perform some aggregations or may not.  On occasion there may be a prior step that is aggregating data if I'm facing massive volumes.  But otherwise, I'll typically scale this up on aws lambdas or kubernetes these days.  Years ago it would be a large SMP with say 16+ cores and use python's multiprocessing.\n\nThe only time I consistently use aggregations with python is when running analytic queries for reporting, ML, scoring, etc against very large data volumes.", "id": "itn7ir1", "owner_tier": 0.1, "score": 0.25454545436363635}, {"content": "Data classes are objectively inferior object factories. They lack the capabilities of Traits, Traitlets and Atom. And usage of collections in data classes is verbose and cumbersome.", "id": "itp05ze", "owner_tier": 0.3, "score": -1.818181807131871e-10}, {"content": "Because it is unnecessary extra plumbing.\n\nBut it's less plumbing than a normal class.\n\nNot to my eye. \nHow is less plumbing to you?\n\nIt generates extremely common boilerplate code like __init__ and __repr__, that's the entire point of it is brevity.\n\nExactly! Plumbing.", "id": "itqdrk3", "owner_tier": 0.3, "score": 0.07272727254545455}, {"content": "Not sure what you're asking here. Type hints being good is an opinion.\n\n>when the bottom arguably reads cleaner,\n\nFalse\n\n>gives a better type hint\n\nFalse\n\n>provides a better default `__repr__`?\n\nFalse\n\nIf I want to keep my class flexible, type hints are a mistake, they are an obstacle to readability not a help and maybe the default `__repr__` doesn't fit my use case. What do I do then?\n\nShow me the case, where dataclasses are better than plain dictionaries, then we can maybe talk, maybe because I don't think you'll find one.\n\nThis entire reply screams \"zealously held minority opinion\".\n\nDataclasses are very popular and widely used. While not everyone agrees with OP that we should be using them at every possible opportunity, \"dicts always beat dataclasses\" will be an opinion without an audience. I guarantee it.\n\nYour first False is on an opinion, hence the \"arguably\". I think it's true.\n\nIt objectively gives a better type hint. \n\nAgain, #3 is an opinion. You can disagree but it's not an invalidation of the idea.\n\nYour attack on type hints are irrelevant to this conversation - I put them in the regular class too for a reason.\n\nClearly plenty of people agree dictionaries are less optimal for some use cases, otherwise dataclasses would not have been added to the language.\n\nSo much hostility about a programming concept\n\nIt's a writing style and I'm allowed to be hostile to a style I don't like, the same way I dislike brutalism in architecture?\n\nNot personally enjoying something doesn't necessitate hostility towards that thing. That's unnecessary. You are \"allowed\" to do what you want yes, nobody said you weren't. You're just acting like an asshole.", "id": "itpg0d7", "owner_tier": 0.7, "score": 0.18181818163636362}, {"content": "What you should be using is attrs https://www.attrs.org/en/stable/\n\n( Dataclasses is basically a subset of this for classes that hold data)\n\nCare to elaborate? I've seen a few references to attrs features that seemed handy (namely their inherited param sorting), but my understanding is that they were more of a prototype and not meant to be used now that dataclasses are builtin.\n\n\"Data Classes are intentionally less powerful than attrs. There is a long list of features that were sacrificed for the sake of simplicity and while the most obvious ones are validators, converters, equality customization, or extensibility in general, it permeates throughout all APIs.\n\nOne way to think about\u00a0attrs\u00a0vs Data Classes is that\u00a0attrs\u00a0is a fully-fledged toolkit to write powerful classes while Data Classes are an easy way to get a class with some attributes. Basically what\u00a0attrs\u00a0was in 2015.\"\n\nhttps://www.attrs.org/en/stable/why.html#data-classes", "id": "itn9np2", "owner_tier": 0.5, "score": -1.818181807131871e-10}], "link": "https://www.reddit.com/r/Python/comments/ycn5ae/any_reason_not_to_use_dataclasses_everywhere/", "question": {"content": "As I've gotten comfortable with dataclasses, I've started stretching the limits of how they're conventionally meant to be used. Except for a few rarely relevant scenarios, they provide feature-parity with regular classes, and they provide a strictly-nicer developer experience IMO. All the things they do intended to clean up a 20-property, methodless class also apply to a 3-input class with methods.\n\nE.g. Why ever write something like the top when the bottom arguably reads cleaner, gives a better type hint, and provides a better default \\_\\_repr\\_\\_?\n\nhttps://preview.redd.it/p0t7193zntv91.png?width=1496&format=png&auto=webp&s=ee3de28b11e26214d7cea9d44bf5a64717e6bcb1", "id": "ycn5ae", "title": "Any reason not to use dataclasses everywhere?", "traffic_rate": 207.942496260595}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "A class is the blueprint telling you how to build the car. The object is the physical car that you can drive.\n\nSolid explanation\n\nThanks Angela\n\nSo was my way of thinking it correct?\n\n\ud83d\ude97\n\nNo, because you said a different type of car. An instance would be a single specific one, not a type. A specific car might be a Tesla, but there's more than one Tesla.\n\n\n\nAssume you own a car...\n\n\n`Car` is the class(ification) of the object that you own.\n\n\nThe object you own is that specific one located in your driveway. The one that I own is the same class, but not the same object.\n\nNo, what you are suggesting is more what a subclass is.", "id": "l75uz8l", "owner_tier": 0.7, "score": 0.9999999999453552}, {"content": "I always thought of it like: \n1. The memory in a computer is like a big ball of dough. \n\n2. A Class is a Cookie Cutter that can take whatever shape you want. It's just made to resemble whatever you want it to. A Person, a Shape, A Tree, A Hero, A Dragon, whatever you want.\n\n3. An Object is whatever dough you cut out with the cookie cutter. It's just a segment of dough(memory) that's intended to follow the design of the Cookie Cutter(Class).\n\nYou can make as many dough cuts with the Cookie Cutter so long as you have dough. You can have different Cookie Cutters cut from the same ball of dough. \n\nYou're not really expected to do more with the Cookie Cutter (class) than make pieces of dough (memory) resemble it. You're having an Inexplicably Counter-Productive Day if you try to Bake without using dough, just the Cookie Cutter. \n\nDisclaimer: \nIt gets a bit more complicated with \"Static\" classes and whatever pertains to the given Programming Language. But that starting point helped me make a Mental Map of the fundamentals.\n\nI hate your explanation because I don\u2019t have any cookies. You just make me want a cookie shaped like a dragon\n\nI'll continue with food. But this \"memory-first\" miss the behavior part. And what objects are from OOP standpoint.\n\n- An object public signature is like a restaurant menu. It describe what the object can do for you (ie food), and what it need from you (ie $, sometime some choices)\n\n- A class is a template to make object (Ie restaurant chain)\n\n- An instance is a specific restaurant from the chain, at a specific time.\n\n- The cookie dough is mostly hidden behind the kitchen counter (encapsulation)\n\n- This is because you don't want to consumer to do micro management.\n\n   - A consumer can order a burger # 6 with extra bacon.\n   - A consumer shall not be able to select a specific cook, take a specific patty from a specific fridge, select a specific grill etc.\n\n- You want a single source of thruth\n   - The restaurant chain  keep the knowledge of what is a burger # 6 and how to make one.\n   - You don't want that knowledge spread accross different burger consumer. Then you setup yourself to have inconsistency and bugs. (copy paste programming)\n\n- You don't want the restaurant chain to micro manage either.\n   - The restaurant instance HAS employees. Those employee can make choices toward your specified goal.\n   - The restaurant istance IS NOT a pile of human organs (among other things) that must be controlled toward your goal.\n\n- Sometime the cookie dough change, you still have the same cookie.\n  - If you have less ketchup in reserve in the fridge you still have the same restaurant.\n\n- Sometime people prefer to work with snapshot in time of what the cookie dough is, and that is fine too. Multiple snapshot of the same thing can coexist and old snapshot can be kept for record keeping. Or to better understand what happened in the workshift.\n\n- Sometime a food inspector can come in, and the best thing you can do is let them inspect(). Whatever that thing is. And different instance of food inspector can do different inspection, and that's fine. You just trust what it say on the label.\n\nIdk about dragon shaped ones, but check your browser. It's full of cookies, I bet! \n\n....I'll show myself out.\n\nYou just made me remember I have cookies and now I\u2019m going to go eat one\n\nI hate that this made me laugh. Take my angry upvote.\n\nHeh, after the day I've had I needed this joke!", "id": "l75z5l9", "owner_tier": 0.7, "score": 0.8852459015846994}, {"content": "The class details the defining features of a Car. The class does NOT specify the values for those features. An object does specify the values for the features of ONE Car", "id": "l75wmbs", "owner_tier": 0.3, "score": 0.13114754092896175}, {"content": "The class is the formula for the object.  The object is one instance of it.\n\nClass Zebra has four legs, two eyes, a tail, and stripes.  It can run, jump, walk, and post memes.\n\njoe = Zebra(long legs, big eyes, fluffy tail, wide stripes) is not the same as daphne = Zebra(short legs, small eyes, curly tail, thin stripes), but they're both Zebras, and if there were an isZebra(zebra) function, isZebra(joe) and isZebra(daphne) would both return True.\n\nHowever, when joe.postMeme('scumbag hyena'), daphne does not.\n\nScumbag hyena lol", "id": "l75zzdn", "owner_tier": 0.9, "score": 0.13114754092896175}, {"content": "People have already given technical and metaphorical descriptions, so I'll try to explain something a little different. Why do we use the words \"class\" and \"object\"?\n\nWhen you think about objects, imagine a physical object, say an apple. That's an object. It's real, not abstract or conceptual. It has properties that can be described and measured. It's a unique thing; even if you had an apple that's a perfect clone, it wouldn't be *this* apple. Objects in programming are the same thing, just made of memory instead of atoms. \n\nWhen we say a submarine is Dreadnought-class or a car is SUV-class or a chef is world-class, we mean it has some set of characteristics that it shares with every other object that class. That's what a class is: a set of characteristics that a set of objects all share. In the real world, we take objects with shared characteristics and create a class to describe it. In programming, we do the reverse: we describe a class with the characteristics we care about, then create objects defined by having those characteristics. \n\nHopefully this makes sense and helps explain why the class/object metaphor is described the way it is. If stuff is confusing, I can try to answer questions.", "id": "l76k10y", "owner_tier": 0.7, "score": 0.08196721306010929}, {"content": "Object is something that carry properties ( like form, color, touch, sound, feel) and functions (actions possible with object or on the object) similar properties and functions creating classes of objects.", "id": "l773gyk", "owner_tier": 0.3, "score": 0.01639344256830601}, {"content": "Hard to answer with an example because needs of the program tend to dictate how it's implemented, and cars could be implemented in so many different ways. \n\nThe class Car could have an init method that accepts make, model, year, vin_number, and miles driven. The instance would be a specific car with a spdcific values for each. \n\n    car_instance = Car(make=\"tesla\",model=\"M3\",year=2024,vin_number=\"X1234512345\",miles_driven=20314) \n\nIf there's a function that all car instances would share, you'd add that to the class definition so that instances could later use that as a method. \n\n    car_instance.honk()\n\nIn the Car class definition, you'd have to define and implement the logic. In this case it may just look like\n\n    class Car:\n        ... \n        def honk(self):\n            print(\"Honk!\")\n\nThat's a good one, thank you! I'm starting to learn this year...", "id": "l76490m", "owner_tier": 0.5, "score": 0.027322404316939893}, {"content": "A class is like \u201ccars\u201d, they can have different manufacturers, age, color, etc.\n\nAn object is like your mums current car. Its real, its there, you can drive it, and it has a defined specific one manufacturer, a defined color and determined age.\n\nOhh so the class is like base properties every object has but the values of each parameter are different for each object.\n\nIn my understanding, yes, that is almost correct. A class is like a blueprint. It tells what KIND of properties, values, things will the objects have, and how they will behave, what will they do, when they will be created.\n\nThen, once you create an object, then the specific values, properties, things will be defined. \n\nDefining a class is like designing a car (the car itself does not exist yet), defining an object, an instance of the class, is like manufacturing a car (now it exist, has a color, and can be driven)", "id": "l76srry", "owner_tier": 0.3, "score": 0.03825136606557377}, {"content": "Thinking about a GUI might make it easier.\n\nIf you're building a simple app, you might have a class called Checkbox.\n\nAn object would be AgreeCheckbox with the text \"I agree to the terms and conditions\", that's a specific checkbox. A different object on the page might be AdvancedCheckbox with the text \"Show Advanced Features\".\n\nSo your car example is tough because what kind of app is it? If the app involves a bunch of cars driving around then you might have two Teslas, right? So an object might be \"my car, that's a white Tesla that's currently on the left side of the screen\" and another object is \"your car, a green Toyota that's currently driving down the mountain\".", "id": "l75zrxw", "owner_tier": 0.9, "score": 0.010928961693989072}, {"content": "A class is like the design of a car. An object is the physical car itself", "id": "l77aouf", "owner_tier": 0.1, "score": 0.010928961693989072}, {"content": "An object is structured data stored in your PC's memory. You can think of it like a bundle of variables that are packed together so that you can save on lines of code in other parts of your program. But that's not all: Objects come with methods which are functions that operate on the variables the object is comprised of. In their essence, objects are a combination of data and functions tightly coupled together so that you can write a part of your program at one location (the class) and use it everywhere you need it wirhout having to repeat the code.", "id": "l77tm3p", "owner_tier": 0.3, "score": 0.010928961693989072}, {"content": "I find that good examples of classes vs objects are locations.  For example, a class might be \"city\", and some examples of objects of the class \"city\" would be Chicago, Paris, New York, etc.  \"city\" is more of an abstract concept that defines structure and behavior, and Chicago is a \"city\" you can actually go visit.  You can't go out and visit \"city\", but you can visit Chicago.   Cities have a population (property/structure), and Chicago's population-- because it actually exists-- has a value of 2.6 million.\n\nA few people have used \"car\" as an example of a class.  Great!  So a car could have a VIN (part of the structure).  An example of an instance/object of \"car\" isn't just a Honda Accord, it's Bill's gray Honda Accord with VIN #123456 that's parked in his garage right now.  Objects \"exist\" and can be interacted with while classes define the properties/structure and behavior of objects.\n\nA class defines properties and behavior (methods), while objects possess concrete values for those properties and can be interacted with by calling the methods of the object.  Create some classes, then instantiate some objects and try it out.  Create a city class with properties like \"name\", \"country\", \"population\", and see if you can create a Chicago object based on that class.", "id": "l768p8s", "owner_tier": 0.3, "score": 0.005464480819672131}, {"content": "Not quite, even types of cars are classes, inheriting from the car class. An object is my car, another object is your car. If you have 2 cars each one is an object", "id": "l76wkh1", "owner_tier": 0.3, "score": 0.005464480819672131}, {"content": "Think out of objects like boxes holding properties that made them function in a way , you can apply on them methods and they have life cycle", "id": "l7872f3", "owner_tier": 0.1, "score": 0.005464480819672131}, {"content": "Yes, but be careful about using the word \"type\". Technically speaking, a \"type\" is a range of permissible values. So for example, \"integer\" is a type whose values are restricted to positive and negative whole numbers. A class also defines a \"type\" because it defines the fields and methods (and their own corresponding types) that an instance/object of the class is permitted to have. So an object is not a \"type\" of a class, because its values respect the restrictions imposed by the corresponding class.\n\nWhen there are multiple objects of a class, we don't say they're each a different \"type\" of the class. Instead, we say they are different instances. But two instances can sometimes share the same values. If the two objects have different values for their fields, there is no name for that of which I'm aware.", "id": "l760lm5", "owner_tier": 0.1, "score": -5.464480841106716e-11}, {"content": "If you have a class House, the objects would be houses. They wouldn't be different types of housing (like an apartment, then a loft, etc), but slightly different houses. For example, object houseA may be blue and houseB may be yellow.", "id": "l760mkb", "owner_tier": 0.3, "score": -5.464480841106716e-11}, {"content": "A class describes the blueprints for a single kind of object. It describes what information we need to know about an object, and what behaviors that object exhibits.\n\nMore specifically, it tells us what variables must be present inside every instance of that class, and it describes the methods that can act on an instance of that class. A constructor details how you build an instance of that class, including what (if any) information is needed in order to create an instance.\n\nYou seem to be close but a little bit off. Tesla, Ford, Mitsubishi etc. are car manufacturers, but they're not cars in and of themselves. A car *has* a manufacturer, as well as a bunch of other defining features. An instance describes one exact car, listing all it's different features, so perhaps one `Car` instance is a Tesla (make) Model S (model), from 2013 (year), owned by John Doe (owner). These pieces of information define 1 exact car, out of the billions of `Car`s that could exist.\n\nThe specific contents of a class depend entirely on what you the programmer decide that class needs to have. So for example a `Car` might require a make and model. It might also require a VIN number; a number of doors; a height, width, and length; an engine type; whether the engine is supercharged, turbocharged, or naturally aspirated; and so-on. All of these are examples of information that could theoretically be part of a `Car` class. The actual information you store depends on what you need to do with objects of that class.\n\nIf you're making a game maybe your `Car`s need a 3d model, and stats that control how it drives (acceleration, top speed, turning, etc.). If you're making a database for a mechanic, your Car class might need completely different information, like the owner; make, model and year; odometer; last oil change; and a history of repairs.", "id": "l762nme", "owner_tier": 0.7, "score": -5.464480841106716e-11}, {"content": "A class is like a recipe.  A recipe for soup is not soup, it\u2019s a description of what makes soup a delicious meal.  An object is the soup.  You know what\u2019s in the soup by looking at the recipe.", "id": "l7699n0", "owner_tier": 0.1, "score": -5.464480841106716e-11}, {"content": "Ben (object) is a human (class). There are things all humans share, therefore Ben shares them too. Some things however are specific to the object, such as name, hair color, age, etc.", "id": "l76btdy", "owner_tier": 0.3, "score": -5.464480841106716e-11}], "link": "https://www.reddit.com/r/learnprogramming/comments/1d8f9zm/can_someone_help_explain_what_objects_are_to_me/", "question": {"content": "I know the whole definition of \"an object is an instance of the class\".  Does this mean like an object kind of like a version of a class?  For example a class would be a Car and the objects would be different types of cars like Tesla, etc.\n\n  \nEDIT\\* Thank you so much for the help on objects and classes.  From what the answers are saying a class is like properties every object has but an object is like the representation of a class.  ", "id": "1d8f9zm", "title": "Can someone help explain what objects are to me?", "traffic_rate": 759.4147559171597}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "My preference is yes to the 'final, no to the 'this' - it just clutters up the code.\n\nSo you write like this?\n\n    public final foo(final int a, final int b){\n      final int c = a + b;\n    }\n\nSeems like so much visual noise.\n\nAgain I have to say that I wish the approach taken by Rust would've been selected 30 years ago. Everything is final by default and mutable variables have to be defined explicitly. That would be so great.\n\n> no to the 'this' - it just clutters up the code.\n\nThe same thing applies to the `final`, though.\n\njavac and JIT don't need _me_ telling them when a variable is final or not -- they already know.  \nThey know the scope and mutability of every single field and var, and whether it can or cannot be inlined. Meaning, they know if a variable is \"effectively final\" and will treat it as such.  \nYou could strip every single `final` from a .java file and the resulting .class would be exactly the same.  \n**The only reason to declare a variable as `final` is to keep _other programmers_ from modifying its value.** And I don't like to do that, because often times, while debugging, that other programmer that needs to change a variable's value is me, and I cannot do that if the variable is final.\n\nIt does nothing but make my code harder to work with. It's just clutter.\n\nI don't get it why you think it clutters up the code. Do you think you can try to elaborate? Like, isn't better to easily see what's an attribute?\n\nYou can use a final AtomicInteger if you want to mutate it. :D\n\nFinal clutters up the code\n\n>it just clutters up the code\n\nLet me guess, you also put brackets on one-liner if-else statements?\n\n\"Types after variables\" is also really nice.  Were I redoing java syntax I'd definitely take that.\n\n`val foo = 1`\n\nor\n\n`val foo: int = 1`\n\nboth really readable to me and makes things like lambda declarations flow better.\n\n>You could strip every single final from a .java file and the resulting .class would be exactly the same.\n\nMaybe for parameters and local variables but not so for classes, member variables and methods.\n\nThe only times I\u2019ve ever wanted to mutate a value during debugging is when I\u2019ve caught a bug and fixed it but I don\u2019t want to abort the test run because what I\u2019m really interested in comes later and I don\u2019t want to take the time to restart the test (I mean it happens but it\u2019s normally not a big deal to drop and restart the frame once I\u2019ve fixed the code). That\u2019s been like twice ever. I might agree with you if I needed that more, but I prefer to explicitly declare as final anything that isn\u2019t intended to be changed.\n\nI\u2019m curious what sort of codebases do you find yourself doing that in? I do a lot of long-term contract work and want to recognize if that might be something to keep in mind for on new projects.\n\nEverything you say is right, but I have a lot more issue with junior developers not understanding the intent of certain classes and horribly misusing them. So defensive coding is more important to me. Plus I have a shit memory and I\u2019ve never prevented myself from screwing up through defensive coding but I\u2019m pretty sure some day it will happen.\n\n[deleted]", "id": "iltcocz", "owner_tier": 0.3, "score": 0.9999999999541284}, {"content": "**Final**\n* **Use final for fields if they should not be reassigned**. Otherwise, it is hard to tell whether a field is reassigned without examining all methods.\n* **Don't use final for local variables**. Methods are natural reassignment boundaries. It is better to reduce method size than it is to make local variables final. If the finality of a local variable is important (e.g. you want to reference it in a lambda) then the compiler already has your back.\n* **Don't use final for parameters**. Reassigning a parameter doesn't affect the calling scope so the impact of reassignment should be clear, because you have stuck to small methods. Mutating a parameter is a far more sticky situation anyway and final doesn't protect you from that.\n\n**This**\n* **Use this when reassigning or mutating a field**. Your method has a side effect and using this makes this explicit, especially in out of context cases e.g. a pull request.\n* **Don't use this when reading a field**. The difference between reading a field or a local variable rarely matters so by not using this, you are not adding unnecessary noise.\n\nYep, I can get behind this, and doing so mostly unconsciously already.", "id": "ilu9igv", "owner_tier": 0.3, "score": 0.19724770637614678}, {"content": "Nope. Your code reviewer thanks you\n\nRight? This Allan Melhor guy from Quora said that we should avoid adding \"this\", as it cleans up the code a little. https://www.quora.com/In-Java-when-should-I-use-this-propertyName-instead-of-propertyName-in-an-instantiated-objects-dynamic-method\n\nI started to question if I'm making my code too polluted by adding those things.\n\nWhen I moved on to my now current project the senior devs on it rejected my code review because I used `final` in method params and `this` when calling private methods and such. They still don't like it but \"oh well\". I think they're good. I think they are even recommended by Google Java Style.\n\nI would argue that things that increase maintainability are not pollutants. Verbose? Sure. But we are using Java after all :-)\n\nThe tradeoff between readability and explicitness is often not considered to be good in that case. Method parameters are usually not supposed to be mutated anyways, and it makes method signatures more difficult to read.\n\nJust set your IDE/Linter to flag parameter reassignment as an error. It can always be avoided by creating a new local. No need for `final` to clutter up parameter declarations.\n\nI don't understand where this verbosity fear is coming from. Recently even Java developers are acting like verbosity is synonym of bad code.\n\nThis was my thinking exactly, and the code reviewer(s) definitely appreciate it, as well as any testing/QA folks\n\nAdding `final` does not make method signatures more difficult to read. That's absurd.\n\n>Method parameters are usually not supposed to be mutated anyways,\n\nAnd that's why the language designers created `final`. It's there to force your intentions :).\n\nPeople are scared of using their keyboard to type a tiny bit more than they really have to. Ignore them and verbose away!\n\nBoilerplate distracts from reader from the logic of the code. Putting `this.` in front of each field name is no better than writing `/* string */` in front of each variable usage. Both help \"maintainability\" in the sense that they are so distracting that people won't even try to change your code. \n\n// Fun fact. I used to program in a language that actually did require you to specify the type of each variable or property each time you accessed it.", "id": "ilt1wbc", "owner_tier": 0.1, "score": 0.4862385320642202}, {"content": "Years ago I put this everywhere then I realized it made it almost as hard to read with self all over the place in Python. Now I just use common sense. A variable that doesn't change is a constant and it does deserve final. Any other time it mostly just looks cool.\n\nI just can't see how adding \"this\" in the variables can make the code hard to read. But maybe is because I haven't being exposed to cases where the keyword appear enough to the point of dominating the code?", "id": "iltlduf", "owner_tier": 0.1, "score": 0.08715596325688073}, {"content": "Not crazy, but it shouldn't matter. These things should be auto-enforced via formatters and Checkstyle. What matters more is your have a consistent style so there isn't \"your code\"; it's the team's code.\n\nAbsolutely true.\n\nI find it better for the team to set guidelines (like Google's Java Style Guidelines) and not to enforce every space, comma and bracket.\n\nThis way there is some room for personal preferences.\n\nGoogle introduced an auto-formatter and thus spaces, commas and brackets are decided by the formatter and additional comments are forbidden. There is some room for variation, but lots of it is 'the formatter decides'.\n\nThey follow a [rectangle rule](https://github.com/google/google-java-format/wiki/The-Rectangle-Rule), which is easy to follow, but can lead to ugly formatting due to excessive indentation in nested statements (which are common using protobuffers). The dart formatter was a lot nicer, and considered human friendly style instead of blindly following the rectangle rule.\n\nI am not talking about their formatter. Talking about this:\n\nhttps://google.github.io/styleguide/javaguide.html\n\nWe also follow the rectangle rule, but an extended one.  This complies:\n\n       a.b(new C(\n           d.toString()\n       ));\n\nBut this does not:\n\n       a.b(new C(\n           d.toString()));\n\nBasically treat every kind of bracket, not just curly ones, the same.\n\nThe number of unmatched opening brackets on a line must also always match the number used on the closing line, so this is not allowed:\n\n       a.b(new C(\n               d.toString()\n           )\n       );\n\nAnd the rule also extends to quotes, including the new multiline quote:\n\n       a.b(new C(\"\"\"\n           text\n       \"\"\"));\n\nOr:\n\n       a.b(new C(\n           \"\"\"\n              text\n           \"\"\"\n       ));\n\nNot allowed:\n\n       a.b(new C(\"\"\"\n               text\n           \"\"\"\n       ));", "id": "iltqpgq", "owner_tier": 0.7, "score": 0.09174311922018348}, {"content": "Fwiw (and I'm just sharing the thinking inside other companies), in my company's style guide we strongly discourage declaring local variables and parameters final.\n\nMostly because there is a wide lack of consistency when the practice is encouraged. When you read a block of code like the following, is `baz` not final? Or did the author simply forget the declaration?\n\n    final int foo = 0;\n    int baz = 1;\n\nYou'll need to read the rest of the code to know, and frankly it  is very rarely relevant to care (for the next reason).\n\nSecondly (and maybe more important) the Java language spec in Java 8 introduced _effectively final_ local variables:\n\nhttps://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4\n\n>Certain variables that are not declared final are instead considered effectively final:\n>\n>A local variable whose declarator has an initializer (\u00a714.4.2) is effectively final if all of the following are true:\n>\n>It is not declared final.\n>\n>It never occurs as the left hand side in an assignment expression (\u00a715.26). (Note that the local variable declarator containing the initializer is not an assignment expression.)\n>\n>It never occurs as the operand of a prefix or postfix increment or decrement operator (\u00a715.14, \u00a715.15).\n>\n>A local variable whose declarator lacks an initializer is effectively final if all of the following are true:\n>\n>It is not declared final.\n>\n>Whenever it occurs as the left hand side in an assignment expression, it is definitely unassigned and not definitely assigned before the assignment; that is, it is definitely unassigned and not definitely assigned after the right hand side of the assignment expression (\u00a716 (Definite Assignment)).\n>\n>It never occurs as the operand of a prefix or postfix increment or decrement operator.\n>\n>A method, constructor, lambda, or exception parameter (\u00a78.4.1, \u00a78.8.1, \u00a79.4, \u00a715.27.1, \u00a714.20) is treated, for the purpose of determining whether it is effectively final, as a local variable whose declarator has an initializer.\n>\n>If a variable is effectively final, adding the final modifier to its declaration will not introduce any compile-time errors. Conversely, a local variable or parameter that is declared final in a valid program becomes effectively final if the final modifier is removed\n\nSo the compiler no longer actually needs the explicit `final` declaration from the programmer.\n\nGiven the combination of these 2 considerations (possible inconsistency, and lack of need by the compiler) then we see declaring locals final (in a massively shared code base) as only having downsides.\n\nThat bring said, it's your code, so do as you please. But if others start to make contributions then it's important that consistency is enforced.", "id": "ilugz6w", "owner_tier": 0.5, "score": 0.04128440362385321}, {"content": "both of these can be enabled in the IDE of your taste and if you forget somehow, it automatically do that for you. I agree with you and do the same.\n\nYeah, I do use that on my IDE. Good to know that more people do that. \n\nI wish that final variables were the default so instead of having a keyword for immutable variables, we had a keyword to declare a variable as mutable since, at least from my experience, mutable variables are actually less frequent (to not say rare).\n\nYour ide should also change the color of \u201cthis\u201d fields vs variables and parameters.\n\nThat is I\u2019m rarely confused because field access/setting has a different color.", "id": "ilt7n6i", "owner_tier": 0.3, "score": 0.05963302747706422}, {"content": "Final makes the compiler do the work for you - that\u2019s good.  Why work harder than you have too.\n\nI personally like \u201cthis\u201d as it makes it obvious when I\u2019m using a meme er variable.\n\nI actually didn't know about the compiler thing. I will search more about it.\n\nFinal = compiler will yell at you if you change it.  If you know that to be the case you can let the computer auto check it for you.\n\nOh, I see. I thought it was something about optimization. But yeah, very good to have the compiler making sure that there's nothing trying to change what is not supposed to change.\n\n`final` constants are useful because it seems the compiler can inline the value in all usages.\n\n`final` variables and fields don't really help with optimization, as far as I know.\n\n`final` classes and methods are useful because the JVM does not have to look for an overridden method in the object being called. That reduces method call overhead. At runtime\\*, the JIT compiler can judge a method to be effectively final by analysing the class hierarchy. In C++, `final` is the default, and you have to annotate methods with `virtual` to make it possible to override them.\n\n\\*: Because of linking and class loading, in Java the full class hierarchy is rarely known at compile time.", "id": "iltqad7", "owner_tier": 0.5, "score": 0.050458715550458715}, {"content": "Yes, I think these are bad practices.\n\nYour editor knows these things. It can therefore tell you (for example, colour a variable differently if it is effectively final, render a field as bold, whatever you want), and this is strictly superior:\n\n* No mistakes. You can fail to mark a variable as final by accident. Your IDE won't do that.\n* Your style actively discourages refactors, because your refactor _also_ has to cover adjusting `final` and `this.` usage.\n* Your practice requires spending the brain space. You can't decide to simply not look at a `final` keyword. With IDE marking you can on the fly change settings and make the colouring for effectively finals just go away.\n\nIt's possible your IDE can't do it. In which case, spend your efforts writing a pull request so that it can, and muse about the fact nobody has cared enough yet.\n\nI agree. Just to show the problems with refactoring for `this` or how it actually causes a lot more work is the case of `wither`-like copy methods (lets ignore code generators like lombok... yes I know you're the author).\n\nLets say I have (shitty contrived example):\n\n\n    public record Point(int x, int y, int z) {\n\n         Point copy(int x) {\n             return new Point(x, y, z);\n         }\n\n         Point copy(int x, int y) {\n             return new Point(x, y, z);\n         }\n\n         Point copyUsingThis(int x) {\n             return new Point(x, this.y, this.z);\n         }\n\n         Point copyUsingThis(int x, int y) {\n             return new Point(x, y, this.z);\n         }\n    }\n\nNotice above without using `this` I can just copy 'n paste `return new Point(x, y, z)` constructor call in the `copy` method over and over again (sure that isn't ideal... yes I know code generators but for the sake of argument).\n\n\nAs for `final` the only place I use it is for places where I wish Java had expressions:\n\n    final int x;\n    if (something) {\n        x = 1;\n    }\n    else if () {\n        x = 2;\n    }\n    else {\n        x = 3;\n    }\n\n    final int y;\n    // old switch for old code bases\n    switch (something) {\n    case A:\n        y = 1;\n    case B:\n        y = 2; // compiler failure\n    default:\n        y = 3;\n    }\n\nObviously with the new `switch` expression I have been doing less of the above old habit.", "id": "ilufoym", "owner_tier": 0.7, "score": 0.027522935733944955}, {"content": "It's a noise which does not make code easier to read IMO. Java would be a better language with variables being final by default, but we've got what we've got.", "id": "ilu2vpx", "owner_tier": 0.3, "score": 0.013761467844036698}, {"content": "These two decisions seems fine to me.\n\nJust use the group convention where you work at.", "id": "iltfkol", "owner_tier": 0.3, "score": 0.009174311880733945}, {"content": "They make the code harder to read and provide minimal protection against bugs. Not worth the effort.", "id": "ilv4dxh", "owner_tier": 0.5, "score": 0.0045871559174311925}, {"content": "Avoiding naming collision leading to funny bugs on production is a good enough reason to use this.blah all over the place i think...", "id": "iltgv4l", "owner_tier": 0.3, "score": 0.009174311880733945}, {"content": "There are toolchains that can be used to enforce immutability and non-variable shadowing (and much much more important concepts) without spamming non-business logic words all over the codebase. You might think your code is easier to read now, but let time and bit rot take its course, and one fine day several months or years down the road when you need to urgently check on the implemented business logic 10 minutes ago, you might no longer appreciate the noise-to-signal ratio.\n\nOr you could inherit a legacy codebase where people have taken this kind of thing to stupid extremes that half the codebase is useless keywords.\n\nBut if the class is named after a business object, and the attribute is a feature of this object, by referring to this attribute as this.feature ain't I just saying \"the feature of this business object\", which is perfectly understandable from the business perspective?\n\nThis is fine if such checks are indeed enforced on all code and you can then really work with the assumption that everything is effectively final unless annotated (I guess? How to tell the checker that something is supposed to be mutated?) Otherwise, there is no other way to tell from a glance that something will never ever be mutated, except by analyzing usages.\n\nImplying that there is an attribute with the same name that is being referred to in the same context, which in turn raises even more questions. If there is not, it's just noise, assuming of course that the team has a similar understanding - all the teams that I've worked with before have had that same understanding and I haven't actually met anyone that needed the \"this\" keyword to say that the attribute is a feature of the business object they're looking at. Outside of constructors, the usage of \"this\" usually draws scrutiny because of what it implies about the rest of the code.", "id": "iltzh2o", "owner_tier": 0.3, "score": 0.032110091697247704}, {"content": "Short answer: Don't.\n\nIn both case, it's unneeded code that makes code less readable and more difficult to maintain.\n\nAbout `final`: The compiler does it for you. Java has the concept of effectively final variable. A lot of developer will also read the `final` keyword as \"immutable\" which is not the case: you can have a `final ArrayList` that is mutable. In 26 years of Java, I never saw a benchmark showing that it's faster too.\n\nAbout `this`: The IDE (at least mine) is showing fields in a different color than variables. So it just makes more code to write and to read.\n\nNote that one of the main advantages of Java is readability of the code, so it's important when writing code to use readable variable name, not too long methods and *avoid unneeded code*.", "id": "ilureat", "owner_tier": 0.1, "score": 0.0045871559174311925}, {"content": " No.  You are not crazy.  I do the same.  I rarely see others do the same.  It doesn't mean it's bad.  \n\n\nIf you go one step deeper and use thoughtful Constructors/Builders (or Records) you can really control the expectation on data.  \n\n\nFundamentally, if the system allows you to do something stupid, it's less than ideal.  If an attribute should not be mutated, then it needs to be protected.    \n\n\nI had a great lesson with my intern over the summer about this very thing.  He had a POJO that stored some data, and stored a variable on whether something was \"processed\".  When he was done processing he used a Setter to set \"processed\" to true.  I asked, \"what happens if something came after your code and set processed to false?\"  I recommended that he perhaps make the processed immutable upon construction and basically copy-construct the attributes and hard-set \"processed\" so that it cannot be changed once set.  We discussed the tradeoffs, that this approach takes more memory etc, but that it brings absolute safety.  No following code can mutate state of \"processed\" and that \"processed\" should only be set once.", "id": "ilv7hof", "owner_tier": 0.7, "score": 0.0045871559174311925}, {"content": "The code should be readable without these.", "id": "ilu518g", "owner_tier": 0.5, "score": 0.0045871559174311925}, {"content": "I get it.  But they're both just extra garbage on my screen when I go back to read\n\nI'd prefer you reduce each variable's \"scope\" to a bare minimum (preferably, I should never have to scroll up or down to see where a variable is declared and every time it's used).\n\nIn that way I can confirm it's effectively `final` or a field on the class, or whatever", "id": "ilv5bcz", "owner_tier": 0.5, "score": -4.5871559354244454e-11}], "link": "https://www.reddit.com/r/java/comments/wxu2hr/i_declare_as_final_every_single_variable_whose/", "question": {"content": "I think that those things make the code easier to read. Am I crazy for thinking like that?", "id": "wxu2hr", "title": "I declare as \"final\" every single variable whose value doesn't change. I also use \"this\" every time that I'm referring to an attribute, even when there's no ambiguity in not using it", "traffic_rate": 55.9755525787006}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "These sorts of axiomatic \"considered harmful\" type posts always get on my nerves. Inheritance is just a tool, like any other - one with ample opportunities for footgun, but a tool nonetheless. It has and serves its purpose, and should not be overused for things outside its purpose, just the same as composition or GOTO. If it's not a tool you personally write good code with, by all means avoid it, but get off your high horse about it.\n\n>But even this is not enough, because `new Ellipse(1,1)` is a circle but is not a member of the `Circle` class. The only solution is to forbid this value somehow\n\nThis is a perfect example of begging the question. You've invented an issue by engineering a situation in which it appears - but this is not an issue inheritance claims to solve, nor one that particularly needs solving. Certainly, the Ellipse class can represent a circle by value, but that's not a problem: the point of the Circle subtype is to guarantee that it is circular, not to guarantee no other Ellipse is. The proper way to make that distinction is, in a strange case where you've been passed an Ellipse and need to know if it's circular, to check its values and cast it to Circle if appropriate.\n\n>Composition offers better encapsulation. For example, suppose we have a `List` class with `add` and `addAll` methods, and we want a \"counting list\" that tracks the total number of objects added.\n\nThis is a conceptual misuse of composition, because it's using a has-a relationship as an implementation detail to represent a conceptual is-a relationship. The key issue here is with the drawbacks of side effects, not actually with inheritance - `CountingList` itself is a problematic implementation that should be replaced, as the issue really stems from non-idempotent side effects. An implementation like this, while potentially less efficient, bypasses the issue you've posited by ensuring that it doesn't matter whether `super.addAll` calls `CountingList::add` or not, since the result is the same in the end.\n\n    class CountingList extends List {\n      int cachedLength;\n     \n      void add(Object o) {\n        super.add(o);\n        this.cachedLength = this.length();\n      }\n     \n      void addAll(Object[] os) {\n        super.addAll(os);\n        this.cachedLength = this.length();\n      }\n    }\n\n(Note that the efficiency could also be highly improved by making `cachedLength` a getter which checks if a `dirty` field is set to determine whether to recalculate and cache the length again, but I'm not typing that on a phone.)\n\n>There is one remaining use case of inheritance, where you have overloaded methods implementing an interface. For example something like the following:\n>\n>But here we can just use lambdas.\n\nYou can only directly use lambdas in this situation because your example is contrived to have only one method with which the implementation needs to be concerned. This is certainly a case which would be ideal to replace with lambdas, but real life use cases are often not this simple; when associated state or additional methods need to be bundled along with said lambdas, a structure like this becomes much more reasonable than you've made it appear.\n\n---\n\nI understand where you're coming from. Inheritance is often a clumsy tool, and drastically overused. But you don't need to bring up contrived examples and fallacious arguments to make that point - that only becomes necessary when you start trying to claim that inheritance is always bad and can never be the right tool. Maybe back it down a few steps, and advocate for conscientious usage of inheritance instead of careless usage, rather than try to advocate for never using it even when it's the right tool for the job.\n\nWoah...you typed that on a phone? Respect.\n\n>These sorts of axiomatic \"considered harmful\" type posts always get on my nerves. Inheritance is just a tool, like any other - one with ample opportunities for footgun, but a tool nonetheless.\n\nOK, but, counterargument.\n\nMany people nowadays would (sorry!) Consider Harmful the idea of a Swiss Army Language that contains all the tools. They would prefer a toolset which is small and orthogonal. At this point we need to consider stuff like this. If this was another subreddit then your remark:\n\n>If it's not a tool you personally write good code with, by all means avoid it, but get off your high horse about it.\n\n... would make perfect sense, but when we're talking about the design of programming languages then the question of whether inheritance is, on balance, harmful, becomes more than a personal choice but one we have to make for our end-users.\n\n---\n\nAlso, a word in favor of dogmatism. I think that dogmatism is a good thing in any creative field, whether it's the design of programming languages or the writing of poetry. Yes, it can lead to quarrels --- it *will* lead to quarrels. *But*, do you suppose anyone ever wrote good poetry (for example) without having strong views on how poetry should be written? The dogmatism is part of the drive. Someone who looks at the vast array of programming languages and their features and says \"I guess they're all good and they all have their place\" may be very broad-minded but they have little chance of producing a better one.\n\n[deleted]\n\n> This is a perfect example of begging the question. \n\nActually this is an example of reductio ad absurdum. I assumed inheritance was the answer, and obtained a nonsensical value that was a circle yet not a `Circle`. You can't cast this value to a `Circle` because it is not an instance of the `Circle` class.\n\n> This is a conceptual misuse of composition, because it's using a has-a relationship as an implementation detail to represent a conceptual is-a relationship.\n\nWell, types represent is-a. Although the relationship is more like \"is\" because types are adjectives and not nouns. For example we could define `ListLike a = { add : Object -> a -> a, addAll : Object[] -> a -> a }` and then both `List` and `CountingList` are `ListLike`.\n\n> cachedLength\n\nI did mention that. I also said that that approach doesn't work if you have non-erasable side effects like logging or printing out messages. If `add` prints `Object added!` there is no way to ensure that `addAll` does not print `Object added!`, other than by inspecting the implementation of `List.addAll` to ensure it does not call `add`, or by using composition instead of inheritance.\n\n> when associated state or additional methods need to be bundled along with said lambdas, a structure like this becomes much more reasonable\n\nIf you have both state and methods, then you get encapsulation issues like with `CountingList`. Inheritance only seems to be usable when it is pure data (CSS-style property cascade) or pure type signature (interfaces / traits).\n\n> conscientious usage of inheritance instead of careless usage\n\nI don't think inheritance is a general-purpose tool, but providing it in a library for legacy compatibility will probably always be necessary. I made this post to see if anyone wanted to argue for inheritance and the answer is no, nobody cares that much.\n\n> contrived examples and fallacious arguments\n\nMy experience has been that whenever someone starts bringing up style nits instead of actual counterpoints it is because they have nothing useful to say and they are just blustering. It is only [level 2](http://www.paulgraham.com/disagree.html) in the argument hierarchy, out of a maximum of 6.\n\nJust curious, have you ever seen a good example of inheritance in an object-oriented programming language?\n\nAs of yet, I have yet to see one but I'm sure that's just because I'm inexperienced. \ud83d\ude1b\n\nI see where you're coming from, and I don't disagree on some of the principles. To be clear, I'm not by any means advocating inheritance for *every language* - far from it, I think that OOP in general is less than ideal as a paradigm to explore in new languages, let alone its most footgunny features. More languages pushing into underexplored design spaces is a great thing!\n\nOn the other hand, though, what I don't agree with is the impulse to push that decision onto others, especially by means of flawed arguments born of misunderstandings. Choosing not to include inheritance in your own language is perfectly fine regardless of reasoning, and even arguably advisable, but the tone of \"this is bad and no one should use it\" goes too far - the same core argument can be made without the polarizing approach. \"Consider this alternative to inheritance\" is a lot less problematic than \"an argument against inheritance\", for example. Especially when combined with contrived examples and fallacious arguments that also undermine the point being made, there's certainly reason to push back on OP's statements a bit and point out where they may have missed the boat on why inheritance exists and why it can be useful - but the pushback only exists insofar as their opinions are presented as advice backed up by evidence, and does not extend to their personal choices about the design of their own language.\n\nTLDR, I'm not advocating every feature in every language, but rather a well informed view of the benefits of any feature - pointing out the issues in OP's assessment of inheritance is not to disagree with their decision to exclude it, only that their assessment and presentation as advice are flawed.\n\nGOTO is a bit of a tricky subject because it's such a *massive* footgun when unrestricted. I personally think that unlabeled GOTO (i.e. classic Assembly style, as contrasted by things like `break` or `continue` or even `goto LocallyScopedLabel`) is liable to cause more problems than it's worth, but labeled GOTO and its derivatives are underrated and overstigmatized by association with its unlabeled cousin - and both kinds are overstigmatized period, as is any tool that becomes the face of this month's \"considered harmful\" trend.\n\n>Actually this is an example of reductio ad absurdum. I assumed inheritance was the answer, and obtained a nonsensical value that was a circle yet not a `Circle`.\n\nAgain: this is not a problem inheritance seeks to solve. `Circle` guarantees that it is a circle, not that no other `Ellipse` can be - that's outside the scope of the tool. If you need that functionality, *use a tool that's designed for it*.\n\n>Well, types represent is-a.\n\nYes, they do. And an implementation of `CountingList` which uses composition is a list, but its type does not represent that without additional finegling, because you've used a has-a relationship to model something that's conceptually an is-a relationship.\n\n>For example we could define `ListLike a = { add : Object -> a -> a, addAll : Object[] -> a -> a }` and then both `List` and `CountingList` are `ListLike`.\n\nThis can be represented as a trait or interface, which funnily enough is a type of inheritance. The only difference here is that the relationship is implicit, which has both benefits and drawbacks.\n\n>I also said that that approach doesn't work if you have non-erasable side effects like logging or printing out messages.\n\nWhich is a problem with your architecture design, not with the use of inheritance itself.\n\n>If you have both state and methods, then you get encapsulation issues like with `CountingList`.\n\nI'm not sure what you mean by this. What specific issues?\n\n>I made this post to see if anyone wanted to argue for inheritance and the answer is no, nobody cares that much.\n\nThen what do you consider my comment?\n\n>My experience has been that whenever someone starts bringing up style nits instead of actual counterpoints it is because they have nothing useful to say and they are just blustering.\n\n\"Your examples are contrived to suit your point and don't represent realistic situations\" is not a style nit. My experience has been that whenever someone starts whinging about \"nitpicking\", it's usually because they don't actually know how to support their arguments in the face of someone pointing out the logical holes in it.\n\n\"Good\" is a bit subjective, but I find that inheritance is often the right tool to use when modeling things like config file formats with recursive schemas (such as JSON), where you need to have a number of disparate types that can be easily accessed in similar terms.\n\nFor example, my own Kotlin JSON library uses [a single abstract base class](https://github.com/KatrinaKitten/haven-json/blob/master/src/main/kotlin/com/tripl3dogdare/havenjson/JsonValue.kt) to represent any JSON value, with a generic to allow type-safe access of the underlying value. Then [a number of child classes](https://github.com/KatrinaKitten/haven-json/blob/master/src/main/kotlin/com/tripl3dogdare/havenjson/JsonTypes.kt) override specific pieces of behavior to handle type-specific things (notice that the abstract implementation of `get` simply returns `JsonNull`, where the implementation on `JsonArray` implements it to access by index, and `JsonObject` by string key), and static factory methods on the base type allow for convenient type-agnostic construction but aren't strictly necessary.\n\nThe real glue of this strategy is `JsonNull`, which simply returns itself for any operation other than accessing its underlying value or converting it to string for serialization. This makes it trivial to safely access values deeply nested in any possible JSON structure, as accessing an invalid path simply results in `null` when unwrapped to the underlying value (which Kotlin already has tools to handle well). It's essentially a domain-specific equivalent of Kotlin's `?.` null-safe access operator.\n\nNow, would a similar strategy be possible without inheritance? Sure, there are ways to replicate similar behavior with union types and other such tools, but it's not quite as convenient in reality, and inheritance doesn't present any of the problems here that are normally complained about by its detractors - it's a small self-contained system so there's no \"over-coupling\" possible, there's no instances where the diamond problem (multiple inheritance issues) becomes relevant, etc.\n\nAll the time. \n\nIt depends what you mean by inheritance. \n\nIf you mean Java style inheritance where you basically have two instances at once then no. That\u2019s a nightmare. \n\nOther languages do it much better (like Eiffel for example or scala)\n\nEven in Java if you use traits instead of classes to define your hierarchy you are much better off.", "id": "izp3glf", "owner_tier": 0.5, "score": 0.9999999999166668}, {"content": "Do you have an argument that inheritance isn't compatible with subtyping which does not use `instanceof`/reflection?\n\nIn your encoding you fail to capture the crucial aspect that is open recursion: methods get the \"current object\" as an argument and can call other methods of the same object. I think your refinement type encoding is too rigid in that it won't allow open recursion with inheritance and also too weak in that you can fail at runtime if the method is undefined.\n\nA more natural approach to typing objects is structural, as in [OCaml](https://v2.ocaml.org/manual/objectexamples.html). In the type system you want information on what methods do you have, not some parent-chasing rigid encoding of an inheritance structure.\n\nYeah, that example is a good argument against `instanceof` though, and also for being careful about using logical NOT in your program properties, since it can make them non-monotonic\n\nMore recently I have found [the paper](https://dl.acm.org/doi/abs/10.1145/96709.96721) \"Inheritance is not subtyping\". This has an example of an equality method: the parent compares on i, the child compares on i and b. Inferring open record types, records with i and b are a subtype of records with i. So by contravariance, the parent eq method's type is a subtype of the child's, i.e. the parent method can be typechecked as applying to records with i and b. This contradicts the usual flow of OO subtyping where the child is a subtype of the parent, hence we must conclude there is no subtyping relationship.\n\nNow in practice languages like Java *impose* the subtyping relationship on inheritance, e.g. if you define an equal(Child other) method in the child it will not override the parent's equal (Parent other) method at all, so inheritance that would break subtyping is forbidden. This does turn out to be sound ([paper](https://cs.rice.edu/~javaplt/papers/Inheritance.pdf)) but I think it's pretty confusing to have situations where using the same name doesn't actually override a method.\n\n> Do you have an argument that inheritance isn't compatible with subtyping which does not use instanceof/reflection?\n\nWell, you can emulate `instanceof`, e.g. B has a method `isB() { return true; }` and A which extends B overrides it to `isB() { return false; }`. Of course there are also situations where inheritance does give a true subtyping relationship, e.g. pure immutable data or interfaces that have no implementation inheritance.\n\n> In your encoding you fail to capture the crucial aspect that is open recursion: methods get the \"current object\" as an argument and can call other methods of the same object.\n\nIf you need the current object you can just pass it in args. I left it out because I didn't want to complicate the implementation.\n\n> I think your refinement type encoding is too rigid in that it won't allow open recursion with inheritance and also too weak in that you can fail at runtime if the method is undefined.\n\nThere are some details of statically type-checked dynamic dispatch that I glossed over by making the dispatch dynamically typed, like overload resolution. But the failing part you can avoid by using refinement types to say that exceptions cannot be returned. The proofs may be nontrivial but that's a typical issue that crops up with refinement types.", "id": "izoyme1", "owner_tier": 0.3, "score": 0.37499999991666666}, {"content": "> Suppose A extends B. Then the predicate `\\x -> not (x instanceof A)` is satisfied by B but not by A. So by LSP, A is not substitutable for B.\n\nThat's why using `instanceof` is bad practice - it breaks encapsulation. Do you want to act on something depending on its type, rather than having it act on itself? That's a reasonable thought, but it simply proves that extending types should be more ergonomic.\n(It's also reasonable to claim that the visitor pattern should be avoided - however, it can't at all be replaced by subsitution. ML-style pattern matching and algebraic datatypes do far better on this front.)\n\n> Composition can directly replace inheritance in at least 22% of real-world cases.\n\nAnd what about the other 78%?\n\nThis also neglects the third class of inheritance, which is simply intended for code reuse - all of the proposed solutions lead to O(M*N) implementations for M methods on N related classes.", "id": "izpkc2t", "owner_tier": 0.1, "score": 0.19999999991666667}, {"content": "Kinda cool but also people generally agree that inheritance is bad. GoF talks about composition over inheritance, Go doesn't have it, and yeah James Gosling who's basically the king of modern OOP says it's bad.\n\nKinda feels like you're beating a dead horse. I guess it's still used a lot, but an axiomatic argument like this probably isn't very compelling to that demographic\n\nGo kind of does have it though. You can put a struct inside of a struct and it behaves just like inheritance.\n\nI super agree with this one. One thing that is odd is that I haven't actually seen a reduction in the usage of inheritance in any code base I've ever seen, whether it was new or old.\n\nI wonder why so many people are not concerned that it usually is a suboptimal tool to use in normal situations (not all but many).\n\nNo, it behaves *just like* composition, 'cos of being composition.\n\nNo it behaves exactly like inheritance. You don't even have to specify the dispatch.", "id": "izow2mg", "owner_tier": 0.3, "score": 0.23333333325}, {"content": "Meanwhile within like a month of Rust 1.0, many Servo devs specifically requested inheritance. It helps for some things, like implementing any GUI framework.\n\nAnd yet Rust never added it in the last 7 years and is still fine with it. Meanwhile people are exploring new ways to do GUIs in Rust without inheritance and they seem to be successful in exploring new designs.\n\nThis does not prove anything.\n\nWhen all you have is a hammer, everything looks like a nail.\n\nThe Servo developers were used to solving their problems with inheritance, so they had to unlearn that and learn new ways to figure out solutions with Rust. _Of course_ they would have been more productive, initially, using what they already knew... but that's an argument for conservatism, not any particular feature.\n\nSyntactical code reduction? Probably just need to use a Rust macro. Casey Muratori did a talk on semantic compression which is essentially what I think most people use inheritance for in aggregate as far as I've seen.", "id": "izp3r89", "owner_tier": 0.7, "score": 0.14999999991666665}, {"content": "This is controversial?\n\nComposition over inheritance seems generally accepted. But removing inheritance entirely is not, e.g. Nim has inheritance as an opt in feature. This post argues that we can remove it from the language proper and provide it as a library.", "id": "izowxgd", "owner_tier": 0.7, "score": 0.10833333325}, {"content": "First of all java, C#, C++, ruby, python, php etc have inheritance and the vast majority of world's software is written in them so clearly they work fine and make billions of dollars for companies all over the world.\n\nSecondly composition means you need to write all the methods again possibly dispatching and that's an annoyance.\n\nIn the real world we do deal with objects with common attributes and behaviors so OO gives us a handy tool to model real world concepts in an elegant way.  Your mother is a person and so is your friend. There is no reason they shouldn't inherit from a person object.\n\nOK but:\n\n(1) Maybe that's because OO is good but inheritance is a misconceived part of it that should have been something else. (E.g. traits.)\n\n(2) Is it a coincidence that newer languages aim to replace or abolish inheritance, like Rust and Go? Those languages also have billions of dollars riding on them. And they were produced by big companies with eyes to profit, not by cranks with theories.\n\n(3) At the time when \"Goto considered harmful\" was written, you could have defended `goto` the same way --- the majority of the world's software is written with it, it makes billions of dollars for companies all over the world.\n\nFirst of all most languages and most code uses dependency injection heavily, which is composition not inheritance. Inheritance is often used for reflection/codegen but that is benign. Genuine human usage of inheritance is few and far between, and codebases using it are a nightmare to extend (I've had to deal with it). I'd say that the impact of inheritance is close to zero for the library authors (they could just as well use composition, if the language made it comfortable to use) and a big negative for client code using those libraries (inheriting from code you don't control is a nightmare).\n\nSecondly composition does not mean you have to write them by hand. That's entirely up to the language. Though I do believe writing methods in one place is better as it improves readability (jumping around the superclasses to find which methods and attributes the class actually has, and where they are defined, is unnecessary work).\n\nThird, no, this textbook \"a cat is an animal\" idiocy is completely unrelated to programming in practice. When programming, you don't care what relationships pieces of bits and code have: you care only which method gets called on which struct in memory at runtime to get the right result. Deep inheritance hierarchies are a detriment to that. As someone once said, taxonomy is tge lowest and least useful form of science. It's absolutely useless to decide whether Foo inherits from Bar, or Bar from Foo, or they both inherit from Baz: either way you end up with brittle inextensible unmaintainable code.\n\n>(1) Maybe that's because OO is good but inheritance is a misconceived part of it that should have been something else. (E.g. traits.)\n\nIt's been proven to work. You can shoulda all you want the fact is that it works.\n\n>(2) Is it a coincidence that newer languages aim to replace or abolish inheritance, like Rust and Go? \n\nNo. Programming has always been about fashion. That's what's fashionable now. It will change.\n\n>And they were produced by big companies with eyes to profit, not by cranks with theories.\n\nSo was react, dart, etc. \n\n>(3) At the time when \"Goto considered harmful\" was written, you could have defended goto the same way --- the majority of the world's software is written with it, it makes billions of dollars for companies all over the world.\n\nBut that wasn't true. \n\nAside from that all languages did was hide the goto behind some other construct. When you compile the code it's all full of gotos.\n\n>First of all most languages and most code uses dependency injection heavily, which is composition not inheritance.\n\nWho cares. The point is that in all of those languages you are creating objects and inheriting from them and using the standard library which is based on inheritance.\n\nThe fact that you have other tools at your disposal doesn't mean you don't use OOP code. In fact you inject OOP classes .\n\n>Secondly composition does not mean you have to write them by hand. \n\nIt doesn't? Explain.\n\n>Third, no, this textbook \"a cat is an animal\" idiocy is completely unrelated to programming in practice.\n\nIn practice you deal with mutable objects in real life. Period. End of sentence.\n\n> either way you end up with brittle inextensible unmaintainable code.\n\nBillions of lines of code in the languages I mentioned says otherwise but I guess you have to hold on to your zealotry any way you can. If that means ignoring 99% of all code written in the world then so be it I guess.\n\n>It's been proven to work. You can shoulda all you want the fact is that it works.\n\nAh, yes, proof by confident assertion.\n\n>No. Programming has always been about fashion. That's what's fashionable now. It will change.\n\nOK, but you've gone from pointing out how inheritance used to be popular back in the 1990s and therefore must be good to saying that if inheritance is no longer popular that's just a quirk of fashion.\n\n>But that wasn't true.\n\n>Aside from that all languages did was hide the goto behind some other construct. When you compile the code it's all full of gotos.\n\nSure. But why did you write that? This is r/ProgrammingLanguages. We all know that. As a very loose description, you might say that this whole subreddit is a discussion of how to \"hide the goto\", how to write in something other than machine code.\n\n> Ah, yes, proof by confident assertion.\n\nAs I said well over 90% of all code in the world is written in object oriented languages.\n\n>OK, but you've gone from pointing out how inheritance used to be popular back in the 1990s and therefore must be good to saying that if inheritance is no longer popular that's just a quirk of fashion\n\nIt's still wildly popular. See above.\n\n>Sure. But why did you write that?\n\nTo point out how foolish your statement was.\n\n\\>As I said well over 90% of all code in the world is written in object oriented languages.\n\nAgain let me remind you that the issue isn't OO but inheritance specifically.\n\n(Also, everyone uses non-decimal time. That's not proof that it's a good idea but rather proof that some technical debt is unfixable.)\n\n\\>It's still wildly popular. See above.\n\nNo, *OO* is still popular. *Inheritance* is not \"wildly popular\". We're now at the point where books on OO tell you to avoid it, and where people designing new languages omit it.\n\n\\>To point out how foolish your statement was.\n\nThen you failed.\n\n>Again let me remind you that the issue isn't OO but inheritance specifically.\n\n\n\nAll of that code uses classes that inherit from other classes.\n\nIf as you say inheritance is dangerous that means 90% of the software being used today is dangerous and unmaintainable and crashing constantly.\n\nSorry but that's just an insane claim from an unthinking zealot.\n\n>No, OO is still popular. Inheritance is not \"wildly popular\".\n\nIt literally is. Go look at any object in the .NET  or Java standard library.\n\n>Then you failed.\n\nI showed that you are an unthinking zealot who can't see past their rigidly held ideology. A fundamentalist.  The taliban of developers!\n\n>Sorry but that's just an insane claim from an unthinking zealot.\n\nAnd one that appears in your post but not mine.\n\nBack in the real world, to suggest that something (for example, the goto statement) is a misfeature is not in fact to say that software developed in languages with that feature \"crashes constantly\". Dijkstra did not write a paper called \"Goto considered as the reason why all software written in C, Fortran, and Cobol crashes constantly\".\n\n>I showed that you are an unthinking zealot who can't see past their rigidly held ideology. A fundamentalist. The taliban of developers!\n\nYour fantasies about me are amusing but inaccurate.", "id": "izpau52", "owner_tier": 0.7, "score": 0.15833333324999999}, {"content": "\nHi Mathnerd,\n\nNot sure if coincidence but this also came up as a subject on Coffee Compiler Club today. And you've clearly put some effort into your post and been thinking about this - let me try and give you as good a reply as I can.\n\nI think its sound advice to \"think twice\" about adding any language feature, but to also air some caution to the alternatives you've suggested -\n\nAs engineers, we often look too deeply at the similarities of ideas. While the differences of ideas is where their true value lies.\n\nI think a good starting point is mentioning that Inheritance comes in a few combinations.\n\nPublic/Private Inheritance - I believe the correct name is Open/Close inheritance, but searching for that will return the Open-Closed principle. Private Inheritance means a subclass can only access methods of the superclass.\n\nStatic/Dynamic Inheritance - Dynamic inheritance is what Smalltalk has and what Self took and made into prototype inheritance.\n\nAnd the roots of inheritance - Alan Kay has written about inheritance and speaks of two things.\n\n[\"Differential Programming\"](https://qr.ae/prTRmM), the idea of a tool that allows engineers to construct something that \"is like this other thing, but with slight differences\".\n\nAnd he mentions the need for a [\"Mathematical binding\"](https://qr.ae/prTRDr) to this concept to stop people making a mess.\n\nThe where, when, and if you should use differential programming really is subjective and has trade-offs, pro's and con's just like any language feature.\n\n**Circle-Ellipse Problem**\n\nIMHO, where implementations of inheritance went wrong is with the \"Mathematical binding\". [\"A behavioural Notion of Subtyping\" By Barbara Liskov](https://dl.acm.org/doi/10.1145/197320.197383) is a wonderful paper that outlines LSP.\n\nThe root of the problems is that we've tried to combine her behavioural typing with our older typing strategies (nominal, structural etc) and our old notions of what a type is.\n\nSummary From Wikipedia (But also in the paper linked above)\n\n    Subtype Requirement: Let O(x) be a property provable about objects x of type T. Then O(y) should be true for objects y of type S where S is a subtype of T.\n    That is, if S subtypes T, what holds for T-objects holds for S-objects. In the same paper, Liskov and Wing detailed their notion of behavioural subtyping in an extension of Hoare logic, which bears a certain resemblance to Bertrand Meyer's design by contract in that it considers the interaction of subtyping with preconditions, postconditions and invariants.\n\nProperties here are invariants, preconditions and postconditions - e.g. *Value Assertions*, while Static Typing is on *variables*\n\nThe Circle-Ellipse problem arises from trying to reconcile a static type system with behavioural typing.\n\nAs the rest of the LSP paper defines, invariants are inherited into the subclass. So it is inevitable that some assertions are going to be added to those new subclasses that are not present in the superclass. And the range of values a given subclass can hold will be smaller than the superclass.\n\nSo here is the Circle-Ellipse again\n\n    class Ellipse {\n      int width, height;\n      func setWidth(w) {...}\n      func setHeight(h) {...}\n      func area() { return pi * (w/2) * (h/2); } \n      func circumference() {\n        let a = (w/2);\n        let b = (h/2);\n        let h = (a - b)^2 / (a + b)^2\n        return pi * (a + b) * ( 1 + (3 * h) / 10 + sqrt(4 - 3 * h));\n      }\n      func bar() { return 42; }\n    }\n    \n    class Circle: Ellipse {\n      invariant(width == height);\n      override func circumference() {\n        return 2*pi*(w/2);\n      }\n      func bar() { Throw(\"This can never happen on a Circle\"); }\n    }\n\nNow we understand that LSP/Behavioural types are value oriented, the moment a type becomes present is in the execution and situation of that Object.\n\nE.g. 1 No invariance violations, always correct\n\n    func foo(Ellipse a) {\n      return a.circumference();\n    }\n\nE.g. 2 Sometimes correct - there *is* a case were the below works, and that's if Width and Height were already 10.\n\n    func bar(Ellipse a) {\n      a.setWidth(10);\n      return a.area();\n    }\n\nE.g. 3 Will always fail if given a Circle.\n\n    func baz(Ellipse a) {\n      return a.foo();\n    }\n\nIf LSP is to gain traction, we need to improve Model checking to get at these types and give us the feedback we're used to.\n\nSoz, already quite long. Hope its of some use!\n\nKind Regards, M \u270c\n\nThat was him on Coffee Compiler Club making that argument \ud83e\udd23", "id": "izpxvn7", "owner_tier": 0.3, "score": 0.08333333324999999}, {"content": "> but here we can just use lambdas\n\nYes and no. Technically, you can replace any interface parameter with a set of closures. But the interface has more semantics: it states that these functions share some mutual state. That's the intention. When someone passes a bunch of closures that reference the same state, I'd get rather sceptical in comparison. Sure, you can force all of those lambdas to work over the same generic state monad, or pass and return the same state type. But at that point it's just confusing for anyone but the most academic programmers compared to a simple interface.\n\nBut yeah, in my experience, the majority of interface parameters can just be replaced with lambdas without any big downsides. But there are rare cases where you want the explicit notion of an interface, even if just for clarity.", "id": "izsatbk", "owner_tier": 0.7, "score": 0.06666666658333334}, {"content": "In my experience, inheritance is terrible but not for those reasons. It's terrible because:\n\n- code coupling: you depend on one or more pieces of code, often not controlled by you, which can break your code in weird ways with just a version bump\n\n- the `private` keyword: if the authors of the superclass used it, inheriting from them becomes a nightmare (`private` should be replaced with `protected` in all cases) \n\n- concrete classes in method types: if a superclass's method requires or returns a concrete type rather than an interface, good luck substituting with another class. Now you need to inherit from another class too (snowball effect) \n\n- constructors that do too much: even if all the class's methods are public or protected, there still may be a lump of non-overridable code in the constructor of the superclass. This is recognized as bad style, but I've seen it and had to dance around it with useless dummy code\n\n- adding to the \"concrete classes\" problem, you cannot override a method to return a subclass of what the super's method returns, even though that would be totally type-safe. Some smart languages like Newspeak don't have this problem, but the mainstream languages do. \n\nThe best solution I know of is Golang's type embedding. It's composition, but it's as concise as inheritance with none of its problems.", "id": "izrg6mb", "owner_tier": 0.3, "score": 0.05833333325}, {"content": "Allan, my fundamental argument for inheritance is simple, and not religious: It's nice to be able to re-use the large portion of one existing design in the creation of some new and different design.\n\nInheritance is one way in which this is achieved, and has proven useful over the years for this purpose; that is not to argue that the concept has no faults, but rather to state that it has use (it has _value_). Were we to discover a new way of doing this, let's call it \"_DefinitelyNotInheritanceButGreatReuseWithDeltas_\", and it had none of the downsides of inheritance, then we would all quickly switch to it, right?\n\nSo your mission is to figure out what DefinitelyNotInheritanceButGreatReuseWithDeltas (hereafter DNIBGRWD) actually is, and how it avoids some of the problems that have plagued languages that relied heavily on inheritance. I will enjoy seeing what you come up with.\n\nAlso, I'm curious as to the \"this could just be done in a library\" line of thought. IIRC, you're working on a replacement for the C language, so your requirements will likely match the static rigidity of that vein of languages. What would such a library look like, and how would it be used?\n\nLastly, languages have rules, and to assume that all implementations of the concept of \"inheritance\" will look exactly like whatever-your-favorite-whipping-boy of a language is (maybe Java?) is a poor start to a thought exercise. Step back and ask yourself what exactly it is about the concept of inheritance that you so viscerally dislike: Is it too many rules? Not enough rules? The wrong rules? The idea itself?", "id": "izsrkjx", "owner_tier": 0.5, "score": 0.05833333325}, {"content": "> Then the predicate \\x -> not (x instanceof A) is satisfied by B but not by A. So by LSP, A is not substitutable for B.\n\nYou could avoid that by just not having `instanceof` -- in fact, it's common to use c++ that way with `-fno-rtti` that disables `dynamic_cast`.\n\nAnd more importantly, that's not actually an argument against *inheritance*, because it also applies to interfaces.  Instead, it's an argument for [*parametricity*](https://en.wikipedia.org/wiki/Parametricity) -- anything where you can behave differently based on something not part of the type signature.", "id": "izvpgow", "owner_tier": 0.3, "score": 0.05833333325}, {"content": "**Is not \"one size fits all\".**\n\nUseful for some stuff, overused for others.", "id": "izq1z83", "owner_tier": 0.7, "score": 0.04999999991666667}, {"content": "Wait, is composition strictly speaking only about has-a relationships?\n\nI could have sworn I've heard at least some people talking about composition as being something like using (multiple) inheritance from interfaces instead of classes. Is that not correct?\n\nBut I guess what really is the distinction between a class that has members of type A B and C, and a class that implements interfaces A B and C? I feel like those are basically isomorphic.\n\nYes, composition is has-a; interfaces/traits are really a form of inheritance, just one that's a lot less rigid and bypasses a lot of the issues strict inheritance can cause if used carelessly. \n\nSome people use composition to model is-a relationships in order to avoid inheritance, but personally I think it's fundamentally a conceptual mismatch, since in reality you're creating a has-a relationship and pretending it's an is-a relationship (which loses out on the primary benefits of being an is-a relationship, in the process of trying to avoid the accompanying footguns).\n\nThe term \"composition\" unfortunately has several meanings, and some of those meanings conflict.", "id": "izr5dg6", "owner_tier": 0.3, "score": 0.07499999991666666}, {"content": ">Inheritance is often confused with subtyping. But in fact inheritance isn't compatible with subtyping, at least if we define subtyping using the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Suppose A extends B. Then the predicate `\\x -> not (x instanceof A)` is satisfied by B but not by A. So by LSP, A is not substitutable for B.\n\nThat doesn't mean all inheritance doesn't work, or am I missing something? You're only showing why *that specific predicate* couldn't be used. And that would be a really odd precondition to have if the class wasn't final.\n\nLSP is \"Let \u03d5 be a property provable about objects of type T. Then \u03d5 should be true for objects of type S where S is a subtype of T. \" LSP should hold for all such properties \u03d5, but I've exhibited a predicate for which it fails. And I made no assumptions about the objects, hence LSP fails on this predicate for every inheritance relationship. The only choices are to exclude this predicate somehow, e.g. by not allowing predicates containing `instanceof`, or to consider instances of A members of a distinct type (neither subtype nor supertype) from instances of B.\n\nI find this Wiki article a little better in explaining behavioral subtyping which (at least based on my small amount research) is sort of the more generic term for liskov substitution. I've also seen a few times some criticisms of the original form of what Liskov described. It seems like it wasn't fully thought out (or rather, given the luxury of hindsight people have thought of better ways to phrase it).\n\nhttps://en.wikipedia.org/wiki/Behavioral_subtyping\n\n>Firstly, in its original formulation, it is too strong: we rarely want the behavior of a subclass to be identical to that of its superclass; substituting a subclass object for a superclass object is often done with the intent to change the program's behavior, albeit, if behavioral subtyping is respected, in a way that maintains the program's desirable properties. Secondly, it makes no mention of specifications, so it invites an incorrect reading where the implementation of type S is compared to the implementation of type T. This is problematic for several reasons, one being that it does not support the common case where T is abstract and has no implementation.\n\nPerhaps more interestingly Barbara Liskov herself described the definition she gave at that conference as an informal rule based on intuition and her and some colleagues went on to better define it in papers. She also says the technical term is behavioral subtyping. https://youtu.be/-Z-17h3jG0A", "id": "j0vyrdz", "owner_tier": 0.9, "score": 0.06666666658333334}, {"content": "An argument against inheritance is that it is counterintuitive and has better alternatives. Inheritance is often confused with subtyping, but is not actually compatible with it according to the Liskov substitution principle. In addition, inheritance can lead to poor encapsulation, whereas object composition offers better encapsulation. A study has shown that composition can replace inheritance in at least 22% of real-world cases.\n\nI'm not sure why your comment was downvoted (whether or not I agree with it). A couple of points to consider:\n\n* Barbara Liskov is a genius; of this there is no doubt. But her \"substitution principle\" is no more realistic than saying \"type systems should prevent all forms of runtime errors\". I like the principle, but in reality there are engineering trade-offs that will occur, or you'll end up with languages like Coq and Idris that no one uses (outside of academic circles). To be clear, Coq and Idris (etc.) are brilliant in their inception and design, but as languages for building things, they are borderline unusable.\n\n* _\"inheritance can lead to poor encapsulation ...\"_ Absolutely! And sometimes this is exactly why it gets used (to work around something that was \"too well\" encapsulated).\n\n* _\"object composition offers better encapsulation.\"_ This seems like a reasonable statement, and aligns well with what I have seen. (As a side note, I dislike the use of the term \"composition\" as it is far too general a term, and sometimes includes inheritance as a form. I'm not sure what term I would prefer; perhaps \"aggregation\" or something similar.)\n\n* _\"A study has shown that composition can replace inheritance in at least 22% of real-world cases.\"_ I would have guessed far higher. I think inheritance is a reasonable tool that gets overused, but I personally appreciate having it when it is available in languages that I use.", "id": "izrbvic", "owner_tier": 0.1, "score": 0.04166666658333333}, {"content": "You're picking a bad example of inheritance (deciding object types at runtime) to attempt to prove that inheritance is bad.\n\nUnconvincing.\n\nBad code is bad code, it will happen no matter the language, no matter the design pattern.\n\nBy the way:\n\n    Ellipse makeCircleOrEllipse(float x, float y) {\n      if(x == y)\n        return new Circle(x);\n\nThe fact that you're using `==` on `floats` (which will never return `true`) makes me think you might be a bit new to the field of software development. I suggest you spend some more time reading up and learning.", "id": "izrbf38", "owner_tier": 0.7, "score": -8.333333282687742e-11}], "link": "https://www.reddit.com/r/ProgrammingLanguages/comments/zi03k9/an_argument_against_inheritance/", "question": {"content": "In this post my goal is to prove that the OO notion of inheritance is counterintuitive and has better alternatives. In particular you should think twice about including it in your language - do you really want another footgun? Let it be known that this is by no means a minority viewpoint - for example James Gosling [has said](https://www.infoworld.com/article/2073649/why-extends-is-evil.html) that if he could redo Java he would leave out the extends keyword for classes.\n\nFirst I should define inheritance. Per [Wikipedia](https://en.wikipedia.org/wiki/Inheritance-oop) inheritance is a mechanism for creating a \"child object\" that acquires all the data fields and methods of the \"parent object\". When we have classes, the child object is an instance of a subclass, while the parent object is an instance of the super class. \n\nInheritance is often confused with subtyping. But in fact inheritance isn't compatible with subtyping, at least if we define subtyping using the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Suppose ``A extends B``. Then the predicate ``\\x -> not (x instanceof A)`` is satisfied by ``B`` but not by ``A``. So by LSP, A is not substitutable for B.\n\nIf this is too abstract, consider a simple example you might find in university class:\n\n    class Ellipse {\n      final float minor_axis, major_axis;\n      Ellipse(float x,float y) {\n        minor_axis = x;\n        major_axis = y;\n      }\n    }\n    class Circle extends Ellipse { \n      Circle(float radius) {\n        super(radius,radius);\n      }\n    }\n  \n`Ellipse` must be immutable, otherwise one could make a circle non-circular. But even this is not enough, because ``new Ellipse(1,1)`` is a circle but is not a member of the `Circle` class. The only solution is to forbid this value somehow, e.g. requiring to construct the objects using a factory function:\n\n    Ellipse makeCircleOrEllipse(float x, float y) {\n      if(x == y)\n        return new Circle(x);\n      else\n        return new Ellipse(x,y);\n    }\n\nBut at this point we have lost any encapsulation properties, because the implementation is tied to the definition of ellipses and circles. A more natural solution is avoid inheritance and instead declare Circle as a refinement type of Ellipse:\n\n    type Ellipse = Ellipse { minor_axis, major_axis : Float }\n    type Circle = { e : Ellipse | e.minor_axis == e.major_axis }\n\nThen an ellipse with equal components is automatically a circle.\n\nInheritance is contrasted with object composition, where one object contains a field that is another object. Composition implements a has-a relationship, in contrast to the is-a relationship of subtyping. Per [this study](https://link.springer.com/chapter/10.1007/978-3-642-39038-8_24) composition can directly replace inheritance in at least 22% of real-world cases. Composition offers better encapsulation. For example, suppose we have a `List` class with ``add`` and ``addAll`` methods, and we want a \"counting list\" that tracks the total number of objects added.\n\n    class List { add(Object o) { \u2026 }; addAll(Object[] os) { \u2026 } }\n    class CountingList extends List {\n      int numObjects;\n      add(Object o) { numObjects++; super.add(o); };\n      addAll(Object[] os) {\n        // XXX\n        for(Object o in os)\n          super.add(o)\n      }\n    }\n\nWith inheritance the `CountingList.addAll` method cannot call the parent `List.addAll` method, because it is an implementation details as to whether `List.addAll` calls `add` or not. If it did not call `add`, we would have to increment `numObjects`, but if it did, `add` would resolve to `CountingList.add` and that method would update the counter. In this case, we could do `int tmp = numObjects; super.addAll(os); numObjects = tmp + os.length` to save and overwrite the object counter, but in a more complex example such as logging each added object there is no way to overwrite the effect. So the only option is to do it the slow way and call `add`, which can be expected to not call any other methods of the class.\n\nWithout inheritance, just using composition, the problem disappears. We can call `super.addAll` because it definitely does not call `CountingList.add`; there is no parent-child method aliasing:\n\n    class CountingList {\n      int numObjects;\n      List super;\n      add(Object o) { numObjects++; super.add(o); };\n      addAll(Object[] os) {\n        super.addAll(os)\n        numObjects += os.length\n      }\n    }\n\nThere is one remaining use case of inheritance, where you have overloaded methods implementing an interface. For example something like the following:\n\n    interface Delegate {\n      void doSomething(Info i)\n    }\n\n    class A implements Delegate {\n      void doSomething(Info i) { ... }\n    }\n\n    class B implements Delegate {\n      void doSomething(Info i) { ... }\n    }\n\nBut here we can just use lambdas.\n\n## Replacement \n\nSo far we have seen inheritance being replaced with a variety of techniques: refinement types, composition, and lambdas. It turns out this is all we need. Consider two arbitrary classes in an inheritance relationship:\n\n    class A { Field_a_1 f_a_1; Field_a_2 f_a_2; ...; Result_a_1 method1(Arg_a_1_1 a_1_1, Arg_a_1_2 a_1_2, ...); ...; }\n    class B extends A { Field_b_1 f_b_1; Field_b_2 f_b_2; ...; Result_b_1 method1(Arg_b_1_1 b_1_1, Arg_b_1_2 b_1_2, ...); ...; }\n\nWe must have a generic method that dispatches to the appropriate implementation. For extensibility this must not be a giant switch, but rather the method should be stored in the value (a vtable pointer). So we can implement it like this:\n\n    vtable_A = {\n      method1 = ...;\n      ...; \n    }\n\n    type A_instance = A { Field_a_1 f_a_1; Field_a_2 f_a_2; ...; vtable = vtable_A; }\n    type A = { a | (a : A_instance) or (a.parent : A) }\n    \n    vtable_B = {\n      method1 = ...;\n      ...; \n    }\n    \n    type B_instance = B { Field_b_1 f_b_1; Field_b_2 f_b_2; ...; vtable = vtable_B; A parent; }\n    type B = { b | (b : B_instance) or (b.parent : B) }\n\n    generic_invoke object method_name args = {\n      if(method_name in object.vtable)\n        object.vtable[method_name](args)\n      else if(object.parent)\n        generic_invoke(parent,method_name,args)\n      else\n        throw new Exception(\"no such method defined\")\n    }\n\nThe lambdas are needed to allow defining the vtable. Composition is used to include the parent pointer. Refinement types are used to define the \"subtyping\" relationship commonly associated with inheritance, although as explained above this relationship is not actually subtyping. So in your next language use these constructs instead of inheritance; you can implement inheritance, multiple inheritance, and a lot more, all without unintuitive footguns.", "id": "zi03k9", "title": "An argument against inheritance", "traffic_rate": 16.86659877800407}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "There are a few reasons, one of which is simply that many tools will expect your classes to conform to the Java Beans specification and attempt to manipulate your objects using the getter and setter functions.\n\nIn addition, by making the fields private you ensure that all modifications to them will have to happen under your control.  Your setter might perform validation or edit checks on the values being passed, whereas raw access to the field won't have that level of safety.  You can't mark a field 'private write/public read' so that makes using a getter a necessity.\n\nAlso, you may find that a few weeks down the road you've delegated responsibility for the values in those fields to some other object, so you change your getter code from this:\n\n    String getName() {\n        return name;\n    }\n\nto \n\n    String getName() {\n        return getNameHelper().getName();\n    }\n\nand remove the name field altogether.  If you are referring to it directly you will be a lot more reluctant to refactor in this way since you may have to change a couple of dozen other source modules.\n\n[deleted]\n\nAlso a big part is that you can perform additional modifiers, such as synchronisation on fields. \n\n> one of which is simply that many tools will expect your classes to conform to the Java Beans specification and attempt to manipulate your objects \n\nThis has nothing to do with why *should* properties be private.\n\n> In addition, by making the fields private you ensure that all modifications to them will have to happen under your control.\n\nAnyone capable of seeing the functions as private can make them public/protected by redefining the class and intantiating that class, so this is simply untrue.\n\nThe primary reason to keep functions private is *intent*. This means it is an effective way to tell the \"coder\" how the class is to be used beyond comments.\n\nUsually you have two types of classes: ones that are mostly structs and ones that do business logic. The former should usually have getters, the latter not. \n\nEspecially for things like dependencies, god help you if you make a dependency publicly accessible and someone else grabs it and accidentally mucks with its settings\n\nAnother approach is to use builders & immutable objects.  I'm not 100% sold on this yet, but having used this model recently, I'm finding it more and more useful.\n\nNot for Java beans\n\nI disagree in a way, I think getters and setters should exist and even be used internally, but scope of the getter/setter should be used appropriately. If the field really is private, keep the getters and setters private too, and so on.\n\nWhat do you mean by \"redefining\" the class?\n\nWhat is the value of a private get method if all it does is give you a field you can access anyway?\n\nRedefining a class is a scenario that's not uncommon in every language with access specifiers. If I can see the fields are private, I have access to the source code (that's the implication and common case). With the source, I can define a new class with them as public, then replace the class.\n\nThe purpose of a private field is either \"this is accounting tied to specific functionality\" or \"having access to this may cause unintended consequences, use the external interfaces plz\". It's very rare you want to use private instead of protected, if you have the option. Of course, private methods tie you immediately to the current implementation, in plain java and any accounting ends up being private for functional consistency when you extend the class. ", "id": "clalfcc", "owner_tier": 0.9, "score": 0.9999999998765433}, {"content": "So here's my basic example:\n\n    public class Item {\n        private String name;\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {            \n            Log.i(\"ITEM\", \"Name changed from outside of object.\");\n            this.name = name;\n        }\n    }\n\nIn this example, a log event is fired when the name is changed. Since this is the only way to change the name from outside the class, it will always fire.\n\nNow, this is a trivial example, but it gets to the point where you can see that there's some sort of process that happens every time the field is set. You could similarly fire something every time it's accessed, for access control methods.\n\nThe reason we design like this all the time, is because you never know when you're going to need to add one of those extra little processes. If you start out with a public field, people writing against your code are going to read and write the field directly, so if you change your mind later, you either break their code, or leave a hole in your program.\n\nDoes that make sense?\n\n/u/RhoOfFeh makes a really good point about Beans, too, but that's a little bit further down the road from where you are now.", "id": "clamftu", "owner_tier": 0.5, "score": 0.2345679011111111}, {"content": "There's lots of talk around state and encapsulation, but no one has mentioned the reason managing both of those things is important: immutability.\n\nIn a multi-threaded environment, the state of your object is extremely important.  While you may or may not be tackling the subject of concurrency at the moment, rest assured you most definitely will in the near future.\n\nAs a result, making instance variables as unmodifiable as possible is imperative.  An example would be a Transaction object which contains a currency amount like $1.00, a sender like \"Bob\", and a receiver like \"Carl\".  You don't want to have to send all three of those values separately, so you generate this Transaction object to carry the values.\n\nIf you don't make the variables private, they become mutatable by any other thread (which, in this particular financially-related case is especially bad!).  So, you instead create the object via a constructor passing those three values in and initializing the three values at object instantiation.  You then only provide accessor methods (getters) to those three values.  By doing this, you ensure that no other threads may modify the Transaction, but enabling all threads to access the Transaction without fear of mutation.\n\nExample below:\n\n    public class Transaction {\n        private final double currency;\n        private final String sender;\n        private final String receiver;\n        \n        public Transaction(double currency, String sender, String receiver) {\n            this.currency = currency;\n            this.sender = sender;\n            this.receiver = receiver;\n        }\n\n        public double getCurrency() {\n            return this.currency;\n        }\n\n        public String getSender() {\n            return this.sender;\n        }\n\n        public String getReceiver() {\n            return this.receiver;\n        }\n    }\n\nNote also that by initializing all variables at instantiation, you can also make your private fields final.  This improves performance at runtime, as well as a couple of other benefits.\n\nSee also Josh Bloch's Effective Java - Item 15.4\n\nExcept in the case of finals, even if they were public nobody could modify them, so you would be safe here either way\n\nIsn't it basically useless to worry about the performance impact using constants or variables has at this level?\n\nYou can't modify the reference, but your could change the state of the object. For example, you could add to a list that is final.\n\nHow so?  If the fields are public, they can be modified. This is the very definition of public.\n\nNot if you have many objects built this way, all with final instance variables.\n\nVery true, also a good example of when getters/setters can do more than just basic access:\n\nIt is generally advised that you do a list copy on get/set instead of just maintaining a pointer to some collection that an outside entity can screw with at whim.\n\nAlso a good reason to make object's fields final whenever possible, to avoid deep modification by anyone who happens to have access to it. In practice though, I often find this is more trouble than it is worth.\n\nNot if they are final. Final means they can only be set one, from a constructor, static block, or similar\n\nCopy on get can be expensive. What you should do in a method which returns a Collection is use an unmodifiable type which simply wraps the existing collection without a full out copy.\n\ne.g. return Collections.unmodifiableList(listAttribute);\n\nIf the caller wants to create a copy of it for their own purposes then nothing stops them from doing this.\n\nAfter doing this, you then provide interface methods to remove/add to this list if desired. This makes it much easier to track down where these lists are being modified versus some business logic utility grabbing the list, passing it into some other business logic method and three levels deeper you find where somebody is changing this list.\n\nOkay, I see what you mean now.  You're saying you could remove the getter's in the above case.  \n\nThat makes sense in the context of the example as is.  However, you'd be unable to do any additional work to the variables (ala rounding up/down to the closest integer at retrieval) if you did not provide the method accessors.\n\nTrue, if you add some of the stuff discussed elsewhere (encapsulation, delegation) it becomes relevant again. But immutability is generally not a concern covered by making fields private. The points in your original post are correct, but more tangentially related to the originally posted question", "id": "claptjh", "owner_tier": 0.1, "score": 0.543209876419753}, {"content": "Take this class\n\n    class FriendSet {\n        private Set<String> secretInternalFriends = new HashSet<>();\n        public void addFriend(String friend) {\n            if(friend.equals(\"billy\")) {\n                throw new RuntimeException(\"BILLY CAN NEVER BE MY FRIEND\");\n            } else {\n                secretInternalSet.add(friend);\n            }\n        }\n        public Set<String> getFriends() {\n          return Collections.unmodifiableSet(secretInternalFriends);\n        }\n    }\n\nThis class lets clients add friends, except for \"billy.\" getFriends() returns an unmodifiable set, so that they don't go and add \"billy\" to the set behind the objects back. Now imagine if the secretInternalFriends field was public. A client could do this:\n\n    FriendSet friends = new FriendSet();\n    friends.secretInternalFriends.add(\"billy\");\n\nNo exception will be thrown. The client has defeated the entire purpose of the class.\n\nIn general, that's one of the main advantages of Java over a dynamic language like JavaScript, Python, or Ruby. Those languages provide very little ability to prevent clients of objects from directly modifying or screwing up the internal state of the object. Clients should have no knowledge of the internal representation of data, or the structures or algorithms used. They only need to know the objects public interface.\n\n\nYou couldn't have described this any more complex could you? :P\n\nWhat these lines mean is that you can put conditions on the getters and setters if you might need them. The main reason of course is to give the least amount of access to everything outside of your class.\n\nThis doesnt answer the question of why it is appropriate to use getter setter exclusively regardless of functional requirements\n\nWoops you are right that this is too complicated. This is just the first example of encapsulation that came to mind.\n\n...so you can add constraints later on.", "id": "clam3n0", "owner_tier": 0.1, "score": 0.1111111109876543}, {"content": "It breaks encapsulation.\n\nHaving a public interface allows you to protect clients of the interface from having to undergo significant modification in the event that the implementation of the interface changes. \n\nEDIT: I realize this explanation may not be simple enough. Give me some time to think of a more straightforward answer or maybe someone else can offer a better explanation.\n\n[deleted]\n\nUnless you are just defining a bean/entity in which there is no internal state per se. ", "id": "clalinb", "owner_tier": 0.1, "score": 0.12345678999999998}, {"content": "Almost all methods make assumptions about the state of their fields; for instance a field that contains the length of a string corresponds to the number of characters in the underlying array of chars. If it is public and not final another method could change this breaking the assumptions of the class. Public fields can also break encapsulation; with private fields their structure and implementation can be changed without breaking any code that accesses it through its API.", "id": "clamgys", "owner_tier": 0.1, "score": 0.03703703691358025}, {"content": "When creating a class, you want to expose as little of its inner workings to the world as possible, making the user of your class play by your rules. If the field is public, it can be changed from outside the object by referencing it directly, bypassing any e.g. validation or logging, and changing one small piece of the state of the class instance, possibly putting the object into inconsistent state.\n\nSure, at first it doesn't look sensible to create a getter and/or setter that only returns/sets the private field, but later, when you want to make the field read-only, or want to add some behavior (calculating the value of some other dependent fields in the setter, for example), you'll find that the refactoring takes a lot less time with the getter and setter already in place.", "id": "claydda", "owner_tier": 0.7, "score": 0.03703703691358025}, {"content": "Check out this PDF from a Williams College Professor of Computer Science:\n\n[http://dept.cs.williams.edu/JavaStructures/Book_files/JavaStructures.pdf](http://dept.cs.williams.edu/JavaStructures/Book_files/JavaStructures.pdf)\n\nIt quickly gets into why abstraction and encapsulation are important points for good software development.", "id": "claly48", "owner_tier": 0.5, "score": 0.02469135790123457}, {"content": "Reverse your question -- if you just allow direct access to the `name` field, and then later decide you DONT want it to just return `name` anymore, how do you change it without breaking code that was already written to use it directly?\n\nIn this example you might decide instead of just returning `name` you want to return the user's entire name built from `firstName` and `lastName` fields. This would be impossible if you already had a bunch of clients just grabbing `name` directly.\n\nThey say to do it all the time because you often wont realize/know what things you will want to change in the future.\n\nAnd keep in mind the JVM is getting better all the time and it will try to inline accessor calls in some cases -- so in fact you can often use an accessor and get all of their benefits, but get the same performance as a direct field access.\n\n\n", "id": "clasexm", "owner_tier": 0.5, "score": 0.02469135790123457}, {"content": "Lots of great points in this thread, but I haven't seen anyone mention Security. By keeping your fields private you can ensure that they are only changed via setters and getters. If you don't want a field to be changed because it could break some other parts then you can avoid a setter and anyone working on the codebase in the future can't do so.", "id": "clay80n", "owner_tier": 0.5, "score": 0.02469135790123457}, {"content": "I highly recommend checking out [Project Lombok]( http://projectlombok.org) to get rid of all the crappy boilerplate code with getters and setters. \n\nYour objects can all conform to the beans spec without cluttering up your source\n\nI second this!\n\nAnemic Java Beans are really really frustrating and a cancer upon java. People say \"but my ide generates the code for me!\" However\n\n1. I have to rely on the IDE, and some arcane GUI to do this.\n2. It still makes the code an unreadable mess.\n3. If my object model changes at all, I have to manually regenerate this code.\n\n\nI find that IDEs are a lot easier to work out than the problems that get thrown up by things like Lombok. Sure it reduces some clutter, but why not just use a different JVM language if verbosity is that much of a problem?\n\nLombok has excellent Eclipse and IntelliJ support.\n\nNot sure what problems you're referring to with Lombok, but it's been a breeze to use in the 3 or 4 projects that I use it in on a daily basis.\n\n>why not just use a different JVM language if verbosity is that much of a problem?\n\nSeems rather drastic.  Lombok solves the problem elegantly without the host of problems involved with getting another language involved in with my projects. \n\n\nI find that lombok is pretty transparent in it's code generation. It's doing the same thing that the IDE would, just in a way that is documented in the code and makes the code more expressive of my intent.", "id": "clamt3o", "owner_tier": 0.5, "score": 0.061728394938271605}, {"content": "I don't see a mention of escape analysis.\n\nThis is a newer jdk feature which tracks modifications and helps the VM manage multitasking and garbage collection.\n\nThere are also other guides that claim private fields improves performance without escape analysis, but I'm having a hard time finding a term easily found out a source to cite.", "id": "clanzxt", "owner_tier": 0.5, "score": 0.012345678888888888}, {"content": "You will hear a lot of nonsense reasons and really twisted examples, the truth of the matter is: it is idiomatic java.  \n\nIdioms are really important to programming languages as they provide a shorthand for both reading and writing and expected norms.  If you go off the reservation, prepare to spend more time talking about why you don't use getters and setters than solving the actual problem at hand.\n\nEven if all your getters and setters are dumb valueless wrappers, they are still what other Java developers expect to find and that has value. \n\n", "id": "claod52", "owner_tier": 0.5, "score": -1.2345679012345679e-10}, {"content": "I ran out of time while composing the other response, but there's another reason for getters to exist.  It's called \"lazy initialization\".\n\nI do this kind of thing all the time:\n\n    Set<String> valueList = null;\n\n    void addValidValue(String newValue) throws InvalidValueException {\n        if (null == newValue) {\n            throw new InvalidValueException(\"Null values are not allowed\");\n        }\n        else {\n            getValueList().add(newValue);\n        }\n    }\n\n    //Lazy initialization.  Don't create the Set until we need it.\n    public Set<String>getValueList() {\n        if (null == valueList) {\n            valueList = new HashSet<String>();\n        }\n        return valueList;\n    }\n\n\n\nStupid question, why do you compare null to valueList instead of valueList to null? I know many languages have some nuance related to this, I'm just unsure of the nuance. \n\nEdit: So many responses! Thank you! \n\nIt's a practice named Yoda conditions - see http://en.m.wikipedia.org/wiki/Yoda_conditions.\n\nThere's no real benefit to it in Java, but in languages where assignments are allowed in if statement conditions it can prevent nasty bugs from cropping up if assignment (=) is used instead of an equals check (==).\n\nI am not sure if this is in the Java coding conventions. I think it is just one's style of writing.\n\nThat's an old convention from my days as a C coder who came up from BASIC.  There is no difference at all between 'null == value' and 'value == null'.  However, it does protect one from the possibility, however remote, of using 'value = null' because one made a typo, or forgot that in this language one uses '=='.  \n\nThat is not really a mistake I make anymore, I've been developing in languages with this syntax for a long time now.  However, I've allowed it to remain part of my style.\n\nI think in the case of comparing null, there isn't exactly a practical reason. But there is a reason for comparing objects for equality that way. Let's say you have a *name* variable, and you want to check if *name == \"bob\"*. If *name* is null then you will get a null pointer exception. If you instead write it as *\"bob\" == name*, then you will never get a null pointer exception because the equals method is being called on *\"bob\"* instead of *name*. I would think that OP just does this universally for consistency's sake. It's easy to just remember that if you have something known, then it should go on the left.\n\n== doesn't care if either side is null; the .equals() method requires the object it's being called on to not be null.\n\nOh that's right, I can't believe I forgot that.", "id": "claox57", "owner_tier": 0.9, "score": 0.18518518506172837}, {"content": "I think your intuition is right in a sense. Getters/setters that map directly to fields don't really add all that much. That's why in many languages, such as objective c, or c#, you don't actually have to provide getter/setter implementations.\n\nThe deeper reasons to make field private are:\n\nA) To isolate the internal representation of an object from the interfaces it exposes. A Date class may expose a method to set a date by some type of calendar, but it's internal representation may be in seconds from some established time. This is encapsulation.\n\nB) Setter/getters are not really meant to be used but for the simplest cases. You may have an object whose fields are interdependent, in which case setters would allow you to put the object in an inconsistent state for instance. In general, you want objects to do work and track it via their field values, rather than have code do work and represent state into a separate object. Then there's the whole principle of making certain types of object immutable, where you'd have no setters at all...\n\nI hope this helps.", "id": "claq7z5", "owner_tier": 0.1, "score": 0.012345678888888888}, {"content": "First thing I thought when I saw the title, and I may or may not be wrong, I have no idea:\n\n1. Abstraction (the Java community really likes this lol :P)\n2. Control\n3. Overriding (combined with the above)\n\nEdit: Oh, and please correct me if I'm wrong.", "id": "clatejy", "owner_tier": 0.3, "score": 0.012345678888888888}, {"content": "It's one of the pillars of OO, encapsulation.  Hiding your implementation details from the consumer lets you change those implementations without the consumer having to change or even be aware tat a change occurred.\n\nFor some languages (C# and Java included) it's especially important to start out with a property (getter methods) because re-factoring toward properties after having a public field can cause breaks.  So, in the end it's best to start with the property even if that property is a \"pass-through\", so that if in the future you need to do something else you can without breaking the consumers.", "id": "clauf4c", "owner_tier": 0.7, "score": 0.012345678888888888}], "link": "https://www.reddit.com/r/java/comments/2jd63m/why_should_fields_be_kept_private/", "question": {"content": "Hey /r/java!\n\nI'm currently taking Comp Sci in HS, and I have a strong background of JavaScript, Python, and Ruby.\n\nRecently the teacher/textbook told us that fields are best kept private, and that a `getFieldName` method is the way to access the value of that field.\n\nThis doesn't make any sense to me. When you've got a method called `getName()` which just returns `name`, why not make `name` a public field?", "id": "2jd63m", "title": "Why should fields be kept private?", "traffic_rate": 55.985432016075016}, "saved_time": 1721102370, "source": "reddit", "tags": []}, {"answers": [{"content": "I would recommend Method #2, but you're better off using a metaclass than a base class. Here is a sample implementation: Or in Python3 If you want to run __init__ every time the class is called, add to the if statement in Singleton.__call__. A few words about metaclasses. A metaclass is the class of a class; that is, a class is an instance of its metaclass. You find the metaclass of an object in Python with type(obj). Normal new-style classes are of type type. Logger in the code above will be of type class 'your_module.Singleton', just as the (only) instance of Logger will be of type class 'your_module.Logger'. When you call logger with Logger(), Python first asks the metaclass of Logger, Singleton, what to do, allowing instance creation to be pre-empted. This process is the same as Python asking a class what to do by calling __getattr__ when you reference one of its attributes by doing myclass.attribute. A metaclass essentially decides what the definition of a class means and how to implement that definition. See for example http://code.activestate.com/recipes/498149/, which essentially recreates C-style structs in Python using metaclasses. The thread What are some (concrete) use-cases for metaclasses? also provides some examples, they generally seem to be related to declarative programming, especially as used in ORMs. In this situation, if you use your Method #2, and a subclass defines a __new__ method, it will be executed every time you call SubClassOfSingleton() -- because it is responsible for calling the method that returns the stored instance. With a metaclass, it will only be called once, when the only instance is created. You want to customize what it means to call the class, which is decided by its type. In general, it makes sense to use a metaclass to implement a singleton. A singleton is special because its instance is created only once, and a metaclass is the way you customize the creation of a class, allowing it to behave differenly than a normal class. Using a metaclass gives you more control in case you need to customize the singleton class definitions in other ways. Your singletons won't need multiple inheritance (because the metaclass is not a base class), but for subclasses of the created class that use multiple inheritance, you need to make sure the singleton class is the first / leftmost one with a metaclass that redefines __call__ This is very unlikely to be an issue. The instance dict is not in the instance's namespace so it won't accidentally overwrite it. You will also hear that the singleton pattern violates the \"Single Responsibility Principle\" -- each class should do only one thing. That way you don't have to worry about messing up one thing the code does if you need to change another, because they are separate and encapsulated. The metaclass implementation passes this test. The metaclass is responsible for enforcing the pattern and the created class and subclasses need not be aware that they are singletons. Method #1 fails this test, as you noted with \"MyClass itself is a a function, not a class, so you cannot call class methods from it.\" Writing something that works in both Python2 and 3 requires using a slightly more complicated scheme. Since metaclasses are usually subclasses of type type, it's possible to use one to dynamically create an intermediary base class at run time with it as its metaclass and then use that as the baseclass of the public Singleton base class. It's harder to explain than to do, as illustrated next: An ironic aspect of this approach is that it's using subclassing to implement a metaclass. One possible advantage is that, unlike with a pure metaclass, isinstance(inst, Singleton) will return True. On another topic, you've probably already noticed this, but the base class implementation in your original post is wrong. _instances needs to be referenced on the class, you need to use super() or you're recursing, and __new__ is actually a static method that you have to pass the class to, not a class method, as the actual class hasn't been created yet when it is called. All of these things will be true for a metaclass implementation as well. I originally was writing a comment but it was too long, so I'll add this here. Method #4 is better than the other decorator version, but it's more code than needed for a singleton, and it's not as clear what it does. The main problems stem from the class being its own base class. First, isn't it weird to have a class be a subclass of a nearly identical class with the same name that exists only in its __class__ attribute? This also means that you can't define any methods that call the method of the same name on their base class with super() because they will recurse. This means your class can't customize __new__, and can't derive from any classes that need __init__ called on them. Your use case is one of the better examples of wanting to use a singleton. You say in one of the comments \"To me logging has always seemed a natural candidate for Singletons.\" You're absolutely right. When people say singletons are bad, the most common reason is they are implicit shared state. While with global variables and top-level module imports are explicit shared state, other objects that are passed around are generally instantiated. This is a good point, with two exceptions. The first, and one that gets mentioned in various places, is when the singletons are constant. Use of global constants, especially enums, is widely accepted, and considered sane because no matter what, none of the users can mess them up for any other user. This is equally true for a constant singleton. The second exception, which get mentioned less, is the opposite -- when the singleton is only a data sink, not a data source (directly or indirectly). This is why loggers feel like a \"natural\" use for singletons. As the various users are not changing the loggers in ways other users will care about, there is not really shared state. This negates the primary argument against the singleton pattern, and makes them a reasonable choice because of their ease of use for the task. Here is a quote from http://googletesting.blogspot.com/2008/08/root-cause-of-singletons.html: Now, there is one kind of Singleton which is OK. That is a singleton where all of the reachable objects are immutable. If all objects are immutable than Singleton has no global state, as everything is constant. But it is so easy to turn this kind of singleton into mutable one, it is very slippery slope. Therefore, I am against these Singletons too, not because they are bad, but because it is very easy for them to go bad. (As a side note Java enumeration are just these kind of singletons. As long as you don't put state into your enumeration you are OK, so please don't.) The other kind of Singletons, which are semi-acceptable are those which don't effect the execution of your code, They have no \"side effects\". Logging is perfect example. It is loaded with Singletons and global state. It is acceptable (as in it will not hurt you) because your application does not behave any different whether or not a given logger is enabled. The information here flows one way: From your application into the logger. Even thought loggers are global state since no information flows from loggers into your application, loggers are acceptable. You should still inject your logger if you want your test to assert that something is getting logged, but in general Loggers are not harmful despite being full of state.", "id": 6798042, "owner_tier": 0.9, "score": 0.9999999999912359}, {"content": "It is slightly similar to the answer by fab but not exactly the same. The singleton pattern does not require that we be able to call the constructor multiple times.  As a singleton should be created once and once only, shouldn't it be seen to be created just once?  \"Spoofing\" the constructor arguably impairs legibility. So my suggestion is just this: This does not rule out the use of the constructor or the field instance by user code: ... if you know for sure that Elvis has not yet been created, and that King has*. But it encourages users to use the the method universally: ... particularly (though not exclusively) if there is doubt concerning the pre-existence of Elvis and/or of that building. To make this complete you could also override __delattr__() to raise an Exception if an attempt is made to delete instance, and override __del__() so that it raises an Exception (unless we know the program is ending...) * some ontological issues here: could one singleton ever be another singleton? Subclassing a singleton class seems fraught with problems. And even then you'd probably be asking isinstance(), not is. My thanks to those who have helped with comments and edits, of which more are welcome. While I use Jython, this should work more generally, and be thread-safe. Points of note:", "id": 35534104, "owner_tier": 0.5, "score": 0.004382120937773883}, {"content": "Pros How does it work? __new__ is overwritten after the first call to __init__ so the constructor is essentially single-use. The lambda is used to return a reference to self using a closure which makes everything very anonymous.", "id": 72246576, "owner_tier": 0.3, "score": 0.0061349693163891324}, {"content": "You don't need it. Python's imported objects are already \"singletons\". When you have a file mymodule.py defining and you write from mymodule import myobject in multiple places, the code is imported/executed only the first time. All subsequent imports will use the same instance, that is cached in sys.imports. So, you don't need that pattern in the way you need it eg. Java, where you can't import already instantiated objects.", "id": 78139747, "owner_tier": 0.9, "score": -8.764241839811823e-12}, {"content": "This seems to be lightweight solution that has not been mentioned yet: Using an Enum class as a singleton class is also suggested in PEP 484 -- Type Hints. Unfortunately, if the Enum-based singleton needs to inherit from some abstract class, you need to jump through some hoops:", "id": 78015133, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "I used this: The output is so:", "id": 77433887, "owner_tier": 0.1, "score": 0.0035056967484662577}, {"content": "I know I am probably late to the party, but I think the metaclass approach can be improved. We don't need a dictionary to map the class to its singleton instance. We can simply have the singleton instance as an attribute of the class. Remember that instances of a metaclass are classes, so instance attributes of a metaclass are class attributes (static attributes for anyone coming from Java or C#). Here's the implementation: This code prints: As you can see, each class gets its own single _instance which needs to be instantiated as normal and can later be accessed with a get() class method. Trying to create another instance will raise a RuntimeError. Of course, you can modify the code to return the existing instance if already been created instead of raising an error, and you can implement __new__(cls, *args, **kwargs) to create the instance immediately when the class is defined instead of lazily when the constructor is first called, but these are easy modifications you can do to suit your needs. This removes the need for a dictionary that maps classes to their singleton instance like in the question and in the first answer. This results in a simpler implementation and probably a slightly faster one since we use simple attribute access instead of dictionary access (I didn't run any benchmarks so don't quote me on that).", "id": 77264282, "owner_tier": 0.5, "score": 0.002629272559158633}, {"content": "I don't know if I'm missing something here, but what about using undecorated static methods? By referring to Is @staticmethod decorator needed for declaring a Static Method in Python? and @staticmethod vs @classmethod in Python it seems that not having any decorator, which would fail if called on an object, is the desired behavior here for a singleton: This gives me the desired output:", "id": 77262132, "owner_tier": 0.3, "score": 0.002629272559158633}, {"content": "Honestly, I found a very simple solution: This does make ClassA an instance of ClassA and makes the uninstanciated class inaccessible. If you want something a bit more flexible you can define a method like so: Althogh I can't imagine why you'd add arguments to your init class if you want a singleton, so let's simplify this to this function, which is the same as the lambda but cleaner:", "id": 76944612, "owner_tier": 0.1, "score": 0.0035056967484662577}, {"content": "You just need a decorator, depending on the python version: Implementation Usage Output Notice how foo got printed only once Implementation:", "id": 73988733, "owner_tier": 0.3, "score": 0.021034180534618755}, {"content": "Few caveats I would want to highlight is,", "id": 72849869, "owner_tier": 0.3, "score": 0.0035056967484662577}, {"content": "As @Staale mentions here, the simplest way to make a singleton in python is to use a module with global variables (as 'attributes' & global functions as 'methods'). BUT I would like to add something very important to this already amazing answer: inheritance works here too! All you need to do to make a 'singleton module' B.py that inherits from another 'singleton module' A.py is start B.py with the line: from A import *, this respects private variables (by not importing them by default).", "id": 72439478, "owner_tier": 0.3, "score": 0.002629272559158633}, {"content": "By overriding the __new__ method to return the same instance of the class. A boolean to only initialize the class for the first time:", "id": 69259814, "owner_tier": 0.3, "score": 0.00964066607361963}, {"content": "I want to point out that the first method defines a dictionary for lookup, which I until today do not understand, and I see this solution spreading all over the place, so I guess everyone just copy pastes it from here. I am talking about this one: It makes sense for metaclass solutions, but with the one-off decorator solution, each time the decorator is called, a new function gets defined, as well as a new instances variable, so each \"instances\" will always only have one entry, except if you make it global. It will also not work with inheritance anyway. A similar, but simpler, and also better adjustable solution: adding a simple as well also allows inheritance or mocking, by accessing __wrapped__, which is also not possible with the inner dict lookup. (Of course pardon me, if I simply did not understand the mystery behind the dictionary lookup. Maybe it is my fault for not understanding the particular intent behind it)", "id": 71943034, "owner_tier": 0.1, "score": 0.002629272559158633}, {"content": "Here's my own implementation of singletons. All you have to do is decorate the class; to get the singleton, you then have to use the Instance method. Here's an example: And here's the code:", "id": 7489659, "owner_tier": 0.9, "score": 0.00964066607361963}, {"content": "You probably never need a singleton in Python. Just define all your data and functions in a module and you have a de facto singleton: To use: If you really absolutely have to have a singleton class then I'd go with: To use: where mysingleton.py is your filename that MySingleton is defined in. This works because after the first time a file is imported, Python doesn't re-execute the code.", "id": 27412017, "owner_tier": 0.3, "score": 0.06573181418930762}, {"content": "I prefer to use a static method GetInstance() to create a singleton object (also not allow any other method to do that) to emphasize that I am using a singleton design pattern.", "id": 70906745, "owner_tier": 0.3, "score": 0.002629272559158633}, {"content": "Here is simple implementation combining @agf and @(Siddhesh Suhas Sathe) solutions, where it uses metaclass and take into consideration the constructor args so you can return the same instance if you created the foo class with the exact same args", "id": 70007900, "owner_tier": 0.5, "score": 0.002629272559158633}, {"content": "Dead easy and works!", "id": 69830623, "owner_tier": 0.5, "score": 0.007887817695004382}, {"content": "One liner (I am not proud, but it does the job):", "id": 49144365, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "I just made a simple one by accident and thought I'd share it...", "id": 68673587, "owner_tier": 0.1, "score": 0.004382120937773883}, {"content": "I also prefer decorator syntax to deriving from metaclass. My two cents: This has some benefits above other decorators provided: Cons: If you need a different instance based on constructor parameters this solution needs to be improved (solution provided by siddhesh-suhas-sathe provides this). Finally, as other suggested, consider using a module in python. Modules are objects. You can even pass them in variables and inject them in other classes.", "id": 65183531, "owner_tier": 0.1, "score": 0.004382120937773883}, {"content": "You can use a metaclass if you want to use instance as a property. For example;", "id": 66568744, "owner_tier": 0.3, "score": 0.004382120937773883}, {"content": "Pros It's a true class Auto-magically covers inheritance Uses metaclass\nfor its proper purpose (and made me aware of it) Cons Are there any? This will be problem with serialziation. If you try to deserialize object from file (pickle) it will not use __call__ so it will create new file, you can use base class inheritance with __new__ to prevent that.", "id": 66509752, "owner_tier": 0.1, "score": 0.004382120937773883}, {"content": "I prefer this solution which I found very clear and straightforward.\nIt is using double check for instance, if some other thread already created it.\nAdditional thing to consider is to make sure that deserialization isn't creating any other instances.\nhttps://gist.github.com/werediver/4396488", "id": 64545504, "owner_tier": 0.3, "score": 0.00964066607361963}, {"content": "I will recommend an elegant solution using metaclasses Output: As you can see from the output, only one object is instantiated", "id": 63483209, "owner_tier": 0.3, "score": 0.00964066607361963}, {"content": "Using a function attribute is also very simple", "id": 62693309, "owner_tier": 0.5, "score": 0.01139351445223488}, {"content": "", "id": 57307127, "owner_tier": 0.3, "score": 0.01139351445223488}, {"content": "After struggling with this for some time I eventually came up with the following, so that the config object would only be loaded once, when called up from separate modules.  The metaclass allows a global class instance to be stored in the builtins dict, which at present appears to be the neatest way of storing a proper program global.", "id": 58452814, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "Maybe I missunderstand the singleton pattern but my solution is this simple and pragmatic (pythonic?). This code fullfills two goals This is the code. Output", "id": 57548242, "owner_tier": 0.5, "score": 0.0052585451270815075}, {"content": "If you don't need lazy initialization of the instance of the Singleton, then the following should be easy and thread-safe: This way A is a singleton initialized at module import.", "id": 53998434, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "This solution causes some namespace pollution at the module level (three definitions rather than just one), but I find it easy to follow. I'd like to be able to write something like this (lazy initialization), but unfortunately classes are not available in the body of their own definitions. Since that isn't possible, we can break out the initialization and the static instance in Eager Initialization: Lazy initialization: Eager Initialization:", "id": 40351307, "owner_tier": 0.5, "score": 0.0008764241805433831}, {"content": "This answer is likely not what you're looking for. I wanted a singleton in the sense that only that object had its identity, for comparison to. In my case it was being used as a Sentinel Value. To which the answer is very simple, make any object mything = object() and by python's nature,  only that thing will have its identity.", "id": 39777706, "owner_tier": 0.5, "score": 0.004382120937773883}, {"content": "I'll toss mine into the ring. It's a simple decorator. Benefits I think it has over some of the other solutions: One downside does occur to me: classmethods and staticmethods of the real class are not transparently callable via the factory class hiding it. I've used this rarely enough that I've never happen to run into that need, but it would be easily rectified by using a custom metaclass on the factory that implements __getattr__() to delegate all-ish attribute access to the real class. A related pattern I've actually found more useful (not that I'm saying these kinds of things are required very often at all) is a \"Unique\" pattern where instantiating the class with the same arguments results in getting back the same instance. I.e. a \"singleton per arguments\". The above adapts to this well and becomes even more concise: All that said, I do agree with the general advice that if you think you need one of these things, you really should probably stop for a moment and ask yourself if you really do. 99% of the time, YAGNI.", "id": 39186313, "owner_tier": 0.5, "score": 0.0061349693163891324}, {"content": "Method 3 seems to be very neat, but if you want your program to run in both Python\u00a02 and Python\u00a03, it doesn't work. Even protecting the separate variants with tests for the Python version fails, because the Python\u00a03 version gives a syntax error in Python\u00a02. Thanks to Mike Watkins: http://mikewatkins.ca/2008/11/29/python-2-and-3-metaclasses/. If you want the program to work in both Python\u00a02 and Python\u00a03, you need to do something like: I presume that 'object' in the assignment needs to be replaced with the 'BaseClass', but I haven't tried that (I have tried code as illustrated).", "id": 17840539, "owner_tier": 0.1, "score": 0.0061349693163891324}, {"content": "How about this: Use it as a decorator on a class that should be a singleton. Like this: This is similar to the singleton = lambda c: c() decorator in another answer. Like the other solution, the only instance has name of the class (MySingleton).  However, with this solution you can still \"create\" instances (actually get the only instance) from the class, by doing MySingleton(). It also prevents you from creating additional instances by doing type(MySingleton)() (that also returns the same instance).", "id": 23717235, "owner_tier": 0.3, "score": 0.004382120937773883}, {"content": "Code based on Tolli's answer. Explanation: Create new class, inheriting from given cls\n(it doesn't modify cls in case someone wants for example singleton(list)) Create instance. Before overriding __new__ it's so easy. The function returns instance only when it's what the caller expects, otherwise raises TypeError.\nThe condition is not met when someone attempts to inherit from decorated class. If __new__() returns an instance of cls, then the new instance\u2019s __init__() method will be invoked like __init__(self[, ...]), where self is the new instance and the remaining arguments are the same as were passed to __new__(). instance is already initialized, so function replaces __init__ with function doing nothing. See it working online", "id": 27713039, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "I can't remember where I found this solution, but I find it to be the most 'elegant' from my non-Python-expert point of view: Why do I like this?  No decorators, no meta classes, no multiple inheritance...and if you decide you don't want it to be a Singleton anymore, just delete the __new__ method.  As I am new to Python (and OOP in general) I expect someone will set me straight about why this is a terrible approach?", "id": 26858284, "owner_tier": 0.5, "score": 0.0035056967484662577}, {"content": "Here's a one-liner for you: Here's how you use it: Your object gets instantiated eagerly.  This may or may not be what you want.", "id": 19467267, "owner_tier": 0.5, "score": 0.01840490796669588}, {"content": "Well, other than agreeing with the general Pythonic suggestion on having module-level global, how about this: Output is:", "id": 6810621, "owner_tier": 0.5, "score": 0.004382120937773883}, {"content": "Use a module. It is imported only once. Define some global variables in it - they will be singleton's 'attributes'. Add some functions - the singleton's 'methods'.", "id": 6760821, "owner_tier": 0.9, "score": 0.08676599473269063}, {"content": "Modules are imported only once, everything else is overthinking. Don't use singletons and try not to use globals.", "id": 6760726, "owner_tier": 0.9, "score": 0.1384750219018405}], "link": "https://stackoverflow.com/questions/6760685/what-is-the-best-way-of-implementing-singleton-in-python", "question": {"content": "This question is not for the discussion of whether or not the singleton design pattern is desirable, is an anti-pattern, or for any religious wars, but to discuss how this pattern is best implemented in Python in such a way that is most pythonic. In this instance I define 'most pythonic' to mean that it follows the 'principle of least astonishment'. I have multiple classes which would become singletons (my use-case is for a logger, but this is not important). I do not wish to clutter several classes with added gumph when I can simply inherit or decorate. Best methods: Pros Cons While objects created using MyClass() would be true singleton objects, MyClass itself is a function, not a class, so you cannot call class methods from it. Also for then x == y but x != t && y != t Pros Cons Pros Cons Pros Cons a module file singleton.py Pros Cons", "id": 6760685, "title": "What is the best way of implementing singleton in Python", "traffic_rate": 156}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "singleton", "decorator", "base-class", "metaclass"]}, {"answers": [{"content": "Keys must be hashable - that's all that's forced upon you. In particular, you can have a user-defined class whose instances are hashable but also mutable - but this is generally a bad idea. By not sharing values between the two dicts. It's generally OK to share the keys, because they should be immutable (and will be, for built-in types). Copying the dictionary, in the sense of the copy standard library module, is definitely safe. Calling the dict constructor here works, too: b = dict(a). You could also use immutable values. All built-in immutable types are hashable. All built-in mutable types are not hashable. The constraint on dict keys simply requires that the built-in hash function works on the key, which in turn requires that its class implements the __hash__ magic method. However, the code may break subtly or unexpectedly if an object's hash could ever change during its lifetime. For a pathological example: This is why trying to make a mutable, hashable type is ill-advised: the hash is expected not to change, but is also expected to reflect the state of the object. No. A type is mutable if it is not immutable. A type is immutable if it is a built-in immutable type: str, int, long, bool, float, tuple, and probably a couple others I'm forgetting. User-defined types are always mutable. An object is mutable if it is not immutable. An object is immutable if it consists, recursively, of only immutable-typed sub-objects. Thus, a tuple of lists is mutable; you cannot replace the elements of the tuple, but you can modify them through the list interface, changing the overall data.", "id": 4374075, "owner_tier": 0.9, "score": 0.9999999996875}, {"content": "you can easily check if datatype is mutable or immutable by print an id or address of memory location of that datatype if datatype is immutable the address of memory location will change as you update the variable for example: you will get address of memory location of that variable stn but when you concatenate that variable with some value and then go ahead print an address of memory location you will get different output from the first one likewise for sure you will get another address of memory location from the first one but when you do it to mutable datatype an address of memory location will stay the same for example here you will get an address of memory location and also also if you go ahead and append some numbers to that lists an address of memory location will continue to be the same and you have notice that an address of memory location is not the same to all computers\nso you couldn't check the same datatype to different computers and get same result", "id": 62760382, "owner_tier": 0.5, "score": 0.1249999996875}, {"content": "There's really no guarantee that a type which is hashable is also immutable, but at very least, correctly implementing __hash__ requires that the type is immutable, with respect to its own hash, and to equality.  This is not enforced in any particular way.   However, we are all adults.  It would be unwise to implement __hash__ unless you really meant it.  Roughly speaking, this just boils down to saying that if a type actually can be used as a dictionary key, then it is intended to be used in that way. If you're looking for something that is like a dict, but also immutable, then namedtuple might be your best bet from what's in the standard library.  Admittedly it's not a very good approximation, but it's a start.", "id": 4374097, "owner_tier": 0.9, "score": 0.2187499996875}, {"content": "dict keys must be hashable, which implies they have an immutable hash value.  dict values may or may not be mutable; however, if they are mutable this impacts your second question. \"Changes to the keys\" will not be reflected between the two dicts.  Changes to immutable values, such as strings will also not be reflected.  Changes to mutable objects, such as user defined classes will be reflected because the object is stored by id (i.e. reference). I think this is explained by the first two answers. Not that I know of in this respect. some additional thoughts: There are two main things to know for understanding the behavior of keys: keys must be hashable (which means they implement object.__hash__(self)) and they must also be \"comparable\" (which means they implement something like object.__cmp__(self)).  One important take-away from the docs: by default, user-defined objects' hash functions return id(). Consider this example: Values are much easier to understand, the dict stores references to objects.  Read the sections on hashable.  Things like strings are immutable, if you \"change\" them, the dict you changed it in now references a new object.  Objects which are mutable can be \"changed in-place\", hence the value of both dicts will change. Anyway, here are the main points of all this: I do not think there is a general way to test either of those points.  The tests for suitability would depend on your use-case.  For instance, it may be sufficient to check that an object does or does not implement __hash__ and comparison (__eq__ or __cmp__) functions.  Like-wise, you might be able to \"check\" an object's __setattr__ method in some way to determine if it is mutable.", "id": 4374114, "owner_tier": 0.5, "score": 0.1562499996875}, {"content": "There isn't actually any such thing as mutability or immutability at the language level in Python.  Some objects provide no way to change them (eg. strings and tuples), and so are effectively immutable, but it's purely conceptual; there's no property at the language level indicating this, neither to your code nor to Python itself. Immutability is not actually relevant to dicts; it's perfectly fine to use mutable values as keys.  What matters is comparison and hashing: the object must always remain equal to itself.  For example: Here, example is not immutable; we're modifying it with a.data = 2.  Yet, we're using it as a key of a hash without any trouble.  Why?  The property we're changing has no effect on equality: the hash is unchanged, and example(1) is always equal to example(1), ignoring any other properties. The most common use of this is caching and memoization: having a property cached or not doesn't logically change the object, and usually has no effect on equality. (I'm going to stop here--please don't ask five questions at once.)", "id": 4374978, "owner_tier": 0.9, "score": 0.6249999996875}, {"content": "There are MutableSequence, MutableSet, MutableMapping in module collections. Which can be used to check mutability of premade types. If you want use this on user defined types, the type must be either inherited from one of them or registered as a virtual subclass. or", "id": 4374362, "owner_tier": 0.5, "score": 0.3437499996875}, {"content": "Dicts are unordered sets of key:value pairs. The keys must be immutable, and therefore hashable. To determine if an object is hashable, you can use the hash() function: The values, on the other hand, can be any object. If you need to check if an object is immutable, then I would use hash().", "id": 4374102, "owner_tier": 0.5, "score": -3.124999981007903e-10}], "link": "https://stackoverflow.com/questions/4374006/check-for-mutability-in-python", "question": {"content": "Consider this code: How do I check if a type is mutable in Python?", "id": 4374006, "title": "Check for mutability in Python?", "traffic_rate": 5}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "immutability", "hashable"]}, {"answers": [{"content": "Slots are very useful for library calls to eliminate the \"named method dispatch\" when making function calls.  This is mentioned in the SWIG documentation.  For high performance libraries that want to reduce function overhead for commonly called functions using slots is much faster. Now this may not be directly related to the OPs question.  It is related more to building extensions than it does to using the __slots__ syntax on an object.  But it does help complete the picture for the usage of slots and some of the reasoning behind them.", "id": 13547906, "owner_tier": 0.5, "score": 0.008375209374651032}, {"content": "In addition to the myriad advantages described in other answers herein \u2013 compact instances for the memory-conscious, less error-prone than the more mutable __dict__-bearing instances, et cetera \u2013 I find that using __slots__ offers more legible class declarations, as the instance variables of the class are explicitly out in the open. To contend with inheritance issues with __slots__ declarations I use this metaclass: \u2026 which, if declared as the metaclass of the base class in an inheritance tower, ensures that everything that derives from that base class will properly inherit __slots__ attributes, even if an intermediate class fails to declare any. Like so:", "id": 73677355, "owner_tier": 0.5, "score": 0.0016750418704634283}, {"content": "In addition to the other answers, __slots__ also adds a little typographical security by limiting attributes to a predefined list. This has long been a problem with JavaScript which also allows you to add new attributes to an existing object, whether you meant to or not. Here is a normal unslotted object which does nothing, but allows you to add attributes: Since Python is case sensitive, the two attributes, spelled the same but with different case, are different. If you suspect that one of those is a typing error, then bad luck. Using slots, you can limit this: This time, the second attribute (Name) is disallowed because it\u2019s not in the __slots__ collection. I would suggest that it\u2019s probably better to use __slots__ where possible to keep more control over the object.", "id": 72282322, "owner_tier": 0.5, "score": 0.004466778330541597}, {"content": "Beginning in Python 3.9, a dict may be used to add descriptions to attributes via __slots__. None may be used for attributes without descriptions, and private variables will not appear even if a description is given.", "id": 71730153, "owner_tier": 0.5, "score": 0.004466778330541597}, {"content": "The special attribute __slots__ allows you to explicitly state which instance attributes you expect your object instances to have, with the expected results: The space savings is from Small caveat, you should only declare a particular slot one time in an inheritance tree. For example: Python doesn't object when you get this wrong (it probably should), problems might not otherwise manifest, but your objects will take up more space than they otherwise should. Python 3.8: This is because the Base's slot descriptor has a slot separate from the Wrong's. This shouldn't usually come up, but it could: The biggest caveat is for multiple inheritance - multiple \"parent classes with nonempty slots\" cannot be combined. To accommodate this restriction, follow best practices: Factor out all but one or all parents' abstraction which their concrete class respectively and your new concrete class collectively will inherit from - giving the abstraction(s) empty slots (just like abstract base classes in the standard library). See section on multiple inheritance below for an example. To have attributes named in __slots__ to actually be stored in slots instead of a __dict__, a class must inherit from object (automatic in Python 3, but must be explicit in Python 2). To prevent the creation of a __dict__, you must inherit from object and all classes in the inheritance must declare __slots__ and none of them can have a '__dict__' entry. There are a lot of details if you wish to keep reading. The creator of Python, Guido van Rossum, states that he actually created __slots__ for faster attribute access. It is trivial to demonstrate measurably significant faster access: and The slotted access is almost 30% faster in Python 3.5 on Ubuntu. In Python 2 on Windows I have measured it about 15% faster. Another purpose of __slots__ is to reduce the space in memory that each object instance takes up. My own contribution to the documentation clearly states the reasons behind this: The space saved over using __dict__ can be significant. SQLAlchemy attributes a lot of memory savings to __slots__. To verify this, using the Anaconda distribution of Python 2.7 on Ubuntu Linux, with guppy.hpy (aka heapy) and sys.getsizeof, the size of a class instance without __slots__ declared, and nothing else, is 64 bytes. That does not include the __dict__. Thank you Python for lazy evaluation again, the __dict__ is apparently not called into existence until it is referenced, but classes without data are usually useless. When called into existence, the __dict__ attribute is a minimum of 280 bytes additionally. In contrast, a class instance with __slots__ declared to be () (no data) is only 16 bytes, and 56 total bytes with one item in slots, 64 with two. For 64 bit Python, I illustrate the memory consumption in bytes in Python 2.7 and 3.6, for __slots__ and __dict__ (no slots defined) for each point where the dict grows in 3.6 (except for 0, 1, and 2 attributes): So, in spite of smaller dicts in Python 3, we see how nicely __slots__ scale for instances to save us memory, and that is a major reason you would want to use __slots__. Just for completeness of my notes, note that there is a one-time cost per slot in the class's namespace of 64 bytes in Python 2, and 72 bytes in Python 3, because slots use data descriptors like properties, called \"members\". To deny the creation of a __dict__, you must subclass object. Everything subclasses object in Python 3, but in Python 2 you had to be explicit: now: Or subclass another class that defines __slots__ and now: but: To allow __dict__ creation while subclassing slotted objects, just add '__dict__' to the __slots__ (note that slots are ordered, and you shouldn't repeat slots that are already in parent classes): and Or you don't even need to declare __slots__ in your subclass, and you will still use slots from the parents, but not restrict the creation of a __dict__: And: However, __slots__ may cause problems for multiple inheritance: Because creating a child class from parents with both non-empty slots fails: If you run into this problem, You could just remove __slots__ from the parents, or if you have control of the parents, give them empty slots, or refactor to abstractions: and now: So with '__dict__' in slots we lose some of the size benefits with the upside of having dynamic assignment and still having slots for the names we do expect. When you inherit from an object that isn't slotted, you get the same sort of semantics when you use __slots__ - names that are in __slots__ point to  slotted values, while any other values are put in the instance's __dict__. Avoiding __slots__ because you want to be able to add attributes on the fly is actually not a good reason - just add \"__dict__\" to your __slots__ if this is required. You can similarly add __weakref__ to __slots__ explicitly if you need that feature. The namedtuple builtin make immutable instances that are very lightweight (essentially, the size of tuples) but to get the benefits, you need to do it yourself if you subclass them: usage: And trying to assign an unexpected attribute raises an AttributeError because we have prevented the creation of __dict__: You can allow __dict__ creation by leaving off __slots__ = (), but you can't use non-empty __slots__ with subtypes of tuple. Even when non-empty slots are the same for multiple parents, they cannot be used together: Using an empty __slots__ in the parent seems to provide the most flexibility, allowing the child to choose to prevent or allow (by adding '__dict__' to get dynamic assignment, see section above) the creation of a __dict__: You don't have to have slots - so if you add them, and remove them later, it shouldn't cause any problems. Going out on a limb here: If you're composing mixins or using abstract base classes, which aren't intended to be instantiated, an empty __slots__ in those parents seems to be the best way to go in terms of flexibility for subclassers. To demonstrate, first, let's create a class with code we'd like to use under multiple inheritance We could use the above directly by inheriting and declaring the expected slots: But we don't care about that, that's trivial single inheritance, we need another class we might also inherit from, maybe with a noisy attribute: Now if both bases had nonempty slots, we couldn't do the below. (In fact, if we wanted, we could have given AbstractBase nonempty slots a and b, and left them out of the below declaration - leaving them in would be wrong): And now we have functionality from both via multiple inheritance, and can still deny __dict__ and __weakref__ instantiation: You may be able to tease out further caveats from the rest of the __slots__ documentation (the 3.7 dev docs are the most current), which I have made significant recent contributions to. The current top answers cite outdated information and are quite hand-wavy and miss the mark in some important ways. I quote: \"You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class.\" Abstract Base Classes, for example, from the collections module, are not instantiated, yet __slots__ are declared for them. Why? If a user wishes to deny __dict__ or __weakref__ creation, those things must not be available in the parent classes. __slots__ contributes to reusability when creating interfaces or mixins. It is true that many Python users aren't writing for reusability, but when you are, having the option to deny unnecessary space usage is valuable. When pickling a slotted object, you may find it complains with a misleading TypeError: This is actually incorrect. This message comes from the oldest protocol, which is the default. You can select the latest protocol with the -1 argument. In Python 2.7 this would be 2 (which was introduced in 2.3), and in 3.6 it is 4. in Python 2.7: in Python 3.6 So I would keep this in mind, as it is a solved problem. The first paragraph is half short explanation, half predictive. Here's the only part that actually answers the question The proper use of __slots__ is to save space in objects. Instead of having a dynamic dict that allows adding attributes to objects at anytime, there is a static structure which does not allow additions after creation. This saves the overhead of one dict for every object that uses slots The second half is wishful thinking, and off the mark: While this is sometimes a useful optimization, it would be completely unnecessary if the Python interpreter was dynamic enough so that it would only require the dict when there actually were additions to the object. Python actually does something similar to this, only creating the __dict__ when it is accessed, but creating lots of objects with no data is fairly ridiculous. The second paragraph oversimplifies and misses actual reasons to avoid __slots__. The below is not a real reason to avoid slots (for actual reasons, see the rest of my answer above.): They change the behavior of the objects that have slots in a way that can be abused by control freaks and static typing weenies. It then goes on to discuss other ways of accomplishing that perverse goal with Python, not discussing anything to do with __slots__. The third paragraph is more wishful thinking. Together it is mostly off-the-mark content that the answerer didn't even author and contributes to ammunition for critics of the site. Create some normal objects and slotted objects: Instantiate a million of them: Inspect with guppy.hpy().heap(): Access the regular objects and their __dict__ and inspect again: This is consistent with the history of Python, from Unifying types and classes in Python 2.2 If you subclass a built-in type, extra space is automatically added to the instances to accomodate __dict__ and __weakrefs__. (The __dict__ is not initialized until you use it though, so you shouldn't worry about the space occupied by an empty dictionary for each instance you create.) If you don't need this extra space, you can add the phrase \"__slots__ = []\" to your class.", "id": 28059785, "owner_tier": 0.9, "score": 0.9999999999944166}, {"content": "You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class. __slots__ only exists as a memory optimization tool. It's highly discouraged to use __slots__ for constraining attribute creation. Pickling objects with __slots__ won't work with the default (oldest) pickle protocol; it's necessary to specify a later version. Some other introspection features of python may also be adversely affected.", "id": 472017, "owner_tier": 0.5, "score": 0.08375209379676159}, {"content": "Another somewhat obscure use of __slots__ is to add attributes to an object proxy from the ProxyTypes package, formerly part of the PEAK project. Its ObjectWrapper allows you to proxy another object, but intercept all interactions with the proxied object. It is not very commonly used (and no Python 3 support), but we have used it to implement a thread-safe blocking wrapper around an async implementation based on tornado that bounces all access to the proxied object through the ioloop, using thread-safe concurrent.Future objects to synchronise and return results. By default any attribute access to the proxy object will give you the result from the proxied object. If you need to add an attribute on the proxy object, __slots__ can be used.", "id": 42099854, "owner_tier": 0.5, "score": 0.0027917364544946957}, {"content": "Quoting Jacob Hallen: The proper use of __slots__ is to save space in objects. Instead of having\n  a dynamic dict that allows adding attributes to objects at anytime,\n  there is a static structure which does not allow additions after creation.\n  [This use of __slots__ eliminates the overhead of one dict for every object.] While this is sometimes a useful optimization, it would be completely\n  unnecessary if the Python interpreter was dynamic enough so that it would\n  only require the dict when there actually were additions to the object. Unfortunately there is a side effect to slots. They change the behavior of\n  the objects that have slots in a way that can be abused by control freaks\n  and static typing weenies. This is bad, because the control freaks should\n  be abusing the metaclasses and the static typing weenies should be abusing\n  decorators, since in Python, there should be only one obvious way of doing something. Making CPython smart enough to handle saving space without __slots__ is a major\n  undertaking, which is probably why it is not on the list of changes for P3k (yet).", "id": 472024, "owner_tier": 0.5, "score": 0.15745393634282523}, {"content": "A very simple example of __slot__ attribute. If I don't have __slot__ attribute  in my class, I can add new attributes to  my objects. If you look at example above, you can see that obj1 and obj2 have their own x and y attributes and python has also created  a dict attribute for each object (obj1 and obj2). Suppose if my class Test has thousands of such objects? Creating an additional attribute dict for each object will cause lot of overhead (memory, computing power etc.) in my code. Now in the following example my class Test contains __slots__ attribute. Now I can't add new attributes to my objects (except attribute x) and python doesn't create a dict attribute anymore. This eliminates overhead for each object, which can become significant if you have many objects.", "id": 40376229, "owner_tier": 0.5, "score": 0.007258514790619765}, {"content": "You have \u2014 essentially \u2014 no use for __slots__.   For the time when you think you might need __slots__, you actually want to use Lightweight or Flyweight design patterns. These are cases when you no longer want to use purely Python objects. Instead, you want a Python object-like wrapper around an array, struct, or numpy array. The class-like wrapper has no attributes \u2014 it just provides methods that act on the underlying data. The methods can be reduced to class methods. Indeed, it could be reduced to just functions operating on the underlying array of data.", "id": 472570, "owner_tier": 0.9, "score": -5.583472920156337e-12}, {"content": "The original question was about general use cases not only about memory.\nSo it should be mentioned here that you also get better performance when instantiating large amounts of objects - interesting e.g. when parsing large documents into objects or from a database. Here is a comparison of creating object trees with a million entries, using slots and without slots. As a reference also the performance when using plain dicts for the trees (Py2.7.10 on OSX): Test classes (ident, appart from slots): testcode, verbose mode:", "id": 34751434, "owner_tier": 0.3, "score": 0.0016750418704634283}, {"content": "In addition to the other answers, here is an example of using __slots__: So, to implement __slots__, it only takes an extra line (and making your class a new-style class if it isn't already). This way you can reduce the memory footprint of those classes 5-fold, at the expense of having to write custom pickle code, if and when that becomes necessary.", "id": 30613834, "owner_tier": 0.7, "score": 0.017867113338916805}, {"content": "An attribute of a class instance has 3 properties: the instance, the name of the attribute, and the value of the attribute. In regular attribute access, the instance acts as a dictionary and the name of the attribute acts as the key in that dictionary looking up value. instance(attribute) --> value In __slots__ access, the name of the attribute acts as the dictionary and the instance acts as the key in the dictionary looking up value. attribute(instance) --> value In flyweight pattern, the name of the attribute acts as the dictionary and the value acts as the key in that dictionary looking up the instance. attribute(value) --> instance", "id": 24048447, "owner_tier": 0.5, "score": 0.007258514790619765}, {"content": "Each python object has a __dict__ atttribute which is a dictionary containing all other attributes. e.g. when you type self.attr python is actually doing self.__dict__['attr']. As you can imagine using a dictionary to store attribute takes some extra space & time for accessing it. However, when you use __slots__, any object created for that class won't have a __dict__ attribute. Instead, all attribute access is done directly via pointers. So if want a C style structure rather than a full fledged class you can use __slots__ for compacting size of the objects & reducing attribute access time. A good example is a Point class containing attributes x & y. If you are going to have a lot of points, you can try using __slots__ in order to conserve some memory.", "id": 472899, "owner_tier": 0.5, "score": 0.04187604689558906}], "link": "https://stackoverflow.com/questions/472000/usage-of-slots", "question": {"content": "What is the purpose of __slots__ in Python \u2014 especially with respect to when I would want to use it, and when not?", "id": 472000, "title": "Usage of __slots__?", "traffic_rate": 73}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "oop", "python-internals", "slots"]}, {"answers": [{"content": "I think you are overcomplicating this. Car.__init__ should perform initialization that is common to any Car, regardless of the specific subclass used to instantiated the object. Each subclass will define an __init__ method that first calls its inherited __init__ method, then does any subclass-specific intialization. civic.id, civic.created_at, and civic.modified_at are defined by Car.__init__; civic.something_else is defined by Honda.__init__.", "id": 76218593, "owner_tier": 0.9, "score": 0.9999999900000001}, {"content": "In Python you will rarely need to touch __new__ - and usually only when you really know what you are doing. Which means: when in doubt, use __init__. :-) But seriously, the tasks you mention are typical, and meant to be done on __init__. There are a few semantic and historic reasons for it - but actually, also, very practical reasons few people are aware of: Among other things Python can do, there is out-of-the box support for serializing and de-serializing almost any object created by a user-defined class - out of the box, without the class author never worrying about it. And one of the reasons that works in such a fine way is this separation of the construction of an object in the __new__ and __init__  methods: __new__ is supposed to build the object as an \"empty shell\", and __init__ to \"fill in any attributes needed at object initialization\" (not quotes, I am wording these now). The de-serialization mechanism uses that to create a new object, and them just filling in the attributes of the originally serialized objects into the new instance, without calling __init__. In your example, if __new__ would create an ID (which might be backed up in some registry or DB at creation, or be an immutable attribute), this mechanism would not work.", "id": 76218211, "owner_tier": 0.9, "score": -9.99999993922529e-09}], "link": "https://stackoverflow.com/questions/76218135/using-parent-class-new-or-init-method-to-assign-default-attributes-f", "question": {"content": "I am trying to create a parent class - Car that would be able to automatically assign a unique id (using uuid.uuid4()), a created_at attribute and an updated_at attribute (both using the datetime and dateutil modules) to any object that would be created through the sub-classes of my parent class. For example: When an object (honda_civic()) of my sub-class Honda, which inherits from my Car parent class, is created, honda_civic would be automatically assigned a unique id, then it will also have a time created and time updated, as well as the other attributes and methods defined in the Honda sub-class. Based on my research so far, I know that I would need to define these attributes inside either of the __new__ or __init__ methods of my parent class Car (I stand to be corrected). However, I'm struggling to figure out exactly which of them should have the definitions. I know that the __new__ method controls object creation while the __init__ method controls object instantiation. My confusion now is that if I define the attributes under the __init__ method, would that not mean that each time the object is created the attributes would have to be passed as arguments? (which is definitely not ideal). What I need help with now is figuring out the syntax of defining the attributes under the __new__ method because I am a bit confused by the def __new__(cls, *args, **kwargs) prototype definition of the __new__ method and how it can accommodate the definitions; can I pass the attributes to the __new__ prototype? like so: def __new__(cls, id, created_at, updated_at)", "id": 76218135, "title": "Using parent class `__new__` or `__init__` method to assign default attributes for every object/instance of a sub-class", "traffic_rate": 116}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "class", "oop", "inheritance", "magic-methods"]}, {"answers": [{"content": "I intend to show you what happens roughly. By the way I over simplified this. first think about implementing __call__ inside your class. It enables the instance of the class to be callable. Now we know that classes are instances themselves -> of type type: So there has to be a __call__ method in \"their\" class(better to say metaclass) and of course there is one in type. When you put parentheses in front of you class, you are actually calling this method with the given argument (here 8). What it does, first(here some another things happens but we ignored) calls the __new__ method with the argument you passed to the __call__, this method returns an instance of int, then __init__ will get called as an instance method on the newly created int object. So the way your class works is because of this: You inherited this __new__ from int and so yes, as @johnrsharpe pointed out in the comment, \"Immutable types in Python generally do the work in __new__, not __init__", "id": 67662112, "owner_tier": 0.5, "score": 0.9999999966666667}], "link": "https://stackoverflow.com/questions/67661671/inheriting-from-int-object", "question": {"content": "I have a class that inherits from int, in my class init function I am not calling the parent init function, but still somehow there is a value when I use the parent (int) methods, which means I think that the parent init was also called? for example: will return 8 I thought that maybe the parent constructor is called implicitly, but in this code I saw it is not: will return: in son init", "id": 67661671, "title": "Inheriting from int object", "traffic_rate": 1203}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "inheritance"]}, {"answers": [{"content": "While you can handle initialization in the __new__ method, because it's always called before __init__ (or even instead of, if __new__'s returned object is other than an instance of the class), it's best practice decoupling object initizalization in __init__ and leaving __new__ only for object creation. For instance, in that way you would be able to subclass Foo. (Furthermore, passing *args, **kwargs to __new__ will allow the subclass have any number of positional or named arguments.) However, if you handle initialization in __new__ you will inherit object's __init__ which hasn't more arguments than the instance itself. And you won't be able to subclass it by the common way.", "id": 59023077, "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "You can do this without implementing __init__ at all: In use:", "id": 55722422, "owner_tier": 0.9, "score": 0.03703703666666667}, {"content": "Both @cgogolin and @qvpham provide working answers. However, I reckon that float.__init__(value) within the __init__ method is irrelevant to the initialization of Foo. That is, it does nothing to initialize attributes of Foo. As such, it rather causes confusion on the necessity of the operation toward subclassing the float type. Indeed, the solution can be further simplified as follows:", "id": 52307860, "owner_tier": 0.3, "score": 0.407407407037037}, {"content": "the solution of cgogolin is right. it's like so with another immutable classes like int, str, ... But i will write:", "id": 35944874, "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "As float is immutable you have to overwrite __new__ as well. The following should do what you want: See also Sub-classing float type in Python, fails to catch exception in __init__()", "id": 35944423, "owner_tier": 0.5, "score": 0.9999999996296296}], "link": "https://stackoverflow.com/questions/35943789/python-can-a-subclass-of-float-take-extra-arguments-in-its-constructor", "question": {"content": "In Python 3.4, I'd like to create a subclass of float -- something that can be used in math and boolean operations like a float, but has other custom functionality and can receive an argument at initialization that controls that functionality. (Specifically, I wanted to have a custom __str__ and a parameter that is used in that method.) However, I can't seem to get a subclass of float to have a functional two-argument constructor. Why? Is this simply a limitation on extending built-in types? Example: Now if I try Foo(1,2) I get: Surprisingly, my new __init__'s arguments are enforced too, so if I do Foo(1) I get: What's the deal here? I've done similar things with subtypes of list and was surprised it didn't work on float.", "id": 35943789, "title": "Python: Can a subclass of float take extra arguments in its constructor?", "traffic_rate": 4}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "python-3.x", "types", "subclass", "built-in"]}, {"answers": [{"content": "Per Dunes' suggestion, I simply dropped the entire int concept entirely. As he pointed out, any vanilla object can implicitly be used as a unique key! In fact MyId could be defined as simply: class MyId: pass. Often, that would be it - a perfectly usable, implicitly unique key! For my use case, however, I need to pass these keys back and forth across sub processes (via multiprocessing queues).  I ran into trouble with that ultra light weight approach, as the hash value would change when the objects where pickled and pushed across processes.  A minor secondary concern was that I wanted to make these objects easy to log and manually read / match up through logs.  As such, I went with this: As you can see, I wrapped the short and sweet approach into a more comprehensive/verbose one. When I create the MyId object, I create a _MyIdPrivate member, and take the hash of that at that moment of creation.  When pickling, and pushing across sub projects, that _MyIdPrivate hash will change - but it doesn't matter because I captured the initial value, and everything ends up pivoting off of that.   The main benefit of this approach over the original int plan is that I get a unique key without \"calculating\" or assigning it directly.   As Dunes' suggested I could have also used a uuid. I can see pros and cons to that vs this...", "id": 53564100, "owner_tier": 0.5, "score": -3.3333333333333334e-09}, {"content": "That's because you need to override the __add__ method. If you don't override this method, it will use the builtin int __add__ method which returns a new integer object. See this topic which explains this behavior as mentioned by @martineau in comments.  Prints: isinstance True", "id": 53561712, "owner_tier": 0.5, "score": 0.9999999966666667}, {"content": "It sounds like what you're after is being able to check that values being passed around have been created in a specific way. In Python 3.5.2+ there is the typing module that provides NewType. This allows you to do static analysis of your code to make sure it's doing the things you expect it to do. The example given in the documentation is: The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors: No actual type checking is performed at runtime, and the value returned by NewType is just a pass-through function that returns its argument unchanged. This also means you cannot do things like isinstance(obj, UserId), since UserId is not an actual class. What is does mean is, as mentioned by the documentation, static type checkers will help uncover logical errors -- which seems like what you're after.", "id": 53562091, "owner_tier": 0.9, "score": 0.33333333}, {"content": "Instead of subclassing int just check that your instance variable is an int.", "id": 53561740, "owner_tier": 0.5, "score": -3.3333333333333334e-09}], "link": "https://stackoverflow.com/questions/53561517/how-to-subclass-int-and-use-isinstance-to-identify-instances-of-it", "question": {"content": "I want to subclass int (or some other analogous builtin numerical type), that I can explicitly type check.   This q&a is similar, but didn't answer what I'm seeing exactly:\nSub-classing a built-in Python type such as int Here's a rough example of what I'm trying to achieve:  Unfortunately, my invocation of isinstance returns False. How do I make it succeed (ideally with this same basic concept)? It's obvious how to achieve is this by giving MyId class a \"has a\" rather than \"is a\" relationship with int... but I thought it be nicer to just make it an int with a specific \"name\". Currently, I'm writing this in Py2, but any cross version answers are appreciated if applicable. ", "id": 53561517, "title": "How to subclass int and use isinstance to identify instances of it?", "traffic_rate": 917}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "subclass", "python-2.x", "isinstance"]}, {"answers": [{"content": "See __new__: __new__() is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation. It is also commonly overridden in custom metaclasses in order to customize class creation.", "id": 5693958, "owner_tier": 0.9, "score": 0.9999999988888888}], "link": "https://stackoverflow.com/questions/5693942/subclassing-int-and-overriding-the-init-method-python", "question": {"content": "Possible Duplicate:\ninheritance from str or int  Hi folks, I'm trying to subclass the int class without any success. Here is my attempt: If I perform the following: I get this error: Any ideas? :)", "id": 5693942, "title": "Subclassing int and overriding the __init__ method - Python", "traffic_rate": 5051}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "int", "subclassing", "built-in"]}, {"answers": [{"content": "You're nearly there, you just need to move your __setattr__ method up to the metaclass: Note that although the metaclass __setattr__ stops you changing attributes in the class it doesn't stop you hiding them with instance attributes: if that's what you want then you need to define __setattr__ in both places. Edit: updated to use Python 3.x syntax instead of ancient Python 2.x", "id": 12913628, "owner_tier": 0.9, "score": -3.3333333130750966e-09}, {"content": "Yep! You do it exactly the same way. A __setattr__ method on a class controls setting attributes on instances of that class. In Python, everything is an object. And objects have classes. So you just need to arrange for your class to be an instance of some class that has a __setattr__ method, exactly as you do when you want to prevent instances having their attributes modified! The class of a class is called a metaclass. The default metaclass is type: the \"type of types\", or \"class of classes\". You want to make a subclass of type that doesn't allow its instances attributes to be set (exactly as you make a subclass of object that doesn't allow its instances attributes to be set when you're doing this at the instance level). Note carefully the distinction between the base class(es) of SomeClass, and the class of SomeClass. SomeClass is a subclass of object. It is an instance of CantTouchThis. Almost everything else that works at instance level can be similarly applied to the class level with metaclasses; classes are simply instances like everything else. They only have their distinctive classy behaviour because of the methods and implementation of type (exactly as ... etc, etc).", "id": 12913833, "owner_tier": 0.9, "score": 0.9999999966666667}], "link": "https://stackoverflow.com/questions/12359707/prevent-alter-access-to-class-variables", "question": {"content": "Is there a way to prevent or alter access to class variables in Python as one can via overriding __setattr__ for instance variables? Note that this question is mistitled and actually refers to instance variables, not class variables. Based on reading multiple posts about the (apparent) deathtrap that is __slots__, I'd prefer not to go that route (and I haven't looked into it enough to know if it does what I'm asking). Example:", "id": 12359707, "title": "Prevent / alter access to class variables", "traffic_rate": 3}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python", "class-variables"]}, {"answers": [{"content": "This kinda works:", "id": 35973132, "owner_tier": 0.9, "score": 0.0}], "link": "https://stackoverflow.com/questions/35970121/allow-super-to-control-setattr-on-subclasses", "question": {"content": "This question is about the read-only problem for objects that are based on a super() and if/how super can/should control __setattr__ on subclasses. Context: Is there a way to write a meta class or a descriptor such that all classes that are subclasses of a class containing the attribute self.read_only = True cannot execute subclassed functions where getattr is starting with \"set_\", but where self.read_only = False can? I'm thinking that an override of object.__setattr__(self, name, value):  Called when an attribute assignment is attempted. This is called\n  instead of the normal mechanism (i.e. store the value in the instance\n  dictionary). name is the attribute name, value is the value to be\n  assigned to it. ...is the right direction, but am in doubt whether my interpretation of the documentation is correct. Example: Super as intended by the system designer: Sub made by the system-extender who has limited understanding of all consequences: Commentary to example In the MutableMessage the system-extender explicitly declares that read_only is False and is knowingly aware that of the consequences of adding the function set_topic.  In the ImmutableMessage (below), the system-extender forgets to declare that message should be read_only=False which should result in supers __setattr__ to raise AttributeError: Core question:\nWill a usage as shown in the example below suffice to apply consistently to all classes who are based on the BaseMessage class?  Think of me as new to meta-programming. Therefore an explanation of any misunderstandings and/or extension and correction of my example would be supreme. I understand the hierarchy [1] but do not have insight to what python does behind the curtains during the inheritance process. Thanks... [1]: The hierarchy The search order that Python uses for attributes goes like this: Since __setattr__ is first in line, if you have one you need to make it smart unless want it to handle all attribute setting for your class. It can be smart in either of two ways. a. Make it handle a specific set attributes only, or,  b. make it handle all but some set of attributes.  For the ones you don't want it to handle, call super().__setattr__. Related questions:", "id": 35970121, "title": "Allow super to control __setattr__ on subclasses", "traffic_rate": 2074}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "stackoverflow", "tags": ["python-3.x", "inheritance", "setattr"]}, {"answers": [{"content": "The most likely reason is just simplicity. Why are TypedDict's not able to be generic? Because initial pep/implementation skipping that case made it easier to start with. There's some ongoing discussion to fix that and it's only like a hundred line change to support in cpython. The current variadic types pep is intentionally avoiding a lot of useful variadic features to get some implementation working with expectation of future peps to improve it.\n\n&#x200B;\n\nFrozen at dataclass level is useful in that it makes hashing safe. Mix of frozen and unfrozen fields would not give you that, but it can still be of value and I don't see any technical issue with it. If this is something you want I'd recommend bringing it up in python-ideas mailing list, https://mail.python.org/archives/list/python-ideas@python.org/. If there's general support for the idea you'd most likely want to make a small edit to dataclass pep updating definition, pr cpython for dataclass change, and some updates to documentation. Type checkers + linters will also be impacted but responsibility would be on them and I expect it to be fairly doable for them to support this. I doubt this would require a new pep/whole pep process.\n\n>Frozen at dataclass level is useful in that it makes hashing safe. Mix of frozen and unfrozen fields would not give you that, but it can still be of value and I don't see any technical issue with it.\n\nI normally would agree, but even with frozen dataclasses, you get to choose which attributes actually participate in generating a hash, so I don't see why it shouldn't be able to be mutable if it's not participating in the hashing process...\n\nI think the biggest thing is just simplicity. That frozen is related to hashing makes current rule simple too, but yes you could define hash as valid if all fields used are frozen. It's perfectly fine to ask for it to be extended. Most likely outcome I'd guess is neutral/weakly positive and if you do the implementation after discussion likely to pass.", "id": "hd1mgkm", "owner_tier": 0.5, "score": 0.8823529408823529}, {"content": "In 2018 I opened an issue to add this feature. I\u2019ve spent a lot of time with the implementation, and as others have said and you intuited it has to do with hashing and being able to use a frozen data class as a key in a dictionary, and not really to do with adding immutability to Python.\n\nThe current implementation (if memory serves) replaces the delattr and setattr to throw exceptions. I\u2019m not intending to work on the feature, but if you want to carry the torch that would be great!\n\nhttps://bugs.python.org/issue33474\n\nThis isn't as hard as this bug report makes it out to be.\n\nFrozen=true overrides setattr on the class. The behavior of the hash method depends on the class flag.\n\nThe descriptor object that represents a single field could very easily have the setter defined to throw an exception, without interacting at all with either of those attributes.", "id": "hd2ft5n", "owner_tier": 0.1, "score": 0.29411764676470586}, {"content": "That is the role of the named tuple. Immutable fields but you can still change them in a albeit painful way\n\n> That is the role of the named tuple.\n\nNot so.  All fields of a namedtuple are immutable.  OP just wants _some_ fields to be immutable.\n\nThe _replace method allows you to replace values in the named tuple. Note that the NamedTuple and namedtuple from typing and collections respectively are the same thing.\n\n`_replace` returns a new instance so it does not change anything regarding mutability.\n\n\\`dataclasses.replace\\` does the same thing.", "id": "hd1vq1f", "owner_tier": 0.3, "score": 0.9999999997058824}, {"content": "[attrs](https://www.attrs.org/en/stable/overview.html) (which is the library dataclasses is based upon / a stripped down copy of) supports individual frozen fields.", "id": "hd4kn25", "owner_tier": 0.5, "score": -2.9411764527133206e-10}], "link": "https://www.reddit.com/r/Python/comments/pp68bk/why_dont_dataclasses_allow_for_immutability_at/", "question": {"content": "As the title suggests, dataclasses in Python have the option of being set `frozen=True`, but when looking at the attibutes, if the object is mutable, there still is no option or possibility of making some fields mutable, while others are immutable? What was the reason for this design choice, because it seems valuable being able to have some immutable and some mutable properties...", "id": "pp68bk", "title": "Why don't dataclasses allow for immutability at the field level?", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "This has been talked about a lot but I don't see one specific point addressed:\n\nState.\n\nIf you need to store state and behavior, a class is, most of the time, what you're looking for. Even if it's only one piece of state and one behavior, a class is likely going to be a good choice.\n\nNow, if the class is _literally_ just a constructor and a method, then, yes, there's no state, and, thus, no need for a class.\n\nIn other languages, there's the concept of a _static_ class, which is a class that, basically, has no actual instances. Very often, static classes are used to store constants and some behavior related to them. More rarely, there may actually be state associated with these static classes in the form of static members.\n\nPython does have \"static\" members, sort of, and a static method could just be \"any method that doesn't affect the `self` of a class\". But that's not really \"pythonic\". \n\nBut importantly, using a static class to define one or two bits of behavior is generally better achieved through things like function pointers or their equivalent.\n\nAnd so, I think the safe takeaway here is this:\n\nIf you have at least some state, but also maybe some behavior, tie it to a class. If you have _just_ behavior, you probably don't need a class.\n\nAs always, be pragmatic, not dogmatic. If you find a reason to use a class with no state and a single method, by all means, do it.\n\nI think in this case it would probably be useful to base your class on some variant of dataclass to both get the benefit and to indicate why you did it that way.\n\nCounterpoint: if it's just one method, accept the state as a function argument, and return the new state. It's going to be a lot easier to test.\n\nI agree with your point on state. I have such classes to run heavy computations on chunks from data files and I need to keep track of the computation between chunks. Only other way would be to have sixteen return values passed to the next function call\n\n> Now, if the class is literally just a constructor and a method, then, yes, there's no state, and, thus, no need for a class.\n\nAnd also no real point of a constructor.\n\n> If you have just behavior, you probably don't need a class.\n\nI disagree here btw. There are several patterns that represent behavior. Sure, for many things you can just pass functions around, but sometimes it makes sense to accept behavior according to an interface.\n\nEven if there is state, a class is usually overkill. Putting them together often leads to weird practices that can be very un-ergonomic when you can often just put data into a list or a dict and get on with processing it as needed in separate functions.\n\nIsn't @classmethod basically a static function?\n\nWhy do you write: \"Now, if the class is literally just a constructor and a method, then, yes, there's no state, and, thus, no need for a class.\"?\n\nInitial state is typically set in the constructor.\n\n    class SomeClass:\n        def __init__(self):\n            self.state = 1\n\nThat's a class with just a constructor and it has state.\n\nNow, a class like  that doesn't make sense but saying it has no state is incorrect.\n\nMy first question was literally\n\n\"What if the constructor is used to initialize data and there's just one function tomanipulate it?\"\n\nA good example is a simple timer, your constructor saves the current time and a single function exists to calculate the difference, report it, and delete itself (if you wanted to do that, you could obviously implement a stop/start function into the clock if you wanted).\n\nWas gonna write a comment if there wasn\u2019t an answer like this. Yup, state is the answer and nothing else.\n\nIt is worth mentioning that functions with state can be done via closures. It's rare that this is a readability win for the \"class with a constructor and one method\" use case, but a closure is more or less the canonical way to implement a stateful decorator.", "id": "i16jeke", "owner_tier": 0.7, "score": 0.9999999999721448}, {"content": "May be talking about [Stop Writing Classes.](https://youtu.be/o9pEzgHorH0) \n\nI generally agree with the sentiment as I see them very overused, especially from people switching from Java. \n\nHowever don't shoot yourself in the foot trying to avoid them and start using globals or some garbage. They have their place and when you need clean namespaces, inheritance, etc don't avoid them.\n\nYeah I think this was the one. Thanks! There was also another guy who was a vim wizard coding in a live presentation and similarly talking about being able to refactor huge libraries into a few functions.\n\nI forgot exactly who said it, but object-oriented programming is supposed to be about messaging. Getting a piece of data from A to B. This, I think, helps distinguish the need for a class versus a function. In some languages, the tree of communication can be visualized by nested trees of logic in a function, where each block could be represented by a data class that encapsulates the operation.\n\nWhat I've typically done is, if I find myself sharing similar arguments between functions, I choose to move them into a class with a constructor, and either use the new data class as an argument, or I bind methods to the class that represent the individual work items, and perhaps even add a static constructor that unifies the workflow.\n\nEdit: [StackExchange comment thread relevant to my referenced quote](https://softwareengineering.stackexchange.com/questions/46592/so-what-did-alan-kay-really-mean-by-the-term-object-oriented)\n\nJust don't take it as dogma.\n\nBut yes, many problems out there doesn't *need* OOP classes. Arguably the latest \"best practise\" is to avoid OOP and the mess that you get from it, unless the problem is really helped by it.\n\nUsing dataclasses or Pydantic BaseModels and simple functions that manipulate them (without mutation!) often leads to a much simpler and straight forward solution than classes. Technically dataclasses and BaseModels are classes (as that's how they're implemented), but they're essentially used as dumb holders of state.\n\nIn some other languages you have \"structs\" and \"classes\", where structs are dumb while classes is a combination of a struct and a set of functions. In Python you can simulate structs by using classes without methods.\n\n---\n\nI've written quite a few production codebases in Python with tens of thousands of lines, where 97% of the business logic was implemented with dumb data structures (dataclasses/pydantic BaseModels) and functions. It's much nicer to work with than OOP codebases, that tend to be much harder to reason about or write tests for.\n\n>similarly talking about being able to refactor huge libraries into a few functions.\n\nYeah, making functions tends to improve your ability to create composable and re-usable functions, which often leads to much less code being needed to fulfill the same result. This is especially true when writing extremely abstract functions, though you should be careful not going too far in that direction as that can make the actual implementation a bit too opaque at times.\n\n> vim wizard coding in a live presentation and similarly talking about being able to refactor huge libraries into a few functions.\n\nmaybe [The Mental Game of Python - Raymond Hettinger](https://www.youtube.com/watch?v=UANN2Eu6ZnM)?\n\nalthough I think its emacs, not vim.\n\nThe bread and butter of my niche is messaging, and OOP is typically a suboptimal choice. It works well if you want to communicate state (and maybe some other situations I just haven\u2019t encountered) but usually you just need  functions to do whatever transforms.\n\nOOP is about logic, and being able to use programming idioms that map to the concepts in your problem.  I have seen OOP implemented poorly, with massive classes that try to do everything.  But small clean classes are often a thing of beauty.\n\n\"Just don't take it as dogma\"\n\nIf programmers at large internalize this one statement things would be so much better.\n\n>although I think its emacs, not vim\n\nThe idea that anyone could mistake one for the other. Horrific.j\n\nI added a link in my original comment, but messaging is meant more abstractly, as the modus operandi of a language, and why it works the way it does, not the problem it's trying to solve.", "id": "i16h2bp", "owner_tier": 0.5, "score": 0.44011142058495817}, {"content": "I agree to this statement.\n\nI only use a class where information and behavior is tightly coupled (or if a framework forces me to write a class). If there is only behavior, a function is better. For only data, there are a few better options in Python like dataclasses or even just a plain dict.\n\nThis makes code easier to understand and easier to test.\n\nDataclasses are amazing. Would highly recommend that over a dict.\n\nI see this misunderstanding everywhere. People make reasonable arguments about classes being overused as a way to tie together data abstraction and functionality abstraction. But then people take it to mean don't make data abstractions. Please for the love of all things make more data abstractions.\n\nAnd ideally not dict. Dicts are nameless. Use dataclasses or named tuples or even just classes with only \\_\\_inti\\_\\_ functions.\n\nA lack of data abstractions is so much worse of a problem in the average code base than too much coupling of data and functions. Both can be a problem but one is far far more prevalent.\n\nPlease stop using plain dicts to store data, 8 months later, a poor sap will get hired and will have an onboarding task that will require him to modify something that\u2019s using your dict and by god he will curse you because he will home no insight into your data structure\u2026 so for the love of all is sacred use dataclasses / pydantic models \ud83e\udd72", "id": "i16hgyf", "owner_tier": 0.7, "score": 0.20612813367688024}, {"content": "I believe you misunderstood the statement.\n\nClass - amid other thing - may serve to preserve a state. So, it may have `__init__` method to create the (initial) state - and any number of methods (even one) to combine processing of the initial state with the arguments of the function. The initial state may remain the same - or be changed.\n\nWhat is wrong it to have a stateless class just wrapping one - or more - functions, Java-style.\n\nI may hazard a guess that you meant [Stop Writing Classes](https://youtu.be/o9pEzgHorH0) talk.", "id": "i16mx2r", "owner_tier": 0.1, "score": 0.06685236766016713}, {"content": "Yes, anything that has the form\n\n```\nclass ABC:\n   def __init__(self, stuff):\n       self.__stuff = stuff\n\n   def do_thing(self, args):\n       ... do something with args and self.__stuff ...\n```\n\nCan be expressed as\n\n```\ndef do_thing(stuff, args):\n    ...\n\nabc = functools.partial(do_thing, stuff)\n```\n\nor\n\n```\ndef abc(stuff)\n   def do_thing(args):\n      ... # maybe \"nonlocal stuff\"\n   return do_thing\n```\n\nBut it is a judgement call as to whether the generic function call syntax conveys enough information for your purposes `f()` or whether you think the added method name adds enough value `f.do_thing()`\n\nI think its important to recognize the equivalence though, and I think for library design taking a plain function is often better design. Thats just my thought though\n\nImo you should always accept a callable and let the user of your library decide how that callable is implemented (class, function, lambda\u2026)\n\nYeah that makes sense. I just learned about partials today and looking at functional patterns and it made me think of all the dozens of classes I've written that have that form you mentioned.\n\nAre there other reasons (like performance / overhead) for choosing between the two patterns? I know that I've head problems before for having too many classes and abstractions.\n\nTriple backticks doesn't work with most reddit implementations (including old.reddit.com which plenty of people still use), you need to prepend every \"code\" line with four spaces instead.\n\nI found a very good academic paper on OOP design principles and when to use classes vs functions years ago and I cannot find it anymore\n\n> Are there other reasons (like performance / overhead) for choosing between the two patterns?\n\nArguably neither are best. OOP does reduce performance, but then so does writing functional immutable code. But if you're using Python, speed shouldn't need to be an issue anyway, as Python is very slow.\n\nThe problem with purely functional approaches is that some things gets more complicated, and some people tend to write functions that are too abstract, which makes it harder for humans to reason about what's actually happening. And there are some problems that are much easier to solve by using encapsulation and/or mutation.\n\nThe great thing about Python is that it's a multi-paradigm language: you can use whatever patterns that best fit your problem. You can write 95% of your code base in an immutable functional way, and use OOP for the 5% that fits it best.\n\nFor example, at work, I work with a ~20k lines-of-code codebase where almost all of it consists of dumb classes (pydantic BaseModels) and functions, but I use a few classes to manage state like database connections, messaging queue connections or shared caches. But most of the core business logic is written as simple functions, that are easy to write tests for.\n\nIn the code pattern that the rule actually is about (and not the what-if-we-make-it-do-10-things hypotheticals that get thrown around) replacing the class with just the inner method that takes the parameters explicitly adds no \"functional\" overhead. In fact passing them to a constructor, stuffing them on a class instance, taking them back out is a more owrk than just passing them to the function directly. \n\nThis is not about \"functional\" programming, its about .. when you have a plain old function, not unnecessarily chopping it in 2 and adding 0-value OOP cruft.", "id": "i16glhs", "owner_tier": 0.5, "score": 0.0612813370194986}, {"content": "The purpose of `class` is to give you the ability to define your own types. If you don't need that kind of abstraction, then it's generally better to go with a simpler construct, like a function or even a closure.\n\nHere's an example of a `class` with one method that I would consider a valid use:\n```python\nclass Settings:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def to_dict(self):\n        return {\n            \"a\": self.a\n            \"b\": self.b\n        }\n```\nyes we could store this as a dict. But the abstraction tells us something about what this type of object is, instead of just being a collection of `key: value` pairs.\n\nAnd as I eluded to, closures are how you would store state given a functional approach. Python has a `nonlocal` keyword which can override the scope of an enclosed function to include variables from outside the inner functions scope.\n\n```python\ndef counter(value=0):\n    def _count():\n        nonlocal value\n        value += 1\n        return value\n    return _count\n\n>>> c = counter()\n>>> c()\n1\n>>> c()\n2\n```\n\n>example of a class with one method that I would consider a valid use:\n\nFor something like that, I'd consider `TypedDict` or maybe `NamedTuple` to be a better fit.", "id": "i16n4u4", "owner_tier": 0.5, "score": 0.05571030637883008}, {"content": "It makes sense if you're just looking for that one bit of functionality but I wouldn't take this as a hard rule to apply to all one-method classes as often you want to make a class to inherit from which might make sense to have only one method, particularly if it's planned to expand in the future. \n\nWithout seeing what the guy in the video is actually saying it sounds quite rash and I wouldn't blindly start implementing that. \n\nTry to use the right thing for the right functionality, I would guess that's what the presenter is also trying to say\n\nThis right here.  All my one method classes are because it's the base class for a tree of happy horseshit to follow.", "id": "i16g2da", "owner_tier": 0.5, "score": 0.027855153175487462}, {"content": "I frequently use dataclasses without any methods as a replacement for named tuples.  \n\nHow would I replace a class with a function? Got any examples?\n\nSame here.  I like the clear and simple syntax.\n\nNamed tuple - after a \"higher-level\" initialization - creates a class. Like\n\n    Point = namedtuple('Point', 'x, y')\n\nCreates a class `Point` that may be later instantiated with values for attributes.\n\nNothing wrong with `dataclass` without methods.\n\nA dataclass is just fine for carrying around a bag of data. The rule of thumb being discussed is about a case where behavior is being represented as a class and yet the intermediate storage of data in the class adds no value as it could have just as easily been passed as function parameters to the method that implements the useful behavior.\n\nYou don't replace the class with a function. You replace the single method with a function and pass in the data structure (even if it is some small custom class based on a named tuple, but with no methods).", "id": "i16g5ku", "owner_tier": 0.5, "score": 0.016713091894150416}, {"content": "Here is a simple class I use for CLIs that have a `verbose` option.  In the main function you can set the option in class and use it in place of print.\n\n\n    class VerbosePrint:\n        def __init__(self, verbose: bool):\n            self.verbose = verbose\n    \n        def __call__(self, *args, **kwargs):\n            if self.verbose:\n                print(*args, **kwargs)\n\n\nIn the main function you can set :\n\n\n    def main(a, b, c, verbose):\n        vprint = VerbosePrint(verbose)\n        ...\n    \n        vprint('Some message')\n\nThis prevents having to make a bunch of if-blocks, and from referencing an out of local scope variable.\n\nBut you could just do:\n\n    def verbose_print(verbose):\n        def wrapper(*args, **kwargs):\n            if verbose:\n                print(*args, **kwargs)\n        return wrapper\n\nAnd then just have:\n\n    vprint = verbose_print(verbose=True)\n    vprint(\"Some message\")\n\nOr:\n\n    from functools import partial\n    \n    def verbose_print(verbose, *args, **kwargs):\n        if verbose:\n            print(*args, **kwargs)\n    \n    vprint = partial(verbose_print, True)\n    vprint(\"Some message\")\n\nYup", "id": "i17g9bu", "owner_tier": 0.7, "score": 0.03899721445682451}, {"content": "I disagree because you can store attributes such as variable in it.\n\nLike having multiple objects of a Dog class where you store info about them.\n\nDog1.colour\n\nIn that case, its not just a class with an init and multiple methods, its a class with one method and some publicly available properties. It doesn't fit the heuristic\n\nNot that you should do it, but you can also do it with a function.\n\n    def test():\n        return\n    test.x =  3\n    print(test.x)\n    >>> 3\n\nThat seems like a good example. Imagine a base class with a dozen attributes, and five subclasses that all need them. The alternative approach would be to define all dozen attributes in all five subclasses, which violates DRY.\n\nYou could just use a dictionary in that case. \n\nThe point being that unless you have a bunch of functions to mutate the state of the instance in different ways (or render state in different ways, or need to compare them etc.), then the mutations you would make are simple enough that you can just update a dictionary instead, or pass the dict or whatever to a function for that single mutation you are performing on the object.\n\nThen better write dataclass with methods needed\n\nSo when faed with \"if you have a class with a constructor and a single method\" you substitue for \"if you have a class with a constructor, a single method and a random assortment of other things\" and base your critique on that?\n\nThe rule of thumb is specifically about the pattern where you have a constructor that captures a couple of parameters and a method that makes use of them, and the class does nothing else. In essence Foo(a,b).do\\_it(c) is just an awkward way to write do\\_foo(a,b,c).\n\nIf you have other fields or the class does other things apart from being a place to temporarily park function parameters then it does not match the rule.\n\nIf you just want to capture function parameters in 2 (or more) stages for whatever reason, there is functools.partial for that, no need to create an ad-hoc class.\n\nWoa, I've never seen this.\n\n>  base class with a dozen attributes, and five subclasses\n\nThen it's not a class with just a constructor and one method.\n\nIt's a class with a constructor, one method, and five subclasses and this rule no longer applies.\n\nDRY?\n\nA dictionary is a garbage choice for that. At least use a dataclass.", "id": "i16ftit", "owner_tier": 0.1, "score": 0.10863509746518106}, {"content": "> > \"If a class is just a constructor and one method, then it shouldn't be a class at all. It should be a function.\"\n\nI don't think it's quite right to look at a class with just a single method and think \"that's wrong\" or that it's a misuse of OOP. It's a minor design detail, really. \n\nThe existence of and use cases for things like `SimpleNamespace` and `dataclasses` would probably also serve as decent counter-examples to that statement.\n\nI tend to favor classes as they are more mailable (useful to users of my code) than functions.\n\n>The existence of and use cases for things like SimpleNamespace and dataclasses would probably also serve as decent counter-examples to that statement.\n\nDataclasses didn't exist at the time the \"Stop Writing Classes\" presentation was made.   Jack Deiderick is a core python developer, so he does know a thing or two.  \n\nIMO, a dataclass isn't a class, so you're not even writing a class.  You're writing a bag of data that could have been a dictionary or a tuple or namedtuple or whatever.  It just has a name, which is useful (ever try to decode a list of lists of lists of 18 floats?).  It's ever so slightly faster than a namedtuple and doesn't equal to a an unlike bag of data (date=(2022,3,18) vs. xyz=(2022,3,18)).\n\nReally depends. Do you need something that changes state and do you need multiple instance of that state. Think of any class that might do a interview coding problem like get all the primes and you need to make a method next_prime(). Of course you could do it some other way as well.\n\nThe point of a dataclass is to contain data. The pattern being advocated against is a class whose primary purpose is that one method, and any state is just function parameters (perhaps captured earlier) in disguise.\n\n> Dataclasses didn't exist at the time the \"Stop Writing Classes\" presentation was made. Jack Deiderick is a core python developer, so he does know a thing or two.\n\nSure. I don't think I ever implied anything different. \n\nFunny enough, the exact same year at PyCon, in fact _just_ before Jack's talk, Raymond Hettinger gave a talk on [The Art of Subclassing](https://www.youtube.com/watch?v=miGolgp9xq8) which makes almost the opposite argument (which Raymond points out at the beginning of the talk).\n\nJust so far as to say, reasonable people can disagree; it's a design decision.\n\nYeah, I think it should go without saying that, like most things, _it depends_. It would be a bit silly to say you should always do one or the other.\n\nOn balance, if I have a tossup in my mind about what decision to make, I tend to lean towards making classes. Maybe because I've been burned too many times by (others) choosing functions.\n\nAs an attempt to illustrate: I hate it whenever I need to change the behavior of some module that's just a collection of inter-related functions.\n\n\n\n    # annoying_module.py\n    def foo(...):\n        ...  # like 10 lines of code\n        x = bar(...)\n        ... # another 10 or 15 lines of code\n        return baz(x)\n\n\nNow, imagine I'm a user of `annoying_module.foo`. I really like this module, it does a lot of things really well. Though, I want to modify the process of one of its dependent functions, `bar`, so that when I call `annoying_module.foo` it will use _my_ function instead of `annoying_module.bar`. \n\n\nIf `annoying_module` had used a class to define its functionality, it would be relatively simple to subclass and alter the behavior of the `bar` member. Unless you're willing/able to resort to monkey-patching, there's no easy way for me, as a user, to minimally alter `annoying_module`'s behavior when it uses functions.\n\nThat's hilarious.  I haven't seen that one.  I'll give it a watch.\n\nI definitely disagree with Jack's simplification.  I think it's a bit too obtuse, but it's not my codebase.  How \"obtuse\" something is depends entirely on your skill as a programmer and the strength of your team.  If you're the best person on your team or writing something for people that aren't as good as you, be a bit more explicit.\n\nI dislike functional programming, which is what Jack was pushing for, but it does have it's place.  It's a tool at the end of the day.", "id": "i16h2lv", "owner_tier": 0.7, "score": 0.013927576573816157}, {"content": "I love how this is implemented with react hooks. Makes whole web pages into functions, how useful.", "id": "i16i4n3", "owner_tier": 0.5, "score": -2.7855153034053735e-11}, {"content": "Hey OP, is this the video that you mention?\nhttps://youtu.be/5ZKvwuZSiyc\nIt's quite old actually and pretty hard to find. Fortunately I've had it in my YouTube history :)", "id": "i16k4w9", "owner_tier": 0.1, "score": -2.7855153034053735e-11}, {"content": "1) You might want a functor\n2) You might want to track some class attributes rather than just instance ones\n3) You might want to leave room for it to become more complicated later in production\n\n\nI know it's trendy right right now to try and avoid OOP, but a nice neat OOP that your whole team can maintain easily is a million times better than a bunch of function factories that you have to explain to every new dev who looks at it", "id": "i17aevi", "owner_tier": 0.5, "score": -2.7855153034053735e-11}, {"content": "I don\u2019t agree. Currying initial state into a first-class function and then passing it around, is less readable than just using the classic Command design pattern (which is, you guessed it, a class with a constructor and one method).\n\nThe first one is more common in languages that don\u2019t really support OOP. Liked LISP, Scheme, Haskell and JavaScript. Python has better OOP support than those languages.", "id": "i17aqaw", "owner_tier": 0.7, "score": -2.7855153034053735e-11}, {"content": "If a class only inits itself with one method, it is just a function by output. But the methods are still classify-able. This extends its utility, beyond the scope of a function, however, it may appear to act like a function by execution alone. \n\nKinda falls under the headache-inducing paradox of schrodingers box. \u201cIf there is py script running and inside that file there are functions , you won\u2019t know if the function is within a single method class until debugged upon\u201d \n\n\nSince a class is an abstract data class and essentially a blueprint, yes the blueprint could act like a function by being self-initiated with one method. In fact it would just be a blueprint or container that contains a defined function. \n\nImagine for a minute, \n\nyou are examining a dog, you have never seen a dogs paw before, you point to the paw of the dog and you ask your dim friend, \n\n\u201c what is this?!\u201d \n\nand they said, \u201cit\u2019s a dog\u201d.", "id": "i17o4js", "owner_tier": 0.1, "score": -2.7855153034053735e-11}, {"content": "It kinda is true. Unless your stuff purely has to do with data like a NamedTuple or something along those lines, there really isn't much of a reason to have a separate class.", "id": "i17vwca", "owner_tier": 0.5, "score": -2.7855153034053735e-11}, {"content": "ive seen some classes where the method doesnt even make use of self. OOP for the sake of OOP makes me want to toaster bath", "id": "i18z4ug", "owner_tier": 0.5, "score": -2.7855153034053735e-11}], "link": "https://www.reddit.com/r/Python/comments/th6ztt/ive_heard_that_if_a_class_is_just_a_constructor/", "question": {"content": "I watched a seminar a few years ago about someone talking about the misuses of OOP in python and talked extensively about the case where people write a class, implement the `__init__()` method and one extra method and that's it.\n\nHe provided examples and showed functional code that simplifies the solution to a few lines and he said:\n\n> \"If a class is just a constructor and one method, then it shouldn't be a class at all. It should be a function.\"\n\nI can't find the video anymore, but I was just wondering what reddit thinks about this statement and if you have any counter examples or in what cases it could be useful.\n\nI'm also interested in the cases where if it is true, how would that functional implementation look like when I need some sort of a state to persist.\n\n\nEDIT: Awesome discussion in the comments. Thanks for everyone's input!", "id": "th6ztt", "title": "I've heard that \"if a class is just a constructor and one method, then it should be a function\". What is your opinion on this and what are counter examples?", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "That\u2019s what happens when you let Java devs do python?\n\nI worked in a team like that, we had multiple empty classes", "id": "jdo97e1", "owner_tier": 0.3, "score": 0.6470588235076252}, {"content": "Okay dumbass moment, but the hell is the point of \"factory\" classes anyways?\n\nLike even in Java, it seems like abstraction for the point of abstraction\n\nFactory classes are a design pattern that is used when you don't know what subclass will be called beforehand.\n\nFor example: You have a Tetronimo() class, with each Tetris piece being a subclass.  The game knows that every time you add a piece to the board, it will be a Tetronimo(), but it could be an LPiece(), a TPiece(), an IPiece() or so on.  So you make a Tetronimo.generate() method that returns a Tetronimo() subclass when you ask for one.\n\nYou can read more [here](https://refactoring.guru/design-patterns/factory-method), hope this helps!\n\nI've found the factory pattern useful when creating unit tests to abstract away creation details of classes for objects from a database ORM (e.g. I don't want to have to specify first name, last name, signup date etc for every User I create in a test if it's only relevant that they have different Usernames). If done well it can help minimise code duplication in the setups for your tests and allow changes to be more easily made to the class without fear of having to fix 100 broken tests.\n\nAllows other people to write tests faster using those class instances as well assuming you have good defaults and parameters.\n\nAnother simple use case is just when you need to create a bunch of the same object all over the place, but want to keep your code DRY. So instead of repeating\n\n    var client = new HttpClient(baseAddress);\n    client.DefaultRequestHeaders.Add(\"apiKey\", apiKey);\n    client...\n\nall over the place, you can use\n\n    HttpClientFactory.CreateClient();\n\nAnd only have to define the basics once\n\nThere are some answers here: https://softwareengineering.stackexchange.com/questions/200647/why-is-the-factory-method-design-pattern-more-useful-than-having-classes-and-cal\n\nI feel most heavy OOP codebases (whether by decision or language) end up with lots of this kind of garbage in them.\n\nYour question has been answered but just would like to add that it's good to know your design patterns, get asked alot on interviews as well in my experience\n\nAs people other already mentioned, it\u2019s to aid unit testing. I want to also chime in that static methods are in general bad for unit testing. They create hard wired dependencies which makes it difficult to isolate the code you actually want to test.\n\nA constructor is a form of a static method. Using them creates hard wired dependencies, which makes your code less testable. With factories you convert the bad static method (the constructor) to a class method, which makes it more easy to isolate your tests with e.g. mocking.\n\nHowever, it doesn\u2019t look like that was the intention with OP\u2019s code. I don\u2019t see what\u2019s to gain with this factory. OP\u2019s code is just a terrible abstraction for the sake of abstraction.\n\nThere are two cases there:\n\n1) You just want a function that encapsulates few steps needed to build an object. This could be a free function, but you language does not support free functions, so just make it a static function in an otherwise dummy class.\n\n2) You need to abstract other different ways of constructing an object. Maybe you want different implementations with same interface/base class. Or it can be just one specific class, but you still want to abstract over which parameters are passed to the initializer. And you can\u2019t just pass an instance, because you want control over when and how many instances are created to be in the callee. So you pass a factory object. If factory interface has a single method, it many languages you can pass anonymous function without declaring separate interface and writing implementation as a class. But Java has its own limitations.\n\nFactory classes are also useful to enforce immutability.  Many OO practitioners consider immutability of instances to be a Good Thing, ie, you should never really have 'setters', and all of the object's dependencies should be provided at object creation time.  So if you need an object of type X that has N dependencies, but one of those dependencies isn't available just yet, you can instead work with an (immutable) XFactory object that has the N-1 dependencies and can create an instance of X once given that last dependency.  Then everything is nice and immutable.  \n\nCompare this to the non factory situation where you would have a mostly-constructed X and then you would still need to call setProperty() later to provide that final missing dependency.  This is a design smell because you can't always guarantee that all instances of X are valid or well-formed, etc...\n\nOh, so runtime decisions.\n\nEvery time I've seen this it's always a SomeRandomClassBuilderFactory that makes a SomeRandomClassBuilder, which itself makes a SomeRandomClass\n\nNone of which have any real logic in them. Like, that's just `new` with extra steps", "id": "jdoob2f", "owner_tier": 0.7, "score": 0.9999999999782135}, {"content": "What's so bad about this? This ensures that ff_value and string is never mistyped\n\nMaking it an enum would be better. They could have also saved the factory and just put the make in the pseudo enum class they already have but that\u2019s mostly semantics.\n\nLike many things in programming horror, this isn\u2019t actually that horrible just kind of a small over sight if it was made ground up like this. That said it could have easily been far more complicated at one time justifying a factory and changing requirements could have lead to this design.\n\nI think it's honestly not that bad.\n\nProbably would be better to actually use a class instead of a dict though. Then you could just write a constructor instead of a weird factory.\n\nThe function is fine, but putting it in a class achieves nothing\n\nJunior devs being junior devs\n\nEnums are a fairly recent addition to Python.\n\nThat's what I would do. But everyone here seems to be talking about how you could just instantiate the direct directly.\n\nNah, this is senior java developer trying to write Python.\n\nSource: Am senior java dev that writes shitty Python code like this.\n\nAdded in 3.4, just 9 years ago.\n\nlol! thank you for the one honest and funny answer.\n\nI think in \u201cPython years\u201d that\u2019s recent. I know some Python folks who still have yet to migrate from 2.x", "id": "jdovxt8", "owner_tier": 0.5, "score": 0.42919389976034855}, {"content": "lol, this code is fine.  I don't know python but I can read and comprehend what it's doing.  One day, you will discover that writing clear code is much more important than whatever code you think would be better, here.\n\n>  One day, you will discover that writing clear code is much more important than whatever code you think would be better, here\n\nThere is absolutely nothing \"clear\" about this code lmao. And this says everything:\n\n> I don't know python\n\nThere you go. If you don't even know python -one of the easiest languages in the world- what in the world makes you think you are qualified to leave your comment?\n\n<-- Spotted the one who doesn't code on their phone very often.\n\nThe code is clear enough for me to get the gist without knowing the syntax.\n\nAnd what makes me qualified is the 40 years I have spent writing software professionally up till and including today.\n\nTry that gatekeeper shit on someone else.\n\nWho on earth voluntarily codes on their phone\n\nyou caught me.  I am definitely not going to code on a phone.\n\nI feel for the other programmers who had to deal with your trash code. \n\n>Try that gatekeeper shit on someone else.\n\nGatekeeping? Lmao. If you LITERALLY don't know python then what in the hell makes you think you can talk back to real programmers about the matter? You aren't some innocent beginner being denied help (what gatekeeping actually would be)- you are an arrogant snob who sucks at programming. Keep your idiotic comments to yourself.\n\nI wouldn\u2019t do anything real, but little one off scripts or very small personal projects when I have nothing else on me? It\u2019s reasonably doable.\n\n\nI\u2019m not sure how it was on topic though?\n\nI don't know python because I get paid.\n\nThat makes zero sense whatsoever. Which figures.\n\nYou'll understand when you start to get paid.\n\nYou're obviously a jr dev, at best, and you haven't spent any time working to maintain software over years of time.  Clear code is always better than clever shortcuts.", "id": "jdoz3dg", "owner_tier": 0.3, "score": 0.03267973854030501}, {"content": "How would you improve it?\n\n    from typing import NamedTuple\n    class ProxyType(NamedTuple):\n        ff_value: str\n        string: str\n\n    class Proxies:\n        DIRECT = ProxyType(0, 'DIRECT')\n        MANUAL = ProxyType(1, 'MANUAL')\n        #...\n\nRemove the Factory class and just keep the function.\n\nhttps://youtube.com/watch?v=o9pEzgHorH0\n\nThanks! I don't know Python very well so was curious about it.\n\nIs it possible `NamedTuple` didn't exist when the code was written, and the code was fine back then?\n\nnamedTuple has existed in some form since Python 2.6 (2008) and this version since 3.6 (2016). \n\nBut it's possible that most Python developers simply aren't aware of it or prefer not to use it, since Python is a very flexible language.", "id": "jdp1vba", "owner_tier": 0.7, "score": 0.08714596947712418}, {"content": "Mfw he probably saved 30 minutes of work that equates to $300", "id": "jdpshbq", "owner_tier": 0.7, "score": 0.010893246165577342}, {"content": "\"Clean code\"", "id": "jdqut8y", "owner_tier": 0.3, "score": 0.0043572984531590414}, {"content": "when you wanna do OOP but you forget to KISS it \ud83d\ude18", "id": "jdouskk", "owner_tier": 0.5, "score": 0.0021786492156862748}, {"content": "I always wanted to have a factory. Now i am complete, i used all the GOF patterns", "id": "jdqhbuz", "owner_tier": 0.3, "score": 0.0021786492156862748}, {"content": "Should have been a data class instead, but this was probably done before that existed.", "id": "jebva00", "owner_tier": 0.3, "score": -2.1786492242320894e-11}, {"content": "Better yet:\n\n```py\nclass ProxyType:\n    def __init__(self) -> None:\n        strings = enumerate([\n            \"DIRECT\",\n            \"MANUAL\",\n            \"PAC\",\n            \"RESERVED1\",\n            \"AUTODETECT\",\n            \"SYSTEM\",\n            \"UNSPECIFIED\"\n        ], 0)\n\n        [(self.__dict__.update({x: {\"ff_value\": i, \"string\": x}})) for i, x in strings]\n```\n\nEven better yet:\n\n    import enum\n\n    class ProxyType(enum.Enum):\n        DIRECT = 0\n        MANUAL = 1\n        PAC = 2\n        RESERVED1 = 3\n        AUTODETECT = 4\n        SYSTEM = 7\n        UNSPECIFIED = 8\n\n(I like to make code maintenance impossible)\n\nuntil you need to ever add another field with more information about a proxy type\n\nNice, however the amount of down votes is honestly crazy \ud83e\udd69\ud83d\udeb2\n\nI forget the details but you can create enums with extra attributes just for that situation. Like if you made enums for different colors, you can give each one multiple attributes so you can do things like Color.RED.hex and Color.RED.rgb\n\ngiven that the value it's representing is patently an enum, I don't see an issue. And in case there's another property you'd want to uniquely associate per variant, you'd just have a getter function that switches on it/does a dict lookup (or maybe there are decorators that can do this or something)\n\nYAGNI", "id": "jdorucy", "owner_tier": 0.1, "score": 0.07625272328976035}], "link": "https://www.reddit.com/r/programminghorror/comments/121zydc/found_in_the_python_selenium_code_base_imagine/", "question": {"content": "", "id": "121zydc", "title": "Found in the Python Selenium code base. Imagine how much time was saved with this abstraction", "traffic_rate": 76.3728362183755}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "I can't say that I know the answer to your question, but I can give you my perspective.  \n\nI am an astrophysicist who works with simulations and simulation data.  Most of my work is fairly linear in nature meaning that I do A then B to get to C.  I then proceed to plot C or do further data manipulation/reduction/etc.  Early in grad school I picked up *C* as it was the language my adviser used; but that quickly got tiresome as I was always writing new code to output ASCII files for plotting.  \n\nOnce I started using python all of that changed since I could do the calculations and the plotting in the same place with simple scripts (no compilation) and results started to come a lot quicker.  However, I was still doing things in a linear fashion and storing large arrays with multiple indexes to represent different properties.  And it ended up that if I wanted to plot data from multiple simulations I had to save those arrays to a file (npz in my case) and remember all of my indexes and naming conventions.  This became a pain when I started changing or adding things to those modules and the indexes/names changed.\n\nIt wasn't until recently (August) that I discovered object-oriented programming and how to use it in python.  I have since rewritten my entire analysis suite (that I spent the previous 6 months working on) to be object-oriented.  Not only is my code cleaner, shorter, and easier to read/maintain/edit/add/subtract - it's much more user friendly.  I can now plot multiple datasets with ease, and access information much quicker without having to write entire new scripts.  I personally don't use methods very often in each of my classes, but having individual objects each with their own set of attributes has proved immensely helpful in my work.  I like to think of the classes as python's structures.\n\nAnyway, hope that helps!\n\n[deleted]\n\nhow did you learn? I've been trying to find resources but I can't find anything. I think I've been using the wrong keywords\n\nI'm guessing something along the lines of[ another example](http://www.reddit.com/r/Python/comments/1qvoop/ive_been_using_python_for_3_years_and_ive_never/cdh2enm) in this thread.\n\nIt's difficult to cite specific examples because the code has changed so drastically (was completely rewritten).  What I've built now is more of a 'framework' rather than just a set of functions.\n\nOne thing we can look at is data handling and the convenience of keeping track of it all.  My simulations typically have thousands of galaxies with an array of different properties.  Each has a gas mass, stellar mass, radius, star formation rate, metallicity just to name a few properties.  To store this data in a non-object oriented python way I simply created large arrays for each of these properties.  To get access to this data I just cycled through the galaxy indexes and all was well.  The problem comes when I want to expand upon this.  For example, I'd like to know exactly what gas & star particles belong to each galaxy, or I'd like to know what dark matter halo each galaxy resides in, and maybe even the properties of that halo as well.  This could probably be done with an array of lists or some other fancy method, but things were already starting to get messy.\n\nThe real question is: which approach is more appealing to you?  In my case the choice was between:\n\n1. Creating a large array for each galaxy property\n2. Creating an object for each galaxy\n\nFor me the second choice has turned out to be far more productive.  I can easily list and access the attributes of each individual galaxy without having to remember much about the structure of the arrays.  \n\nAnother benefit for me has turned out to be in my plotting routines.  I would read in data from a dataset, plot it, read in another dataset overwriting the variables from the previous dataset, plot it, etc etc.  Now I simply create a new object that holds all datasets of interest, and cycle through that; basically my plotting scripts have become more general and dynamic.\n\nI think what it all boils down to in my example is working with actual variable names as opposed to indexes.  So if I want to get the radius of galaxy 10 I can get it via approach 1 or 2:\n\n1. `radius[10]`\n2. `galaxies[10].radius`\n\nWhich I find the second to be far more intuitive to think about, especially when each galaxy has 10-20 properties associated with it.  Additionally, I could have galaxy specific functions (methods), create a class for each type of galaxy that inherits from the parent class, use polymorphism to redefine those galaxy specific methods, and all kinds of other stuff I don't know how to use very efficiently =)  I think the benefits of using classes even in the simplest cases speak for themselves once you start to use them.\n\n*All of what I have done is certainly doable without having to invoke classes, but I find using them to much cleaner and far more convenient*.  Hope that helps, if not let me know and I'll see about posting some code somewhere.\n\nI don't know about his case, but I can provide an useful example extrapolated from my work.   Part of my work involves using mixtures  of a large number of multi-dimensional Gaussians to describe my data.  I'll stick to single univariate Gaussians/Normals to illustrate my points though.   I've found one of the easiest ways to introduce object oriented programing is to describe it as a way to encapsulate data collections and common operations on that data into a single 'entity'.\n\nA normal distribution is parameterized by it's mean an variance.  And you'll typically want to evaluate things like the PDF or CDF of a normal, or calculate the likelihood or log-likelihood, or even perform affine transformations.  In a functional style each of those would be a function, that operates on the mean and variance ie:\n\ndef normalPDF(x,mean,var) ...\n\ndef normalCDF(x,mean,var) ...\n\n...\n\nwhich isn't so bad, unless you're dealing with large numbers of them, in which case you'll need some bookkeeping to keep your means and covariances paid up correctly.  And lets get back to the affine transform of a normal.  Functionally it'd probably look like:\n\ndef affineNormal(A,b,mean,var)\n\n...\n\nand return the new mean and variance of the transformed normal, but if you started using that in a bunch of places in the code, it'd probably get a little awkward as you'd be having to bookkeep two new values.\n\nWhat if we defined an object to represent our normal instead?  Recall we're describing a single distribution, that is parameterized by two values, so wouldn't it be nice to just treat it as a single thing (a distribution) as opposed to the two things that parameterize it?\n\nClass Normal:\n\n    def __init__(self, mean, var):\n        self.mean = mean\n        self.var = var\n...\n\nthis makes this easier for bookkeeping, as the object keeps the mean and variance together for us.  Heck if we've already written the functional version of the PDF or CDF we can exploit them as methods in our object:\n\n    def pdf(x):\n        return NormalPDF(x,self.mean,self.var)\n\n\nBut real saving comes from functions like our affine transform, as we can overload the arithmetic operators (+/- etc).\n\n    def __add__(self, k):\n        new_mean = self.mean + k\n        return Normal(new_mean, self.var)\n\nthis way we can make our affine transformations of normals much easier to read as we can directly say:\n\nX = Normal(0,1)\n\nnew_X = X+4\n\nwhich can be a lot clearer than walking through the rules for transforms of normals.\n\n\nI had a difficult time wrapping my head around the concept of object-oriented programming at first.  It took a few Lynda tutorials my buddy had to convince me it was worth putting some time into, but I'm glad I did.  The best way to learn something IMO is to actually do it.  Sit down with [an example such as this site](http://www.tutorialspoint.com/python/python_classes_objects.htm),  try it for yourself and experiment.\n\nI'd use named tuples for this use case. Sets of data with named properties are perfect for named tuples. Unless these guys are changing state and have lots of methods associated with them, I'd use named tuples with some functional programming style\n\nTo expand on that, classes arent used just for having named properties. If that's the only reason, even dicts ~~are~~ might be better for that.\n\nConsider classes for design patterns but not simply for the sake of having named properties and a method or two.\n\nEdit: \"stateful\" is a keyword that hints towards using classes too.\n\nCan you post an example of the work you do with the data you get? I was gonna get some instructions from a professor doing research in gravitational waves\n\nNoob here. Are tuples mutable?", "id": "cdh1oil", "owner_tier": 0.3, "score": 0.5714285713392857}, {"content": "What kind of data structures do you find yourself using usually?  Are you just implementing your own ad-hoc \"classes\" via dicts or lists?\n\n\n\n \n\nThis is the question that came to my mind, also.  Do you end up with lots of arrays or dicts that share the same keys, so that one data point is a key with values in different tables?  If so, classes would let you instead have a single array of data points, each of which has several named fields:\n\n    cat_colors[12] = 'orange' // color of cat 12\n    cat_weights[12] = 13 // weight of cat 12\n\nvs.\n\n    cats[12].color = 'orange' // color of cat 12\n    cats[12].weight = 13 // weight of cat 12\n\nThat can be convenient, but it is more about c-style structs than classes.  \n\nMy typical data structure consists of large textual documents, so I use lots of flat files for storage. For smaller pieces of text, like user reviews, I generally use CSV files for each item where every row in the CSV file relates to a user review for that item.\n\nI also have a couple TB of metadata related to the large text documents. This includes statistics about the document (ngrams, tf-idf, sentiment, and other related NLP stuff) along with quantitative and qualitative metadata. For this I typically use lists of tuples before storing it in the SQL database (MariaDB) used by the APIs to access it. Most of the memory on the database server is used for in-memory tables which make things really fast.\n\nWhen analyzing the metadata I typically load things in pandas/numpy/statsmodels to do my statistical analyses.\n\nSo my data structures are not very interesting. I would be curious if anyone had a better solution for storing ~700k large textual documents (avg size is about 6MB) other than flat files.\n\nNamedtuple has replaced those for me. \n\nPersonally, I've never had any great need for my own classes in data processing, I find myself just using higher dimensional numpy ndarrays. Only needing to store numerical values kinda helps.\n\nFor large possibly multi-d (text) files I usually reach for hdf5. I've found it strikes a pleasant balance between simplicity, speed and interoperability.\n\nFor high volumes of structured metadata I often use a  BSON format. With a good implementation it is highly compact and screaming fast. \n\nI try to avoid kv stores and other in mem databases unless I need concurrent connections and/or good indexing. \n :-)\n\nSame. Using `__new__` isn't a big deal, and the forced immutability makes functional-style programming easier. Usually I find myself using this pattern:\n\n    class Foo(namedtuple('Foo', ('foo', 'bar'))):\n        #Foo methods\n\nSo the data layout is fixed, but I can still have some basic methods or properties.\n\n... or a dotdict\n\ncute. i'll have to remember that. i guess you can't have anything in __init__ that would set attributes, though, right?\n\nnamedtuples also have a `_source` attribute that contains the source code for the namedtuple.\n\nWhat's wrong with \\_\\_slots\\_\\_", "id": "cdh16vx", "owner_tier": 0.5, "score": 0.9999999999107143}, {"content": "Post an example of your code?\n\nOr, post this question and an example of your code to http://codereview.stackexchange.com .\n\nNeat! How long has that site been available?\n\nSince [Jan 20, 2011](http://area51.stackexchange.com/proposals/11464/code-review).", "id": "cdh2p1j", "owner_tier": 0.3, "score": 0.37499999991071425}, {"content": "I use classes very sparingly in Python. Really, I mostly use them to wrap complex state, like C libraries or GUI objects or Test Suites. I also use classes to mimic other types using magic methods such as `__index__` and `__next__` and `__enter__`.\n\nBut all those are very specific use cases. Outside of these things, I prefer to organize my code around functions and modules. Those magic methods can be used to great effect, though. \n\nI use a lot of modules. I like breaking my code up into many modules that contain only the functions/libs used by that logical chunk. Often the script I actually run is maybe 10-20 lines of code because  everything that that's more static (like a function or logical procedure) is defined in another module which I import in.\n\nThen you're already practicing a rudimentary form of object oriented programming.  \n\nNow imagine that your \"module\" can have a lifetime of its own with some private data that only it should modify and see, and some public data that any other class can use, and that new modules can be based on the old one through inheritance, and you'll start to get an idea of what OO brings to the table.  Throw in polymorphism, which is just a fancy way of saying that we can treat all objects of a certain category the same even though the actual behavior for each object might vary according to its sub-type (and without using a bunch of if statements), and you find that you'll be able to simplify your code in some surprising ways.\n\nDon't get me wrong - I think structured programming is just fine for a large category of problems, especially the linear analytical problems you seem to be dealing with, but OOP can help organize to help you solve the problem.\n\nDo you have any suggestions for guides on Python classes? I do a lot of data churning and I often find myself thinking that while my code gets the job done, that I'm probably doing things far from the best way possible.\n\nI generally don't have to share my code but I sometimes feel like it takes more effort than it should for me to dissect what the hell I was doing in a script if I don't look at it for a few months.\n\nThe next time you're working with a module, pay attention to how you group your functions.  Most programmers tend to put the related functions all in one module.  Notice how those functions all tend to operate on that same kind of data.  Now, you might be passing around big tuples of stuff right now where you have to remember what data is in each slot.  That works fine, but wouldn't it be nice to have a name for each of those instead?  Voila!  You've just discovered some fields or properties you can make for your first class.\n\nSo, for example, if you have employee_data.py module, make it an Employee.py class instead.  What are the functions of that?  What are the fields of that?  Now you can \"re-phrase\" your module as a class.  Then you need to discover how you use that class; where do you start?  With a module of course!  But instead of just importing the module, you have to create a new object based on your class.  Then you can use it.  You would create a new object for each Employee you would have in memory at one time.  All of the functions in your Employee module would be functions that operate on that specific Employee.  \n\nIn short, the best way to learn it is to just try it.  Start small and don't pay attention to fancy language, or complicated patterns, etc.  Just go with whatever makes sense.  Once you have your ah-ha moment around polymorphism, you will pretty much have arrived.\n\nThere are some half-decent Python OO examples here: http://www.tutorialspoint.com/python/python_classes_objects.htm\n", "id": "cdh0a2i", "owner_tier": 0.5, "score": 0.24999999991071428}, {"content": "\nAs soon as you have different kinds of data that should be worked upon the same way, and you make conditions\n\n    if foo.kind == \"widget\":\n       widget_doer(foo)\n    else:\n       general_doer(foo)\n\nyou should be using classes with the doer function in the class.\n\n    foo.doer()\n\nwhere the General.doer() does one thing and you extend General and make Widget.doer() do something else.\n\nConditions on kinds of data should be embedded in the kind of data it is, not in many places in your code.", "id": "cdh3sqw", "owner_tier": 0.7, "score": 0.08928571419642857}, {"content": "Good on you for asking!\n\nClasses aren't an ends in themselves, but object oriented programming can be a means to better interfaces and therefore testability, something that's hard to appreciate until you've seen it in the wild.\n\nTesting your code will give you and (maybe I'm giving them too much credit) peer reviewers more faith in your research.  *It will also make you a faster and more effective programmer.*\n\nIn much the same way that functions let you abstract groups of logical statements from what would otherwise be a giant piece of spaghetti code, classes will help you abstract data types and even some methods relevant to that data type.\n\nExample*: Imagine you're working with medical records and have two files.  One containing demographic information and another describing every single outpatient procedure.  You could pipe everything through scripts and end up with two giant variables that contain all the data so you can cross reference them using whatever functions you've got.  Or, you could have one set of \"people\" objects.  Each person object contains its own outpatient records so you can call person.has_heart_disease() or person.has_mental_health_condition() and get a boolean back.  You could read person.age and person.height and person.weight.  It's cleaner and more readable to use an object-oriented (class based) approach.\n\nNot only can you design small simple test cases, you can do fun stuff like:\n\n    visits_per_person = sum([person.emergency_room_visits for person in all_people])/len(all_people)\n\nWhich is oh-so-more-readable than most any set of functions.\n\nEven if you don't ever write a single automated test (write automated tests!!!) classes can help you decouple the \"what does this code do\" from the \"how does it do it?\".  (e.g. When you go to refactor your code as in the iterator instead of read-to-memory example you gave)\n\n*Real example from my own experience as a researcher.  I wish I had known in grad school what I know now.  I wrote a pile of functions (thousands of lines of code) and I could have done so much better.\n\nAny guides you can recommend on this? For the data I deal with it sounds like classes would potentially be helpful. \n\nI don't know that I have any guides I can recommend.  You might try looking for MOOCs or Open CourseWare courses that teach \"object oriented\" programming.\n\nI'm sure there are also dozens of good sources that are a bit lighter weight than a full course, but I don't know of any off the top of my head.", "id": "cdh3jy5", "owner_tier": 0.1, "score": 0.10714285705357142}, {"content": "I'd say if you do not need classes there is no real reason to use them. Python is great for scripting and writing small programs, which you usually don't need classes for. \n\nI'm not sure you are aware of it but when it comes to multi-processing python is a bit special, which can be read here: http://stackoverflow.com/questions/4496680/python-threads-all-executing-on-a-single-core\n\nI've had many situations where I have used classes in python, but most often I do not. In a sense your programming is more functional than object-oriented, which also can answer for why you do not use classes.\n\nBut I do not think you miss out on something though :)", "id": "cdh02lo", "owner_tier": 0.5, "score": 0.08035714276785713}, {"content": "Whether or not you use classes will depend a lot on what task you're trying to achieve. Right now I work as a research assistant in a psychology lab, and my time is split between creating experiments and analysing the results.\n\nCreating experiments (which you can think of as really simple, fairly shitty computer games) generally requires classes out the wazoo.\n\nData analysis, on the other hand, often just ends up being done with long scripts full of single expressions, one after the other. This is especially true for the simple analyses that are needed to analyse the results of a psychology experiment, where your main goal is to split the means of the different conditions up. Almost 0 classes, and often very few functions, apart from simple one line lambdas.\n\nI don't find it particularly odd that you've used no classes for the statistical side of things, but my limited knowledge of web dev leads me to think you might find some use for them there.\n\nOff-topic, but does your lab use Python-based experimental presentation software?  I'd love to, but I haven't found anything that meets my needs.\n\nipython notebook with reveal.js support\n\nMy lab mostly uses PsychToolbox for MATLAB. Right now I'm putting together an experiment using Pygame, since this experiment is more game-like than your average experiment and it helps to have concepts like sprites available. It seems like most of the presentation software for Python uses Pygame as a backend anyway, so I figured I might as well just use it directly.\n\nI've briefly poked around with PsychoPy, enough to see that it seems roughly on par with PsychToolbox, but haven't actually run any experiments with it yet. One thing I did see recently that I've been meaning to try out is [Expyriment](http://www.expyriment.org/), which seems to have a nice design,\n\nHave you tried psychopy?\n\nNow that's an interesting idea.  I've used reveal.js before, but I wouldn't have thought of knitting it together with iPython.\n\nCool, I'm also most comfortable with PsychToolbox.  Have to take a look at Expyriment, too.\n\nPerhaps this could be tweaked to fit your experiments: http://econwillow.sourceforge.net/\n\nI helped an economist doing experimental economics and game theory setup an experiment using willow in my final year of grad school and it was super intuitive. The interface is kind of bland, but so are most interfaces in social science experiments. :)\n\nNot yet, although that's the one that everyone mentions.  Any thoughts?\n\nYou don't have to do anything. nbconvert does it for you.\n\nhttp://ipython.org/ipython-doc/rel-1.0.0/interactive/nbconvert.html\n\nI used it for my undergrad thesis a while ago. I liked it back then. Lots of similar functionality to psychtoolbox. In the last two years they've put a lot of work into it and an experimental GUI that's supposed to be easy to use for novice programmers. It actually is pretty easy to use and will generate code for you. But if you want to make any non-standard stimuli or complicated animations you have to get into the nitty gritty and I think this scares some novices off. GUI aside, I found psychopy to be a pretty good replacement for psychtoolbox (which I'm back to using now because that's what we use in my current lab). ", "id": "cdh0gxs", "owner_tier": 0.1, "score": 0.16071428562499998}, {"content": "> So my question is: Given that I know how to get stuff done quickly, what am I really missing out on or shorting myself on by never using classes?\n\nIn traditional languages classes have a number of roles including\n\n* encapsulation\n\n* modelling objects with similar but non identical properties\n\nLets consider encapsulation first. Now obviously if you are collaborating you don't want to randly set variables inside someone else's module, but consider this:\n\n    class Walrus\n\n        def __enter__(): \n            print (\"enter\")\n            self.x = get_thing_from_shared_store()\n\n        def use ():\n            # do stuff with the shared thing\n            print (\"use\", self.x)\n\n        def __exit__():\n            print (\"exit\")\n            return_thing_to_shared_store (x)\n\nNow:\n    \n    >>> with Walrus () as p:\n    >>>    p.use ()\n    enter\n    use\n    exit\n\nWhy was this good? Well we automatically allocated and returned a shared resource, without chance of forgetting to put it back and causing a \"leak\"\n\nNow considiering similar but unrelated objects:\n\nFor example \"car\" and \"truck\" are both really types of vehicle. One has \"load cargo\" function and one has a \"load people\" function. All share drive. Without classes you'd have to store the type of each and you need to check what abilities it had before you loaded it. With classes you would define car and truck as child classes of vehicle, both with their own load function, then you could then just call load without needing to know if you had a car or truck.\n\n    class Vehicle:\n        def load (self):\n            print ( loading unknown type\")\n        def drive (self):\n            print (\"VROOOM\")\n\n    class Car (Vehicle):\n        def load (self):\n            print (\"loading passengers\")\n\n    class SportCar (Vehicle):\n        def load (self):\n            print (\"loading golf clubs\")\n        def drive (self):\n            print (\"moar vroom!\")\n\n    class Truck (Vehicle):\n        def load (self):\n            print (\"loading cargo\")\n\n    things = [Car(), Car(), Truck(), SportCar()]\n    for t in things:\n        t.load ()\n        t.drive()\n\nHow do we *easily* and *robustly* do this without classes? Note how tere 2 different drives (sport car has a faster one), otherwise it defaults to the base. Also everyone has a different cargo. Now in python the language is dynamic and you don't need classes to do this. However it's bit of a pain to do; you would probably  pass a function or a function name, and that makes debugging a lot harder.\n\nI'm guessing this is an unpopular topic and I don't want to be that guy, but your use of spaces is inconsistent. You seem to prefer using a space before a parenthesis, but on two lines you don't.\n\n[PEP8 also disagrees](http://www.python.org/dev/peps/pep-0008/#whitespace-in-expressions-and-statements) with your whitespace strategy and to add an argument to that: it makes it seem like (what's inside) the parentheses and the object's name aren't related while they are.\n\nThis is doable without classes as well.\n\ndefine functions that operate on stuff.  e.g.\n\n    def drive(d, ....):\n        print \"I'm driving %d mph\" % d\n\nDefine some data structures.  I realize namedtuple constructs classes without behaviours.\n\n    Car = namedtuple('Car','speed')\n    Truck = namedtuple('Truck','speed')\n\nbut you can do it with dicts too though the syntax changes.\n\n    car = dict{'speed'}\n\nIntegrate.\n\n    drive(foo, foo.speed)\nor \n    drive(foo, foo['speed'])\n\nOf the two, plus one you gave, one will be uglier.  Which one it is, is up to personal taste.  They both arrive at the same algorithm with different checks and balances, e.g. namedtuple is immutable, using Class new methods can be added and it's directly available per structure, , one has less state etc..\n\nAll we're doing is reordering the receiver and its data.\n\nYour first example can be done without explicitly defining a class:\n\n    from contextlib import contextmanager\n\n    @contextmanager\n    def walrus_use():\n        x = get_thing_from_shared_store()\n        print(\"use\", x)\n        yield x\n        print(\"exit\")\n        return_thing_to_shared_store(x)\n    \n\nYour second example could probably be done with [single dispatch generic functions](http://www.python.org/dev/peps/pep-0443/), but that will not be in python until 3.4 is released - you would need to use a third party library for now.  \n\nYou're right to mention it. However I just type stuff in and the code formatter in Pycharm's IDE deals with all of that. I don't even know where I am supposed or not supposed to put spaces in. BTW your spelling of parenthesis / parentheses is inconsistent :-)\n\n> Of the two, plus one you gave, one will be uglier.\n\nDon't care. Which is easier to maintain? That's important! :-)\n\nNot saying classes are the only correct way, but it's a good model for this kind of thing.\n\nOh come on. Is that easier and more robust (readable and maintainable) than just using plain classes? And we could *probably* use some kind of niche future feature?\n\nWhat would you do if you needed to supply multiple use functions? Repeat the boiler plate, pass a function, use a dict as a case/switch?\n\nI agree, nothing REQUIRES classes, just that the context manager pattern is a nice, safe way to do this, and it's fairly robust especially when others start tinkering with your code.\n\nActually, my spelling is correct, I just forgot an \"a\". Parentheses is the plural for of parenthesis (AFAIK). \n\nUsing classes as a namespacing mechanism where no state in a language like python doesn't buy you too much.  There are mechanisms such as dispatch tables which aren't only useful for class design.\n\ne.g. \n\n    if foo == 'foo':\n        foo()\n    elif foo == 'bar':\n        bar()\n         \nvs\n\n     stuff_to_do = {'foo': foo, 'bar': bar }\n     stuff_to_do[foo]()\n\nThe one big pitfall in OOP is the attn/love an OOP hierarchy needs.\n\ne.g. A car is a vehicle, as much as a plane.  Some helicopters have wheels, some don't.  But they both can fly.  Boats can float, as do some planes and helicopters etc.  You can go on and on and on.  Same with modelling shapes such as squares, circles, cones and so on.\n\nFor simple hierarchies where state exists, OOP is friggin AWESOME.  When it starts getting complex, keeping your hierarchies really shallow or non existent is key.  A fun example of a hierarchy that went wrong, but there's no backing out of it now without breaking source compatability, are mutable and immutable lists in scala.  Some methods do zilch.  In java, the same applies. Functions that throw stating these methods aren't used.\n\n\nDamn, you're right.", "id": "cdh2yae", "owner_tier": 0.1, "score": 0.24107142848214286}, {"content": "I guess the main things I'd ask are:\n\n1. How often do you end up with global variables?\n2. Do you find your functions end up with lots of arguments?\n3. When you use libraries, do you appreciate it when you get objects back? How would you deal with xml without classes, for instance?\n\nOne of the nice things about a class is that you get a namespace to track some little bits of state, but you can keep the state under control, so that you don't have to keep a note of what code touches that global variable. You know the variable can only be touched within the class.\n\nHere's a simple implementation of the Averaged Perceptron algorithm, a surprisingly okay way to learn a linear model for thousands or millions of features: https://github.com/sloria/textblob-aptagger/blob/master/textblob_aptagger/_perceptron.py\n\nThe gist of the algorithm is, we want to predict some class variable given some features. During training, we iteratively predict the training instances, and if we're wrong we'll tweak the weights, so that next time the correct class gets a higher score than it did this time.\n\nWithout a class, we have to thread the \"weights\" data structure through all the logic, passing it as a parameter. And during training, we need auxiliary data structures as well, for various book-keeping.", "id": "cdh40fk", "owner_tier": 0.3, "score": 0.026785714196428573}, {"content": "The main strength of object oriented program is polymorphism (aka message passing): you could have a list with multiple types of objects in it, call a method of each object, and have it behave differently depending on its type. You could also implement this with a list of functions with the same indexes, or by defining a list of dictionaries where each dictionary has some members that are functions (pretty much how Python implements classes), but then you're just avoiding the cleaner class syntax.\n\nA good example of this is the world wide web.  Each server is an object.  We have (evolving) standards that define what messages (methods) you can send to a server with what parameters, But each server decides how (and if) to respond to any messages it receives.  This would be infeasible to implement in a functional paradigm.\n\nObject oriented programing is extremely useful anytime you want to organize your code around different **types** of data structure, with each type having a whole suite of behavior for different situations.  **tl;dr:** OOP organizes code by type, instead of by situation. If you frequently have to edit one case in many different switch statements, OOP might have helped.  If you have simulated this, you simulated OOP.\n\nThe problem with most people's arguments for when to use object oriented code is that they always go straight to web and server examples. No one can give a good example that is directly applicable to scientific computing. The typical scientific computer is not worried about passing information across a server or reading some specialized stream. They have some physical system that needs to be manipulated in some way, usually with operations like passing it through an equation. How does one use object oriented code when they don't care about dealing with  servers, transfer protocols, etc. via objects? That is the answer to OP's question.\n\n\n\n\nYou stated that \n>Object oriented programing is extremely useful anytime you want to organize your code around different types of data structure\n\nThe issue with this from the standpoint of a scientific computing individual is that short of making objects for physical things (this wave is an object, that wave is an object, that car is an object, etc. and all of them will be acted on by forces of some sort), it typically doesn't make sense to do anything with objects. Or, to rephrase, it is typically more intuitive to not use the object paradigm and just design whatever operation you want to happen. I would love to be proven wrong because then I could justify OO programming with respect to scientific computing. But short of the above scenario, I cannot see any good reason why it is needed for scientific computing. It obviously has uses in other paradigms. But that is beyond the scope of this discussion. \n\nHow often do you actually do that? I use classes plenty, but that basically just...never happens.\n\n\nThe term \"scientific computing\" is quite broad. Perhaps you don't find much use for OOP in *your* corner of scientific computing, but to extrapolate that to all scientific computing is ridiculous. For example, I make a ton of use of OOP concepts in my research, which is based around protein fragment libraries.\n\nI don't think anyone can argue that OOP is essential to any computing algorithms and it does NOT enable new classes of solutions that I've seen.  It's purely there for the programmer so that we, as humans, have a better chance of understanding what is going on in the system at a given point in time.  If it's not going to do that for you in your situation, then don't use it.\n\nOn the other hand, we could argue much the same point about structured programming.  A long time ago, there were very passionate arguments about all the computing time and memory that would be \"wasted\" with all of this horribly stupid jumping around in memory, continually shifting things on and off the stack to registers, and all of that just so you can call a \"function\" instead of just setting a register or two and jumping to the relevant set of instructions?!  \n\nThe problem with OOP though is that the benefits aren't always as clear cut; especially when someone has used it to create a design that defeats understanding by mere mortals.  Sometimes it's a good idea; sometimes not.  \n\nI really tried to explain the virtues of OOP in a way that wouldn't sound right for every case.  Scientific programming often requires doing identical operations to very large sets of data - OOP is especially bad at that, because it usually means less efficient memory layouts (every field of a struct is in the cache) and lots of virtual function lookups.  Might be useful in some subset of problems, though.\n\nDo message passing, you mean?  In game development I exploit polymorphism very often: call the .update() method of every object in the world, etc.  Also very handy for GUI work.  In other situations it might be a good idea less often, but if you default to hammer paradigm, everything looks like a nail I guess.\n\nWhat's a protein fragment? It's an object with properties which is the exact use case I said computational scientist would use it for. My argument was merely that it was the only case that a computational scientist would use if for. Thus, there is no reason for you to think we are in disagreement at all.\n\nI think I will just trust my intuition. So far I have determined the use that OOP would have for me in my line of work and searching the web has shown that intuition to be true. OOP has its place. It can have its place in scientific computing, but it is more likely that a functional paradigm is more appropriate in most cases.\n\nThere are some examples (like www servers) where OOP allows a division of code that makes new things feasible.\n\nI was taking issue with your use of the word \"typical.\" You claimed that OO is useless in scientific computing save for some \"marginal\" cases. My point is that perhaps they aren't marginal.\n\nI also suspect OO could be used to great benefit for modelling physical systems. I would love to prove you wrong, but I claim that evidence would require a constructive proof (e.g., code samples). Since I'm not involved in that type of research, I don't have the evidence required, unfortunately.", "id": "cdh2gg9", "owner_tier": 0.3, "score": 0.1339285713392857}, {"content": "Whatever works for you is fine, but have you tried using classes for any particular cases? I also use Python in a scientific environment, usually for scripting/automation or converting or processing data sets, so I tend to write a lot of short to-the-point scripts and one-offs. I had never used classes until quite recently. I had to expand a webscraping script so that it could scrape multiple pages instead of one. I ended up converting all the code for dealing with a webpage into a class and then starting using lists of pages. It ended up being very clean and I would guess that the code is much easier for someone else to use.", "id": "cdh37f3", "owner_tier": 0.3, "score": 0.008928571339285716}, {"content": "http://lucumr.pocoo.org/2013/2/13/moar-classes/\n\n[this](http://me.veekun.com/blog/2013/03/03/the-controller-pattern-is-awful-and-other-oo-heresy/) is a fairly good wrap-up:\n\n> Stop writing *stupid* classes.", "id": "cdh28u9", "owner_tier": 0.5, "score": 0.017857142767857142}, {"content": "Custom exceptions.\n\n    class MoreSpecificValueError(ValueError): pass\n\n\n:o cool!!", "id": "cdh3t3t", "owner_tier": 0.7, "score": 0.008928571339285716}, {"content": "I too avoid writing classes but I do love namespaces. Do you use them?", "id": "cdh4f81", "owner_tier": 0.3, "score": -8.928571374308295e-11}, {"content": "Most of what classes give you, you can get from other constructs. A class is really just a way of defining a data structure, and coupling it with the behaviors that operate on that data structure.\n\nWriting lots of little functions that mutate data and can then be strung together is a perfectly legitimate way to structure and aggregate code. That's the \"functional programming\" way, and it's very powerful and very extensible. There's a down side -- it can be very hard to read and debug -- but the up sides are fantastic in problem domains where your program's raison d'etre is to calculate a result.\n\nContrast that -- the focus on *calculating a result* with a typical desktop application's focus, which is on *entering and manipulating data objects*. In the latter case, you frequently have many different types of data objects, and you want to be able to mutate those specific data objects in response to application events -- button pushed, text typed, timer expired, whatever. Until the event occurs, you're not sure which manipulation you will want to perform.\n\nIn a program designed to calculate a result, an input gets heavily processed through several phases of computation. It might be useful to define classes here, and it might not: I could see cases where heterogenous input needed to be processed along a common axis, but with the heterogenous identity preserved. Named tuples or classes might serve this goal well. But the concept of the program is essentially a stream or blob of data that moves through a processing pipeline until an intermediate or final result is produced.\n\nIn a program designed to provide a set of interactive workflows, you can envision the data instead as a set of related data objects -- documents perhaps, or account credentials, or card catalog records, or all of the above -- upon which the program performs operations at the request of the user. The objects are like a lattice of interrelated data, waiting to be tickled or touched in exactly the right way. Classes fit this paradigm perfectly.\n\nMany problem domains can be conceived in either way, depending on the vision of the architect. That's why both OOP and FP are general-purpose paradigms. But I think some fit one style better than others. It sounds to me like OP's problem space orients strongly to the functional side of things. Classes might be useful there, but they might not be, too.", "id": "cdh6c79", "owner_tier": 0.1, "score": -8.928571374308295e-11}], "link": "https://www.reddit.com/r/Python/comments/1qvoop/ive_been_using_python_for_3_years_and_ive_never/", "question": {"content": "I consider myself a nearly advanced-level Python programmer. From data processing and statistical analysis to web development and systems administration of large clusters, I do it all regularly.\n\nI started using it in grad school for my research and now use it everyday in my job as a computational scientist. However, I simply do not use classes. I use functions for everything, often many small functions whose output I feed into another. For large highly parallel data processing tasks, I'll have one main worker function that does the heavy lifting on each item that I'll pass to a multiprocessing Pool. \n\nSo my question is: Given that I know how to get stuff done quickly, what am I really missing out on or shorting myself on by never using classes?", "id": "1qvoop", "title": "I've been using Python for 3 years and I've never defined a Class", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "On July 1st, a [change to Reddit's API pricing](https://www.reddit.com/r/reddit/comments/12qwagm/an_update_regarding_reddits_api/) will come into effect. [Several developers](https://www.reddit.com/r/redditisfun/comments/144gmfq/rif_will_shut_down_on_june_30_2023_in_response_to/) of commercial third-party apps have announced that this change will compel them to shut down their apps. At least [one accessibility-focused non-commercial third party app](https://www.reddit.com/r/DystopiaForReddit/comments/145e9sk/update_dystopia_will_continue_operating_for_free/) will continue to be available free of charge.\n\nIf you want to express your strong disagreement with the API pricing change or with Reddit's response to the backlash, you may want to consider the following options:\n\n1. Limiting your involvement with Reddit, or\n2. Temporarily refraining from using Reddit\n3. Cancelling your subscription of Reddit Premium\n\nas a way to voice your protest.\n\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*", "id": "k1e5qec", "owner_tier": 0.1, "score": 0.01851851833333333}, {"content": "List. Of() is immutable in java. Since java 11\n\n[deleted]\n\nlike?\n\nIts not deeply immutable. Its shallow immutable and its deep mutability depends on the mutability of the objects contained therein.\n\nJava cannot enforce deep immutability on mutable classes, so this is as immutable as it gets in Java.\n\nThere is a difference, but List.of returns a immutable list. You are probably thinking of methods in the Collections class that are doing that\n\nEdit: Corrected mutable to immutable (typo)\n\nunmodifiable list can be thought as a view of a collection.. you cannot change the collection itself through this view, but the original collection can be changed and that change reflected via the view so you can still observe adding or removing elements to or from the unmodifiable collection (given you still have the reference to the original one)\non the other hand immutable collection are standalone instances meaning they jave their own inner representation.\n\nconsider Arrays.asList(...), which wraps the incoming parameter array and that array cannot be changed  through the returned instance but you are free to change the elements of the array as you have full control over it.\nhope this answers your question\n\nIn oracles java lingo Immutable list would be something that would have also it's content elements not be modified(and it's basically up to you to not modify the objects in there).  \n\n\nHowever in most java like languages that have immutable named lists you can also modify the data in the objects that are in the 'immutable' list, and it just seems to be used as a substitute word for unmodifiable.\n\nNo, it is immutable. [Google is a hell if a thing](https://docs.oracle.com/javase/9/docs/api/java/util/List.html#of-E...-). The variable itself maybe mutable, the list is not\n\ni use both terms for the same thing: immutable lists (because i always talk about things from the \"owner's perspective\" of the variable) - i think the when talking about code, precision and clarity matter, so i call the other thing \"a view\". then it's always clear what i mean.\n\nIt was a typo, we talked about immutable vs unmodifiable\n\nNo, it's unmodifable.\n\nEdit: What's the difference? Unmodifiable collections are just wrappers that disallow mutation on this instance, but the underlying mutable collection can still be modified:\n\n    List<String> arrayList = new ArrayList<>();\n    List<String> unmodifiableList = Collections.unmodifiableList(arrayList);\n    arrayList.add(\"test\");\n    System.out.println(unmodifiableList); // [\"test\"]\n    unmodifiableList.add(\"test\"); // Exception java.lang.UnsupportedOperationException", "id": "k1ehck5", "owner_tier": 0.3, "score": 0.9999999998148148}, {"content": "There is  the .copyOf static methods on them for copying into an immutable collections, as well as Collections.unmodifiable<collectiontype> for unmodifiable views.\n\nThese still expose the full api though and will throw exceptions if you try to modify. There is no way to add them with out making a separate immuutable interface which was decided to not be worth the comparability issues of having a new  separate interface for all collection types.\n\nGood implementations of immutable collections are usually persistent, though. They do not copy the full structure of the collections during modifications.\n\nI think it should be the other way around. I mean how an interface for an immutable collection would look like? Would be something that simply omits the add and remove methods and supports only the enumeration, would it not? Then we would use such interface accessing the data, then would need to have a MutableCollection or similarly named interface for performing modifications.\n\nYeah its not the most preferable implementation, though I understand the reason behind not making a separate interface for immutability and just making implementations of the existing apis. I normally work around this by creating then wrapping with Collections.unmodifiable at the creation and making sure the original modifiable reference falls out of scope. If that is not possible then encapsulating any access/getting of them via wrapping. Though with the second option there is still the chance someone later makes an edit not honoring this \"weak\" contract. Not really a problem with personal code, but in an environment where immutable is not an established norm and preferable I could see how this could go wrong and be a source of hard to find errors.\n\nThere's a fundamental problem of having an immutable collection interface: if the collection could be directly instantiated as immutable, how are you getting the elements into the list in the first place? Given that, it does make sense that you need to create the collection as modifiable and then make the immutable copy from it.\n\nYes. This is pretty much what kotlin does.\n\nThe issue your mention already exist with or without a super interface for the immutability anyway. That's the way currently it works in the JDK or am I missing something?", "id": "k1e7blf", "owner_tier": 0.5, "score": 0.8518518516666667}, {"content": "[Why don't they just... introduce ImmutableCollecton!?](https://youtu.be/ZN9bgpBdxAE?feature=shared&t=1812) by Nicolai Parlog.\n\nThe interface explosion was also mentioned by others.\n\nI have a hard time taking the argument seriously.\n\nFirst of all, there doesn't have to be any explosion of interfaces. You can introduce an independent system of persistent collections. Mutable and persistent collections sharing common ancestor interfaces provides almost no value.\n\nSecond, the argument that we can't have nice things because it would fragment the community could be applied to almost anything, even the features that have already been introduced to Java over the years. Virtual threads, records, sealed types, pattern matching, generics or non-nullable types via Valhalla. They all, at least in some sense, divide the community and libraries into those that utilize them and those that solve the problem at hand differently. And yet, it's very much worth it to have these features.\n\nDude in the video here. A more detailed version of these arguments can be found in [this blog post](https://nipafx.dev/immutable-collections-in-java/).\n\n> First of all, there doesn't have to be any explosion of interfaces. You can introduce an independent system of persistent collections.\n\nAs a single data point: [Vavr's `collection` package](https://www.javadoc.io/doc/io.vavr/vavr/latest/index.html) contains 45 public types. We can probably argue whether that counts as an \"explosion\" but I invite you to count how often Java added APIs that contain that many new, non-trivial types. As a reference for that: [`java.util.stream`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/package-summary.html) contains 16 (arguably, minus 9 that are conceptually identical to 3 others). Heck, even [`java.util.function`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html) has fewer than 45 public types and those are all conceptual one-liners.\n\n> Second, the argument that we can't have nice things because it would fragment the community could be applied to almost anything, even the features that have already been introduced to Java over the years. Virtual threads, records, sealed types, pattern matching, generics or non-nullable types via Valhalla.\n\nTL;DR: Unless you can explain how to introduce these types as seamlessly as all the other features you mentioned as reference, you're arguing for an unprecedented fragmentation of the ecosystem.\n\nNow, on to the long version...\n\n----\n\nYou could apply that argument, but you would be (mostly) wrong \ud83d\ude09:\n\n* If your code uses virtual threads but my library uses platform threads, they would still work together just fine (although with lower scalability than could be hoped for).\n* If you use pattern matching with sealed types and records, but I don't, that's ok and everybody can benefit from their choice in their code (although there's synergy left on the table from both using the same approach in similar situations).\n* It's interesting that you bring up generics because they were specifically designed to _not_ fragment the ecosystem (which is probably why you think that can't happen). Your code can use them while mine doesn't and it works together swimmingly (although you'd get more out of them, if I followed suit).\n\nThe pattern should be obvious: Every project can use the features they think work best for them without (too much of) a burden if their dependencies didn't adopt them yet. And while there's added benefit in all projects adopting new features, that can happen over time in a decentralized way because old and new can conveniently be used side by side (usually).\n\n----\n\nNow let's talk about introducing a persistent collection API that's unrelated to the existing interface hierarchy. Yes, your code can use the new API internally while my code doesn't and all will work great. But will it work great *together*? Because with the exception of generics, the features you mention are not particularly present at the boundary between projects. But collections are and that presents a big problem because you'd want to migrate from old to new (where suitable) without requiring a flag day where everybody updates.\n\nAs I see it (and please correct me if I'm wrong), for the JDK to use those types in its own public APIs at all, it would have to duplicate _all_ methods that accept or return a collection. That's bonkers. The other option I see is to add `toPersistent()` and `toClassic()` (or whatever) to the old and new types, respectively, which gives you an additional method call on every boundary between projects that use / don't use them yet. Maybe there's some compiler magic akin to (un)boxing that could be applied here, but that doesn't sound great, either. And all of that ignores that these collections work very differently and a transformation at the boundary might not even be correct because of that.\n\nThat means that every boundary that doesn't want to make a hard cut needs to exist in two versions and for projects that value backwards compatibility (like the JDK) both would live forever. Or version X of my library uses the old and version Y uses the new API and users have to migrate in one swoop while still having to deal with other projects that don't provide a new API yet. All this would require an amount of churn that is unprecedented in the Java community.\n\nRemember I said \"with the exception of generics\" earlier? One thing that stands out in their design is that a `List<String>` is a `List`. That is their saving grace! Without that, all the same logic would apply to them but (soon) 20 years earlier with billions of lines of code that would have to be changed fewer.\n\n>First of all, there doesn't have to be any explosion of interfaces. You can introduce an independent system of persistent collections.  \n>  \n>...  \n>  \n>Second, the argument that we can't have nice things because it would fragment the community could be applied to almost anything, even the features that have already been introduced to Java over the years.\n\nAgreed in order to do it \"right\" would essentially require a second Collections framework.  But Collections aren't just another library in Java, they are foundational to almost every project ever created.  With all features that create a \"new\" vs \"old\" dichotomy, the pros and cons of implementing that feature need to be considered.  In this case it's not at all clear that the pros of a second Collections framework provide all the much benefit over what is already available (e.g. `List.of()`, `Set.of()`, `Collections.unmodifiable...()`, etc.).  However, it's fairly trivial to see the cons of such an approach and how massive of a negative impact it would be.\n\nThere would probably have at least as many new interfaces and implementations as we have now (e.g. [vavr](https://docs.vavr.io/images/vavr-collections.png)). You don't want these types to live in a vacuum but want to use them with existing JDK API's so many of these would need overloads because conversions to and from classic Collection's all the time would be a real pita.\n\nIt's not impossible to do - Stuart Marks just mentioned yesterday that they could think about adding persistent collections someday or not - but it would be a monumental undertaking making it retrofit into the existing JDK without it looking nailed on.\n\nHello Nicolai, thank you for such a detailed response.\n\nThe points you raise are valid. Yes, there are challenges to introducing a whole new collections library to JDK.\n\nBut my point is more higher-level: I bet that Persistent collections will be added to Java simply because they're just so damn useful. Sooner or later, it will happen. They will find a way to make it work. Maybe even in the next-next LTS, which is 4 years. And I'm here complaining that if there were more enthusiasm regarding Persistent collections in JDK from the Java authors now, we may have them sooner, let's say next LTS, which is 2 years.\n\nObviously, I don't have a crystal ball. But I see the trajectory that Java has been going for the last years and I can guess where it leads. When Java 8 was released, almost 10 years ago, having immutable product types (records) and sum types (sealed interfaces) with pattern matching would have seemed totally alien and unfeasible, just like Persistent collections today. But they did arrive. It's just a bit pity they didn't arrive _sooner_.\n\n>it's not at all clear that the pros of a second Collections framework provide all the much benefit over what is already available (e.g. List.of(), Set.of(), Collections.unmodifiable...(), etc.).\n\nSorry, but no. The benefits of Persistent collections are very much clear. Persistent collections provide a totally new dimension of functionality compared to the currently existing examples `.of()` that you've mentioned.\n\nYou can read more about them here https://en.m.wikipedia.org/wiki/Persistent_data_structure\n\nThe \"concern about new vs old\" could be had about any significant improvement to Java over the last 10 years (or ever). I just don't find such an argument very convincing.\n\n\"monumental undertaking\" is the part that I disagree with. Persistent collections could be added relatively soonish if there were enough will on the part of Oracle.\n\nBut if I had to guess, it will probably be added unnecessarily late, just like other Java features...\n\n> They will find a way to make it work.\n\nMaybe they will but unless you yourself see a way to make it work, I recommend to take the arguments of the people who tell you why there might be no way, more seriously.\n\n> And I'm here complaining that if there were more enthusiasm regarding Persistent collections in JDK from the Java authors now, we may have them sooner, let's say next LTS, which is 2 years.\n\nBut that complaint entirely hinges on your belief in the existence of a solution that you yourself can't see. What if there isn't one?\n\n> When Java 8 was released, almost 10 years ago, having immutable product types (records) and sum types (sealed interfaces) with pattern matching would have seemed totally alien and unfeasible, just like Persistent collections today. \n\nThat's just plain wrong - records and sealed types didn't seem \"unfeasible\" back then (if you disagree, I challenge you to find quotes from OpenJDK members to support that claim) and it's not like it just needed more complaints for the feature to arrive sooner.\n\nIf they do it, they do it so it doesn't look tacked on, as if it were there from the start, integrated into the JVM. If you just want a persistent collection library, you can use [vavr](https://www.vavr.io/), [pcollections](https://pcollections.org/), [cyclopsx](https://github.com/aol/cyclops) or any other now.\n\nWe'll see in 4 years. I'm optimistic.", "id": "k1eb3c6", "owner_tier": 0.5, "score": 0.7407407405555555}, {"content": "`List.of(..)`, `Set.of(..)` and `Map.of(..)` are all immutable.\n\nI hate that `EnumSet.of` is mutable", "id": "k1ejxxh", "owner_tier": 0.3, "score": 0.5370370368518519}, {"content": "List.copyOf(xxx) is shallow immutable. Same with Set.\n\nYou also have Collections.unmodifiableList and Collections.unmodifiableSet if you wish to decorate instead of copy, that assumes the internal collection is not changed at the source.\n\nUnmodifiable is not the same as immutable.\n\nThe decorator is just a view onto an underlying collection. The underlying collection can still change and that will be reflected in the view.\n\nThe decorator version could be effectively immutable if the underlying collection is only referenced by the view.\n\nIf we mean pure immutability, then this is not something you can directly enforce at a language level anyway, because there isn't a true concept of \"deep immutability\" in Java. It is simply a best effort contract. This is converse to, say, C++ which has the concept of constness. The JVM itself only provides the concept of constness on specific value-like types.\n\n> Unmodifiable is not the same as immutable.\n\nI dispute this claim. Immutable is the same as unmodifiable. I can cite some authoritative sources:\n\nFrom the Cambridge dictionary (https://dictionary.cambridge.org/us/dictionary/english/immutable):\n\n> not changing, or unable to be changed:\n\nFrom Merriam-Webster (https://www.merriam-webster.com/dictionary/immutable):\n\n> not capable of or susceptible to change\n\nFrom wikipedia (https://en.wikipedia.org/wiki/Immutable_object):\n\n> In object-oriented (OO) and functional programming, an immutable object (unchangeable[1] object) is an object whose state cannot be modified after it is created.\n\nWhy are you talking about language level? Everything we talked about is not language-level. They are part of the standard library.\n\n\"*Unmodifiable* is actually a different concept\" - Stuart Marks\n\n[https://www.youtube.com/watch?v=q6zF3vf114M&t=2522s](https://www.youtube.com/watch?v=q6zF3vf114M&t=2522s)\n\nBut I'm sure two general-purpose dictionary definitions and wikipedia are \"more authoritative\".\n\nEven by this definition Java's unmodifiable lists are not immutable because their internal state can be mutated (without reflection): https://www.reddit.com/r/java/comments/16ngn2l/why_there_is_no_immutablecollectionlistset_in_jre/k1hjrhg/\n\n> I can cite some authoritative sources:\n\nNot a one of these is an authoritative source on programming terminology.\n\nBecause reflection exists that can bypass any form of immutable design. Likewise if you use a language like Scala with immutable patterns and then integrate with this code from another language that doesn't' support those specific patterns at the language level, then you risk breaking that contract.\n\nThe standard library provides no mechanism for true deep immutability, only shallow immutability and referential immutability which is what I addressed in the original comment that I made.\n\nWith runtime and language level features like reflection that can violate immutability, the concept in Java itself is not as relevant. You can follow good patterns, sure, but it isn't a guaranteed contract that is impossible to work around.\n\nThere are implementation differences in the Java standard library between collection types named \"Unmodifiable\" versus the collection types named \"Immutable\". Stuart Marks is talking about these and he's correct.\n\nThe dictionary is talking about the general definitions. An immutable collection has the same meaning as an unmodifiable collection. The dictionaries aren't even attempting to describe specific implementation issues within the Java standard library.\n\nThe Java standard library collection classes named unmodifiable, do let you modify them via modifying the underlying collection. Conceptually, you can't modify an unmodifiable collection. That would be a contradiction.\n\nSure. I agree. I'd still say the terms immutable and unmodifiable have the same meaning this context and Java's unmodifiable lists aren't really unmodifiable in the sense that you can modify them.", "id": "k1eebnx", "owner_tier": 0.7, "score": 0.48148148129629625}, {"content": "Java has immutable collections with `List.of` and similar.\n\nI believe you want persistently immutable collections, or just persistent collections, not merely immutable collections, where you can add/remove, but they give new references to new versions of the collection, while any old references continue to work and reference the old state before the changes.\n\nhttps://en.wikipedia.org//wiki/Persistent_data_structure", "id": "k1ejzsx", "owner_tier": 0.3, "score": 0.2037037035185185}, {"content": "Collections API has an old FAQ doc - first question addresses this design\n\n* [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-designfaq.html#a1](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-designfaq.html#a1)\n\nBasically, addressing different expectations leads to a combinatorial explosion of new abstractions. It was considered a sound engineering compromise to trade the problem of \"many competing abstractions\" for the problem of \"few abstractions, but don't assume you can mutate\".", "id": "k1euotk", "owner_tier": 0.1, "score": 0.16666666648148146}, {"content": "List.of(), Map.of(), Set.of()\n\nThis", "id": "k1ex4bf", "owner_tier": 0.1, "score": 0.12962962944444445}, {"content": "The problem would be how to retrofit the existing collections API.\n\nIf you would completely redesign java.util.Collections as well java.util.Iterable and java.util.Iterator, you would probably want to start with immutable collections.\n\nI will only use sets in the following for ease of writing, but it applies to lists, maps etc. analoguous.\n\nFirst things first: It doesnt make sense to have a *mutable* `Set` and an `ImmutableSet`. You simply cannot build a sensible class hierachy/subtyping relationship from this.\n\nIf `Set` is mutable and has an `add` method, `ImmutableSet` cannot be a subclass. Or well it could be, but you would need to make the `add` method no-op or throwing. Not a good solution. The other way round you could have `Set` inherit from `ImmutableSet`, and have `Set` add *mutation*. But then a `if (s instanceof ImmutableSet)` would succeed despite the set being mutable. not good either.\n\nSo you'd start with `Set` being *immutable* and then adding a `MutableSet` subclasss. That way round it works ok.\n\nThen you would need to make `Iterator` immutable anf remov the mutations from it, and add a `MutableIterator`.\n\nBut changing all this requires extensive, incompatblie rework of `java.util.collection`.\n\nJava does have immutable Collections, but they all just throw when you call their mutating operations. That the best you can do without bricking all existing code. And since Java is *heavily* invested in backward compatibility, I don't see the status quo change any time soon.\n\nThat being said, I'd be delighted so see a new Collections API akin to `java.nio` which supplants the old API. but that would require maintaining two APIs, which I don't see happening, either.\n\n>So you'd start with `Set` being *immutable* and then adding a `MutableSet` subclasss. That way round it works ok.\n\nHow do I indicate then that I want an immutable set as parameter?  Asking for `Set` won't work because `MutableSet` would qualify.\n\nOr I could return `Set` and you would be under the mistaken impression that it will never change, as it may be a `MutableSet` internally.\n\nThere are always two viewpoints here; what the owner of the collection wants you to be able to do, and what guarantees the receiver would like.\n\nThats an absolutely valid point. It surely depends what *contracts* you want these classes to have. You always have to bite *some* bullet because we don't have intersection types or type negations in Java.", "id": "k1fxac7", "owner_tier": 0.7, "score": 0.16666666648148146}, {"content": "Actually they talked about it why yesterday at the live stream event: [https://www.youtube.com/watch?v=E8NV68ihJyY](https://www.youtube.com/watch?v=E8NV68ihJyY&t=1s) \n\nTo help you avoid watching the 8 hours, it's at around 6h48min.\n\n6:52\n\nWhy in a far off distant future? We could have Persistent collections in the standard Java library in the next release, if there were a political will for it. I'm exaggerating, but only a little bit.", "id": "k1egx51", "owner_tier": 0.1, "score": 0.09259259240740741}, {"content": "List.of, Set.of is immutable by default.", "id": "k1en972", "owner_tier": 0.1, "score": 0.09259259240740741}, {"content": "They weren't added when collections where introduced and adding them niw wouldn't make sense as existing code is already built to work with the current system where mutability is an optional feature.\n\ninmutable is a new trend and has no real uses, because you can do the same and just not modify your list.\npeople use it because a trend on youtube\n\nImmutability by default has some real benefits. It offers more safety, preventing many bugs earlier. If you know that you have an immutable collection then you can safely store it without risking some other code changing it. It's also often possible to accidentally mutate things when you don't mean to in some cases (not so much for collections tho).", "id": "k1e72ha", "owner_tier": 0.3, "score": 0.05555555537037037}, {"content": "One thing that Java has going for it that Python, Javascript, etc. do not is that the built in collections are not that privileged.\n\n  \nYes, built in methods accept and return `java.util.List`. But all of\n\n* Eclipse Collections\n* Guava Collections\n* Vavr collections\n* Pcollections\n* ...etc\n\ncan be just as ergonomic or more so than the built-ins.\n\nIf you want your system to have clear delineation between Immutable and Mutable collections, that is very doable. It just comes at the cost of an API tradeoff that the core libraries did not want to make.", "id": "k1feifh", "owner_tier": 0.5, "score": 0.037037036851851855}, {"content": "don\u2019t know and don\u2019t care. i\u2019m sure the people in charge have encountered this question. it\u2019s probably a huge pain to implement", "id": "k1h4t3h", "owner_tier": 0.7, "score": 0.037037036851851855}, {"content": "One trick I use is to code things, wherever possible as Iterable.  This does not work everywhere (for example, if you know it is an ArrayList and want to access by index efficiently), but for the vast majority of cases where folks are simply going to stream or iterate over the items in a loop, it works.  Be sure you have a backing collection that is already itself immutable (ala List.of()).", "id": "k1er09b", "owner_tier": 0.5, "score": -1.8518518518518518e-10}, {"content": "I don't understand what is the interest of an immutable list? In this case you can replace it with an immutable array and this is quite better. This is just to show that immutable data structure is often a weird structure at the end. Data structures without modificators are very limited. Instead of immutable data structure in general, ask for some new immutable data structures that are a kind of view that you will build on request and after the initialization they have no more relation with the initial data structure", "id": "k1jfpc7", "owner_tier": 0.5, "score": -1.8518518518518518e-10}, {"content": "java has no immutable reference ;-)", "id": "k1jpjxs", "owner_tier": 0.1, "score": -1.8518518518518518e-10}], "link": "https://www.reddit.com/r/java/comments/16ngn2l/why_there_is_no_immutablecollectionlistset_in_jre/", "question": {"content": "Those are super useful as seen in Scala/Kotlin/Guava library. Are there any reasons against having it in JRE?", "id": "16ngn2l", "title": "Why there is no ImmutableCollection/List/Set in JRE?", "traffic_rate": 55.9755525787006}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "Absolutely use data classes when they do the job. Cases when this is not true (or it's awkward):\n\n- custom init method\n- custom new method\n- various patterns that use inheritance\n- if you want different names for the attributes,. including implementing encapsulation \n- probably more things :)\n\n\nChanging later might have some cost, so use dataclasses when you are fairly certain you won't need those things. This is still a lot of cases, I use them often.\n\nCustom init method is handled by \n\n    post_init\n\nLast I checked it doesn't work for inherited classes - i.e. post_init won't run in the parent class, unless added in the child class as well.\n\n>various patterns that use inheritance\n\nNot true for immutable (frozen) dataclasses.\n\nYou can activate it with super(), same as a regular class init.\n\nThere is also a (admittedly hacky) way to use it with frozen data classes\n\nOh, true! Although it's still a bit hacky: https://stackoverflow.com/questions/59986413/achieving-multiple-inheritance-using-python-dataclasses\n\nI feel like `admittedly hacky` is part of the question here though.\n\nAs long as you're comfortable bending so far backward that you can lick your own anus, you can use anything to achieve anything in Python. But that doesn't make it a good idea.\n\nI think the question here is basically \"how hacky is too hacky?\" \"How far from the intent of dataclasses can you go before it becomes a bad use case for dataclasses?\" Etc.\n\nI don't have the answer myself - especially since my work rarely has a need for dataclasses - but am interested to follow the discusion.\n\nI appreciate the way you phrased this, yes that's pretty much it ![gif](emote|free_emotes_pack|joy)", "id": "itn7h6i", "owner_tier": 0.7, "score": 0.9999999998181818}, {"content": "The data class is, well, data class. It's ideal for purely data storage and transfer. By default, it gives you the \"value semantics\". For anything else, eg when you need to add (any significant) behaviors, just regular classes are more suitable.\n\nCan you elaborate on what makes them \"more suitable\"? Is there a performance difference? I've been using data classes in this way for a few weeks and haven't noticed any difference.\n\nPerformance is negligible, if you need performance, use `__slots__`... or don't use python. In your example, all you're really doing it getting `__init__` for free. But a dataclass has value semantics and anyone using it would expect that. Values don't usually have methods besides those that are pure transformations, like math.\n\n> or don't use python\n\n\ud83e\udd23", "id": "itn5jap", "owner_tier": 0.3, "score": 0.5272727270909091}, {"content": "When I don't control the storage or need primitive types for any reason, I use named tuples. They're also great\n\nWhy prefer named tuples to data classes?\n\nI'm also curious, not that it's wrong.\n\nI use named tuples specifically when I want my class not to be immutable. idk otherwise\n\nNot the original commenter, but for one thing, less overhead.\n\nThat's the fundamental problem with classes IMHO, it's just more code to write and maintain. By contrast, named tuples are *almost* like simple classes, but can be defined on just a single line.\n\nThey are a lot faster\n\nHashable immutable extremely lightweight without any decorator shenanigans. Use typing.NamedTuple for the convenient object-oriented declaration style.\n\nI often use named tuples to encapsulate types I feed through an old API that requires undocumented tuple (looking at you, Sphinx). Named tuples behave exactly the same as tuples, and you can add your own methods like classmethods for factory functions (a.k.a. named constructors).\n\nSince named tuples are not configurable, you can't mess with its API or misuse it, and even quite old type checkers can analyze them.\n\nWell, unless I specifically require features not in named tuples I might use dataclasses. If I need any validation or schema generation I'll go with pydantic models.\n\nWell... I don't think I have much use cases remaining for dataclasses, and I am not a huge fan of it's API. It is also a matter of personal preference I guess.\n\nYou can do frozen data classes\n\nSource? What I'm reading online seems to indicate a minute difference in speed.", "id": "itnpb03", "owner_tier": 0.3, "score": 0.418181818}, {"content": "`third_input` should be:\n\n    third_input: datetime = field(default_factory=datetime.now)\n\nOtherwise all instances will have the same date.\n\nBut didn't they mess it up in the \\_\\_init\\_\\_ as well? There's an `or` so we get an evaluation for truth right? And as long as datetime.now() is True third_input will have the value True.\n\ncommy2 is right, I made an assumption in the 2nd example when I should have kept them functionally identical.\n\nTo your question, it's a little bit of an operator trick but actually it's correct! https://stackoverflow.com/a/4978745\n\nEveryone on stackoverflow says it's bad practice. I don't think I've ever seen 82 upvotes on a comment before.\n\nBut apparently it does the thing. I'm mortified.", "id": "itoxt90", "owner_tier": 0.5, "score": 0.1999999998181818}, {"content": "Data classes are great when every attribute of the class is public.  In contrast, they're not meant for classes that have private attributes.  Most of the time, my reason for making a class is to hide some information from the outside world, so I don't use data classes that often.   \n When I do use them, I basically treat them like more well-defined dicts/tuples.\n\nPython doesn't have private attributes. If you're looking for that you're using the wrong language.", "id": "ito6yy5", "owner_tier": 0.1, "score": 0.1272727270909091}, {"content": "Why not Pydantic?\n\nI'm looking to introduce either, or something else, in my own code and seems like Pydantic is more powerful. It has built-in validation methods, and those can easily be extended and customized.\n\nIn my case I'm hoping to do elaborate payload handling. Upstream system submits JSON that contains a request for service to be provisioned. To do so, numerous validation steps need to be completed. And queries made, which then need to be validated and then best selection made. Finally resulting in the payload containing the actual details to use to build the thing. Device names, addresses, labels, etc. Payload sent through template generators to build actual config, and template uploaded to device to do the work.\n\ndepends on OP's use-case. validation has a performance cost, which if you're doing some kind of high-throughput data processing that would involve instantiating many of these objects, the overhead can be killer. here's a small test that shows instantiating a data class is about 20x faster than using pydantic (at least in this specific case).\n\n```python\n$ python -m timeit -s '\nfrom pydantic import BaseModel\nclass Test(BaseModel):\n    x: float\n    y: int\n    z: str\n' 't = Test(x=1.0, y=2, z=\"3\")'\n50000 loops, best of 5: 7 usec per loop\n```\n\n```python\n$ python -m timeit -s '\nfrom dataclasses import dataclass\n@dataclass\nclass Test:\n    x: float\n    y: int\n    z: str\n' 't = Test(x=1.0, y=2, z=\"3\")'\n1000000 loops, best of 5: 386 nsec per loop\n```\n\nof course there are always pros and cons. if you're handling a small amount of data, the processing of that data takes much longer than deserializing it, or the data could be fairly dirty/irregular (as is typically the case with API requests), then pydantic is probably fine (or preferred) for the job.\n\nIf pydantic is too much you could give a try to chili [http://github.com/kodemore/chili](http://github.com/kodemore/chili). I am author of the lib and build it because pydantic was either too much or too slow. Also I didnt like the fact that my code gets polluted by bloat code provieded by 3rd party libraries because this keeps me coupled to whathever their author decides to do with them. I like my stuff to be kept simple and as much independant as possible from the outside world.  \n\n\nSo you have 4 functions:  \n\\- asdict (trasforms dataclass to dict)  \n\\- init\\_dataclass, from\\_dict (transforms dict into dataclass)  \n\\- from\\_json (creates dataclass from json)  \n\\- as\\_json (trasforms dataclass into json)  \n\n\nEnd :)\n\nHi, if one of your usecases is to map & convert json data to existing python structures also have a look at the [DictGest module](https://github.com/bmsan/DictGest) .\n\nI created it some time ago to due to finding myself writing constantly translation functions( field X in this json payload should go to the Y field in this python strucure)\n\nThe usecases that I wanted to solve were the following:\n\n* The dictionary might have extra fields that are of no interest\r\n* The keys names in the dictionary do not match the class attribute names\r\n* The structure of nested dictionaries does not match the class structure\r\n* The data types in the dictionary do not match data types of the target class\n* The data might come from multiple APIs(with different structures/format) and I wanted a way to map them to the same python class\n\nSee this analysis by a co-author of attrs\n\nhttps://threeofwands.com/why-i-use-attrs-instead-of-pydantic/\n\nThey suggest attrs for class building ( no magic)\n\nAnd cattrs for structuring unstructuring data eg json", "id": "itowumc", "owner_tier": 0.7, "score": 0.418181818}, {"content": "Dataclasses are nice and better in many ways, but you kind of hurt your own argument by providing an example where the two classes are not functionally equivalent, because you messed up the call to *field*.\n\nFair, I made an assumption in the 2nd when I should have made it a default\\_factory to keep it functionally identical. Hopefully that typo in my 2-minute scratch example doesn't invalidate the idea though!", "id": "itp7ddn", "owner_tier": 0.7, "score": 0.09090909072727273}, {"content": "IMHO dataclasses are meant primarily for DTOs. I use them in this capacity and they work well.", "id": "itqs5hc", "owner_tier": 0.3, "score": 0.018181818000000002}, {"content": "Last data project I did we used pandas extensively and every time we introduced a dataclass i found that it clashed with pandas quite a lot.  The vast majority of the time it was more convenient and more efficient to refer to data column-wise instead of row-wise, although for the latter case automatic conversion to and from dataclasses would have been handy.  (Turns out pandas supports something similar with named tuples and itertuples though.). We did use dataclasses for configs and stuff but it felt unnecessary to me vs just using dicts, an extra conversion step just to help the linter, basically, and removing some flexibility in the process.  So overall while i liked the idea of dataclasses, I didn't find them that useful in practice.\n\nThe purpose of this post was more about their utility compared to normal classes, but coincidentally I'm just starting into a similar project and am very interested in your experience! Could you share a link to the namedtuples/itertuples feature you mentioned?\n\nSure, basically if you're iterating over a Pandas dataframe (something to be avoided but sometimes necessary), then you can use [iterrows](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html) or [itertuples](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html).\n\nFor a long time I was only using the former, which gives you a Series for each row. (Or column, you can choose which way you are iterating.)\n\nThe latter gives you a namedtuple for each row, where the attributes of the tuple are the table column names.  It's not a huge difference in practice but it can be handy.  However, as this object is dynamically generated based on the contents of the table, it doesn't help much with type hinting.  It would be nice if itertuple accepted a dataclass class name as input., and just errored out if things didn't match.  This would require some complicated type hints for `itertuple`, not sure if it's even feasible with Python's type system.", "id": "itra1y0", "owner_tier": 0.5, "score": 0.07272727254545455}, {"content": "Can you explain data classing briefly? I do a lot of database ETL, as in, I query a database and create new data from the queried data within Python. Will using data classing help me?\n\nIt's relatively typical to pull data from a database and store it in python in the form of a dictionary (with column names as keys, and the corresponding value)\n\nThis is annoying for large/complex sets of data ( or even small but unfamiliar sets of data, like if you're a new hire being onboarded) since you don't know the types of the data.  Each database column could be a string, an integer, raw image data.. but to the programmer interacting with it, you can't tell immediately. If you hover over my_row[\"column_1\"] in your editor, it will just say \"unknown\" or \"Any\". Could be a number, or a string, or none..\n\nIn my opinion the best part about data classes (although there's lots of other stuff!) Is that it provides a great interface to declare the types of each field in your data. You directly tell python (and therefore your editor) that column_1 is an integer, and column_2 is a list of strings, etc.\n\nNow, your editor can auto-complete your code for you based on that information, and if you ever forget, you can just hover over the variable to see what the type is.\n\nYou get better and more accurate errors in your editor, faster onboarding of new hires, it's great.\n\nYou can also do this other ways, like with a TypedDict, but dataclasses provide a lot of other useful tools as well.\n\nIf you're doing a lot of ETL, and you're looking at one record at a time (rather than running big sql queries or just launching a loader), then yes, it's the way to go.\n\n[Here's the doc](https://docs.python.org/3/library/dataclasses.html). Conventionally they're meant to simplify the construction of classes just meant to store data. I don't know your setup, but speaking in general they are definitely handy for adding structure to data transfer objects if you don't already use an ORM.\n\n\n>In my opinion the best part about data classes (although there's lots of other stuff!) Is that it provides a great interface to declare the types of each field in your data.\n\nInterface is good for scalar types but not for collections. Traitlets provides a uniform interface to both. Not only that but you can configure Traitlets objects from the command line and configuration files once you define the objects.\n\nNamedTuples are probably much more efficient and give you 90% of the functionality. In an ETL context I'd probably prefer them.\n\nWhen doing ETL, how much time are you really spending looking at individual records instead of aggregating? Is it not like 0.001% of the time?\n\nGreat consideration - since ETL may so often involve gobs of records.\n\nBut I think performance only favors namedtuples on constructing a record, but retrieval, space and transforming the record are faster with the dataclass.\n\nGoing from memory on this however.\n\nWhen I write the transformation layer in python then typically my programs will read 100% of the records.  The Python code may perform some aggregations or may not.  On occasion there may be a prior step that is aggregating data if I'm facing massive volumes.  But otherwise, I'll typically scale this up on aws lambdas or kubernetes these days.  Years ago it would be a large SMP with say 16+ cores and use python's multiprocessing.\n\nThe only time I consistently use aggregations with python is when running analytic queries for reporting, ML, scoring, etc against very large data volumes.", "id": "itn7ir1", "owner_tier": 0.1, "score": 0.25454545436363635}, {"content": "Data classes are objectively inferior object factories. They lack the capabilities of Traits, Traitlets and Atom. And usage of collections in data classes is verbose and cumbersome.", "id": "itp05ze", "owner_tier": 0.3, "score": -1.818181807131871e-10}, {"content": "Because it is unnecessary extra plumbing.\n\nBut it's less plumbing than a normal class.\n\nNot to my eye. \nHow is less plumbing to you?\n\nIt generates extremely common boilerplate code like __init__ and __repr__, that's the entire point of it is brevity.\n\nExactly! Plumbing.", "id": "itqdrk3", "owner_tier": 0.3, "score": 0.07272727254545455}, {"content": "Not sure what you're asking here. Type hints being good is an opinion.\n\n>when the bottom arguably reads cleaner,\n\nFalse\n\n>gives a better type hint\n\nFalse\n\n>provides a better default `__repr__`?\n\nFalse\n\nIf I want to keep my class flexible, type hints are a mistake, they are an obstacle to readability not a help and maybe the default `__repr__` doesn't fit my use case. What do I do then?\n\nShow me the case, where dataclasses are better than plain dictionaries, then we can maybe talk, maybe because I don't think you'll find one.\n\nThis entire reply screams \"zealously held minority opinion\".\n\nDataclasses are very popular and widely used. While not everyone agrees with OP that we should be using them at every possible opportunity, \"dicts always beat dataclasses\" will be an opinion without an audience. I guarantee it.\n\nYour first False is on an opinion, hence the \"arguably\". I think it's true.\n\nIt objectively gives a better type hint. \n\nAgain, #3 is an opinion. You can disagree but it's not an invalidation of the idea.\n\nYour attack on type hints are irrelevant to this conversation - I put them in the regular class too for a reason.\n\nClearly plenty of people agree dictionaries are less optimal for some use cases, otherwise dataclasses would not have been added to the language.\n\nSo much hostility about a programming concept\n\nIt's a writing style and I'm allowed to be hostile to a style I don't like, the same way I dislike brutalism in architecture?\n\nNot personally enjoying something doesn't necessitate hostility towards that thing. That's unnecessary. You are \"allowed\" to do what you want yes, nobody said you weren't. You're just acting like an asshole.", "id": "itpg0d7", "owner_tier": 0.7, "score": 0.18181818163636362}, {"content": "What you should be using is attrs https://www.attrs.org/en/stable/\n\n( Dataclasses is basically a subset of this for classes that hold data)\n\nCare to elaborate? I've seen a few references to attrs features that seemed handy (namely their inherited param sorting), but my understanding is that they were more of a prototype and not meant to be used now that dataclasses are builtin.\n\n\"Data Classes are intentionally less powerful than attrs. There is a long list of features that were sacrificed for the sake of simplicity and while the most obvious ones are validators, converters, equality customization, or extensibility in general, it permeates throughout all APIs.\n\nOne way to think about\u00a0attrs\u00a0vs Data Classes is that\u00a0attrs\u00a0is a fully-fledged toolkit to write powerful classes while Data Classes are an easy way to get a class with some attributes. Basically what\u00a0attrs\u00a0was in 2015.\"\n\nhttps://www.attrs.org/en/stable/why.html#data-classes", "id": "itn9np2", "owner_tier": 0.5, "score": -1.818181807131871e-10}], "link": "https://www.reddit.com/r/Python/comments/ycn5ae/any_reason_not_to_use_dataclasses_everywhere/", "question": {"content": "As I've gotten comfortable with dataclasses, I've started stretching the limits of how they're conventionally meant to be used. Except for a few rarely relevant scenarios, they provide feature-parity with regular classes, and they provide a strictly-nicer developer experience IMO. All the things they do intended to clean up a 20-property, methodless class also apply to a 3-input class with methods.\n\nE.g. Why ever write something like the top when the bottom arguably reads cleaner, gives a better type hint, and provides a better default \\_\\_repr\\_\\_?\n\nhttps://preview.redd.it/p0t7193zntv91.png?width=1496&format=png&auto=webp&s=ee3de28b11e26214d7cea9d44bf5a64717e6bcb1", "id": "ycn5ae", "title": "Any reason not to use dataclasses everywhere?", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "A class is the blueprint telling you how to build the car. The object is the physical car that you can drive.\n\nSolid explanation\n\nThanks Angela\n\nSo was my way of thinking it correct?\n\n\ud83d\ude97\n\nNo, because you said a different type of car. An instance would be a single specific one, not a type. A specific car might be a Tesla, but there's more than one Tesla.\n\n\n\nAssume you own a car...\n\n\n`Car` is the class(ification) of the object that you own.\n\n\nThe object you own is that specific one located in your driveway. The one that I own is the same class, but not the same object.\n\nNo, what you are suggesting is more what a subclass is.", "id": "l75uz8l", "owner_tier": 0.7, "score": 0.9999999999453552}, {"content": "I always thought of it like: \n1. The memory in a computer is like a big ball of dough. \n\n2. A Class is a Cookie Cutter that can take whatever shape you want. It's just made to resemble whatever you want it to. A Person, a Shape, A Tree, A Hero, A Dragon, whatever you want.\n\n3. An Object is whatever dough you cut out with the cookie cutter. It's just a segment of dough(memory) that's intended to follow the design of the Cookie Cutter(Class).\n\nYou can make as many dough cuts with the Cookie Cutter so long as you have dough. You can have different Cookie Cutters cut from the same ball of dough. \n\nYou're not really expected to do more with the Cookie Cutter (class) than make pieces of dough (memory) resemble it. You're having an Inexplicably Counter-Productive Day if you try to Bake without using dough, just the Cookie Cutter. \n\nDisclaimer: \nIt gets a bit more complicated with \"Static\" classes and whatever pertains to the given Programming Language. But that starting point helped me make a Mental Map of the fundamentals.\n\nI hate your explanation because I don\u2019t have any cookies. You just make me want a cookie shaped like a dragon\n\nI'll continue with food. But this \"memory-first\" miss the behavior part. And what objects are from OOP standpoint.\n\n- An object public signature is like a restaurant menu. It describe what the object can do for you (ie food), and what it need from you (ie $, sometime some choices)\n\n- A class is a template to make object (Ie restaurant chain)\n\n- An instance is a specific restaurant from the chain, at a specific time.\n\n- The cookie dough is mostly hidden behind the kitchen counter (encapsulation)\n\n- This is because you don't want to consumer to do micro management.\n\n   - A consumer can order a burger # 6 with extra bacon.\n   - A consumer shall not be able to select a specific cook, take a specific patty from a specific fridge, select a specific grill etc.\n\n- You want a single source of thruth\n   - The restaurant chain  keep the knowledge of what is a burger # 6 and how to make one.\n   - You don't want that knowledge spread accross different burger consumer. Then you setup yourself to have inconsistency and bugs. (copy paste programming)\n\n- You don't want the restaurant chain to micro manage either.\n   - The restaurant instance HAS employees. Those employee can make choices toward your specified goal.\n   - The restaurant istance IS NOT a pile of human organs (among other things) that must be controlled toward your goal.\n\n- Sometime the cookie dough change, you still have the same cookie.\n  - If you have less ketchup in reserve in the fridge you still have the same restaurant.\n\n- Sometime people prefer to work with snapshot in time of what the cookie dough is, and that is fine too. Multiple snapshot of the same thing can coexist and old snapshot can be kept for record keeping. Or to better understand what happened in the workshift.\n\n- Sometime a food inspector can come in, and the best thing you can do is let them inspect(). Whatever that thing is. And different instance of food inspector can do different inspection, and that's fine. You just trust what it say on the label.\n\nIdk about dragon shaped ones, but check your browser. It's full of cookies, I bet! \n\n....I'll show myself out.\n\nYou just made me remember I have cookies and now I\u2019m going to go eat one\n\nI hate that this made me laugh. Take my angry upvote.\n\nHeh, after the day I've had I needed this joke!", "id": "l75z5l9", "owner_tier": 0.7, "score": 0.8852459015846994}, {"content": "The class details the defining features of a Car. The class does NOT specify the values for those features. An object does specify the values for the features of ONE Car", "id": "l75wmbs", "owner_tier": 0.3, "score": 0.13114754092896175}, {"content": "The class is the formula for the object.  The object is one instance of it.\n\nClass Zebra has four legs, two eyes, a tail, and stripes.  It can run, jump, walk, and post memes.\n\njoe = Zebra(long legs, big eyes, fluffy tail, wide stripes) is not the same as daphne = Zebra(short legs, small eyes, curly tail, thin stripes), but they're both Zebras, and if there were an isZebra(zebra) function, isZebra(joe) and isZebra(daphne) would both return True.\n\nHowever, when joe.postMeme('scumbag hyena'), daphne does not.\n\nScumbag hyena lol", "id": "l75zzdn", "owner_tier": 0.9, "score": 0.13114754092896175}, {"content": "People have already given technical and metaphorical descriptions, so I'll try to explain something a little different. Why do we use the words \"class\" and \"object\"?\n\nWhen you think about objects, imagine a physical object, say an apple. That's an object. It's real, not abstract or conceptual. It has properties that can be described and measured. It's a unique thing; even if you had an apple that's a perfect clone, it wouldn't be *this* apple. Objects in programming are the same thing, just made of memory instead of atoms. \n\nWhen we say a submarine is Dreadnought-class or a car is SUV-class or a chef is world-class, we mean it has some set of characteristics that it shares with every other object that class. That's what a class is: a set of characteristics that a set of objects all share. In the real world, we take objects with shared characteristics and create a class to describe it. In programming, we do the reverse: we describe a class with the characteristics we care about, then create objects defined by having those characteristics. \n\nHopefully this makes sense and helps explain why the class/object metaphor is described the way it is. If stuff is confusing, I can try to answer questions.", "id": "l76k10y", "owner_tier": 0.7, "score": 0.08196721306010929}, {"content": "Object is something that carry properties ( like form, color, touch, sound, feel) and functions (actions possible with object or on the object) similar properties and functions creating classes of objects.", "id": "l773gyk", "owner_tier": 0.3, "score": 0.01639344256830601}, {"content": "Hard to answer with an example because needs of the program tend to dictate how it's implemented, and cars could be implemented in so many different ways. \n\nThe class Car could have an init method that accepts make, model, year, vin_number, and miles driven. The instance would be a specific car with a spdcific values for each. \n\n    car_instance = Car(make=\"tesla\",model=\"M3\",year=2024,vin_number=\"X1234512345\",miles_driven=20314) \n\nIf there's a function that all car instances would share, you'd add that to the class definition so that instances could later use that as a method. \n\n    car_instance.honk()\n\nIn the Car class definition, you'd have to define and implement the logic. In this case it may just look like\n\n    class Car:\n        ... \n        def honk(self):\n            print(\"Honk!\")\n\nThat's a good one, thank you! I'm starting to learn this year...", "id": "l76490m", "owner_tier": 0.5, "score": 0.027322404316939893}, {"content": "A class is like \u201ccars\u201d, they can have different manufacturers, age, color, etc.\n\nAn object is like your mums current car. Its real, its there, you can drive it, and it has a defined specific one manufacturer, a defined color and determined age.\n\nOhh so the class is like base properties every object has but the values of each parameter are different for each object.\n\nIn my understanding, yes, that is almost correct. A class is like a blueprint. It tells what KIND of properties, values, things will the objects have, and how they will behave, what will they do, when they will be created.\n\nThen, once you create an object, then the specific values, properties, things will be defined. \n\nDefining a class is like designing a car (the car itself does not exist yet), defining an object, an instance of the class, is like manufacturing a car (now it exist, has a color, and can be driven)", "id": "l76srry", "owner_tier": 0.3, "score": 0.03825136606557377}, {"content": "Thinking about a GUI might make it easier.\n\nIf you're building a simple app, you might have a class called Checkbox.\n\nAn object would be AgreeCheckbox with the text \"I agree to the terms and conditions\", that's a specific checkbox. A different object on the page might be AdvancedCheckbox with the text \"Show Advanced Features\".\n\nSo your car example is tough because what kind of app is it? If the app involves a bunch of cars driving around then you might have two Teslas, right? So an object might be \"my car, that's a white Tesla that's currently on the left side of the screen\" and another object is \"your car, a green Toyota that's currently driving down the mountain\".", "id": "l75zrxw", "owner_tier": 0.9, "score": 0.010928961693989072}, {"content": "A class is like the design of a car. An object is the physical car itself", "id": "l77aouf", "owner_tier": 0.1, "score": 0.010928961693989072}, {"content": "An object is structured data stored in your PC's memory. You can think of it like a bundle of variables that are packed together so that you can save on lines of code in other parts of your program. But that's not all: Objects come with methods which are functions that operate on the variables the object is comprised of. In their essence, objects are a combination of data and functions tightly coupled together so that you can write a part of your program at one location (the class) and use it everywhere you need it wirhout having to repeat the code.", "id": "l77tm3p", "owner_tier": 0.3, "score": 0.010928961693989072}, {"content": "I find that good examples of classes vs objects are locations.  For example, a class might be \"city\", and some examples of objects of the class \"city\" would be Chicago, Paris, New York, etc.  \"city\" is more of an abstract concept that defines structure and behavior, and Chicago is a \"city\" you can actually go visit.  You can't go out and visit \"city\", but you can visit Chicago.   Cities have a population (property/structure), and Chicago's population-- because it actually exists-- has a value of 2.6 million.\n\nA few people have used \"car\" as an example of a class.  Great!  So a car could have a VIN (part of the structure).  An example of an instance/object of \"car\" isn't just a Honda Accord, it's Bill's gray Honda Accord with VIN #123456 that's parked in his garage right now.  Objects \"exist\" and can be interacted with while classes define the properties/structure and behavior of objects.\n\nA class defines properties and behavior (methods), while objects possess concrete values for those properties and can be interacted with by calling the methods of the object.  Create some classes, then instantiate some objects and try it out.  Create a city class with properties like \"name\", \"country\", \"population\", and see if you can create a Chicago object based on that class.", "id": "l768p8s", "owner_tier": 0.3, "score": 0.005464480819672131}, {"content": "Not quite, even types of cars are classes, inheriting from the car class. An object is my car, another object is your car. If you have 2 cars each one is an object", "id": "l76wkh1", "owner_tier": 0.3, "score": 0.005464480819672131}, {"content": "Think out of objects like boxes holding properties that made them function in a way , you can apply on them methods and they have life cycle", "id": "l7872f3", "owner_tier": 0.1, "score": 0.005464480819672131}, {"content": "Yes, but be careful about using the word \"type\". Technically speaking, a \"type\" is a range of permissible values. So for example, \"integer\" is a type whose values are restricted to positive and negative whole numbers. A class also defines a \"type\" because it defines the fields and methods (and their own corresponding types) that an instance/object of the class is permitted to have. So an object is not a \"type\" of a class, because its values respect the restrictions imposed by the corresponding class.\n\nWhen there are multiple objects of a class, we don't say they're each a different \"type\" of the class. Instead, we say they are different instances. But two instances can sometimes share the same values. If the two objects have different values for their fields, there is no name for that of which I'm aware.", "id": "l760lm5", "owner_tier": 0.1, "score": -5.464480841106716e-11}, {"content": "If you have a class House, the objects would be houses. They wouldn't be different types of housing (like an apartment, then a loft, etc), but slightly different houses. For example, object houseA may be blue and houseB may be yellow.", "id": "l760mkb", "owner_tier": 0.3, "score": -5.464480841106716e-11}, {"content": "A class describes the blueprints for a single kind of object. It describes what information we need to know about an object, and what behaviors that object exhibits.\n\nMore specifically, it tells us what variables must be present inside every instance of that class, and it describes the methods that can act on an instance of that class. A constructor details how you build an instance of that class, including what (if any) information is needed in order to create an instance.\n\nYou seem to be close but a little bit off. Tesla, Ford, Mitsubishi etc. are car manufacturers, but they're not cars in and of themselves. A car *has* a manufacturer, as well as a bunch of other defining features. An instance describes one exact car, listing all it's different features, so perhaps one `Car` instance is a Tesla (make) Model S (model), from 2013 (year), owned by John Doe (owner). These pieces of information define 1 exact car, out of the billions of `Car`s that could exist.\n\nThe specific contents of a class depend entirely on what you the programmer decide that class needs to have. So for example a `Car` might require a make and model. It might also require a VIN number; a number of doors; a height, width, and length; an engine type; whether the engine is supercharged, turbocharged, or naturally aspirated; and so-on. All of these are examples of information that could theoretically be part of a `Car` class. The actual information you store depends on what you need to do with objects of that class.\n\nIf you're making a game maybe your `Car`s need a 3d model, and stats that control how it drives (acceleration, top speed, turning, etc.). If you're making a database for a mechanic, your Car class might need completely different information, like the owner; make, model and year; odometer; last oil change; and a history of repairs.", "id": "l762nme", "owner_tier": 0.7, "score": -5.464480841106716e-11}, {"content": "A class is like a recipe.  A recipe for soup is not soup, it\u2019s a description of what makes soup a delicious meal.  An object is the soup.  You know what\u2019s in the soup by looking at the recipe.", "id": "l7699n0", "owner_tier": 0.1, "score": -5.464480841106716e-11}, {"content": "Ben (object) is a human (class). There are things all humans share, therefore Ben shares them too. Some things however are specific to the object, such as name, hair color, age, etc.", "id": "l76btdy", "owner_tier": 0.3, "score": -5.464480841106716e-11}], "link": "https://www.reddit.com/r/learnprogramming/comments/1d8f9zm/can_someone_help_explain_what_objects_are_to_me/", "question": {"content": "I know the whole definition of \"an object is an instance of the class\".  Does this mean like an object kind of like a version of a class?  For example a class would be a Car and the objects would be different types of cars like Tesla, etc.\n\n  \nEDIT\\* Thank you so much for the help on objects and classes.  From what the answers are saying a class is like properties every object has but an object is like the representation of a class.  ", "id": "1d8f9zm", "title": "Can someone help explain what objects are to me?", "traffic_rate": 759.4147559171597}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "My preference is yes to the 'final, no to the 'this' - it just clutters up the code.\n\nSo you write like this?\n\n    public final foo(final int a, final int b){\n      final int c = a + b;\n    }\n\nSeems like so much visual noise.\n\nAgain I have to say that I wish the approach taken by Rust would've been selected 30 years ago. Everything is final by default and mutable variables have to be defined explicitly. That would be so great.\n\n> no to the 'this' - it just clutters up the code.\n\nThe same thing applies to the `final`, though.\n\njavac and JIT don't need _me_ telling them when a variable is final or not -- they already know.  \nThey know the scope and mutability of every single field and var, and whether it can or cannot be inlined. Meaning, they know if a variable is \"effectively final\" and will treat it as such.  \nYou could strip every single `final` from a .java file and the resulting .class would be exactly the same.  \n**The only reason to declare a variable as `final` is to keep _other programmers_ from modifying its value.** And I don't like to do that, because often times, while debugging, that other programmer that needs to change a variable's value is me, and I cannot do that if the variable is final.\n\nIt does nothing but make my code harder to work with. It's just clutter.\n\nI don't get it why you think it clutters up the code. Do you think you can try to elaborate? Like, isn't better to easily see what's an attribute?\n\nYou can use a final AtomicInteger if you want to mutate it. :D\n\nFinal clutters up the code\n\n>it just clutters up the code\n\nLet me guess, you also put brackets on one-liner if-else statements?\n\n\"Types after variables\" is also really nice.  Were I redoing java syntax I'd definitely take that.\n\n`val foo = 1`\n\nor\n\n`val foo: int = 1`\n\nboth really readable to me and makes things like lambda declarations flow better.\n\n>You could strip every single final from a .java file and the resulting .class would be exactly the same.\n\nMaybe for parameters and local variables but not so for classes, member variables and methods.\n\nThe only times I\u2019ve ever wanted to mutate a value during debugging is when I\u2019ve caught a bug and fixed it but I don\u2019t want to abort the test run because what I\u2019m really interested in comes later and I don\u2019t want to take the time to restart the test (I mean it happens but it\u2019s normally not a big deal to drop and restart the frame once I\u2019ve fixed the code). That\u2019s been like twice ever. I might agree with you if I needed that more, but I prefer to explicitly declare as final anything that isn\u2019t intended to be changed.\n\nI\u2019m curious what sort of codebases do you find yourself doing that in? I do a lot of long-term contract work and want to recognize if that might be something to keep in mind for on new projects.\n\nEverything you say is right, but I have a lot more issue with junior developers not understanding the intent of certain classes and horribly misusing them. So defensive coding is more important to me. Plus I have a shit memory and I\u2019ve never prevented myself from screwing up through defensive coding but I\u2019m pretty sure some day it will happen.\n\n[deleted]", "id": "iltcocz", "owner_tier": 0.3, "score": 0.9999999999541284}, {"content": "**Final**\n* **Use final for fields if they should not be reassigned**. Otherwise, it is hard to tell whether a field is reassigned without examining all methods.\n* **Don't use final for local variables**. Methods are natural reassignment boundaries. It is better to reduce method size than it is to make local variables final. If the finality of a local variable is important (e.g. you want to reference it in a lambda) then the compiler already has your back.\n* **Don't use final for parameters**. Reassigning a parameter doesn't affect the calling scope so the impact of reassignment should be clear, because you have stuck to small methods. Mutating a parameter is a far more sticky situation anyway and final doesn't protect you from that.\n\n**This**\n* **Use this when reassigning or mutating a field**. Your method has a side effect and using this makes this explicit, especially in out of context cases e.g. a pull request.\n* **Don't use this when reading a field**. The difference between reading a field or a local variable rarely matters so by not using this, you are not adding unnecessary noise.\n\nYep, I can get behind this, and doing so mostly unconsciously already.", "id": "ilu9igv", "owner_tier": 0.3, "score": 0.19724770637614678}, {"content": "Nope. Your code reviewer thanks you\n\nRight? This Allan Melhor guy from Quora said that we should avoid adding \"this\", as it cleans up the code a little. https://www.quora.com/In-Java-when-should-I-use-this-propertyName-instead-of-propertyName-in-an-instantiated-objects-dynamic-method\n\nI started to question if I'm making my code too polluted by adding those things.\n\nWhen I moved on to my now current project the senior devs on it rejected my code review because I used `final` in method params and `this` when calling private methods and such. They still don't like it but \"oh well\". I think they're good. I think they are even recommended by Google Java Style.\n\nI would argue that things that increase maintainability are not pollutants. Verbose? Sure. But we are using Java after all :-)\n\nThe tradeoff between readability and explicitness is often not considered to be good in that case. Method parameters are usually not supposed to be mutated anyways, and it makes method signatures more difficult to read.\n\nJust set your IDE/Linter to flag parameter reassignment as an error. It can always be avoided by creating a new local. No need for `final` to clutter up parameter declarations.\n\nI don't understand where this verbosity fear is coming from. Recently even Java developers are acting like verbosity is synonym of bad code.\n\nThis was my thinking exactly, and the code reviewer(s) definitely appreciate it, as well as any testing/QA folks\n\nAdding `final` does not make method signatures more difficult to read. That's absurd.\n\n>Method parameters are usually not supposed to be mutated anyways,\n\nAnd that's why the language designers created `final`. It's there to force your intentions :).\n\nPeople are scared of using their keyboard to type a tiny bit more than they really have to. Ignore them and verbose away!\n\nBoilerplate distracts from reader from the logic of the code. Putting `this.` in front of each field name is no better than writing `/* string */` in front of each variable usage. Both help \"maintainability\" in the sense that they are so distracting that people won't even try to change your code. \n\n// Fun fact. I used to program in a language that actually did require you to specify the type of each variable or property each time you accessed it.", "id": "ilt1wbc", "owner_tier": 0.1, "score": 0.4862385320642202}, {"content": "Years ago I put this everywhere then I realized it made it almost as hard to read with self all over the place in Python. Now I just use common sense. A variable that doesn't change is a constant and it does deserve final. Any other time it mostly just looks cool.\n\nI just can't see how adding \"this\" in the variables can make the code hard to read. But maybe is because I haven't being exposed to cases where the keyword appear enough to the point of dominating the code?", "id": "iltlduf", "owner_tier": 0.1, "score": 0.08715596325688073}, {"content": "Not crazy, but it shouldn't matter. These things should be auto-enforced via formatters and Checkstyle. What matters more is your have a consistent style so there isn't \"your code\"; it's the team's code.\n\nAbsolutely true.\n\nI find it better for the team to set guidelines (like Google's Java Style Guidelines) and not to enforce every space, comma and bracket.\n\nThis way there is some room for personal preferences.\n\nGoogle introduced an auto-formatter and thus spaces, commas and brackets are decided by the formatter and additional comments are forbidden. There is some room for variation, but lots of it is 'the formatter decides'.\n\nThey follow a [rectangle rule](https://github.com/google/google-java-format/wiki/The-Rectangle-Rule), which is easy to follow, but can lead to ugly formatting due to excessive indentation in nested statements (which are common using protobuffers). The dart formatter was a lot nicer, and considered human friendly style instead of blindly following the rectangle rule.\n\nI am not talking about their formatter. Talking about this:\n\nhttps://google.github.io/styleguide/javaguide.html\n\nWe also follow the rectangle rule, but an extended one.  This complies:\n\n       a.b(new C(\n           d.toString()\n       ));\n\nBut this does not:\n\n       a.b(new C(\n           d.toString()));\n\nBasically treat every kind of bracket, not just curly ones, the same.\n\nThe number of unmatched opening brackets on a line must also always match the number used on the closing line, so this is not allowed:\n\n       a.b(new C(\n               d.toString()\n           )\n       );\n\nAnd the rule also extends to quotes, including the new multiline quote:\n\n       a.b(new C(\"\"\"\n           text\n       \"\"\"));\n\nOr:\n\n       a.b(new C(\n           \"\"\"\n              text\n           \"\"\"\n       ));\n\nNot allowed:\n\n       a.b(new C(\"\"\"\n               text\n           \"\"\"\n       ));", "id": "iltqpgq", "owner_tier": 0.7, "score": 0.09174311922018348}, {"content": "Fwiw (and I'm just sharing the thinking inside other companies), in my company's style guide we strongly discourage declaring local variables and parameters final.\n\nMostly because there is a wide lack of consistency when the practice is encouraged. When you read a block of code like the following, is `baz` not final? Or did the author simply forget the declaration?\n\n    final int foo = 0;\n    int baz = 1;\n\nYou'll need to read the rest of the code to know, and frankly it  is very rarely relevant to care (for the next reason).\n\nSecondly (and maybe more important) the Java language spec in Java 8 introduced _effectively final_ local variables:\n\nhttps://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4\n\n>Certain variables that are not declared final are instead considered effectively final:\n>\n>A local variable whose declarator has an initializer (\u00a714.4.2) is effectively final if all of the following are true:\n>\n>It is not declared final.\n>\n>It never occurs as the left hand side in an assignment expression (\u00a715.26). (Note that the local variable declarator containing the initializer is not an assignment expression.)\n>\n>It never occurs as the operand of a prefix or postfix increment or decrement operator (\u00a715.14, \u00a715.15).\n>\n>A local variable whose declarator lacks an initializer is effectively final if all of the following are true:\n>\n>It is not declared final.\n>\n>Whenever it occurs as the left hand side in an assignment expression, it is definitely unassigned and not definitely assigned before the assignment; that is, it is definitely unassigned and not definitely assigned after the right hand side of the assignment expression (\u00a716 (Definite Assignment)).\n>\n>It never occurs as the operand of a prefix or postfix increment or decrement operator.\n>\n>A method, constructor, lambda, or exception parameter (\u00a78.4.1, \u00a78.8.1, \u00a79.4, \u00a715.27.1, \u00a714.20) is treated, for the purpose of determining whether it is effectively final, as a local variable whose declarator has an initializer.\n>\n>If a variable is effectively final, adding the final modifier to its declaration will not introduce any compile-time errors. Conversely, a local variable or parameter that is declared final in a valid program becomes effectively final if the final modifier is removed\n\nSo the compiler no longer actually needs the explicit `final` declaration from the programmer.\n\nGiven the combination of these 2 considerations (possible inconsistency, and lack of need by the compiler) then we see declaring locals final (in a massively shared code base) as only having downsides.\n\nThat bring said, it's your code, so do as you please. But if others start to make contributions then it's important that consistency is enforced.", "id": "ilugz6w", "owner_tier": 0.5, "score": 0.04128440362385321}, {"content": "both of these can be enabled in the IDE of your taste and if you forget somehow, it automatically do that for you. I agree with you and do the same.\n\nYeah, I do use that on my IDE. Good to know that more people do that. \n\nI wish that final variables were the default so instead of having a keyword for immutable variables, we had a keyword to declare a variable as mutable since, at least from my experience, mutable variables are actually less frequent (to not say rare).\n\nYour ide should also change the color of \u201cthis\u201d fields vs variables and parameters.\n\nThat is I\u2019m rarely confused because field access/setting has a different color.", "id": "ilt7n6i", "owner_tier": 0.3, "score": 0.05963302747706422}, {"content": "Final makes the compiler do the work for you - that\u2019s good.  Why work harder than you have too.\n\nI personally like \u201cthis\u201d as it makes it obvious when I\u2019m using a meme er variable.\n\nI actually didn't know about the compiler thing. I will search more about it.\n\nFinal = compiler will yell at you if you change it.  If you know that to be the case you can let the computer auto check it for you.\n\nOh, I see. I thought it was something about optimization. But yeah, very good to have the compiler making sure that there's nothing trying to change what is not supposed to change.\n\n`final` constants are useful because it seems the compiler can inline the value in all usages.\n\n`final` variables and fields don't really help with optimization, as far as I know.\n\n`final` classes and methods are useful because the JVM does not have to look for an overridden method in the object being called. That reduces method call overhead. At runtime\\*, the JIT compiler can judge a method to be effectively final by analysing the class hierarchy. In C++, `final` is the default, and you have to annotate methods with `virtual` to make it possible to override them.\n\n\\*: Because of linking and class loading, in Java the full class hierarchy is rarely known at compile time.", "id": "iltqad7", "owner_tier": 0.5, "score": 0.050458715550458715}, {"content": "Yes, I think these are bad practices.\n\nYour editor knows these things. It can therefore tell you (for example, colour a variable differently if it is effectively final, render a field as bold, whatever you want), and this is strictly superior:\n\n* No mistakes. You can fail to mark a variable as final by accident. Your IDE won't do that.\n* Your style actively discourages refactors, because your refactor _also_ has to cover adjusting `final` and `this.` usage.\n* Your practice requires spending the brain space. You can't decide to simply not look at a `final` keyword. With IDE marking you can on the fly change settings and make the colouring for effectively finals just go away.\n\nIt's possible your IDE can't do it. In which case, spend your efforts writing a pull request so that it can, and muse about the fact nobody has cared enough yet.\n\nI agree. Just to show the problems with refactoring for `this` or how it actually causes a lot more work is the case of `wither`-like copy methods (lets ignore code generators like lombok... yes I know you're the author).\n\nLets say I have (shitty contrived example):\n\n\n    public record Point(int x, int y, int z) {\n\n         Point copy(int x) {\n             return new Point(x, y, z);\n         }\n\n         Point copy(int x, int y) {\n             return new Point(x, y, z);\n         }\n\n         Point copyUsingThis(int x) {\n             return new Point(x, this.y, this.z);\n         }\n\n         Point copyUsingThis(int x, int y) {\n             return new Point(x, y, this.z);\n         }\n    }\n\nNotice above without using `this` I can just copy 'n paste `return new Point(x, y, z)` constructor call in the `copy` method over and over again (sure that isn't ideal... yes I know code generators but for the sake of argument).\n\n\nAs for `final` the only place I use it is for places where I wish Java had expressions:\n\n    final int x;\n    if (something) {\n        x = 1;\n    }\n    else if () {\n        x = 2;\n    }\n    else {\n        x = 3;\n    }\n\n    final int y;\n    // old switch for old code bases\n    switch (something) {\n    case A:\n        y = 1;\n    case B:\n        y = 2; // compiler failure\n    default:\n        y = 3;\n    }\n\nObviously with the new `switch` expression I have been doing less of the above old habit.", "id": "ilufoym", "owner_tier": 0.7, "score": 0.027522935733944955}, {"content": "It's a noise which does not make code easier to read IMO. Java would be a better language with variables being final by default, but we've got what we've got.", "id": "ilu2vpx", "owner_tier": 0.3, "score": 0.013761467844036698}, {"content": "These two decisions seems fine to me.\n\nJust use the group convention where you work at.", "id": "iltfkol", "owner_tier": 0.3, "score": 0.009174311880733945}, {"content": "They make the code harder to read and provide minimal protection against bugs. Not worth the effort.", "id": "ilv4dxh", "owner_tier": 0.5, "score": 0.0045871559174311925}, {"content": "Avoiding naming collision leading to funny bugs on production is a good enough reason to use this.blah all over the place i think...", "id": "iltgv4l", "owner_tier": 0.3, "score": 0.009174311880733945}, {"content": "There are toolchains that can be used to enforce immutability and non-variable shadowing (and much much more important concepts) without spamming non-business logic words all over the codebase. You might think your code is easier to read now, but let time and bit rot take its course, and one fine day several months or years down the road when you need to urgently check on the implemented business logic 10 minutes ago, you might no longer appreciate the noise-to-signal ratio.\n\nOr you could inherit a legacy codebase where people have taken this kind of thing to stupid extremes that half the codebase is useless keywords.\n\nBut if the class is named after a business object, and the attribute is a feature of this object, by referring to this attribute as this.feature ain't I just saying \"the feature of this business object\", which is perfectly understandable from the business perspective?\n\nThis is fine if such checks are indeed enforced on all code and you can then really work with the assumption that everything is effectively final unless annotated (I guess? How to tell the checker that something is supposed to be mutated?) Otherwise, there is no other way to tell from a glance that something will never ever be mutated, except by analyzing usages.\n\nImplying that there is an attribute with the same name that is being referred to in the same context, which in turn raises even more questions. If there is not, it's just noise, assuming of course that the team has a similar understanding - all the teams that I've worked with before have had that same understanding and I haven't actually met anyone that needed the \"this\" keyword to say that the attribute is a feature of the business object they're looking at. Outside of constructors, the usage of \"this\" usually draws scrutiny because of what it implies about the rest of the code.", "id": "iltzh2o", "owner_tier": 0.3, "score": 0.032110091697247704}, {"content": "Short answer: Don't.\n\nIn both case, it's unneeded code that makes code less readable and more difficult to maintain.\n\nAbout `final`: The compiler does it for you. Java has the concept of effectively final variable. A lot of developer will also read the `final` keyword as \"immutable\" which is not the case: you can have a `final ArrayList` that is mutable. In 26 years of Java, I never saw a benchmark showing that it's faster too.\n\nAbout `this`: The IDE (at least mine) is showing fields in a different color than variables. So it just makes more code to write and to read.\n\nNote that one of the main advantages of Java is readability of the code, so it's important when writing code to use readable variable name, not too long methods and *avoid unneeded code*.", "id": "ilureat", "owner_tier": 0.1, "score": 0.0045871559174311925}, {"content": " No.  You are not crazy.  I do the same.  I rarely see others do the same.  It doesn't mean it's bad.  \n\n\nIf you go one step deeper and use thoughtful Constructors/Builders (or Records) you can really control the expectation on data.  \n\n\nFundamentally, if the system allows you to do something stupid, it's less than ideal.  If an attribute should not be mutated, then it needs to be protected.    \n\n\nI had a great lesson with my intern over the summer about this very thing.  He had a POJO that stored some data, and stored a variable on whether something was \"processed\".  When he was done processing he used a Setter to set \"processed\" to true.  I asked, \"what happens if something came after your code and set processed to false?\"  I recommended that he perhaps make the processed immutable upon construction and basically copy-construct the attributes and hard-set \"processed\" so that it cannot be changed once set.  We discussed the tradeoffs, that this approach takes more memory etc, but that it brings absolute safety.  No following code can mutate state of \"processed\" and that \"processed\" should only be set once.", "id": "ilv7hof", "owner_tier": 0.7, "score": 0.0045871559174311925}, {"content": "The code should be readable without these.", "id": "ilu518g", "owner_tier": 0.5, "score": 0.0045871559174311925}, {"content": "I get it.  But they're both just extra garbage on my screen when I go back to read\n\nI'd prefer you reduce each variable's \"scope\" to a bare minimum (preferably, I should never have to scroll up or down to see where a variable is declared and every time it's used).\n\nIn that way I can confirm it's effectively `final` or a field on the class, or whatever", "id": "ilv5bcz", "owner_tier": 0.5, "score": -4.5871559354244454e-11}], "link": "https://www.reddit.com/r/java/comments/wxu2hr/i_declare_as_final_every_single_variable_whose/", "question": {"content": "I think that those things make the code easier to read. Am I crazy for thinking like that?", "id": "wxu2hr", "title": "I declare as \"final\" every single variable whose value doesn't change. I also use \"this\" every time that I'm referring to an attribute, even when there's no ambiguity in not using it", "traffic_rate": 55.9755525787006}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "These sorts of axiomatic \"considered harmful\" type posts always get on my nerves. Inheritance is just a tool, like any other - one with ample opportunities for footgun, but a tool nonetheless. It has and serves its purpose, and should not be overused for things outside its purpose, just the same as composition or GOTO. If it's not a tool you personally write good code with, by all means avoid it, but get off your high horse about it.\n\n>But even this is not enough, because `new Ellipse(1,1)` is a circle but is not a member of the `Circle` class. The only solution is to forbid this value somehow\n\nThis is a perfect example of begging the question. You've invented an issue by engineering a situation in which it appears - but this is not an issue inheritance claims to solve, nor one that particularly needs solving. Certainly, the Ellipse class can represent a circle by value, but that's not a problem: the point of the Circle subtype is to guarantee that it is circular, not to guarantee no other Ellipse is. The proper way to make that distinction is, in a strange case where you've been passed an Ellipse and need to know if it's circular, to check its values and cast it to Circle if appropriate.\n\n>Composition offers better encapsulation. For example, suppose we have a `List` class with `add` and `addAll` methods, and we want a \"counting list\" that tracks the total number of objects added.\n\nThis is a conceptual misuse of composition, because it's using a has-a relationship as an implementation detail to represent a conceptual is-a relationship. The key issue here is with the drawbacks of side effects, not actually with inheritance - `CountingList` itself is a problematic implementation that should be replaced, as the issue really stems from non-idempotent side effects. An implementation like this, while potentially less efficient, bypasses the issue you've posited by ensuring that it doesn't matter whether `super.addAll` calls `CountingList::add` or not, since the result is the same in the end.\n\n    class CountingList extends List {\n      int cachedLength;\n     \n      void add(Object o) {\n        super.add(o);\n        this.cachedLength = this.length();\n      }\n     \n      void addAll(Object[] os) {\n        super.addAll(os);\n        this.cachedLength = this.length();\n      }\n    }\n\n(Note that the efficiency could also be highly improved by making `cachedLength` a getter which checks if a `dirty` field is set to determine whether to recalculate and cache the length again, but I'm not typing that on a phone.)\n\n>There is one remaining use case of inheritance, where you have overloaded methods implementing an interface. For example something like the following:\n>\n>But here we can just use lambdas.\n\nYou can only directly use lambdas in this situation because your example is contrived to have only one method with which the implementation needs to be concerned. This is certainly a case which would be ideal to replace with lambdas, but real life use cases are often not this simple; when associated state or additional methods need to be bundled along with said lambdas, a structure like this becomes much more reasonable than you've made it appear.\n\n---\n\nI understand where you're coming from. Inheritance is often a clumsy tool, and drastically overused. But you don't need to bring up contrived examples and fallacious arguments to make that point - that only becomes necessary when you start trying to claim that inheritance is always bad and can never be the right tool. Maybe back it down a few steps, and advocate for conscientious usage of inheritance instead of careless usage, rather than try to advocate for never using it even when it's the right tool for the job.\n\nWoah...you typed that on a phone? Respect.\n\n>These sorts of axiomatic \"considered harmful\" type posts always get on my nerves. Inheritance is just a tool, like any other - one with ample opportunities for footgun, but a tool nonetheless.\n\nOK, but, counterargument.\n\nMany people nowadays would (sorry!) Consider Harmful the idea of a Swiss Army Language that contains all the tools. They would prefer a toolset which is small and orthogonal. At this point we need to consider stuff like this. If this was another subreddit then your remark:\n\n>If it's not a tool you personally write good code with, by all means avoid it, but get off your high horse about it.\n\n... would make perfect sense, but when we're talking about the design of programming languages then the question of whether inheritance is, on balance, harmful, becomes more than a personal choice but one we have to make for our end-users.\n\n---\n\nAlso, a word in favor of dogmatism. I think that dogmatism is a good thing in any creative field, whether it's the design of programming languages or the writing of poetry. Yes, it can lead to quarrels --- it *will* lead to quarrels. *But*, do you suppose anyone ever wrote good poetry (for example) without having strong views on how poetry should be written? The dogmatism is part of the drive. Someone who looks at the vast array of programming languages and their features and says \"I guess they're all good and they all have their place\" may be very broad-minded but they have little chance of producing a better one.\n\n[deleted]\n\n> This is a perfect example of begging the question. \n\nActually this is an example of reductio ad absurdum. I assumed inheritance was the answer, and obtained a nonsensical value that was a circle yet not a `Circle`. You can't cast this value to a `Circle` because it is not an instance of the `Circle` class.\n\n> This is a conceptual misuse of composition, because it's using a has-a relationship as an implementation detail to represent a conceptual is-a relationship.\n\nWell, types represent is-a. Although the relationship is more like \"is\" because types are adjectives and not nouns. For example we could define `ListLike a = { add : Object -> a -> a, addAll : Object[] -> a -> a }` and then both `List` and `CountingList` are `ListLike`.\n\n> cachedLength\n\nI did mention that. I also said that that approach doesn't work if you have non-erasable side effects like logging or printing out messages. If `add` prints `Object added!` there is no way to ensure that `addAll` does not print `Object added!`, other than by inspecting the implementation of `List.addAll` to ensure it does not call `add`, or by using composition instead of inheritance.\n\n> when associated state or additional methods need to be bundled along with said lambdas, a structure like this becomes much more reasonable\n\nIf you have both state and methods, then you get encapsulation issues like with `CountingList`. Inheritance only seems to be usable when it is pure data (CSS-style property cascade) or pure type signature (interfaces / traits).\n\n> conscientious usage of inheritance instead of careless usage\n\nI don't think inheritance is a general-purpose tool, but providing it in a library for legacy compatibility will probably always be necessary. I made this post to see if anyone wanted to argue for inheritance and the answer is no, nobody cares that much.\n\n> contrived examples and fallacious arguments\n\nMy experience has been that whenever someone starts bringing up style nits instead of actual counterpoints it is because they have nothing useful to say and they are just blustering. It is only [level 2](http://www.paulgraham.com/disagree.html) in the argument hierarchy, out of a maximum of 6.\n\nJust curious, have you ever seen a good example of inheritance in an object-oriented programming language?\n\nAs of yet, I have yet to see one but I'm sure that's just because I'm inexperienced. \ud83d\ude1b\n\nI see where you're coming from, and I don't disagree on some of the principles. To be clear, I'm not by any means advocating inheritance for *every language* - far from it, I think that OOP in general is less than ideal as a paradigm to explore in new languages, let alone its most footgunny features. More languages pushing into underexplored design spaces is a great thing!\n\nOn the other hand, though, what I don't agree with is the impulse to push that decision onto others, especially by means of flawed arguments born of misunderstandings. Choosing not to include inheritance in your own language is perfectly fine regardless of reasoning, and even arguably advisable, but the tone of \"this is bad and no one should use it\" goes too far - the same core argument can be made without the polarizing approach. \"Consider this alternative to inheritance\" is a lot less problematic than \"an argument against inheritance\", for example. Especially when combined with contrived examples and fallacious arguments that also undermine the point being made, there's certainly reason to push back on OP's statements a bit and point out where they may have missed the boat on why inheritance exists and why it can be useful - but the pushback only exists insofar as their opinions are presented as advice backed up by evidence, and does not extend to their personal choices about the design of their own language.\n\nTLDR, I'm not advocating every feature in every language, but rather a well informed view of the benefits of any feature - pointing out the issues in OP's assessment of inheritance is not to disagree with their decision to exclude it, only that their assessment and presentation as advice are flawed.\n\nGOTO is a bit of a tricky subject because it's such a *massive* footgun when unrestricted. I personally think that unlabeled GOTO (i.e. classic Assembly style, as contrasted by things like `break` or `continue` or even `goto LocallyScopedLabel`) is liable to cause more problems than it's worth, but labeled GOTO and its derivatives are underrated and overstigmatized by association with its unlabeled cousin - and both kinds are overstigmatized period, as is any tool that becomes the face of this month's \"considered harmful\" trend.\n\n>Actually this is an example of reductio ad absurdum. I assumed inheritance was the answer, and obtained a nonsensical value that was a circle yet not a `Circle`.\n\nAgain: this is not a problem inheritance seeks to solve. `Circle` guarantees that it is a circle, not that no other `Ellipse` can be - that's outside the scope of the tool. If you need that functionality, *use a tool that's designed for it*.\n\n>Well, types represent is-a.\n\nYes, they do. And an implementation of `CountingList` which uses composition is a list, but its type does not represent that without additional finegling, because you've used a has-a relationship to model something that's conceptually an is-a relationship.\n\n>For example we could define `ListLike a = { add : Object -> a -> a, addAll : Object[] -> a -> a }` and then both `List` and `CountingList` are `ListLike`.\n\nThis can be represented as a trait or interface, which funnily enough is a type of inheritance. The only difference here is that the relationship is implicit, which has both benefits and drawbacks.\n\n>I also said that that approach doesn't work if you have non-erasable side effects like logging or printing out messages.\n\nWhich is a problem with your architecture design, not with the use of inheritance itself.\n\n>If you have both state and methods, then you get encapsulation issues like with `CountingList`.\n\nI'm not sure what you mean by this. What specific issues?\n\n>I made this post to see if anyone wanted to argue for inheritance and the answer is no, nobody cares that much.\n\nThen what do you consider my comment?\n\n>My experience has been that whenever someone starts bringing up style nits instead of actual counterpoints it is because they have nothing useful to say and they are just blustering.\n\n\"Your examples are contrived to suit your point and don't represent realistic situations\" is not a style nit. My experience has been that whenever someone starts whinging about \"nitpicking\", it's usually because they don't actually know how to support their arguments in the face of someone pointing out the logical holes in it.\n\n\"Good\" is a bit subjective, but I find that inheritance is often the right tool to use when modeling things like config file formats with recursive schemas (such as JSON), where you need to have a number of disparate types that can be easily accessed in similar terms.\n\nFor example, my own Kotlin JSON library uses [a single abstract base class](https://github.com/KatrinaKitten/haven-json/blob/master/src/main/kotlin/com/tripl3dogdare/havenjson/JsonValue.kt) to represent any JSON value, with a generic to allow type-safe access of the underlying value. Then [a number of child classes](https://github.com/KatrinaKitten/haven-json/blob/master/src/main/kotlin/com/tripl3dogdare/havenjson/JsonTypes.kt) override specific pieces of behavior to handle type-specific things (notice that the abstract implementation of `get` simply returns `JsonNull`, where the implementation on `JsonArray` implements it to access by index, and `JsonObject` by string key), and static factory methods on the base type allow for convenient type-agnostic construction but aren't strictly necessary.\n\nThe real glue of this strategy is `JsonNull`, which simply returns itself for any operation other than accessing its underlying value or converting it to string for serialization. This makes it trivial to safely access values deeply nested in any possible JSON structure, as accessing an invalid path simply results in `null` when unwrapped to the underlying value (which Kotlin already has tools to handle well). It's essentially a domain-specific equivalent of Kotlin's `?.` null-safe access operator.\n\nNow, would a similar strategy be possible without inheritance? Sure, there are ways to replicate similar behavior with union types and other such tools, but it's not quite as convenient in reality, and inheritance doesn't present any of the problems here that are normally complained about by its detractors - it's a small self-contained system so there's no \"over-coupling\" possible, there's no instances where the diamond problem (multiple inheritance issues) becomes relevant, etc.\n\nAll the time. \n\nIt depends what you mean by inheritance. \n\nIf you mean Java style inheritance where you basically have two instances at once then no. That\u2019s a nightmare. \n\nOther languages do it much better (like Eiffel for example or scala)\n\nEven in Java if you use traits instead of classes to define your hierarchy you are much better off.", "id": "izp3glf", "owner_tier": 0.5, "score": 0.9999999999166668}, {"content": "Do you have an argument that inheritance isn't compatible with subtyping which does not use `instanceof`/reflection?\n\nIn your encoding you fail to capture the crucial aspect that is open recursion: methods get the \"current object\" as an argument and can call other methods of the same object. I think your refinement type encoding is too rigid in that it won't allow open recursion with inheritance and also too weak in that you can fail at runtime if the method is undefined.\n\nA more natural approach to typing objects is structural, as in [OCaml](https://v2.ocaml.org/manual/objectexamples.html). In the type system you want information on what methods do you have, not some parent-chasing rigid encoding of an inheritance structure.\n\nYeah, that example is a good argument against `instanceof` though, and also for being careful about using logical NOT in your program properties, since it can make them non-monotonic\n\nMore recently I have found [the paper](https://dl.acm.org/doi/abs/10.1145/96709.96721) \"Inheritance is not subtyping\". This has an example of an equality method: the parent compares on i, the child compares on i and b. Inferring open record types, records with i and b are a subtype of records with i. So by contravariance, the parent eq method's type is a subtype of the child's, i.e. the parent method can be typechecked as applying to records with i and b. This contradicts the usual flow of OO subtyping where the child is a subtype of the parent, hence we must conclude there is no subtyping relationship.\n\nNow in practice languages like Java *impose* the subtyping relationship on inheritance, e.g. if you define an equal(Child other) method in the child it will not override the parent's equal (Parent other) method at all, so inheritance that would break subtyping is forbidden. This does turn out to be sound ([paper](https://cs.rice.edu/~javaplt/papers/Inheritance.pdf)) but I think it's pretty confusing to have situations where using the same name doesn't actually override a method.\n\n> Do you have an argument that inheritance isn't compatible with subtyping which does not use instanceof/reflection?\n\nWell, you can emulate `instanceof`, e.g. B has a method `isB() { return true; }` and A which extends B overrides it to `isB() { return false; }`. Of course there are also situations where inheritance does give a true subtyping relationship, e.g. pure immutable data or interfaces that have no implementation inheritance.\n\n> In your encoding you fail to capture the crucial aspect that is open recursion: methods get the \"current object\" as an argument and can call other methods of the same object.\n\nIf you need the current object you can just pass it in args. I left it out because I didn't want to complicate the implementation.\n\n> I think your refinement type encoding is too rigid in that it won't allow open recursion with inheritance and also too weak in that you can fail at runtime if the method is undefined.\n\nThere are some details of statically type-checked dynamic dispatch that I glossed over by making the dispatch dynamically typed, like overload resolution. But the failing part you can avoid by using refinement types to say that exceptions cannot be returned. The proofs may be nontrivial but that's a typical issue that crops up with refinement types.", "id": "izoyme1", "owner_tier": 0.3, "score": 0.37499999991666666}, {"content": "> Suppose A extends B. Then the predicate `\\x -> not (x instanceof A)` is satisfied by B but not by A. So by LSP, A is not substitutable for B.\n\nThat's why using `instanceof` is bad practice - it breaks encapsulation. Do you want to act on something depending on its type, rather than having it act on itself? That's a reasonable thought, but it simply proves that extending types should be more ergonomic.\n(It's also reasonable to claim that the visitor pattern should be avoided - however, it can't at all be replaced by subsitution. ML-style pattern matching and algebraic datatypes do far better on this front.)\n\n> Composition can directly replace inheritance in at least 22% of real-world cases.\n\nAnd what about the other 78%?\n\nThis also neglects the third class of inheritance, which is simply intended for code reuse - all of the proposed solutions lead to O(M*N) implementations for M methods on N related classes.", "id": "izpkc2t", "owner_tier": 0.1, "score": 0.19999999991666667}, {"content": "Kinda cool but also people generally agree that inheritance is bad. GoF talks about composition over inheritance, Go doesn't have it, and yeah James Gosling who's basically the king of modern OOP says it's bad.\n\nKinda feels like you're beating a dead horse. I guess it's still used a lot, but an axiomatic argument like this probably isn't very compelling to that demographic\n\nGo kind of does have it though. You can put a struct inside of a struct and it behaves just like inheritance.\n\nI super agree with this one. One thing that is odd is that I haven't actually seen a reduction in the usage of inheritance in any code base I've ever seen, whether it was new or old.\n\nI wonder why so many people are not concerned that it usually is a suboptimal tool to use in normal situations (not all but many).\n\nNo, it behaves *just like* composition, 'cos of being composition.\n\nNo it behaves exactly like inheritance. You don't even have to specify the dispatch.", "id": "izow2mg", "owner_tier": 0.3, "score": 0.23333333325}, {"content": "Meanwhile within like a month of Rust 1.0, many Servo devs specifically requested inheritance. It helps for some things, like implementing any GUI framework.\n\nAnd yet Rust never added it in the last 7 years and is still fine with it. Meanwhile people are exploring new ways to do GUIs in Rust without inheritance and they seem to be successful in exploring new designs.\n\nThis does not prove anything.\n\nWhen all you have is a hammer, everything looks like a nail.\n\nThe Servo developers were used to solving their problems with inheritance, so they had to unlearn that and learn new ways to figure out solutions with Rust. _Of course_ they would have been more productive, initially, using what they already knew... but that's an argument for conservatism, not any particular feature.\n\nSyntactical code reduction? Probably just need to use a Rust macro. Casey Muratori did a talk on semantic compression which is essentially what I think most people use inheritance for in aggregate as far as I've seen.", "id": "izp3r89", "owner_tier": 0.7, "score": 0.14999999991666665}, {"content": "This is controversial?\n\nComposition over inheritance seems generally accepted. But removing inheritance entirely is not, e.g. Nim has inheritance as an opt in feature. This post argues that we can remove it from the language proper and provide it as a library.", "id": "izowxgd", "owner_tier": 0.7, "score": 0.10833333325}, {"content": "First of all java, C#, C++, ruby, python, php etc have inheritance and the vast majority of world's software is written in them so clearly they work fine and make billions of dollars for companies all over the world.\n\nSecondly composition means you need to write all the methods again possibly dispatching and that's an annoyance.\n\nIn the real world we do deal with objects with common attributes and behaviors so OO gives us a handy tool to model real world concepts in an elegant way.  Your mother is a person and so is your friend. There is no reason they shouldn't inherit from a person object.\n\nOK but:\n\n(1) Maybe that's because OO is good but inheritance is a misconceived part of it that should have been something else. (E.g. traits.)\n\n(2) Is it a coincidence that newer languages aim to replace or abolish inheritance, like Rust and Go? Those languages also have billions of dollars riding on them. And they were produced by big companies with eyes to profit, not by cranks with theories.\n\n(3) At the time when \"Goto considered harmful\" was written, you could have defended `goto` the same way --- the majority of the world's software is written with it, it makes billions of dollars for companies all over the world.\n\nFirst of all most languages and most code uses dependency injection heavily, which is composition not inheritance. Inheritance is often used for reflection/codegen but that is benign. Genuine human usage of inheritance is few and far between, and codebases using it are a nightmare to extend (I've had to deal with it). I'd say that the impact of inheritance is close to zero for the library authors (they could just as well use composition, if the language made it comfortable to use) and a big negative for client code using those libraries (inheriting from code you don't control is a nightmare).\n\nSecondly composition does not mean you have to write them by hand. That's entirely up to the language. Though I do believe writing methods in one place is better as it improves readability (jumping around the superclasses to find which methods and attributes the class actually has, and where they are defined, is unnecessary work).\n\nThird, no, this textbook \"a cat is an animal\" idiocy is completely unrelated to programming in practice. When programming, you don't care what relationships pieces of bits and code have: you care only which method gets called on which struct in memory at runtime to get the right result. Deep inheritance hierarchies are a detriment to that. As someone once said, taxonomy is tge lowest and least useful form of science. It's absolutely useless to decide whether Foo inherits from Bar, or Bar from Foo, or they both inherit from Baz: either way you end up with brittle inextensible unmaintainable code.\n\n>(1) Maybe that's because OO is good but inheritance is a misconceived part of it that should have been something else. (E.g. traits.)\n\nIt's been proven to work. You can shoulda all you want the fact is that it works.\n\n>(2) Is it a coincidence that newer languages aim to replace or abolish inheritance, like Rust and Go? \n\nNo. Programming has always been about fashion. That's what's fashionable now. It will change.\n\n>And they were produced by big companies with eyes to profit, not by cranks with theories.\n\nSo was react, dart, etc. \n\n>(3) At the time when \"Goto considered harmful\" was written, you could have defended goto the same way --- the majority of the world's software is written with it, it makes billions of dollars for companies all over the world.\n\nBut that wasn't true. \n\nAside from that all languages did was hide the goto behind some other construct. When you compile the code it's all full of gotos.\n\n>First of all most languages and most code uses dependency injection heavily, which is composition not inheritance.\n\nWho cares. The point is that in all of those languages you are creating objects and inheriting from them and using the standard library which is based on inheritance.\n\nThe fact that you have other tools at your disposal doesn't mean you don't use OOP code. In fact you inject OOP classes .\n\n>Secondly composition does not mean you have to write them by hand. \n\nIt doesn't? Explain.\n\n>Third, no, this textbook \"a cat is an animal\" idiocy is completely unrelated to programming in practice.\n\nIn practice you deal with mutable objects in real life. Period. End of sentence.\n\n> either way you end up with brittle inextensible unmaintainable code.\n\nBillions of lines of code in the languages I mentioned says otherwise but I guess you have to hold on to your zealotry any way you can. If that means ignoring 99% of all code written in the world then so be it I guess.\n\n>It's been proven to work. You can shoulda all you want the fact is that it works.\n\nAh, yes, proof by confident assertion.\n\n>No. Programming has always been about fashion. That's what's fashionable now. It will change.\n\nOK, but you've gone from pointing out how inheritance used to be popular back in the 1990s and therefore must be good to saying that if inheritance is no longer popular that's just a quirk of fashion.\n\n>But that wasn't true.\n\n>Aside from that all languages did was hide the goto behind some other construct. When you compile the code it's all full of gotos.\n\nSure. But why did you write that? This is r/ProgrammingLanguages. We all know that. As a very loose description, you might say that this whole subreddit is a discussion of how to \"hide the goto\", how to write in something other than machine code.\n\n> Ah, yes, proof by confident assertion.\n\nAs I said well over 90% of all code in the world is written in object oriented languages.\n\n>OK, but you've gone from pointing out how inheritance used to be popular back in the 1990s and therefore must be good to saying that if inheritance is no longer popular that's just a quirk of fashion\n\nIt's still wildly popular. See above.\n\n>Sure. But why did you write that?\n\nTo point out how foolish your statement was.\n\n\\>As I said well over 90% of all code in the world is written in object oriented languages.\n\nAgain let me remind you that the issue isn't OO but inheritance specifically.\n\n(Also, everyone uses non-decimal time. That's not proof that it's a good idea but rather proof that some technical debt is unfixable.)\n\n\\>It's still wildly popular. See above.\n\nNo, *OO* is still popular. *Inheritance* is not \"wildly popular\". We're now at the point where books on OO tell you to avoid it, and where people designing new languages omit it.\n\n\\>To point out how foolish your statement was.\n\nThen you failed.\n\n>Again let me remind you that the issue isn't OO but inheritance specifically.\n\n\n\nAll of that code uses classes that inherit from other classes.\n\nIf as you say inheritance is dangerous that means 90% of the software being used today is dangerous and unmaintainable and crashing constantly.\n\nSorry but that's just an insane claim from an unthinking zealot.\n\n>No, OO is still popular. Inheritance is not \"wildly popular\".\n\nIt literally is. Go look at any object in the .NET  or Java standard library.\n\n>Then you failed.\n\nI showed that you are an unthinking zealot who can't see past their rigidly held ideology. A fundamentalist.  The taliban of developers!\n\n>Sorry but that's just an insane claim from an unthinking zealot.\n\nAnd one that appears in your post but not mine.\n\nBack in the real world, to suggest that something (for example, the goto statement) is a misfeature is not in fact to say that software developed in languages with that feature \"crashes constantly\". Dijkstra did not write a paper called \"Goto considered as the reason why all software written in C, Fortran, and Cobol crashes constantly\".\n\n>I showed that you are an unthinking zealot who can't see past their rigidly held ideology. A fundamentalist. The taliban of developers!\n\nYour fantasies about me are amusing but inaccurate.", "id": "izpau52", "owner_tier": 0.7, "score": 0.15833333324999999}, {"content": "\nHi Mathnerd,\n\nNot sure if coincidence but this also came up as a subject on Coffee Compiler Club today. And you've clearly put some effort into your post and been thinking about this - let me try and give you as good a reply as I can.\n\nI think its sound advice to \"think twice\" about adding any language feature, but to also air some caution to the alternatives you've suggested -\n\nAs engineers, we often look too deeply at the similarities of ideas. While the differences of ideas is where their true value lies.\n\nI think a good starting point is mentioning that Inheritance comes in a few combinations.\n\nPublic/Private Inheritance - I believe the correct name is Open/Close inheritance, but searching for that will return the Open-Closed principle. Private Inheritance means a subclass can only access methods of the superclass.\n\nStatic/Dynamic Inheritance - Dynamic inheritance is what Smalltalk has and what Self took and made into prototype inheritance.\n\nAnd the roots of inheritance - Alan Kay has written about inheritance and speaks of two things.\n\n[\"Differential Programming\"](https://qr.ae/prTRmM), the idea of a tool that allows engineers to construct something that \"is like this other thing, but with slight differences\".\n\nAnd he mentions the need for a [\"Mathematical binding\"](https://qr.ae/prTRDr) to this concept to stop people making a mess.\n\nThe where, when, and if you should use differential programming really is subjective and has trade-offs, pro's and con's just like any language feature.\n\n**Circle-Ellipse Problem**\n\nIMHO, where implementations of inheritance went wrong is with the \"Mathematical binding\". [\"A behavioural Notion of Subtyping\" By Barbara Liskov](https://dl.acm.org/doi/10.1145/197320.197383) is a wonderful paper that outlines LSP.\n\nThe root of the problems is that we've tried to combine her behavioural typing with our older typing strategies (nominal, structural etc) and our old notions of what a type is.\n\nSummary From Wikipedia (But also in the paper linked above)\n\n    Subtype Requirement: Let O(x) be a property provable about objects x of type T. Then O(y) should be true for objects y of type S where S is a subtype of T.\n    That is, if S subtypes T, what holds for T-objects holds for S-objects. In the same paper, Liskov and Wing detailed their notion of behavioural subtyping in an extension of Hoare logic, which bears a certain resemblance to Bertrand Meyer's design by contract in that it considers the interaction of subtyping with preconditions, postconditions and invariants.\n\nProperties here are invariants, preconditions and postconditions - e.g. *Value Assertions*, while Static Typing is on *variables*\n\nThe Circle-Ellipse problem arises from trying to reconcile a static type system with behavioural typing.\n\nAs the rest of the LSP paper defines, invariants are inherited into the subclass. So it is inevitable that some assertions are going to be added to those new subclasses that are not present in the superclass. And the range of values a given subclass can hold will be smaller than the superclass.\n\nSo here is the Circle-Ellipse again\n\n    class Ellipse {\n      int width, height;\n      func setWidth(w) {...}\n      func setHeight(h) {...}\n      func area() { return pi * (w/2) * (h/2); } \n      func circumference() {\n        let a = (w/2);\n        let b = (h/2);\n        let h = (a - b)^2 / (a + b)^2\n        return pi * (a + b) * ( 1 + (3 * h) / 10 + sqrt(4 - 3 * h));\n      }\n      func bar() { return 42; }\n    }\n    \n    class Circle: Ellipse {\n      invariant(width == height);\n      override func circumference() {\n        return 2*pi*(w/2);\n      }\n      func bar() { Throw(\"This can never happen on a Circle\"); }\n    }\n\nNow we understand that LSP/Behavioural types are value oriented, the moment a type becomes present is in the execution and situation of that Object.\n\nE.g. 1 No invariance violations, always correct\n\n    func foo(Ellipse a) {\n      return a.circumference();\n    }\n\nE.g. 2 Sometimes correct - there *is* a case were the below works, and that's if Width and Height were already 10.\n\n    func bar(Ellipse a) {\n      a.setWidth(10);\n      return a.area();\n    }\n\nE.g. 3 Will always fail if given a Circle.\n\n    func baz(Ellipse a) {\n      return a.foo();\n    }\n\nIf LSP is to gain traction, we need to improve Model checking to get at these types and give us the feedback we're used to.\n\nSoz, already quite long. Hope its of some use!\n\nKind Regards, M \u270c\n\nThat was him on Coffee Compiler Club making that argument \ud83e\udd23", "id": "izpxvn7", "owner_tier": 0.3, "score": 0.08333333324999999}, {"content": "> but here we can just use lambdas\n\nYes and no. Technically, you can replace any interface parameter with a set of closures. But the interface has more semantics: it states that these functions share some mutual state. That's the intention. When someone passes a bunch of closures that reference the same state, I'd get rather sceptical in comparison. Sure, you can force all of those lambdas to work over the same generic state monad, or pass and return the same state type. But at that point it's just confusing for anyone but the most academic programmers compared to a simple interface.\n\nBut yeah, in my experience, the majority of interface parameters can just be replaced with lambdas without any big downsides. But there are rare cases where you want the explicit notion of an interface, even if just for clarity.", "id": "izsatbk", "owner_tier": 0.7, "score": 0.06666666658333334}, {"content": "In my experience, inheritance is terrible but not for those reasons. It's terrible because:\n\n- code coupling: you depend on one or more pieces of code, often not controlled by you, which can break your code in weird ways with just a version bump\n\n- the `private` keyword: if the authors of the superclass used it, inheriting from them becomes a nightmare (`private` should be replaced with `protected` in all cases) \n\n- concrete classes in method types: if a superclass's method requires or returns a concrete type rather than an interface, good luck substituting with another class. Now you need to inherit from another class too (snowball effect) \n\n- constructors that do too much: even if all the class's methods are public or protected, there still may be a lump of non-overridable code in the constructor of the superclass. This is recognized as bad style, but I've seen it and had to dance around it with useless dummy code\n\n- adding to the \"concrete classes\" problem, you cannot override a method to return a subclass of what the super's method returns, even though that would be totally type-safe. Some smart languages like Newspeak don't have this problem, but the mainstream languages do. \n\nThe best solution I know of is Golang's type embedding. It's composition, but it's as concise as inheritance with none of its problems.", "id": "izrg6mb", "owner_tier": 0.3, "score": 0.05833333325}, {"content": "Allan, my fundamental argument for inheritance is simple, and not religious: It's nice to be able to re-use the large portion of one existing design in the creation of some new and different design.\n\nInheritance is one way in which this is achieved, and has proven useful over the years for this purpose; that is not to argue that the concept has no faults, but rather to state that it has use (it has _value_). Were we to discover a new way of doing this, let's call it \"_DefinitelyNotInheritanceButGreatReuseWithDeltas_\", and it had none of the downsides of inheritance, then we would all quickly switch to it, right?\n\nSo your mission is to figure out what DefinitelyNotInheritanceButGreatReuseWithDeltas (hereafter DNIBGRWD) actually is, and how it avoids some of the problems that have plagued languages that relied heavily on inheritance. I will enjoy seeing what you come up with.\n\nAlso, I'm curious as to the \"this could just be done in a library\" line of thought. IIRC, you're working on a replacement for the C language, so your requirements will likely match the static rigidity of that vein of languages. What would such a library look like, and how would it be used?\n\nLastly, languages have rules, and to assume that all implementations of the concept of \"inheritance\" will look exactly like whatever-your-favorite-whipping-boy of a language is (maybe Java?) is a poor start to a thought exercise. Step back and ask yourself what exactly it is about the concept of inheritance that you so viscerally dislike: Is it too many rules? Not enough rules? The wrong rules? The idea itself?", "id": "izsrkjx", "owner_tier": 0.5, "score": 0.05833333325}, {"content": "> Then the predicate \\x -> not (x instanceof A) is satisfied by B but not by A. So by LSP, A is not substitutable for B.\n\nYou could avoid that by just not having `instanceof` -- in fact, it's common to use c++ that way with `-fno-rtti` that disables `dynamic_cast`.\n\nAnd more importantly, that's not actually an argument against *inheritance*, because it also applies to interfaces.  Instead, it's an argument for [*parametricity*](https://en.wikipedia.org/wiki/Parametricity) -- anything where you can behave differently based on something not part of the type signature.", "id": "izvpgow", "owner_tier": 0.3, "score": 0.05833333325}, {"content": "**Is not \"one size fits all\".**\n\nUseful for some stuff, overused for others.", "id": "izq1z83", "owner_tier": 0.7, "score": 0.04999999991666667}, {"content": "Wait, is composition strictly speaking only about has-a relationships?\n\nI could have sworn I've heard at least some people talking about composition as being something like using (multiple) inheritance from interfaces instead of classes. Is that not correct?\n\nBut I guess what really is the distinction between a class that has members of type A B and C, and a class that implements interfaces A B and C? I feel like those are basically isomorphic.\n\nYes, composition is has-a; interfaces/traits are really a form of inheritance, just one that's a lot less rigid and bypasses a lot of the issues strict inheritance can cause if used carelessly. \n\nSome people use composition to model is-a relationships in order to avoid inheritance, but personally I think it's fundamentally a conceptual mismatch, since in reality you're creating a has-a relationship and pretending it's an is-a relationship (which loses out on the primary benefits of being an is-a relationship, in the process of trying to avoid the accompanying footguns).\n\nThe term \"composition\" unfortunately has several meanings, and some of those meanings conflict.", "id": "izr5dg6", "owner_tier": 0.3, "score": 0.07499999991666666}, {"content": ">Inheritance is often confused with subtyping. But in fact inheritance isn't compatible with subtyping, at least if we define subtyping using the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Suppose A extends B. Then the predicate `\\x -> not (x instanceof A)` is satisfied by B but not by A. So by LSP, A is not substitutable for B.\n\nThat doesn't mean all inheritance doesn't work, or am I missing something? You're only showing why *that specific predicate* couldn't be used. And that would be a really odd precondition to have if the class wasn't final.\n\nLSP is \"Let \u03d5 be a property provable about objects of type T. Then \u03d5 should be true for objects of type S where S is a subtype of T. \" LSP should hold for all such properties \u03d5, but I've exhibited a predicate for which it fails. And I made no assumptions about the objects, hence LSP fails on this predicate for every inheritance relationship. The only choices are to exclude this predicate somehow, e.g. by not allowing predicates containing `instanceof`, or to consider instances of A members of a distinct type (neither subtype nor supertype) from instances of B.\n\nI find this Wiki article a little better in explaining behavioral subtyping which (at least based on my small amount research) is sort of the more generic term for liskov substitution. I've also seen a few times some criticisms of the original form of what Liskov described. It seems like it wasn't fully thought out (or rather, given the luxury of hindsight people have thought of better ways to phrase it).\n\nhttps://en.wikipedia.org/wiki/Behavioral_subtyping\n\n>Firstly, in its original formulation, it is too strong: we rarely want the behavior of a subclass to be identical to that of its superclass; substituting a subclass object for a superclass object is often done with the intent to change the program's behavior, albeit, if behavioral subtyping is respected, in a way that maintains the program's desirable properties. Secondly, it makes no mention of specifications, so it invites an incorrect reading where the implementation of type S is compared to the implementation of type T. This is problematic for several reasons, one being that it does not support the common case where T is abstract and has no implementation.\n\nPerhaps more interestingly Barbara Liskov herself described the definition she gave at that conference as an informal rule based on intuition and her and some colleagues went on to better define it in papers. She also says the technical term is behavioral subtyping. https://youtu.be/-Z-17h3jG0A", "id": "j0vyrdz", "owner_tier": 0.9, "score": 0.06666666658333334}, {"content": "An argument against inheritance is that it is counterintuitive and has better alternatives. Inheritance is often confused with subtyping, but is not actually compatible with it according to the Liskov substitution principle. In addition, inheritance can lead to poor encapsulation, whereas object composition offers better encapsulation. A study has shown that composition can replace inheritance in at least 22% of real-world cases.\n\nI'm not sure why your comment was downvoted (whether or not I agree with it). A couple of points to consider:\n\n* Barbara Liskov is a genius; of this there is no doubt. But her \"substitution principle\" is no more realistic than saying \"type systems should prevent all forms of runtime errors\". I like the principle, but in reality there are engineering trade-offs that will occur, or you'll end up with languages like Coq and Idris that no one uses (outside of academic circles). To be clear, Coq and Idris (etc.) are brilliant in their inception and design, but as languages for building things, they are borderline unusable.\n\n* _\"inheritance can lead to poor encapsulation ...\"_ Absolutely! And sometimes this is exactly why it gets used (to work around something that was \"too well\" encapsulated).\n\n* _\"object composition offers better encapsulation.\"_ This seems like a reasonable statement, and aligns well with what I have seen. (As a side note, I dislike the use of the term \"composition\" as it is far too general a term, and sometimes includes inheritance as a form. I'm not sure what term I would prefer; perhaps \"aggregation\" or something similar.)\n\n* _\"A study has shown that composition can replace inheritance in at least 22% of real-world cases.\"_ I would have guessed far higher. I think inheritance is a reasonable tool that gets overused, but I personally appreciate having it when it is available in languages that I use.", "id": "izrbvic", "owner_tier": 0.1, "score": 0.04166666658333333}, {"content": "You're picking a bad example of inheritance (deciding object types at runtime) to attempt to prove that inheritance is bad.\n\nUnconvincing.\n\nBad code is bad code, it will happen no matter the language, no matter the design pattern.\n\nBy the way:\n\n    Ellipse makeCircleOrEllipse(float x, float y) {\n      if(x == y)\n        return new Circle(x);\n\nThe fact that you're using `==` on `floats` (which will never return `true`) makes me think you might be a bit new to the field of software development. I suggest you spend some more time reading up and learning.", "id": "izrbf38", "owner_tier": 0.7, "score": -8.333333282687742e-11}], "link": "https://www.reddit.com/r/ProgrammingLanguages/comments/zi03k9/an_argument_against_inheritance/", "question": {"content": "In this post my goal is to prove that the OO notion of inheritance is counterintuitive and has better alternatives. In particular you should think twice about including it in your language - do you really want another footgun? Let it be known that this is by no means a minority viewpoint - for example James Gosling [has said](https://www.infoworld.com/article/2073649/why-extends-is-evil.html) that if he could redo Java he would leave out the extends keyword for classes.\n\nFirst I should define inheritance. Per [Wikipedia](https://en.wikipedia.org/wiki/Inheritance-oop) inheritance is a mechanism for creating a \"child object\" that acquires all the data fields and methods of the \"parent object\". When we have classes, the child object is an instance of a subclass, while the parent object is an instance of the super class. \n\nInheritance is often confused with subtyping. But in fact inheritance isn't compatible with subtyping, at least if we define subtyping using the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Suppose ``A extends B``. Then the predicate ``\\x -> not (x instanceof A)`` is satisfied by ``B`` but not by ``A``. So by LSP, A is not substitutable for B.\n\nIf this is too abstract, consider a simple example you might find in university class:\n\n    class Ellipse {\n      final float minor_axis, major_axis;\n      Ellipse(float x,float y) {\n        minor_axis = x;\n        major_axis = y;\n      }\n    }\n    class Circle extends Ellipse { \n      Circle(float radius) {\n        super(radius,radius);\n      }\n    }\n  \n`Ellipse` must be immutable, otherwise one could make a circle non-circular. But even this is not enough, because ``new Ellipse(1,1)`` is a circle but is not a member of the `Circle` class. The only solution is to forbid this value somehow, e.g. requiring to construct the objects using a factory function:\n\n    Ellipse makeCircleOrEllipse(float x, float y) {\n      if(x == y)\n        return new Circle(x);\n      else\n        return new Ellipse(x,y);\n    }\n\nBut at this point we have lost any encapsulation properties, because the implementation is tied to the definition of ellipses and circles. A more natural solution is avoid inheritance and instead declare Circle as a refinement type of Ellipse:\n\n    type Ellipse = Ellipse { minor_axis, major_axis : Float }\n    type Circle = { e : Ellipse | e.minor_axis == e.major_axis }\n\nThen an ellipse with equal components is automatically a circle.\n\nInheritance is contrasted with object composition, where one object contains a field that is another object. Composition implements a has-a relationship, in contrast to the is-a relationship of subtyping. Per [this study](https://link.springer.com/chapter/10.1007/978-3-642-39038-8_24) composition can directly replace inheritance in at least 22% of real-world cases. Composition offers better encapsulation. For example, suppose we have a `List` class with ``add`` and ``addAll`` methods, and we want a \"counting list\" that tracks the total number of objects added.\n\n    class List { add(Object o) { \u2026 }; addAll(Object[] os) { \u2026 } }\n    class CountingList extends List {\n      int numObjects;\n      add(Object o) { numObjects++; super.add(o); };\n      addAll(Object[] os) {\n        // XXX\n        for(Object o in os)\n          super.add(o)\n      }\n    }\n\nWith inheritance the `CountingList.addAll` method cannot call the parent `List.addAll` method, because it is an implementation details as to whether `List.addAll` calls `add` or not. If it did not call `add`, we would have to increment `numObjects`, but if it did, `add` would resolve to `CountingList.add` and that method would update the counter. In this case, we could do `int tmp = numObjects; super.addAll(os); numObjects = tmp + os.length` to save and overwrite the object counter, but in a more complex example such as logging each added object there is no way to overwrite the effect. So the only option is to do it the slow way and call `add`, which can be expected to not call any other methods of the class.\n\nWithout inheritance, just using composition, the problem disappears. We can call `super.addAll` because it definitely does not call `CountingList.add`; there is no parent-child method aliasing:\n\n    class CountingList {\n      int numObjects;\n      List super;\n      add(Object o) { numObjects++; super.add(o); };\n      addAll(Object[] os) {\n        super.addAll(os)\n        numObjects += os.length\n      }\n    }\n\nThere is one remaining use case of inheritance, where you have overloaded methods implementing an interface. For example something like the following:\n\n    interface Delegate {\n      void doSomething(Info i)\n    }\n\n    class A implements Delegate {\n      void doSomething(Info i) { ... }\n    }\n\n    class B implements Delegate {\n      void doSomething(Info i) { ... }\n    }\n\nBut here we can just use lambdas.\n\n## Replacement \n\nSo far we have seen inheritance being replaced with a variety of techniques: refinement types, composition, and lambdas. It turns out this is all we need. Consider two arbitrary classes in an inheritance relationship:\n\n    class A { Field_a_1 f_a_1; Field_a_2 f_a_2; ...; Result_a_1 method1(Arg_a_1_1 a_1_1, Arg_a_1_2 a_1_2, ...); ...; }\n    class B extends A { Field_b_1 f_b_1; Field_b_2 f_b_2; ...; Result_b_1 method1(Arg_b_1_1 b_1_1, Arg_b_1_2 b_1_2, ...); ...; }\n\nWe must have a generic method that dispatches to the appropriate implementation. For extensibility this must not be a giant switch, but rather the method should be stored in the value (a vtable pointer). So we can implement it like this:\n\n    vtable_A = {\n      method1 = ...;\n      ...; \n    }\n\n    type A_instance = A { Field_a_1 f_a_1; Field_a_2 f_a_2; ...; vtable = vtable_A; }\n    type A = { a | (a : A_instance) or (a.parent : A) }\n    \n    vtable_B = {\n      method1 = ...;\n      ...; \n    }\n    \n    type B_instance = B { Field_b_1 f_b_1; Field_b_2 f_b_2; ...; vtable = vtable_B; A parent; }\n    type B = { b | (b : B_instance) or (b.parent : B) }\n\n    generic_invoke object method_name args = {\n      if(method_name in object.vtable)\n        object.vtable[method_name](args)\n      else if(object.parent)\n        generic_invoke(parent,method_name,args)\n      else\n        throw new Exception(\"no such method defined\")\n    }\n\nThe lambdas are needed to allow defining the vtable. Composition is used to include the parent pointer. Refinement types are used to define the \"subtyping\" relationship commonly associated with inheritance, although as explained above this relationship is not actually subtyping. So in your next language use these constructs instead of inheritance; you can implement inheritance, multiple inheritance, and a lot more, all without unintuitive footguns.", "id": "zi03k9", "title": "An argument against inheritance", "traffic_rate": 16.86659877800407}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}, {"answers": [{"content": "There are a few reasons, one of which is simply that many tools will expect your classes to conform to the Java Beans specification and attempt to manipulate your objects using the getter and setter functions.\n\nIn addition, by making the fields private you ensure that all modifications to them will have to happen under your control.  Your setter might perform validation or edit checks on the values being passed, whereas raw access to the field won't have that level of safety.  You can't mark a field 'private write/public read' so that makes using a getter a necessity.\n\nAlso, you may find that a few weeks down the road you've delegated responsibility for the values in those fields to some other object, so you change your getter code from this:\n\n    String getName() {\n        return name;\n    }\n\nto \n\n    String getName() {\n        return getNameHelper().getName();\n    }\n\nand remove the name field altogether.  If you are referring to it directly you will be a lot more reluctant to refactor in this way since you may have to change a couple of dozen other source modules.\n\n[deleted]\n\nAlso a big part is that you can perform additional modifiers, such as synchronisation on fields. \n\n> one of which is simply that many tools will expect your classes to conform to the Java Beans specification and attempt to manipulate your objects \n\nThis has nothing to do with why *should* properties be private.\n\n> In addition, by making the fields private you ensure that all modifications to them will have to happen under your control.\n\nAnyone capable of seeing the functions as private can make them public/protected by redefining the class and intantiating that class, so this is simply untrue.\n\nThe primary reason to keep functions private is *intent*. This means it is an effective way to tell the \"coder\" how the class is to be used beyond comments.\n\nUsually you have two types of classes: ones that are mostly structs and ones that do business logic. The former should usually have getters, the latter not. \n\nEspecially for things like dependencies, god help you if you make a dependency publicly accessible and someone else grabs it and accidentally mucks with its settings\n\nAnother approach is to use builders & immutable objects.  I'm not 100% sold on this yet, but having used this model recently, I'm finding it more and more useful.\n\nNot for Java beans\n\nI disagree in a way, I think getters and setters should exist and even be used internally, but scope of the getter/setter should be used appropriately. If the field really is private, keep the getters and setters private too, and so on.\n\nWhat do you mean by \"redefining\" the class?\n\nWhat is the value of a private get method if all it does is give you a field you can access anyway?\n\nRedefining a class is a scenario that's not uncommon in every language with access specifiers. If I can see the fields are private, I have access to the source code (that's the implication and common case). With the source, I can define a new class with them as public, then replace the class.\n\nThe purpose of a private field is either \"this is accounting tied to specific functionality\" or \"having access to this may cause unintended consequences, use the external interfaces plz\". It's very rare you want to use private instead of protected, if you have the option. Of course, private methods tie you immediately to the current implementation, in plain java and any accounting ends up being private for functional consistency when you extend the class. ", "id": "clalfcc", "owner_tier": 0.9, "score": 0.9999999998765433}, {"content": "So here's my basic example:\n\n    public class Item {\n        private String name;\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {            \n            Log.i(\"ITEM\", \"Name changed from outside of object.\");\n            this.name = name;\n        }\n    }\n\nIn this example, a log event is fired when the name is changed. Since this is the only way to change the name from outside the class, it will always fire.\n\nNow, this is a trivial example, but it gets to the point where you can see that there's some sort of process that happens every time the field is set. You could similarly fire something every time it's accessed, for access control methods.\n\nThe reason we design like this all the time, is because you never know when you're going to need to add one of those extra little processes. If you start out with a public field, people writing against your code are going to read and write the field directly, so if you change your mind later, you either break their code, or leave a hole in your program.\n\nDoes that make sense?\n\n/u/RhoOfFeh makes a really good point about Beans, too, but that's a little bit further down the road from where you are now.", "id": "clamftu", "owner_tier": 0.5, "score": 0.2345679011111111}, {"content": "There's lots of talk around state and encapsulation, but no one has mentioned the reason managing both of those things is important: immutability.\n\nIn a multi-threaded environment, the state of your object is extremely important.  While you may or may not be tackling the subject of concurrency at the moment, rest assured you most definitely will in the near future.\n\nAs a result, making instance variables as unmodifiable as possible is imperative.  An example would be a Transaction object which contains a currency amount like $1.00, a sender like \"Bob\", and a receiver like \"Carl\".  You don't want to have to send all three of those values separately, so you generate this Transaction object to carry the values.\n\nIf you don't make the variables private, they become mutatable by any other thread (which, in this particular financially-related case is especially bad!).  So, you instead create the object via a constructor passing those three values in and initializing the three values at object instantiation.  You then only provide accessor methods (getters) to those three values.  By doing this, you ensure that no other threads may modify the Transaction, but enabling all threads to access the Transaction without fear of mutation.\n\nExample below:\n\n    public class Transaction {\n        private final double currency;\n        private final String sender;\n        private final String receiver;\n        \n        public Transaction(double currency, String sender, String receiver) {\n            this.currency = currency;\n            this.sender = sender;\n            this.receiver = receiver;\n        }\n\n        public double getCurrency() {\n            return this.currency;\n        }\n\n        public String getSender() {\n            return this.sender;\n        }\n\n        public String getReceiver() {\n            return this.receiver;\n        }\n    }\n\nNote also that by initializing all variables at instantiation, you can also make your private fields final.  This improves performance at runtime, as well as a couple of other benefits.\n\nSee also Josh Bloch's Effective Java - Item 15.4\n\nExcept in the case of finals, even if they were public nobody could modify them, so you would be safe here either way\n\nIsn't it basically useless to worry about the performance impact using constants or variables has at this level?\n\nYou can't modify the reference, but your could change the state of the object. For example, you could add to a list that is final.\n\nHow so?  If the fields are public, they can be modified. This is the very definition of public.\n\nNot if you have many objects built this way, all with final instance variables.\n\nVery true, also a good example of when getters/setters can do more than just basic access:\n\nIt is generally advised that you do a list copy on get/set instead of just maintaining a pointer to some collection that an outside entity can screw with at whim.\n\nAlso a good reason to make object's fields final whenever possible, to avoid deep modification by anyone who happens to have access to it. In practice though, I often find this is more trouble than it is worth.\n\nNot if they are final. Final means they can only be set one, from a constructor, static block, or similar\n\nCopy on get can be expensive. What you should do in a method which returns a Collection is use an unmodifiable type which simply wraps the existing collection without a full out copy.\n\ne.g. return Collections.unmodifiableList(listAttribute);\n\nIf the caller wants to create a copy of it for their own purposes then nothing stops them from doing this.\n\nAfter doing this, you then provide interface methods to remove/add to this list if desired. This makes it much easier to track down where these lists are being modified versus some business logic utility grabbing the list, passing it into some other business logic method and three levels deeper you find where somebody is changing this list.\n\nOkay, I see what you mean now.  You're saying you could remove the getter's in the above case.  \n\nThat makes sense in the context of the example as is.  However, you'd be unable to do any additional work to the variables (ala rounding up/down to the closest integer at retrieval) if you did not provide the method accessors.\n\nTrue, if you add some of the stuff discussed elsewhere (encapsulation, delegation) it becomes relevant again. But immutability is generally not a concern covered by making fields private. The points in your original post are correct, but more tangentially related to the originally posted question", "id": "claptjh", "owner_tier": 0.1, "score": 0.543209876419753}, {"content": "Take this class\n\n    class FriendSet {\n        private Set<String> secretInternalFriends = new HashSet<>();\n        public void addFriend(String friend) {\n            if(friend.equals(\"billy\")) {\n                throw new RuntimeException(\"BILLY CAN NEVER BE MY FRIEND\");\n            } else {\n                secretInternalSet.add(friend);\n            }\n        }\n        public Set<String> getFriends() {\n          return Collections.unmodifiableSet(secretInternalFriends);\n        }\n    }\n\nThis class lets clients add friends, except for \"billy.\" getFriends() returns an unmodifiable set, so that they don't go and add \"billy\" to the set behind the objects back. Now imagine if the secretInternalFriends field was public. A client could do this:\n\n    FriendSet friends = new FriendSet();\n    friends.secretInternalFriends.add(\"billy\");\n\nNo exception will be thrown. The client has defeated the entire purpose of the class.\n\nIn general, that's one of the main advantages of Java over a dynamic language like JavaScript, Python, or Ruby. Those languages provide very little ability to prevent clients of objects from directly modifying or screwing up the internal state of the object. Clients should have no knowledge of the internal representation of data, or the structures or algorithms used. They only need to know the objects public interface.\n\n\nYou couldn't have described this any more complex could you? :P\n\nWhat these lines mean is that you can put conditions on the getters and setters if you might need them. The main reason of course is to give the least amount of access to everything outside of your class.\n\nThis doesnt answer the question of why it is appropriate to use getter setter exclusively regardless of functional requirements\n\nWoops you are right that this is too complicated. This is just the first example of encapsulation that came to mind.\n\n...so you can add constraints later on.", "id": "clam3n0", "owner_tier": 0.1, "score": 0.1111111109876543}, {"content": "It breaks encapsulation.\n\nHaving a public interface allows you to protect clients of the interface from having to undergo significant modification in the event that the implementation of the interface changes. \n\nEDIT: I realize this explanation may not be simple enough. Give me some time to think of a more straightforward answer or maybe someone else can offer a better explanation.\n\n[deleted]\n\nUnless you are just defining a bean/entity in which there is no internal state per se. ", "id": "clalinb", "owner_tier": 0.1, "score": 0.12345678999999998}, {"content": "Almost all methods make assumptions about the state of their fields; for instance a field that contains the length of a string corresponds to the number of characters in the underlying array of chars. If it is public and not final another method could change this breaking the assumptions of the class. Public fields can also break encapsulation; with private fields their structure and implementation can be changed without breaking any code that accesses it through its API.", "id": "clamgys", "owner_tier": 0.1, "score": 0.03703703691358025}, {"content": "When creating a class, you want to expose as little of its inner workings to the world as possible, making the user of your class play by your rules. If the field is public, it can be changed from outside the object by referencing it directly, bypassing any e.g. validation or logging, and changing one small piece of the state of the class instance, possibly putting the object into inconsistent state.\n\nSure, at first it doesn't look sensible to create a getter and/or setter that only returns/sets the private field, but later, when you want to make the field read-only, or want to add some behavior (calculating the value of some other dependent fields in the setter, for example), you'll find that the refactoring takes a lot less time with the getter and setter already in place.", "id": "claydda", "owner_tier": 0.7, "score": 0.03703703691358025}, {"content": "Check out this PDF from a Williams College Professor of Computer Science:\n\n[http://dept.cs.williams.edu/JavaStructures/Book_files/JavaStructures.pdf](http://dept.cs.williams.edu/JavaStructures/Book_files/JavaStructures.pdf)\n\nIt quickly gets into why abstraction and encapsulation are important points for good software development.", "id": "claly48", "owner_tier": 0.5, "score": 0.02469135790123457}, {"content": "Reverse your question -- if you just allow direct access to the `name` field, and then later decide you DONT want it to just return `name` anymore, how do you change it without breaking code that was already written to use it directly?\n\nIn this example you might decide instead of just returning `name` you want to return the user's entire name built from `firstName` and `lastName` fields. This would be impossible if you already had a bunch of clients just grabbing `name` directly.\n\nThey say to do it all the time because you often wont realize/know what things you will want to change in the future.\n\nAnd keep in mind the JVM is getting better all the time and it will try to inline accessor calls in some cases -- so in fact you can often use an accessor and get all of their benefits, but get the same performance as a direct field access.\n\n\n", "id": "clasexm", "owner_tier": 0.5, "score": 0.02469135790123457}, {"content": "Lots of great points in this thread, but I haven't seen anyone mention Security. By keeping your fields private you can ensure that they are only changed via setters and getters. If you don't want a field to be changed because it could break some other parts then you can avoid a setter and anyone working on the codebase in the future can't do so.", "id": "clay80n", "owner_tier": 0.5, "score": 0.02469135790123457}, {"content": "I highly recommend checking out [Project Lombok]( http://projectlombok.org) to get rid of all the crappy boilerplate code with getters and setters. \n\nYour objects can all conform to the beans spec without cluttering up your source\n\nI second this!\n\nAnemic Java Beans are really really frustrating and a cancer upon java. People say \"but my ide generates the code for me!\" However\n\n1. I have to rely on the IDE, and some arcane GUI to do this.\n2. It still makes the code an unreadable mess.\n3. If my object model changes at all, I have to manually regenerate this code.\n\n\nI find that IDEs are a lot easier to work out than the problems that get thrown up by things like Lombok. Sure it reduces some clutter, but why not just use a different JVM language if verbosity is that much of a problem?\n\nLombok has excellent Eclipse and IntelliJ support.\n\nNot sure what problems you're referring to with Lombok, but it's been a breeze to use in the 3 or 4 projects that I use it in on a daily basis.\n\n>why not just use a different JVM language if verbosity is that much of a problem?\n\nSeems rather drastic.  Lombok solves the problem elegantly without the host of problems involved with getting another language involved in with my projects. \n\n\nI find that lombok is pretty transparent in it's code generation. It's doing the same thing that the IDE would, just in a way that is documented in the code and makes the code more expressive of my intent.", "id": "clamt3o", "owner_tier": 0.5, "score": 0.061728394938271605}, {"content": "I don't see a mention of escape analysis.\n\nThis is a newer jdk feature which tracks modifications and helps the VM manage multitasking and garbage collection.\n\nThere are also other guides that claim private fields improves performance without escape analysis, but I'm having a hard time finding a term easily found out a source to cite.", "id": "clanzxt", "owner_tier": 0.5, "score": 0.012345678888888888}, {"content": "You will hear a lot of nonsense reasons and really twisted examples, the truth of the matter is: it is idiomatic java.  \n\nIdioms are really important to programming languages as they provide a shorthand for both reading and writing and expected norms.  If you go off the reservation, prepare to spend more time talking about why you don't use getters and setters than solving the actual problem at hand.\n\nEven if all your getters and setters are dumb valueless wrappers, they are still what other Java developers expect to find and that has value. \n\n", "id": "claod52", "owner_tier": 0.5, "score": -1.2345679012345679e-10}, {"content": "I ran out of time while composing the other response, but there's another reason for getters to exist.  It's called \"lazy initialization\".\n\nI do this kind of thing all the time:\n\n    Set<String> valueList = null;\n\n    void addValidValue(String newValue) throws InvalidValueException {\n        if (null == newValue) {\n            throw new InvalidValueException(\"Null values are not allowed\");\n        }\n        else {\n            getValueList().add(newValue);\n        }\n    }\n\n    //Lazy initialization.  Don't create the Set until we need it.\n    public Set<String>getValueList() {\n        if (null == valueList) {\n            valueList = new HashSet<String>();\n        }\n        return valueList;\n    }\n\n\n\nStupid question, why do you compare null to valueList instead of valueList to null? I know many languages have some nuance related to this, I'm just unsure of the nuance. \n\nEdit: So many responses! Thank you! \n\nIt's a practice named Yoda conditions - see http://en.m.wikipedia.org/wiki/Yoda_conditions.\n\nThere's no real benefit to it in Java, but in languages where assignments are allowed in if statement conditions it can prevent nasty bugs from cropping up if assignment (=) is used instead of an equals check (==).\n\nI am not sure if this is in the Java coding conventions. I think it is just one's style of writing.\n\nThat's an old convention from my days as a C coder who came up from BASIC.  There is no difference at all between 'null == value' and 'value == null'.  However, it does protect one from the possibility, however remote, of using 'value = null' because one made a typo, or forgot that in this language one uses '=='.  \n\nThat is not really a mistake I make anymore, I've been developing in languages with this syntax for a long time now.  However, I've allowed it to remain part of my style.\n\nI think in the case of comparing null, there isn't exactly a practical reason. But there is a reason for comparing objects for equality that way. Let's say you have a *name* variable, and you want to check if *name == \"bob\"*. If *name* is null then you will get a null pointer exception. If you instead write it as *\"bob\" == name*, then you will never get a null pointer exception because the equals method is being called on *\"bob\"* instead of *name*. I would think that OP just does this universally for consistency's sake. It's easy to just remember that if you have something known, then it should go on the left.\n\n== doesn't care if either side is null; the .equals() method requires the object it's being called on to not be null.\n\nOh that's right, I can't believe I forgot that.", "id": "claox57", "owner_tier": 0.9, "score": 0.18518518506172837}, {"content": "I think your intuition is right in a sense. Getters/setters that map directly to fields don't really add all that much. That's why in many languages, such as objective c, or c#, you don't actually have to provide getter/setter implementations.\n\nThe deeper reasons to make field private are:\n\nA) To isolate the internal representation of an object from the interfaces it exposes. A Date class may expose a method to set a date by some type of calendar, but it's internal representation may be in seconds from some established time. This is encapsulation.\n\nB) Setter/getters are not really meant to be used but for the simplest cases. You may have an object whose fields are interdependent, in which case setters would allow you to put the object in an inconsistent state for instance. In general, you want objects to do work and track it via their field values, rather than have code do work and represent state into a separate object. Then there's the whole principle of making certain types of object immutable, where you'd have no setters at all...\n\nI hope this helps.", "id": "claq7z5", "owner_tier": 0.1, "score": 0.012345678888888888}, {"content": "First thing I thought when I saw the title, and I may or may not be wrong, I have no idea:\n\n1. Abstraction (the Java community really likes this lol :P)\n2. Control\n3. Overriding (combined with the above)\n\nEdit: Oh, and please correct me if I'm wrong.", "id": "clatejy", "owner_tier": 0.3, "score": 0.012345678888888888}, {"content": "It's one of the pillars of OO, encapsulation.  Hiding your implementation details from the consumer lets you change those implementations without the consumer having to change or even be aware tat a change occurred.\n\nFor some languages (C# and Java included) it's especially important to start out with a property (getter methods) because re-factoring toward properties after having a public field can cause breaks.  So, in the end it's best to start with the property even if that property is a \"pass-through\", so that if in the future you need to do something else you can without breaking the consumers.", "id": "clauf4c", "owner_tier": 0.7, "score": 0.012345678888888888}], "link": "https://www.reddit.com/r/java/comments/2jd63m/why_should_fields_be_kept_private/", "question": {"content": "Hey /r/java!\n\nI'm currently taking Comp Sci in HS, and I have a strong background of JavaScript, Python, and Ruby.\n\nRecently the teacher/textbook told us that fields are best kept private, and that a `getFieldName` method is the way to access the value of that field.\n\nThis doesn't make any sense to me. When you've got a method called `getName()` which just returns `name`, why not make `name` a public field?", "id": "2jd63m", "title": "Why should fields be kept private?", "traffic_rate": 55.985432016075016}, "saved_time": "Tue, 16 Jul 2024 03:59:30 GMT", "source": "reddit"}]}