{"result": [{"answers": [{"content": "As danben previously said, you're just copying the same dict into 3 variables, so that each one refers to the same object. To get the behaviour you want, you should instantiate a different dict in each variable:", "id": 2439352, "owner_tier": 0.5, "score": 0.0166666665}, {"content": "I agree with what is said above. The key here is that, in Python, assignments represent references to the object.\nI was trying to grasp the concept myself and I think is it important to understand in which case a new object is created and when is the existing one changed. In the example above, the line: doesn't create a new object. It only changes the object which is referenced by dict_a, dict_b, and dict_c. If, instead, you wrote: it would create a new object which would be referenced by dict_c. Dict_a and dict_b would still be pointing to the empty object. In that case, if you run: you would get:", "id": 62374952, "owner_tier": 0.1, "score": -1.6666666666666666e-10}, {"content": "Even though  is the right way to go in most cases, when it get more than 3 it looks weird Imagine In cases where I wanna initialize more than 3 things, I use", "id": 2445989, "owner_tier": 0.5, "score": 0.16666666649999998}, {"content": "This is because in Python, variables (names) are just references to individual objects.  When you assign dict_a = dict_b, you are really copying a memory address (or pointer, if you will) from dict_b to dict_a.  There is still one instance of that dictionary. To get the desired behavior, use either the dict.copy method, or use copy.deepcopy if your dict may have nested dicts or other nested objects.", "id": 2438943, "owner_tier": 0.9, "score": 0.9999999998333333}, {"content": "Your first assignment assigns the same dictionary object to the variables dict_a, dict_b, and dict_c. It is equivalent to dict_c = {}; dict_b = dict_c; dict_a = dict_c.", "id": 2438945, "owner_tier": 0.3, "score": 0.0166666665}], "link": "https://stackoverflow.com/questions/2438938/does-python-make-a-copy-of-objects-on-assignment", "question": {"content": "When I try this code: I expected that it would just initialise the dict_a, dict_b and dict_c dictionaries, and then assign a key in dict_c, resulting in But it seems to have a copy-through effect instead: Why? See also:", "id": 2438938, "title": "Does Python make a copy of objects on assignment?", "traffic_rate": 13}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "For class objects, I find it's best to add their own copy method.  This allows a work around for internal, non-pickelable objects in the deepcopy: In your working code, it would then become: This is a toy problem of course.  In reality, you would do this if you have complex objects within your class which cannot be readily copied directly with the copy.deepcopy() type operation.  If it were a simple problem, just use b = copy.deepcopy(a) without the explicit definition in the class.", "id": 75163196, "owner_tier": 0.5, "score": -1.1363636363636364e-10}, {"content": "Using this you can almost copy everything from one object to another: However, if you run the code above, you will see these errors: You can only copy these read-only properties by doing it on the class static initialization, like the other built-in magic python methods as __str__ just above: Now this new version completely works coping everything: The disadvantage of it is that you need to write the Python code manually to overcome the read only attributes. However, you can write python code on the fly with metaprogramming: So, if you work over this initial code just above, you can write a script which generates the code it needs to. Hence, you can dynamically and completely copy any Python object.", "id": 48970465, "owner_tier": 0.5, "score": 0.01136363625}, {"content": "If your class does not modify __getitem__ or __setitem__ for special attribute access all your attributes are stored in __dict__ so you can do: If you use python properties you should look at inspect.getmembers() and filter out the ones you want to copy.", "id": 244116, "owner_tier": 0.9, "score": 0.6590909089772727}, {"content": "If you have to do this, I guess the nicest way is to have a class attribute something like : Then iterate them explicitly and use setattr(new, attr, getattr(old, attr)). I still believe it can be solved with a better design though, and don't recommend it.", "id": 252393, "owner_tier": 0.9, "score": 0.022727272613636364}, {"content": "At the risk of being modded down, is there a decent any use-case for this?  Unless we know exactly what it's for, we can't sensibly call it as \"broken\" as it seems. Perhaps try this: That's the sane way of copying things between instances.", "id": 248608, "owner_tier": 0.9, "score": -1.1363636363636364e-10}, {"content": "Try destination.__dict__.update(source.__dict__).", "id": 244654, "owner_tier": 0.9, "score": 0.9999999998863637}], "link": "https://stackoverflow.com/questions/243836/how-to-copy-all-properties-of-an-object-to-another-object-in-python", "question": {"content": "Is there a library method to copy all the properties between two (already present) instances of the same class, in Python? I mean, something like Apache Commons' PropertyUtilsBean.copyProperties()", "id": 243836, "title": "How to copy all properties of an object to another object, in Python?", "traffic_rate": 13}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "You're right,  using deepcopy from the built-in copy module is the way to go, since you want the exact replica of the Object Foo. Here, passing the object Foo(5) will return a Foo object, passing it without any args will return __name__.Foo", "id": 72220352, "owner_tier": 0.3, "score": 0.9999999900000002}], "link": "https://stackoverflow.com/questions/72219980/how-to-copy-a-class-object-in-python", "question": {"content": "This is quite a simple question, however I cannot seem to figure out how to do it. I simply need to make a copy of a class object, for example: I tried to do both A.copy() and A.deepcopy(), but I get \"'Foo' object has no attribute 'copy'\"\nThis may be a super simple fix, however I have never used the copy module before and am not aware of why this may be an issue.\nFor reference, I need the copied object to be mutable (without affecting the original) so I figured the best way would be to use .deepcopy().", "id": 72219980, "title": "How to copy a class object in python", "traffic_rate": 3103}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python", "class", "object", "copy"]}, {"answers": [{"content": "So, if I change values of the fields of the new object, the old object should not be affected by that. You mean a mutable object then. In Python 3, lists get a copy method (in 2, you'd use a slice to make a copy): Shallow copies are just copies of the outermost container. list.copy is a shallow copy: You don't get a copy of the interior objects. They're the same object - so when they're mutated, the change shows up in both containers. Deep copies are recursive copies of each interior object. Changes are not reflected in the original, only in the copy. Immutable objects do not usually need to be copied. In fact, if you try to, Python will just give you the original object: Tuples don't even have a copy method, so let's try it with a slice: But we see it's the same object: Similarly for strings: and for frozensets, even though they have a copy method: Immutable objects should be copied if you need a mutable interior object copied. As we can see, when the interior object of the copy is mutated, the original does not change. Custom objects usually store data in a __dict__ attribute or in __slots__ (a tuple-like memory structure.) To make a copyable object, define __copy__ (for shallow copies) and/or __deepcopy__ (for deep copies). Note that deepcopy keeps a memoization dictionary of id(original) (or identity numbers) to copies. To enjoy good behavior with recursive data structures, make sure you haven't already made a copy, and if you have, return that. So let's make an object: And copy makes a shallow copy: And deepcopy now makes a deep copy:", "id": 46939443, "owner_tier": 0.9, "score": 0.49999999996855343}, {"content": "To get a fully independent copy of an object you can use the copy.deepcopy() function. For more details about shallow and deep copying please refer to the other answers to this question and the nice explanation in this answer to a related question.", "id": 4794254, "owner_tier": 0.9, "score": 0.9999999999685535}, {"content": "Shallow copy with copy.copy() Deep copy with copy.deepcopy() Documentation: https://docs.python.org/3/library/copy.html Tested on Python 3.6.5.", "id": 52160051, "owner_tier": 0.9, "score": 0.08490566034591195}, {"content": "I believe the following should work with many well-behaved classed in Python: (Of course, I am not talking here about \"deep copies,\" which is a different story, and which may be not a very clear concept -- how deep is deep enough?) According to my tests with Python 3, for immutable objects, like tuples or strings, it returns the same object (because there is no need to make a shallow copy of an immutable object), but for lists or dictionaries it creates an independent shallow copy. Of course this method only works for classes whose constructors behave accordingly. Possible use cases: making a shallow copy of a standard Python container class.", "id": 48906171, "owner_tier": 0.5, "score": -3.1446541038514446e-11}], "link": "https://stackoverflow.com/questions/4794244/how-can-i-create-a-copy-of-an-object-in-python", "question": {"content": "I would like to create a copy of an object. I want the new object to possess all properties of the old object (values of the fields). But I want to have independent objects. So, if I change values of the fields of the new object, the old object should not be affected by that.", "id": 4794244, "title": "How can I create a copy of an object in Python?", "traffic_rate": 146}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python", "oop", "object", "copy"]}, {"answers": [{"content": "If you want to make a copy then one way is using deepcopy: All = does is to assign another reference to the same object in memory. The deepcopy creates a whole new object in memory with the values of A and B will reference it. if you do the following you will see different prints:", "id": 42143502, "owner_tier": 0.9, "score": 0.9999999993333333}], "link": "https://stackoverflow.com/questions/42143461/make-copy-of-object-instance-in-python", "question": {"content": "I would like to make a copy of a python class object which does not change when the original object changes. Here is my simple working example: From my understanding, when I set B = A, this just means B points to the object A. Hence when I change A it changes B as well. Is it possible to instead make B a new instance with all the same properties as A, but does not change when I change A? In my above example, I would like the value for B to stay at 1 when I increment A.  If A and B were lists instead of objects I would write B = list(A). I guess I am asking if there is a similar method for class objects? Thank you in advance for your help!", "id": 42143461, "title": "Make copy of object instance in Python", "traffic_rate": 22762}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python", "oop"]}, {"answers": [{"content": "In general, you can use the copy module to produce copies of Python objects. copy.copy() will produce a shallow copy; a new instance is created but all attributes are simply copied over. If any of your attributes are mutable and you mutate those objects you'll see those changes reflected on both objects. copy.deepcopy() will produce a copy recursively; any mutable objects will themselves be cloned. If your class implements a __copy__ method it'll be used to create a shallow copy of the object; return a new instance with attributes copied over and altered as needed. Similarly, you can implement a __deepcopy__ method to implement a custom deep copy method; it'll be passed the memo state, pass this on to recursive copy.deepcopy() calls. Note that you cannot use this to copy a class object however. Classes are meant to be singletons; you don't need to create a copy in that case. You can use subclassing instead, or a class factory function, to produce distinct class objects.", "id": 29398459, "owner_tier": 0.9, "score": 0.9999999994736841}], "link": "https://stackoverflow.com/questions/29398336/how-to-copy-instances-of-a-custom-defined-class-in-python-3-3", "question": {"content": "I am trying to copy instances of a custom class in Python 3.3, similar to how dict.copy() and list.copy() work. How do I go about this? Here is an example of my custom class:", "id": 29398336, "title": "How to copy instances of a custom defined class in Python 3.3?", "traffic_rate": 15121}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python", "python-3.x"]}, {"answers": [{"content": "Does Python make a copy of objects on assignment? This is because in Python, variables (names) are just references to individual objects. When you assign dict_a = dict_b, you are really copying a memory address (or pointer, if you will) from dict_b to dict_a. There is still one instance of that dictionary. In your example, df and instance.df is the same thing of dict_a and dict_b, which is only holding the reference of the instance. How to delete every reference of an object in Python? No no no. Python has a garbage collector that has very strong territory issues - it won't mess with you creating objects, you don't mess with it deleting objects. Simply put, it can't be done, and for a good reason. This is by design and intentional, delete the variable of df, would not eliminate the existence of the instance, it only remove the reference from you df, therefore, as long as instance.df is still holding the instance, you could still access it even you deleted the variable df.", "id": 73328910, "owner_tier": 0.3, "score": 0.0}], "link": "https://stackoverflow.com/questions/73328857/does-python-copy-objects-on-instance-attribute-assignment", "question": {"content": "Consider some Python 3 code where we have a very large object, and I need to store a reference to this object within a class due to third-party libraries. In this case, the object df is a very large numpy array (>20 GB) and my system's memory is already almost maxed out. Does assigning df as an instance attribute duplicate the memory required, or simply act as a reference to the existing object? In code: I'm hitting some memory issues later on and trying to debug where it might be coming from. My intuition tells me that Python knows to not copy the object, however if we do something like del df then instance.df is still defined.", "id": 73328857, "title": "Does Python copy objects on instance attribute assignment?", "traffic_rate": 410}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python", "memory", "bigdata"]}, {"answers": [{"content": "I have mostly figured it out. The only problem which I cannot overcome is knowing an acceptable set of initialization arguments (arguments for __init__) for all classes. So I have to make the following two assumtions: 1) I have a set of default arguments for class C which I call argsC.\n2) All objects in C can be initialized with empty arguments. In which case I can\nFirst:\nInitialize a new instance of the class C from it's instance which I want to copy c: Second:\nGo through all the attributes of c and set the attributes c_copy to be a copy of the attributes of c where object_copy is a recursive application of the function we are building. Last:\nDelete all attributes in c_copy but not in c: Putting this all together we have: So putting it all together we have: {'a': 11, 'r': [[1], 2, 3]} {'a': 11, 'r': [[1], 2, 3]} {'a': 11, 'r': [[1, 33], 2, 3]} {'a': 11, 'r': [[1], 2, 3]} Which is the desired outcome. It uses deepcopy if it can, but for the cases where it would raise an exception, it can do without.", "id": 48528831, "owner_tier": 0.5, "score": -3.1250002585636594e-10}, {"content": "One way to do that is by implementing __copy__ in the C Class like so: ", "id": 48339837, "owner_tier": 0.5, "score": 0.21874999968749997}, {"content": "Yes you can make a copy of class instance using deepcopy: This creates the copy of class instance 'c' in 'd' .", "id": 48339768, "owner_tier": 0.5, "score": 0.9999999996875}], "link": "https://stackoverflow.com/questions/48338847/how-to-copy-a-python-class-instance-if-deepcopy-does-not-work", "question": {"content": "I would like to make a copy of a class instance in python. I tried copy.deepcopy but I get the error message: RuntimeError: Only Variables created explicitly by the user (graph leaves) support the deepcopy protocol at the moment So suppose I have something like: And now I want to make an identical deep copy of c, is there an easy way?", "id": 48338847, "title": "How to copy a Python class instance if deepcopy() does not work?", "traffic_rate": 51}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python", "class", "deep-copy"]}, {"answers": [{"content": "If you take a look at dir(test1), you'll see that one of the elements is 'copy'. In other words, you're not just copying the type attribute. You're copying the copy method. test2 gets test2.copy set to test1.copy, a bound method that will copy test1. Don't use dir for this. Look at the instance's __dict__, which only contains instance-specific data.", "id": 45765988, "owner_tier": 0.9, "score": -9.99999993922529e-09}, {"content": "Your copy() method copied the copy method (not the function from the class) from test1, which means that self in test2.copy() is still test1.", "id": 45765979, "owner_tier": 0.9, "score": 0.9999999900000001}], "link": "https://stackoverflow.com/questions/45765946/cant-do-a-copy-of-an-object-in-python-3-with-attributes", "question": {"content": "I'm using some objects in python with dynamic properties, all with numbers and strings. Also I created a simple method to make a copy of an object. One of the property is a list, but I don't need it to be deep copied. This method seems to work fine, but I found an odd problem. This piece of code shows it: Where is my conceptual error? Thanks.", "id": 45765946, "title": "Can&#39;t do a copy of an object in python 3 with attributes", "traffic_rate": 172}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python-3.x", "oop"]}, {"answers": [{"content": "If you want to create a copy of the class and assign that to a new object, you can use copy: Depending on the structure of your class, you may want to do a deepcopy instead. A shallow copy will only copy references to the objects found in your initial class. A deepcopy will attempt to recursively copy all objects within your original class. There can be issues with this if you have some recursive structure within your classes, but for the most part this won't be an issue. See this for more info - https://docs.python.org/2/library/copy.html", "id": 40478341, "owner_tier": 0.5, "score": 0.9999999966666667}], "link": "https://stackoverflow.com/questions/40478253/python-copy-class-object-to-another-class", "question": {"content": "I have a class defined as follows: I have a dictionary which contains the key value pairs which has key indices and values are table objects. Now I want to get the table object and copy the details to another object, something like: How do I change the class or copy the details to another object?", "id": 40478253, "title": "Python: Copy class object to another class", "traffic_rate": 3591}, "saved_time": 1721101368, "source": "stackoverflow", "tags": ["python", "oop"]}, {"answers": [{"content": "You need to copy the array\n\n`current_data =` [`self.data`](https://self.data)`[:]`\n\nor\n\n`current_data = self.data.copy()`\n\notherwise your variable refers to the same one, and it is reversed in place.", "id": "jfqhcgl", "owner_tier": 0.1, "score": 0.9999999983333333}, {"content": "You're not copying. Simple assignment *never* copies in Python. You would need to copy the data explicitly.", "id": "jfqhmtd", "owner_tier": 0.5, "score": -1.6666666565375483e-09}], "link": "https://www.reddit.com/r/learnpython/comments/12htd7g/copying_an_attribute_of_an_object_into_a_variable/", "question": {"content": "Hi! I feel like this is a very basic concept that I am doing wrong. I have a function of an object that has to access an attribute of the same object, copy it and reverse it. (I'ts an array)\n\n&#x200B;\n\n    def back_propagation(self, expected_values):\n    \n    \n         current_data = self.data\n    \n         current_data.reverse()\n\nHowever, when I do this [self.data](https://self.data) also gets reversed. What am I doing wrong? How can I fix this? Thank you!", "id": "12htd7g", "title": "Copying an attribute of an object into a variable", "traffic_rate": 153.12444444444444}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "`copy.copy` only copies the outer list, not the inner lists. It simply creates new references to those inner lists. Compare, for example, `id(masterList[0])`, `id(nested[0])`, and `id(empty[0])`.\n\nThere's a difference between `copy.copy` and `copy.deepcopy` for any object that contains references to other objects. `copy.copy` creates a new object with the same references. `copy.deepcopy` creates a new object with references to new objects.\n\nOk that makes sense! Thank you. In that case why would I not want to use deepcopy every time?\n\nBecause there might be a situation where a shallow copy is desired (you might need the new object to contain the same references) or at least is sufficient (consider that copying large nested structures might be quite wasteful in terms of runtime and memory). For nested lists specifically, maybe shallow copies are less often needed, but `copy.copy` and `copy.deepcopy` work on all Python objects.\n\nBut while using deepcopy might give worse performance, using copy or play = might lead to unexpected side effects that can be highly confusing. Ibprefer to start with trying to avoid mutability and start optimizing if it matters.", "id": "j15dozd", "owner_tier": 0.3, "score": 0.9999999991666666}, {"content": "https://www.reddit.com/r/learnpython/comments/zr8uxy/how_the_value_of_a30_is_changed_to_b_while_a1/", "id": "j169f4u", "owner_tier": 0.5, "score": -8.333333282687742e-10}], "link": "https://www.reddit.com/r/learnpython/comments/zrz5t9/not_understanding_copy_vs_deepcopy/", "question": {"content": "I'm on chapter 4 of Automate the Boring Stuff with Python, about lists. He explains the difference between mutable and immutable datatypes, and how if you assign the same list to two different variables and change the list in one, it will do the same to the other variable since they are referencing the same list.\n\nTo avoid this problem he introduces the copy.copy() functions from the copy module, and explains that...\n\n>If the list you need to copy contains lists, then use the copy.deepcopy() function instead of copy.copy(). The deepcopy() function will copy these inner lists as well.\n\nHowever I tried to test this and I see no difference:\n\n    import copy\n    \n    list1 = ['A', 'B', 'C']\n    list2 = ['E', 'F', 'G']\n    list3 = ['H', 'I', 'J']\n    list4 = ['K', 'L', 'M']\n    list5 = ['N', 'O', 'P']\n    list6 = ['Q', 'R', 'S']\n    \n    alpha = [list1, list2, list3]\n    beta = [list4, list5, list6]\n    masterList = [alpha, beta]\n    \n    print(masterList)\n    print(id(masterList))\n    print()\n    \n    nocopy = masterList\n    print(nocopy)\n    print(id(nocopy))\n    print()\n    \n    empty = copy.copy(masterList)\n    print(empty)\n    print(id(empty))\n    print()\n    \n    nested = copy.deepcopy(masterList)\n    print(nested)\n    print(id(nested))\n    print()\n\nThe result is the following:\n\n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614336\n    \n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614336\n    \n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614784\n    \n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614912\n\nI see the copy functions have different IDs, but the copy.copy() function copied the lists inside the lists... what am I not understanding? Can someone show me an example of when these two would be different? Why wouldn't I just always use deepcopy to be safe?", "id": "zrz5t9", "title": "Not understanding copy vs deepcopy", "traffic_rate": 153.12444444444444}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": ">In simple terms, after a bit of experimentation, deep copy is a copy where you can do shenanigans without messing with the original object. Shallow copy is essentially a copy which affects the original. That makes sense\n\nWell, that's not _exactly_ correct. Let's see what [the Python docs say about this](https://docs.python.org/3/library/copy.html):\n\n> The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):\n\n> * A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.\n\n> * A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.\n\nSo, the first indication here is that it only matters for objects that contain other objects.\n\nA deep copy is basically a recursive copy operation, where it continues to copy each sub-object and sub-object of the sub-objects until it reaches a point where there's nothing else to copy.\n\nA shallow copy just copies the references from the target to the clone. So, if you then modified a field in a sub-object, the change would be reflected in the original, since they are both pointing to the object that has the field that has been modified.\n\nBut it comes down to understanding how references work. Here's an example of a _shallow_ copy, but shows that not everything you do affects the copy target:\n\n    from copy import copy\n    \n    class Person:\n        def __init__(self, fname, lname):\n            self.firstName = fname\n            self.lastName = lname\n    \n    p1 = Person('Jack', 'Smith')\n    p2 = copy(Person)\n    p2.firstName = 'James'\n    \n    print(p1.firstName) #prints Jack\n    print(p2.firstName) #prints James\n\nIn this example, `copy` performs a shallow copy on our `Person` object, and copies the references to the string from `p1` into `p2`. But then we _reassign_ the `firstName` field. That means we set a brand new reference, and as such, the change wouldn't be reflected back to the original object, because now they are pointing at two completely different strings.", "id": "h3q3k0i", "owner_tier": 0.9, "score": 0.9999999900000001}, {"content": "if you have a list of immutable objects (strings, ints, bools) then you can just shallow copy them to avoid the overhead of making new instances", "id": "h3q00e4", "owner_tier": 0.7, "score": -9.99999993922529e-09}, {"content": "\u201cMaking a shallow copy of an object won\u2019t clone child objects. Therefore, the copy is not fully independent of the original\u201d. Maybe this little blurb can lead to some use cases.\n\nEdit: you may also want to create a copy of the original object at a point in time and then modify the original without modifying the copy. So like taking a snapshot, just being aware that the copy will still affect the original\n\nI was thinking on that blurb and coming up fairly blank - it makes sense to me they exist, what they may be, I wouldn't really be sure (in my case, I mainly use Python in the context of data analysis and engineering, so there are some language features I may not lean on too heavily). On the point of the edit though that makes sense - cheers!", "id": "h3q0a08", "owner_tier": 0.5, "score": 0.9999999900000001}], "link": "https://www.reddit.com/r/learnprogramming/comments/obtkt6/python_what_is_the_use_case_for_shallow_copy/", "question": {"content": "Before going further, to clarify: the question is not what is the difference between shallow copy and deep copy.  \n\n\nIn simple terms, after a bit of experimentation, deep copy is a copy where you can do shenanigans without messing with the original object. Shallow copy is essentially a copy which affects the original. That makes sense. Here's my question:  \n\n\nIf shallow copies affect the original, why wouldn't we just act on the original object? What would be a practical case where using it makes sense? The fact it exists means there's some case where it is useful but haven't a clue myself what that case may be! :)", "id": "obtkt6", "title": "Python - what is the use case for shallow copy?", "traffic_rate": 759.40625}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "Try making a list that contains lists as it's items.\n\nThen try shallow copy and deep copy and modify one of the nested lists.\n\nYou should see a difference then.\n\n'''\n\n\\>>> c = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n\n\\>>> d= c.copy()\n\n\\>>> e=c\n\n\\>>> f=list(c)\n\n\\>>> g=c\\[:\\]\n\n\\>>> c\n\n\\[\\[1, 2, 3\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> c\\[0\\].append(\"COOL\")\n\n\\>>> c\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> d\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> e\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> f\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> g\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> d is c\n\nFalse\n\n\\>>> e is c\n\nTrue\n\n\\>>> f is c\n\nFalse\n\n\\>>> g is c\n\nFalse\n\n\\>>>\n\n'''\n\n&#x200B;\n\nFrom this,  only operator that stood out was e = c. They both have the same ids. whereas the other pairs had different pair of ids. Does this mean \"= operator\" is the only one that used deep copy?  I am really sorry, if I sound dumb. Thanks for the previous reply!!\n\nBut you did not use deep copy anywhere.\n\n    >>> a = [[1,2,3],[4,5,6]]\n    >>> b = a.copy()\n    >>> b[0][0]=333\n    >>> a\n    [[333, 2, 3], [4, 5, 6]]\n    >>> import copy\n    >>> c = copy.deepcopy(a)\n    >>> c[0][0]=555\n    >>> c\n    [[555, 2, 3], [4, 5, 6]]\n    >>> a\n    [[333, 2, 3], [4, 5, 6]]\n    >>>\n\nMost regular copies create shallow copies, only deep copy creates a full copy of the contained items as well.\n\nYou can see in example above, .copy() created for b was shallow, meaning it copied the reference to the inner lists, but not the inner lists themselves. so changing b\\[0\\] resulted in a\\[0\\] being changed.\n\nOn the other hand, c is a deepcopy, so changing anything there does not reflect on a.\n\nThe assignment operator, in Python, doesn't copy.  Ever.  It adds a reference to a object, basically giving it a new name (as a variable), or putting that reference into a container (like a list or dictionary).\n\n&#x200B;\n\nThe lists that have different ids from c, are shallow copies.  However, when you append 'COOL' you are not adding it to one of the copied lists, you are adding it to a list that is inside *all* the lists, even the copies.  Do the following for all the lists (c, d, e, f, g):\n\n    [id(x) for x in c]  # then change 'c' to 'd', then 'e', etc\n\nYou will see that the ids are the same, since even the copies refer to the same objects inside them, and thus they all contain the same list objects.\n\n&#x200B;\n\nA \"deep\" copy would make copies of those inner lists to.  So, try this next:\n\n    from copy import deepcopy\n    h = deepcopy(c)\n    [id(x) for x in h]  # now you will see it contains different list objects\n\nThis was what I needed. Thank you so much for putting up with my doubts!", "id": "fr09n2b", "owner_tier": 0.7, "score": 0.9999999975}, {"content": "A shallow list copy makes a copy of exactly one object: the list.  The objects inside the list are added to the new list, but they are the same objects.  A deep copy makes a copy of the list, and a copy of each mutable object inside the list, and a copy of each object that the mutable objects inside the list hold, etc.\n\nSlicing with \\[:\\] is a shallow copy (It's older than the list.copy() method, which came later as a more intuitive addition; but they both do the same thing).\n\nlist() constructor can make a list for any sequence, so it's a bit more than just a shallow copy; it can also change the type of the sequence (into a list).\n\nAssignment (=) does not copy.  Repeat, assigning an object doesn't copy it.  It's more like giving another name to an object.  That's why when you assign a list, you still get the same list, just with two names referring to it.\n\n&#x200B;\n\nObjects have id's.  Here's a list and it's id number:\n\n    >>> l = [1, 2, 3]\n    >>> id(l)\n    4321308016\n    \n    # But, if I assign the list, the new name still refers to the same object'\n    # The id is the same for both:\n    >>> l2 = l\n    >>> id(l2)\n    4321308016\n    \n    # However, if I make a copy of the list, that makes a new list object,\n    # with a different object id.  It's a different list, with the same content\n    >>> l3 = l.copy()\n    >>> id(l3)\n    4322278608\n\nThank you so much for the reply! \n\nSo from what you are saying, any changes in the shallow copied list  will result in a change on the former list as well? I mean for an example \"List1= List2.copy()\"... if a change is made in the List2, will it be seen on the List1 only when they are shallow copied? Whereas you can't see the change, when deep copied?  \n\n&#x200B;\n\nCan I assume the techniques that I have mentioned in my question, all use shallow copy principle?\n\n>So from what you are saying, any changes in the shallow copied list  will result in a change on the former list as well?\n\nNo.  That's an actual copy, so changing the copied list won't affect the original list.\n\n&#x200B;\n\nIt's when a list is just assigned (using '=') that no copy is made, so changing List1 or List2 affects the other (because there is no \"other\" object; it's the *same* list object, not a copy).\n\n&#x200B;\n\nDeep copying is for when a list holds a list.  A copy of the list means both copies still hold the same list inside, and so changing that *inner* list appears to affect both (because there is really only 1 inner list object, that both outer list copies refer to).  By making a \"deep\" copy of a list that holds a list, you get copies of both the outer and inner list objects.\n\n&#x200B;\n\n>Can I assume the techniques that I have mentioned in my question, all use shallow copy principle?\n\nThe assignment isn't a copy.\n\n&#x200B;\n\nThe slice, list.copy(), and list() constructors make shallow copies.  To get a deep copy, you generally need copy.deepcopy (from the 'copy' module), although some custom objects could provide their own helpers for making a deep copy.\n\nThank you! I understood the mechanics finally!", "id": "fr0bk8n", "owner_tier": 0.7, "score": 0.9999999975}, {"content": "1) Yes `.copy()` is a shallow copy it basically copies the values from the list to a new part of memory and returns the reference. An example of the effects of shallow copy:\n\na = [1, 2, 3]\n\nb = [a, 4]\n\nc = b.copy()\n\nc[1] = 5\n\nprint(b[1]) # still 4\n\nc[0][0] = 6\n\nprint(a[0]) # now 6\n\nprint(b[0][0]) # also 6\n\n2) `[:]`,  `list()` and `.copy` do the same when it comes to copying a list `=` on the other hand  just copies the reference. When you create an array imagine it's like placing  down a house and writing down the address of that House  that's what is stored in the variable. When you change something in the list it's like going to the saved address and changing the window of that house. Now when you copy the variable using an equal sign it's like copying the address to the house instead of placing down a new house. Now when you do a shallow copy you are kinda placing down a new identical house and storing that address. Now when you do another shallow copy imagine that house you are copying is holding addresses of other houses, when you duplicate the house you don't actually go into the house, go to those addresses and copy those houses too you just copy the single house a deep copy would go through all the referenced houses and copy them too. I hope that analogy helped/made sense!\n\nInteresting to see different perspectives on this concept! Thank you so much for the reply!", "id": "fr0ctw6", "owner_tier": 0.3, "score": -2.4999999848063226e-09}], "link": "https://www.reddit.com/r/learnpython/comments/glwyw2/shallow_and_deep_copy/", "question": {"content": "I am fairly new to the Python realm. What is the difference between shallow and deep copy? I know the theoritical part of it but Im not actually able to understand while practicing it. \n\n1)Does the **list.copy()** work on shallow copy technique? How does it work? \n\n2)How does it differ from the other copying techniques like the = operator; slicing [:] ; list() constructor? \n\nI have experimented it on the interactive python using two lists list1 and list2. When using \"List2 = List1\", I was able to see changes I made to the List2 on the List1. Whereas  copying the contents of List1 to the List2 using \" List2 = List1.copy()\" , didn't do so. \n\nPlease enlighten me! Thanks in advance!", "id": "glwyw2", "title": "Shallow and Deep Copy", "traffic_rate": 153.12444444444444}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "It sounds like you are attempting to mock up the parts of the code you need to test.\n\nI am not sure why a simple sequence of copy, mutate, compare doesn't  effectively test the independence of the two copies.\n\nThe sub-objects that deepcopy needs to operate on all have refcounts; might `sys.getrefcount` or `gc.get_referrers` help?\n\n\nNot sure how that would work in my case. The child classes are all mocked - and therefore deepcopy on the instance simply returns the same object.\n\nNot sure how that would work in my case. The child classes are all mocked - and therefore deepcopy on the instance simply returns the same object.\n\nYou should only mock up the parts of the system that are irrelevant to the current test. Your test should run the code that does the child object's deepcopying, so you should'nt mock them for this test.\n\nYou should only mock up the parts of the system that are irrelevant to the current test. If your test involves the code that does the child object's deepcopying, so you shouldn't mock them for this test.\n\nExactly - and I am not trying to test that the object gets copyied correctly - that is tested elsewhere in the suite. Here I am trying to prove that the parent class does the right thing - and that includes invoking deep copy on it's children - regardless of what those children are. \n\nI think the ONLY solution is to refactor the code on ALL of my classes (current around 20) so that they have a copy method - and they are responsible for deepcopying themselves. That way I can prove that the parent class calls the copy method and can test each class with mocked out children.\n\nMy intuition is that you should test each class with **all** of it's dependencies mocked out - and then also do integration testing where you test the API with everything in place (with maybe only external sources mocked up so you can control data and error conditions).\n\nThank you for trying to help - it is appreciated.", "id": "dnqjvnd", "owner_tier": 0.3, "score": 0.9999999979999998}, {"content": "You could always add a `copied` parameter in `__init__`.\n\nshudders a little - I would prefer I didn't have special attributes just to support testing.\n\nIt's definitely not the ideal solution. You could write a new class in your test, add the attribute, and only have it exist in the test, but again that's a lot of work.", "id": "dnqmfvb", "owner_tier": 0.5, "score": 0.19999999799999998}, {"content": "    for member_new, member_old in zip(object_new, object_old):\n        if type(member_new) not in immutable_types:\n            assert member_new == member_old\n            assert member_new is not member_old\n        if member_new and member_old are iterable:\n            recurse\n\n> it doesn't prove that the new instance is a copy.\n\npast checking equality and checking IDs, you can't prove or deny if something is a copy or not (and there isn't a reason to)\n\n- - -\n\nyou can always just make your objects practically \"immutable\" and call it done, sidestep the whole issue and have a better resiliency against future similar issues\n\nLet me try to explain \nI have a parent class - call it Q, and a set of other classes which are child classes of Q - call them A,B,C,D. I don't want to test A,B,C & D - I do that elsewhere. Here I want to test Q - and prove that when i do operations on Q that it does the right things on A,B,C & D - I do that by mocking out A,B,C & D; and this works in all cases apart from deepcopy. I can't find a way to prove that Q attempts to deepcopy A,B,C,D - but since they are mocked out deepcopy on them returns the same instance, but there is no way to assert any calls on the __deepcopy__ method ", "id": "dnr07ts", "owner_tier": 0.5, "score": -1.999999987845058e-09}], "link": "https://www.reddit.com/r/Python/comments/73ibxr/how_to_prove_that_an_object_was_copied/", "question": {"content": "I am trying to test my current software, and I have one part of the API where a method (call it the clone method) called on one instance will return  a new instance with some changes.\n\nBy necessity the new instance must be a deep copy of the old instance, since the user might change the old instance (after the copy operation) and that must not effect the new instance - so any attribute of the old instance which refers to a mutable object MUST be deep copied.\n\nThe problem I have is in proving that deep copy.\n\nI am using the unittest module, and the unittest.mock classes and methods heavily during my testing. \n\nMy original plan was to use either Mock or MagicMock as values for the attributes, and and then try to make assertions against the __deepcopy__ method but neither Mock or MagicMock support the __deepcopy__ method.\n\nI can't just rely on the attributes refering to different objects after the clone method is called - as all that does is prove that a new instance is created - it doesn't prove that the new instance is a copy.\n\nHas anyone got any ideas that I can try ?", "id": "73ibxr", "title": "How to prove that an object was copied", "traffic_rate": 207.9358484294499}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "[`copy.deepcopy`](https://docs.python.org/3/library/copy.html?highlight=deepcopy#copy.deepcopy) will produce the result you want.\n\nThe problem with it is that it is slow and it's almost never needed because you can normally get away with shallow-copies/defining new variables instead.\nYou would only need `deepcopy` if you need to change the dicts/other objects contained inside your list without them changing on the outside too.\n\nAlso, if you elaborate what your doing/why you need the copy I can probably tell you whether a shallow copy is sufficient or how you can probably get away with no copies.\nPersonally, I've never needed a `deepcopy` in practice and shallow copies are rare-events, normally I just define a new list, with all the changes I need.", "id": "g8alzv7", "owner_tier": 0.3, "score": 0.9999999980000001}, {"content": "I actually don\u2019t know the best answer to this. But why not just make a copy function that creates and returns a new object with all the fun stuff copied?", "id": "g8alj0v", "owner_tier": 0.5, "score": -1.999999987845058e-09}], "link": "https://www.reddit.com/r/learnpython/comments/j8fjke/there_are_too_many_versions_of_copy_in_python_how/", "question": {"content": " I have a list of objects that I instantiated from my own Class definition. The Class has lots of properties which might be any type (int, string, list, tuple, dictionary, other objects, etc.). How do I make an EXACT copy of this list that I can modify and not affect the original list?\n\nUsage: I have an important list that I want to preserve, but I need to mess with it for this one operation. When I'm done, I want to restore the original list.", "id": "j8fjke", "title": "There are too many versions of COPY in Python. How do I make an EXACT copy of a list?", "traffic_rate": 153.12444444444444}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "The difference between a deep copy and a shallow copy is whether or not nested mutable structures are (recursively) copied (deep) or just referenced (shallow). \n\nAll elements of your list are immutable. Therefore, there is no difference between a shallow and a deep copy.\n\nA proper demonstration of the difference is this:\n\n    import copy\n\n    my_list = [['first'], ['second'], ['third']]\n\n    my_deep_copy = copy.deepcopy(my_list)\n    my_deep_copy[1][0] = 'new value'\n    print(my_list)\n\n    my_shallow_copy = copy.copy(my_list)\n    my_shallow_copy[1][0] = 'new value'\n    print(my_list)\n\nNote how it requires nested mutable structures.\n\nThank you! I didn't know that the nested arrays would impact that.  I just tried it out and it works the way that I expected it to with my example.", "id": "isq6467", "owner_tier": 0.5, "score": 0.9999999998684211}, {"content": "Setting the value at an index mutates the list, not the item at the index. The underlying values are still the same data:\n\n    from copy import copy\n    myL = ['first', 'second', 'third']\n    myLReg = copy(myL)\n    myL[0] is myLReg[0] # True\n    myLReg[0] = 'first'\n    myL[0] is myLReg[0] # False\n    myL[0] == myLReg[0] # True\n\nmyL and myLReg are different lists, so mutating one does not affect the other.", "id": "isqpzer", "owner_tier": 0.3, "score": 0.052631578815789476}, {"content": "Hello, I'm a Reddit bot who's here to help people nicely format their coding questions. This makes it as easy as possible for people to read your post and help you.\n\nI think I have detected some formatting issues with your submission:\n\n1. Inline formatting (`` `my code` ``) used across multiple lines of code. This can mess with indentation.\n\nIf I am correct, please edit the text in your post and try to follow [these instructions](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) to fix up your post's formatting.\n\n___\n\n^(Am I misbehaving? Have a comment or suggestion? Reply to this comment or raise an issue )^[here](https://github.com/0Hughman0/pyredditformatbot/issues).", "id": "isq16nn", "owner_tier": 0.1, "score": 0.026315789342105263}, {"content": "myLReg is a *new list object* with \"pointers\" to the same strings in myL, but in a new memory area. Modifying myLReg by overwriting myLReg[1] with a new value, only alters *the new object's* contents. The 'second' string object still exists in memory, and myL's list of contents still references it, but the object bound to myLReg contains a different, independent list of objects.", "id": "isqa361", "owner_tier": 0.5, "score": 0.03947368407894737}, {"content": "It's also worth noting that `copy` has no effect on immutable objects anyway:\n\n    import copy\n\n    string = \"hello world\"\n    string_copy = copy.copy(string)\n\n    print(id(string), id(string_copy), sep=\"\\n\")\n    # Prints\n    #1833251401584\n    #1833251401584\n\nThere's no point in copying a immutable object, so Python doesn't.", "id": "isqhn8q", "owner_tier": 0.9, "score": -1.3157894656875383e-10}, {"content": "I'm not too familiar with copy but I'll give it a shot.\nAre you wanting to change myL or myLReg?\nYou're changing myLReg but returning the other one.\nWhat happens when you return the myLReg in your console.log?\n\nSo I wanted to learn how to make a deep copy of myL but tried the \"shallow copy\" first.  So What I wanted to do was show that when I make a shallow copy of myL and assign it to myLReg and change a value in myLReg that myL would also change since it's simply a reference to myL.  According to these docs that should be the case but it looks like it only changes myLReg since myLReg outputs \\['first', 'new value', 'third'\\].\n\nThat's not what a shallow copy is. That's just a reference, as you say. A shallow copy is one that only copies the first level of references, as opposed to a deep copy which copies all levels. Consider:\n\n    >>> d = {\"a\": {\"b\": \"c\"}, \"d\": \"e\"}\n    >>> d2 = copy.copy(d)\n    >>> d2[\"d\"] = \"f\"\n    >>> d2[\"a\"][\"b\"] = \"g\"\n    >>> d2\n    {'a': {'b': 'g'}, 'd': 'f'}\n    >>> d\n    {'a': {'b': 'g'}, 'd': 'e'}\n\nAs you see, with the shallow copy \"\"d is changed but \"b\" is not.\n\nAh. I think copy makes them independent of one another.\nThis article might be a little clearer in how it works\nhttps://realpython.com/copying-python-objects/", "id": "isq3qq3", "owner_tier": 0.3, "score": 0.026315789342105263}], "link": "https://www.reddit.com/r/learnpython/comments/y6mq7i/python_copycopy_appears_to_make_a_deep_copy/", "question": {"content": "I am following the python docs for copy functions to learn how to make a deep copy of a list or dictionary.  ([https://docs.python.org/3/library/copy.html](https://docs.python.org/3/library/copy.html)) However, when I use copy.copy(list) and change one of the values it doesn't modify the original list like I thought.  \n\n\nExample\n\n`import copy`\n\n`myL = ['first', 'second', 'third']`\n\n`myLReg = copy.copy(myL)`\n\n`myLReg[1] = 'new value'`\n\n`console.log(myL)`\n\nWhat I expect the output to be is `['first', 'new value', 'third']` but I get `['first', 'second', 'third']`\n\n&#x200B;\n\nAm I understanding the docs wrong, is there a bug, or something else?\n\n&#x200B;\n\nThis is the behavior I expected from copy.deepcopy(myL)", "id": "y6mq7i", "title": "Python copy.copy() appears to make a deep copy", "traffic_rate": 153.12444444444444}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "Besides the answers you got, I wanted to mention that the way you use classes is not how instance variables are created.\n\nYou are creating class variables instead of instance variables.\n\nhttps://www.javatpoint.com/class-variable-vs-instance", "id": "jwonoc9", "owner_tier": 0.7, "score": 0.9999999983333333}, {"content": "> The link discusses the problems of copy. If we copy a list into another variable b and  \nthen add any element in b then original list should also append that element. But when I am doing the above in the following list, it doesn\u2019t work:\n\nI think you've misunderstood something. The article focuses on the fact that if you assign a list to another name, what's copied is the reference to the list, not the list itself. If you want an analogy, it's like writing down the address of a house and sharing it with someone else instead of building an exact replica of the house.\n\nIn your example code, you're not doing that. `list.copy` produces a new list, although it's a shallow copy - in other words the contents are actually still the same. That doesn't matter in the example, though, because you're only storing immutable data, like strings and numbers. So adding or removing things from either list won't change anything in the other.", "id": "jwoijuv", "owner_tier": 0.7, "score": 0.49999999833333336}, {"content": "What do you mean it doesn't work? What are you getting, and what do you expect to get?\n\nHave you read this yet? All python programmers should read this to help understand mutability and assignment: \n[mutable presto-chango](https://nedbatchelder.com/text/names.html)", "id": "jwohpbd", "owner_tier": 0.7, "score": 0.16666666500000002}, {"content": "The first example in the link you posted makes what they're doing confusing because it uses the phrase \"copy assignment\".\n\nI've never heard anyone use that phrase for b = a.\n\nWhen you do b = a, you are assigning another reference to the object that contains the list that is also referenced as a.\n\nIt's like one person referring to you by your first name and another person referring to you by your last name.\n\ncopy() creates a new object that has no references or connections to the object it was copied from.\n\nThe Python docs explain the difference between assignment and copying better.\n\n[https://docs.python.org/3/library/copy.html](https://docs.python.org/3/library/copy.html)\n\n>Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other. This module provides generic shallow and deep copy operations (explained below).", "id": "jwp38nz", "owner_tier": 0.7, "score": -1.6666666565375483e-09}, {"content": "One key idea is that there are objects and there are names. Object must have at least one name. Object may have more names than one. You can only do something with an object via one of its names.\n\nx = 1 # create object 1, assign name 'x' to it\n\ny = 2 # create object 2, assign name 'y' to it\n\nx\\*2 # use name x to use the assigned object in a multiplication\n\nz = x # create a new name 'z' and assign it to object assigned to x", "id": "jwq3o9n", "owner_tier": 0.1, "score": -1.6666666565375483e-09}], "link": "https://www.reddit.com/r/learnpython/comments/15uafc6/python_side_effects_of_copy/", "question": {"content": "Hi.Following link at:[Side effect of copy](https://www.python-engineer.com/posts/how-to-copy-list/)The link discusses the problems of copy. If we copy a list into another variable b andthen add any element in b then original list should also append that element. But when I am doing the above in the following list, it doesn\u2019t work:\n\n    import numpy as np \n    class PyThonCopyListStringArr: \n        List1 = [2, 5, 6, 19, 4, 21, 65, 82, 22] \n        String1 = [\"223\",\"456\", \"324\", \"986\",\"999\", \"256\"] \n        arr = np.array([ 34,25,67,55, 83, 65, 46, 86, 39]) \n        def appendList(self): \n            b = PyThonCopyListStringArr.List1.copy(); \n            b.append(400) \n            print(\"b =\"+str(b)) print(\"List1 = \"+ str(PyThonCopyListStringArr.List1)) \n    if name == \"main\": \n        obj = PyThonCopyListStringArr() \n        obj.appendList()\n\nFollowing is my output:\n\n    b =[2, 5, 6, 19, 4, 21, 65, 82, 22, 400]\n    List1 = [2, 5, 6, 19, 4, 21, 65, 82, 22]\n\nWhy both the outputs are different?\n\n&#x200B;\n\nSomebody please guide me.\n\nZulfi.", "id": "15uafc6", "title": "Python: Side Effects of copy", "traffic_rate": 153.12444444444444}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "This kind of confusion is mostly because you're thinking about python's object model wrong, or don't fully understand it. Perhaps this is a better way to think about things. Say you have this data structure:\n\n    x = [\n        [1,2,3],\n        [4,5,6],\n        ]\n\nThis statement creates 3 lists: 2 inner lists and one outer list. A reference to the outer list is then made available under the name x.\n\nWhen you execute this statement:\n\n    y = x\n\nno data gets copied. You still have the same 3 lists in memory somewhere. All this did is make the outer list availible under the name y, in addition to its previous name x.\n\nWhen you execute this statement:\n\n    y = list(x)\n\nor\n\n    y = x[:]\n\nThis creates a new list with the same contents as x. List x contained a reference to the 2 inner lists, so the new list will also contain a reference to those same 2 inner lists. Only one list is copied\u2014the outer list.\n\nNow there are 4 lists in memory, the two inner lists, the outer list, and the copy of the outer list. The original outer list is available under the name x, and the new outer list is made available under the name y.\n\nThe inner lists have *not* been copied! You can access and edit the inner lists from either x or y at this point!\n\nIf you have a two dimensional (or higher) list, or any kind of nested data structure, and you want to make a full copy of everything, then you want to use the deepcopy() function in the copy module. Your solution also works for 2-D lists, as iterates over the items in the outer list and makes a copy of each of them, then builds a new outer list for all the inner copies.\n\nHope this explanation helps.\n\nGreat answer. \n\nthanks, this is an excellent answer for a concept I never quite understood!\n\nAs a follow-up, the python tutor site helps visualize what's happening.\n\nAfter the line y=x, you can see that [both y and x reference the same list](http://pythontutor.com/visualize.html#code=x+%3D+%5B%0A+++++%5B1,2,3%5D,%0A+++++%5B4,5,6%5D,%0A+++++%5D%0A%0Ay+%3D+x%0A%0Ay+%3D+list\\(x\\)%0A%0Ay+%3D+%5Blist\\(inner\\)+for+inner+in+x%5D&mode=display&cumulative=false&heapPrimitives=false&drawParentPointers=false&textReferences=false&py=2&curInstr=3)\n\nAfter y=list(x), you can see that there are two outer lists, but [they both reference the same inner lists](http://pythontutor.com/visualize.html#code=x+%3D+%5B%0A+++++%5B1,2,3%5D,%0A+++++%5B4,5,6%5D,%0A+++++%5D%0A%0Ay+%3D+x%0A%0Ay+%3D+list\\(x\\)%0A%0Ay+%3D+%5Blist\\(inner\\)+for+inner+in+x%5D&mode=display&cumulative=false&heapPrimitives=false&drawParentPointers=false&textReferences=false&py=2&curInstr=4)\n\nAnd finally, after a proper copy, you can see that there are [two outer lists and two inner lists, properly copied](http://pythontutor.com/visualize.html#code=x+%3D+%5B%0A+++++%5B1,2,3%5D,%0A+++++%5B4,5,6%5D,%0A+++++%5D%0A%0Ay+%3D+x%0A%0Ay+%3D+list\\(x\\)%0A%0Ay+%3D+%5Blist\\(inner\\)+for+inner+in+x%5D%0Adel+inner&mode=display&cumulative=false&heapPrimitives=false&drawParentPointers=false&textReferences=false&py=2&curInstr=8). (I delete \"inner\" because it leaks out of the scope of the generator expression and adds arrows to the diagram that aren't relevant to the discussion.)", "id": "c8wywto", "owner_tier": 0.3, "score": 0.9565217389130435}, {"content": "> I am sure there is a reason for this design in Python but why is it so difficult to clone a list?\n\nYea! At the heart of python is the concept of mutable and immutable datatypes. Ints, strings, floats, tuples, frozen sets -- all immutable. Lists & sets? Mutable.\n\nIf you want a copy, look at the copy module. copy.copy() and copy.deepcopy() are the tools you need.\n\nWhat you're doing with the some_list[:] is called a shallow copy (or copy.copy()). That is, select all of the elements from some_list; the result of which is a list.\n\nCopying in python isn't hard; if you're coming from other languages, just think of python as a language that passes by reference by default.\n\nTo get a complete copy; simply:\n\n    import copy\n    copy_of_list = copy.deepcopy(your_list)\n\nWhile deepcopy is not evil or anything, it's almost certainly not what a beginner needs. In my experience, if a beginner asks about deep copying, it's almost always an [XY problem](http://www.perlmonks.org/index.pl?node_id=542341). So if you're tempted to use deepcopy, please think hard about what you're really trying to do. If deepcopy is really your solution, though, by all means use it.\n\nIf the OP really wanted a copy of a 2-d array, I would recommend:\n\n    bar = [list(x) for x in foo]\n\nor:\n\n    bar = map(list, foo)\n\nBut again, I'm skeptical that that's what the OP really needed.\n\nIt doesn't pass by reference, and it's dangerous (well, not really) to think that it does. It passes by value, where the value is sometimes a reference. If it passed by reference, you could do something like:\n\n    def swap(a, b):\n        a, b = b, a\n\n    a = 1  # or some other value with a different type\n    b = 2\n    swap(a, b)\n    print a, b  # would print 2 1\n\nThis is not possible in Python. There is no way you can code `swap` such that it affects the _value_ of the object in the caller. Compare this with C++:\n\n    void swap(int &a, int &b) {\n        int temp = a;\n        a = b;\n        b = temp;\n    }\n\n    void main() {\n        int a = 1, b = 2;\n        swap(a, b)\n        cout << a << endl;  // prints 2\n    }\n\nThe `swap` function here changes the value in the caller. Even if you do something like this to swap a list in Python:\n    \n    >>> a = [1]                       \n    >>> b = [2]                                                              \n    >>> hex(id(a))  # this is the actual value of a, not [1]\n    '0xb736f24cL'                     \n    >>> hex(id(b))                    \n    '0xb736f56cL'                     \n    >>> def swap(a, b):               \n    ...     a[:], b[:] = b[:], a[:]   \n    ...                               \n    >>> swap(a, b)                    \n    >>> hex(id(a))  # a still has the same value\n    '0xb736f24cL'                     \n    >>> hex(id(b))                    \n    '0xb736f56cL'                     \n    >>> a  # only the contents of a are different\n    [2]\n\nWhat you're saying is accurate, afaik, however:\n\n    def swap(a, b):\n       a, b = b, a\n\nIs operating in its own scope (despite using the same variable names). Unless you're returning the local scope from the function and capturing once again with:\n\n    a, b = swap(a, b)\n\nThere should be no change.\n\nThe full swap would then look like:\n\n    1, 2 = a, b\n    def swap(a, b):\n        a, b = b, a\n        return a, b\n    a, b = swap(a, b)\n    print a, b\n    #results in 2, 1\n\nedit: proof from an interactive interpreter:\n\n    a, b = 1, 2\n    id(a), id(b)\n    (31017312, 31017300)\n    a, b = swap(a, b)\n    id(a), id(b)\n    (31017300, 31017312)\n\nTo prove that the implementation of python I'm using isn't using cached integer values for a and b, it works with ranges outside of -3 to 250 or so that is pretty common.\n\n    >>> a, b = 12345, 67890\n    >>> id(a), id(b)\n    (34047788, 34046848)\n    >>> a, b = swap(a, b)\n    >>> print a, b\n    67890 12345\n    >>> id(a), id(b)\n    (34046848, 34047788)\n\nNo, you are objectively wrong. Python ***always*** passes by reference. There is *no such thing* as a primitive value in python. Even ints, floats, etc. are passed by reference, as they are actually subclasses of `object`. Your misunderstanding lies in your comprehension of literals in python.\n\nIn C, `a=5` copies the value `5` into the memory location denoted by `a` (which is on the stack if you're assigning like this). In Python, `a=5` is totally different, because `a` is `PyObject` pointer and `5` is actually a constructor that sometimes creates and always returns a pointer to an `int` object that holds the value `5`.\n\nAdditionally, the reason that your code doesn't swap has to do with variable scope. All function arguments in Python are copied into the function's stack frame. So if `a` is the name of an argument, assigning some value to `a` does literally nothing to its original value. If you want to manipulate `a`, you have to dereference it first, a la `a.foo = bar` (as the dot operator in Python is much like the `->` operator in C).\n\nTo clarify the last part, when a Python function starts, it copies all the function's arguments into the function's stack frame. Remember that since all things in Python are objects on the heap, only pointers have to be copied, not the large objects themselves. So if `a` is the name of an argument, `a` actually refers to a pointer *in the current function's stack frame*. Therefore, assigning a value to `a` will necessarily not do anything outside the function. However, doing something to `*a` (to put it in C syntax) will, in fact, affect the object outside of the current function's stack frame. However, if `*a` is a static integer object, trying to operate on `*a` would be kind of like trying to do `5 = 6` or `\"hello\" = \"goodbye\"`. You can't assign to \"literal\" objects like that.\n\nExactly, you need to return something. That's why it's not pass by reference, but pass by value, where the value is sometimes a reference. That's the point.\n\n>No, you are objectively wrong. Python ***always*** passes by reference. \n\nI wrote some stuff out, but it might be easier to just read the documentation:\n\nhttp://docs.python.org/2/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference\n\n>There is *no such thing* as a primitive value in python.\n\nSure, OK, this is something I am objectively wrong about. I'm far too used to having this discussion about Java, so it's easy to get confused (given the extremely similar semantics). However, that doesn't change anything I've said except this line here:\n\n> It passes by value, where the value is sometimes a reference.\n\nWhat it should say is this:\n\n> It passes by value, where the value is always a reference.\n\nOK, moving on:\n\n>Additionally, the reason that your code doesn't swap has to do with variable scope. \n\nThe callee has no access to the parents' variables, so it cannot be pass by reference. They're all copied values, where sometimes (OK, always, in Python) that value is a reference. You're not given an implicit reference to the variable, which you can alter. You're given a copy of the variable, where the variable's value is a reference. So, the original `PyObject` pointers `a` and `b` are not available to the callee. Therefore, it is impossible to affect their values, which are `PyObject` pointers to integers. There's no way you can cause them to be pointed to a different object from within the callee.\n\nTake a closer look at the Python and C++ examples I provided earlier:\n\n    def swap(a, b):\n        a, b = b, a\n    \n     a = 1\n     b = 2\n     swap(a, b)\n\nThe `a` on line 4 is different from the `a` on line 2. I think that's obvious to everyone. Compare that to this C++ example:\n\n    void swap(int &x, int &y) {\n        int &temp = x;  // I left out this & in my other comment\n        x = y;\n        y = temp;\n    }\n    \n    void main() {\n        int a = 1;\n        int b = 2;\n        int c = 3;\n        swap(a, b);\n    }\n\nThe `a` on line 8 is in fact the same variable as the `x` on line 2, which is the same variable as the variable `temp` declared on line 2. It's not a pointer or a reference. It's literally the same variable. `void swap(int &x, int &y)` doesn't have access to other variables like `c` in `main`; they're out of scope. It has _implicit_ access to `a` and `b` because they've been passed by reference. There's no way to do this in Python. You can't pass a variable from caller to callee such that the callee has the exact same variable. It's always another `PyObject` pointer, one that points to the same object, but is not the same `PyObject` pointer as before.\n\n>All function arguments in Python are copied into the function's stack frame. \n\nYes, so it is definitely not call by reference. In call by reference you would not copy the arguments into the new stack frame, since...well...it's the same variable. There's no need for any copying. What would you copy? It makes no sense to copy function arguments in a call by reference scenario. It's the same variable in the caller and callee; there is _no_ copying to be done. That would mean the callee gets a different variable, a copy of the original, which is not what call by reference is.\n\n>So if `a` is the name of an argument, assigning some value to `a` does literally nothing to its original value.\n\nThat's because you have copied it, passing it by value. It doesn't matter what I named it. I see choosing `a` and `b` everywhere was a mistake that obscures what I'm trying to say.\n\n> If you want to manipulate `a`, you have to dereference it first, a la `a.foo = bar` (as the dot operator in Python is much like the `->` operator in C).\n\nCorrect; the `.` operator in both Python and Java is the same as the `->` in C or C++. That only reinforces the notion that you have passed a value which is a reference; otherwise, why are you dereferencing it? Pass by reference does not mean you literally pass a reference; it means that the variable the child gets is the exact same variable the parent has. Consider this sample in C:\n\n    void modify(struct foo the_foo) {\n        the_foo.bar = 1;\n    }\n\n    void main() {\n        struct foo my_foo;\n        my_foo.bar = 2;\n        modify(my_foo);\n        printf(\"%d\", my_foo.bar);\n    }\n\nI think we both agree that `my_foo` cannot be modified by `modify`, because its value, which is the entire struct, is copied on to the call stack of `modify`. Contrast this with a call-by-reference version in C++:\n\n    void modify(struct foo &the_foo) {  // note change here\n        the_foo.bar = 1;  // but no change here\n    }\n\n    void main() {\n        struct foo my_foo;\n        my_foo.bar = 2;\n        modify(my_foo);\n        printf(\"%d\", my_foo.bar);\n    }\n\nSo the choice of syntax isn't really relevant. Actually, I'm really not sure what to say regarding the bit about syntax; it's more or less meaningless here. I could define a language that uses `->` to access members of things passed by reference or value.\n\nSide note: Apparently it's common to call this \"call by sharing\" in Python, but it's pretty much always called \"call by value\" in Java and really just about everywhere else; Python differs in that the only thing that can be passed around is a `PyObject` pointer, whereas in Java you can still pass primitive values. I rarely have to explain to people that Python isn't \"call by reference\" so \"call by sharing\" is unusual to me, but not inaccurate. The object is shared via a reference that is copied from caller to callee; the caller can never give the callee access to its own reference. Regardless, it's universally agreed upon that Python is not call by reference, for the reasons I have described above.\n\nI don't think we actually disagree on anything besides the fact that everything is an object (and as you stated, you simply mixed up Python and Java). \n\nThe thing about syntax was just me saying \"You can't do this in python, but pretend you can and that you do it with C syntax.\"\n\nAlso, we are sometimes using different definitions of \"reference\". You are often thinking of it as a C++ reference, whereas I am thinking of the more generic usage of \"reference\" (i.e. a pointer). \n\nI wrote all that stuff because I thought you were saying \"Integers are passed by value, therefore you cannot modify the original integer.\" which is obviously not the correct justification.\n\n>Also, we are sometimes using different definitions of \"reference\". \n\nNo, the problem is in the definition you're using for \"pass by reference\". It is not the generally-accepted definition of \"pass by reference\".\n\n>You are often thinking of it as a C++ reference, \n\nNo, or I would not say that Python \"passes by value, where the value is always a reference\".\n\nYour definition of \"pass by reference\" is the issue here. \"Pass by reference\" is not the same as \"pass by value where the value is always a reference\". \"Pass by reference\" only means one thing--the callee gets the same variable as the caller, the exact same variable. This is what we disagree on. At most, it could be call by sharing. It can't be call by reference.\n\n>I wrote all that stuff because I thought you were saying \"Integers are passed by value, therefore you cannot modify the original integer.\" which is obviously not the correct justification.\n\nWhile it is true that I mistakenly thought (or at least wrote) that integers were primitives passed by value as in Java, that's not actually relevant to anything I said. I didn't really think about what they really were in Python, since, like I said, it wasn't relevant to the point I was trying to make (which is that Python is never pass by reference).\n\n>No, the problem is in the definition you're using for \"pass by reference\". \n\nYou are correct. My bad. I did not realize that the C++ definition of \"pass by reference\" applied everywhere. But really, that's a pretty ridiculous definition, considering that \"passing by reference\" apparently just means \"pass a compiler-managed `*const` to something on the stack\". It is literally nothing but any other kind of pointer passing except for that it is managed more extensively by the compiler in C++ and it generally points to a stack variable.", "id": "c8wyodk", "owner_tier": 0.5, "score": 0.9999999997826087}, {"content": "    bar = list(foo)\n\ndoesn't work?  That surprises me.\n\nIt didn't when I tried it on a 2d list.\n\nhttp://i.imgur.com/1Q7aYID.png\n\n\nI think what you're looking for is\n\n    import copy\n    bar = copy.deepcopy(foo)\n\nThis is what you need to do for lists with more than 1 dimension, apparently.\n\nThanks.  I figured out how to do it earlier but my question is *WHY* does python make it so difficult.  It would make so much more sense to just go\n\n    bar2dList = foo2dList\n\nJust like you would with variables.\n\nLike someone above said, that (li1=li2) makes a shallow copy. That is, li1 is a variable. li2 is then just a variable that points to the memory that li1 was pointing at (think c++ pointer, if you're familiar), not a new list object. Since you're changing li1, li2 reflects that change because they both represent the same memory bit. \n\nSo why did the developers of python chose to have lists and sets do this but not variables?\n\nThere is no difference in how assignment works across types.  The difference is that you can never observe the shallow copy if the object is immutable, because it's impossible to modify it.  Most objects in Python are immutable.  In your original example in your post, when you write `bar = 2`, you are not modifying anything; all numbers are immutable in Python.  You're creating a new number object and giving it the name `bar`.  No mutation has occurred, which means the object that `foo` refers to is still the number 1.\n\nLists, sets, and dicts are the only commonly encountered types that are mutable, so they are the ones that confuse people that don't understand the object model.  But it's not like they are any different than all the other types in terms of what happens when they are assigned.\n\n\ni know no one's really answered your question as to *why* it's like this. most people are just telling you *that* it is like this, which doesn't really make for an explanation. i'm trying to figure it out myself.\n\nanyway, in terms of the explanation, it can be kind of weird to think about exactly *why* some things are implemented in a given language some particular way as opposed to anything else. in this case, it probably has to do something with efficient memory usage. typically, each design decision has a list of pros and cons\nassociated with it.\n\nmy guess: in most cases, this kind of behavior is fine for lists and ends up saving a lot of time and memory (compared to deep-copying any time a list is referenced). the trade off, of course, is that python looks a little less beautiful syntactically when you *do* want to deep copy something. i don't think it's more complicated than that. i don't think it's a bug or an oversight on the part of the developers.\n\nedit: after reading up on this a bit more, i'd like to emphasize that copying a list isn't really \"so damn difficult.\" you could maybe argue that the fact that lists don't just 'work like they should,' but i think the overall decision here fits pretty well within the [zen of python](http://www.python.org/dev/peps/pep-0020/) after all.", "id": "c8wxxu5", "owner_tier": 0.9, "score": 0.41304347804347824}, {"content": "You found a way to do it, but another way would be to use extend.\n\n    a = range(10)\n    b = []\n    b.extend(a)\n\n\n\nNo I tried extend too and that didnt help with a 2d list.\n\nThat wouldn't make a deep copy. It only works in your example because the range function produces a non-nested list of immutable objects, which means a shallow copy is all you need. ", "id": "c8wyx0a", "owner_tier": 0.3, "score": 0.04347826065217392}, {"content": "in c variables contain data.  in python variables are pointers to data.\n\nconsider what happens in a python dictionary if you have a key pointing at a list and then add another key pointing to that same list.\n\nall the variables you are using are really just keys in a dict.", "id": "c8wzxcy", "owner_tier": 0.5, "score": -2.1739130302663674e-10}, {"content": "I just spent 45 minutes trying to copy a 2D array thinking it should be a freaking cakewalk and knowing that somebody somewhere 10 years ago once spent a full day on it makes me feel better. Thank you", "id": "ipfl7d9", "owner_tier": 0.1, "score": -2.1739130302663674e-10}], "link": "https://www.reddit.com/r/learnpython/comments/1afldr/why_is_copying_a_list_so_damn_difficult_in_python/", "question": {"content": "I am sure there is a reason for this design in Python but why is it so difficult to clone a list?  Copying a variable is easy\n\n    foo = 1\n    bar = foo\n    bar = 2\n    print bar # returns 2\n    print foo # returns 1\n\nBut trying to do the same thing, which is what makes sense in my mind coming from other languages, does not work.  You have to add the list splice otherwise it doesn't work.  \n\nThen I spent a day trying to figure out how to copy a 2d list and that was even more frustrating.  I had the following code and none of these worked to properly copy a list without modifying the original.\n\n    foo = [[1,2], [3,4], [5,6]]\n    bar = foo # doesnt work\n    bar = foo[:] # doesnt work\n    bar = list(foo) # doesnt work\n    bar = list(foo[:]) # doesnt work\n    bar = []\n    bar += foo # doesnt work\n    bar = []\n    bar.append(foo) # doesnt work\n    for i, x in enumerate(foo):\n        bar[i] = x[:]\n    # didnt work\n\nI am sure I tried a few more methods and none of them worked.  It was finally this method that was the only way I could find to copy a 2d list, modify the new one without affecting the original list\n\n    bar = [x[:] for x in foo]\n\nSo why is copying a list in python just so hard?  \n", "id": "1afldr", "title": "Why is copying a list so damn difficult in python?", "traffic_rate": 153.1714814814815}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": ">Does Python just have multiple ways to copy a list in the same way??? \n\nAlthough most of the approaches mentioned can be used to copy lists, that doesn't mean that's what they're for! Every operation has a different purpose:\n\n> 1. Using the slicing technique \n\nThe purpose of slicing is to select an arbitrary subset of a list. Slices can be used to either obtain a copy of this subset, or to modify the selected subset. For example:\n\n    foo = [1, 2, 3, 4, 5]\n    print(foo[1:3])   # will print: [2, 3]\n\n    foo[1:3] = ['a', 'b', 'c', 'd']\n    print(foo)        # will print: [1, a, b, c, d, 4, 5]\n  \n \n> 2. Using the extend() method \n\nThe purpose of extend is to add a whole other collection of items onto the end of an existing list. Although slicing can be used for this too, .extend() is less error prone since you don't have to worry about calculating the correct indexes.\n\n\n> 3. List copy using =(assignment operator)\n\nGeeksforgeeks is wrong here. The = operator doesn't make a copy. Rather, you simply have two different variables refer to the exact same list. \n\n\n> 4. Using the method of Shallow Copy \n\nPython's copy module wasn't made for lists. The copy() and deepcopy() functions are able to make copies of **any** arbitrary Python object. For example:\n\n    from copy import copy\n\n    class Person:\n\n        def __init__(self, fname, lname):\n            self.first_name = fname\n            self.last_name = lname\n\n        def print_greeting(self):\n            print(f\"Hello! My name is {self.first_name} {self.last_name}.\")\n\n\n    foo = Person(\"Jack\", \"Johnson\")\n    foo.print_greeting()  # Will print: Hello! My name is Jack Johnson.\n\n    bar = copy(foo)\n    bar.print_greeting()  # Will print: Hello! My name is Jack Johnson.\n\n    foo.first_name = \"John\"\n    foo.last_name = \"Jackson\"\n   \n    foo.print_greeting()   # Will print: Hello! My name is John Jackson\n    bar.print_greeting()   # Will print: Hello! My name is Jack Johnson\n\n\nAs you see, the copy operation actually made a copy of our Person object. The fact that it works for lists is just a consequence, but that doesn't make it *the* way of copying lists.\n\n>5. Using list comprehension \n\nList comprehensions are for constructing a new list based on the data in existing collections. Basically, they're meant to be a concise way to compose map() and filter() operations. You can also use it to quickly construct the cartesian product of multiple collections.\n\n>6. Using the append() method \n\nThe append operation is simply for adding a single item onto a list. Nothing more. Manually writing your own for-loop to append items one by one is perhaps the most clucky & verbose way to copy a list. \n\n>7. Using the copy() method \n\nThis is the only operation whose specific purpose is to copy a Python list. It's finely tuned just for that. Thus, it'll offer you the best performance. \n\n>8. Using the method of Deep Copy \n\nSee #4. The deepcopy() function can make a copy of any arbitrary object, not just a list. \n\n>9. The list() function (not mentioned on geeksforgeeks).\n\nThis is simply the list class constructor. Since 'list' is a class, it has to have a constructor, so might as well make it useful. It can accept any arbitrary collection - a set, a dictionary, a generator, a custom collection class, basically any object that has \\_\\_iter\\_\\_ defined on it. It uses the iterator interface to copy each item one by one into the new Python list.\n\nI am so glad that all those methods weren't actually meant for copying a list TT And apparently, I shouldn't trust G4G the way I was doing before. \n\n>The copy() and deepcopy() functions are able to make copies of any arbitrary Python object\n\nYou mentioned how copy() and deepcopy() weren't just meant for lists but for any arbitrary Python object, which I guess means every Python object??? But if that is the case, choosing when to use what gets a bit more complicated. Because from what I understand you use deepcopy() when dealing with compound objects of mutable datatypes, right? so, I can use copy() for \\[1, 2, 3, 4\\], but should use deepcopy() for \\[1, 2, \\[3, 4\\]\\].\n\nbut when talking about dictionaries you are dealing with keys that need to be of an immutable datatype, but you can only use a tuple if all the elements inside of it are also immutable. and I guess frozensets would be allowed as well. but dictionary values can be of any datatype. So, when dealing with a basic dictionary, would copy() be okay? or should you always use deepcopy() on dictionaries? or does that change according to the datatype of the values?\n\nAnd what about sets? I guess sets wouldn't need deepcopy(), right? because even though sets are mutable, set values must always be of an immutabel type. So, that's like a list with a bunch of integers or strings. \n\nAnd tuples are immutable, but their values can be of a mutable datatype.\n\nSo, what I am trying to say is, I understand what the conditions are for lists when choosing to use copy() or deepcopy(), but what are those conditions when dealing with dictionaries, tuples and sets?\n\nYour daily reminder that GeeksForGeeks is a garbage-quality site that does not verify if what they post is correct or not. I've sent them an email regarding this specific issue, but you should never trust G4G.\n\nYou're really overthinking copy() vs. deepcopy().\n\nUse copy() if you want a copy of an existing data structure, without copying the items within it. \n\nUse deepcopy() if you want to recursively copy both the data structure and all the data contained within.\n\nDictionary keys and set items don't necessarily have to be immutable. The important thing is that each item's hash code doesn't change, and also that for any two items x and y in the set, whether x == y is true or false doesn't change.\n\nGoing back to the Person example from before:\n\n    from copy import copy, deepcopy\n\n    class Person:\n\n        def __init__(self, fname, lname):\n            self.first_name = fname\n            self.last_name = lname\n\n        def __repr__(self):\n            return self.first_name + \" \" + self.last_name\n\n\n    anderson = Person(\"Alice\", \"Anderson\")\n    baker = Person(\"Bob\", \"Baker\")\n    cooper = Person(\"Charles\", \"Cooper\")\n    danvers = Person(\"Debby\", \"Danvers\")\n    ellison = Person(\"Eve\", \"Ellison\")\n\n    red_team = {anderson, baker, cooper}\n\n    # Example 1) The = operator doesn't copy anything.\n    # crimson_team and red_team refer to the exact same set.\n\n    crimson_team = red_team\n    crimson_team.add(danvers)\n\n    print(crimson_team)     # Will print: {Charles Cooper, Alice Anderson, Bob Baker, Debby Danvers}\n    print(red_team)         # Will print: {Charles Cooper, Alice Anderson, Bob Baker, Debby Danvers}\n                            # Notice that Danvers appears in both.\n                            \n                            \n    # Example 2) copy() creates a shallow copy only.\n\n    green_team = copy(red_team)\n    green_team.add(ellison)\n\n    print(red_team)     # Will print: {Charles Cooper, Alice Anderson, Bob Baker, Debby Danvers}\n    print(green_team)   # Will print: {Debby Danvers, Eve Ellison, Charles Cooper, Alice Anderson, Bob Baker}\n                        # Notice that Ellison only appears in green_team.\n                        \n    # If we change Baker's name from Bob to Bill, however:\n    baker.first_name = \"Billy\"\n\n    print(red_team)         # Will print: {Charles Cooper, Alice Anderson, Billy Baker, Debby Danvers}\n    print(crimson_team)     # Will print: {Charles Cooper, Alice Anderson, Billy Baker, Debby Danvers}\n    print(green_team)       # Will print: {Debby Danvers, Eve Ellison, Charles Cooper, Alice Anderson, Billy Baker}\n                            # Notice his name has changed across *all* sets.\n                            \n                            \n    # Example 3) deepcopy() will make copies of the people too.\n\n    blue_team = deepcopy(red_team)\n\n    anderson.first_name = \"Amanda\"\n\n    print(red_team)     # Will print: {Charles Cooper, Amanda Anderson, Billy Baker, Debby Danvers}\n    print(blue_team)    # Will print: {Billy Baker, Debby Danvers, Charles Cooper, Alice Anderson}\n                        # Notice that blue_team kept Anderson's old name, Alice.\n\nG4G is like what w3schools was circa 10-15 years ago, where they have good articles mixed in with garbage ones. \n\nw3schools got much better over time, I think G4G will as well.\n\n>Use copy() if you want a copy of an existing data structure, without copying the items within it.  \n>  \n>Use deepcopy() if you want to recursively copy both the data structure and all the data contained within.\n\nI will keep this in mind then! I guess I can't really think of a situation where I would choose a shallow copy over a deep copy, which is why I wanted to know about when you should use which where. But your example is great! thanks lots!\n\nI wish I shared your optimism. I've contacted them multiple times regarding bad material, and they've never fixed any issues. I was told during one conversation that they don't remove material; even if it's outright wrong. The best they'll do is add a note after the bad material; and even that took them half a year to do.\n\nI won't be happy until there's an equivalent to https://www.w3fools.com/ for G4G.", "id": "iuy0k2s", "owner_tier": 0.7, "score": 0.9999999989999999}, {"content": "I've always assumed that `[:]` making a full copy was a \"happy accident\". They made it so that omitting the first argument results in the start defaulting to the start of the list, and omitting the second argument results in the end defaulting to the end of the list. The consequence then of omitting both is that the entire list is copied.\n\n***\n\nAnd I posted this in another comment, but **do not use G4G**. Their \"articles\" contain a lot of misinformation; as is the case here. The section on `=` is nonsense. They seemed to have tried to \"correct\" it by writing\n\n> Note: There is an issue with this method if you modify in the new list then the old list is also modified due to the new list is referencing \n\nBut that just shows that they don't understand what \"copy\" even means.\n\nI never even thought of using slicing in that way before I researched this. \n\nI actually though that when you assign a variable to a slice of a list, that that variable would just refer to the same object, but only a certain amount of the variables inside of that object. so, I thought that a slice of a list would have the same id as the list itself. but apparently a whole new object is created. Which makes using slicing as a copy method make so much sense now.\n\nalso, I saw your comment! thanks for letting me know! I often went for G4G because it explained these concept in a very easy way, which I appreciated a lot as a beginner. but I appreciate factual articles more, so I guess I'll have to be more careful when reading those articles.\n\nThe word I think you're looking for how you thought slices work is a \"view\". No, slices don't create a view. `islice` can kind of be used for that purpose.\n\nAnd yes, they have the odd good article, and their stuff is very simply explained, but with that, a lot is wrong. Also avoid askpython.com. They're even worse, and are growing in search results unfortunately.", "id": "iuybnhs", "owner_tier": 0.9, "score": 0.399999999}, {"content": "You might be overthinking it. \n\nAnything that does not specify deep copy, is most likely shallow copy. \n\nMany functions are written for many different purposes, and shallow copy might just be one of their unintended use when you ask it to do nothing.  Their speed depends on their actual code/implementation/weird interaction with interpreter etc, and how optimized they are, but they are generally in the same realm and usually not worth worrying about.", "id": "iuxvxrs", "owner_tier": 0.5, "score": -9.99999993922529e-10}], "link": "https://www.reddit.com/r/AskProgramming/comments/ylc4o8/why_choose_to_copy_a_list_with_slices_instead_of/", "question": {"content": "Hi there! beginner Python programmer here\\~\n\nI've been thinking more and more about what Python is doing in the background because I've noticed that it improves the way I think of writing programs. And because I had to copy a list in one of my school assignments, I got curious about what the best way to go about it is. \n\nI looked it up and got a bunch of articles explaining about copy() and deepcopy() in detail, explaining how deepcopy is used when dealing with lists with mutable elements, etc. So, I guess I understand what those two are doing to an extent. \n\nHowever, when it comes to copying a list with slicing (cloning) or by using list(), all I've been able to find is that cloning is much faster because it just copies a piece of memory onto a new location, and with list() the function needs to be called first. That I understand. But when would I want to use the one method over the other? Or when would I rather use list() instead of copy()?? does list() copy shallow or deep??? would I only want to use cloning when my goal is speed? does one use up more memory than the other? Those are questions that pop into my head.\n\nAnd it doesn't stop there because I found this one article ( [Python | Cloning or Copying a list - GeeksforGeeks](https://www.geeksforgeeks.org/python-cloning-copying-list/) ) that explains FIVE other ways to copy a list... Does Python just have multiple ways to copy a list in the same way??? or is it because Python language updates that caused there to be overlap?? Or does every technique have a specific purpose/result, even if the difference might be slight?? \n\nI have also found a few articles that might have discussed this in greater detail, but they were just too complicated for me to understand. I have only been doing this for a few weeks", "id": "ylc4o8", "title": "Why choose to copy a list with slices instead of copy(), deepcopy(), or list()??", "traffic_rate": 28.040370751802264}, "saved_time": 1721101368, "source": "reddit", "tags": []}, {"answers": [{"content": "\r\n    The error is caused by a problem within the rsync program:\nQuote:23 Partial transfer due to error.\r\nSee rsync(1) - Linux man page[^]\r\n", "id": "2_5293376_1", "owner_tier": 0.7, "score": 0}], "link": "https://www.codeproject.com/Questions/5293367/How-to-copy-the-data-b-w-two-paths-using-ctypes", "question": {"content": "\n\n\r\npractice.c\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nchar *transfer(char *f1, char *f2){\r\n    char cmd[500];\r\n    sprintf(cmd, \"rsync -av %s %s\", f1, f2);\r\n    system(cmd);\r\n}\r\n\r\nint main(void){\r\n    transfer(\"/home/bilal/Pictures/New\", \"/home/bilal/Music\");\r\n    return 0;\r\n}\r\n\r\npractice.py\r\n\r\nfrom ctypes import cdll\r\n\r\ntransfer = cdll.LoadLibrary(\"/Path/to/practice.so\")\r\ntransfer.transfer(\"/home/bilal/Pictures/New\", \"/home/bilal/Music\")\r\n\r\nError\r\nrsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1330) [sender=3.2.3]\r\nsent 26,209,993 bytes  received 92,218 bytes  3,506,961.47 bytes/sec\r\ntotal size is 140,764,280,507,967  speedup is 5,351,804.09\n\nWhat I have tried:\n\r\nIn this code, I am trying to copy the data from the first path to the second path and I am using ctypes to call the C file in python but when I run the Python code, it gives me so many lines of error. I don't know what is the problem with it and I am just pasting some lines of error. I hope you will understand.\r\n\t\t    ", "id": "5293367", "title": "How to copy the data b/w two paths using ctypes?", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["C", "Python"]}, {"answers": [{"content": "\r\n    Please, follow these links:\nPython PyQt clipboard example - Python[^], \npython - PyQt clipboard doesn't copy to system clipboard - Stack Overflow[^]\nPyQt5 - QClipboard[^]\r\n", "id": "2_5315509_1", "owner_tier": 0.5, "score": 5.0}], "link": "https://www.codeproject.com/Questions/5315504/How-do-I-copy-text-to-clipboard-in-pyqt6", "question": {"content": "\n\n\r\nHow do i copy text to clipboard in pyqt6\r\ni want to copy a text in line edit on clicking a button\n\nWhat I have tried:\n\nPython\n\r\ncb = QApplication.clipboard()\r\n        cb.clear(mode=cb.Clipboard())\r\n        cb.setText(self.blogurl.text(), mode=cb.Clipboard()) \r\ni have tried this code but it is showing error :\n\n\r\nAttributeError: 'QClipboard' object has no attribute 'Clipboard'\n", "id": "5315504", "title": "How do I copy text to clipboard in pyqt6", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["Python", "PyQt"]}, {"answers": [{"content": "\r\n    Um...the child class EditCollectionGroupViewModel derives from the parent CollectionGroupViewModel class - so it already contains all the properties for the parent.\n\r\nYou don't need to copy values, unless you are trying to create a new child based on the parent. In that case, I'd create a child constructor which accepted a parent as the parameter and copied the values.\n\nC#\n\r\npublic EditCollectionGroupViewModel(CollectionGroupViewModel parent)\r\n   {\r\n   TenantID = parent.TenantID; \r\n   ...\r\n   }But a better way would be to create an instance of teh child class in teh first place instead of the parent:\nC#\n\r\nfor (int i = 0; i < 10; i++)\r\n{\r\n    CollectionGroupViewModel model = new EditCollectionGroupViewModel();\r\n\r\n    model.TenantID = i + 1000;\r\n    model.Market = \"UK\";\r\n    model.GroupName = \"Collection Group 1\";\r\n    model.GTS = \"yes\";\r\n    model.ProcessingCenter = \"Processing Centre 1\";\r\n\r\n    modelList.Add(model);\r\n}\r\n\n", "id": "2_831621_1", "owner_tier": 0.9, "score": 1.0}], "link": "https://www.codeproject.com/Questions/831616/how-to-copy-parent-object-to-child-object", "question": {"content": "\r\n\t\t\t    hi friends,\r\nI have below model structure\nC#\n\r\npublic class CollectionGroupViewModel\r\n{\r\n        public int TenantID { get; set; }\r\n\r\n        public string Market { get; set; }\r\n\r\n        public string GroupName { get; set; }\r\n\r\n        public string GTS { get; set; }\r\n\r\n        public string ProcessingCenter { get; set; }\r\n\r\n}\r\n\r\npublic class EditCollectionGroupViewModel : CollectionGroupViewModel\r\n{\r\n        public IList<SelectListItem> ProcessingCenter { get; set; }\r\n}\r\nI have class to create Mock data as follows:\nXML\n\r\npublic static List<CollectionGroupViewModel> GetCollectionGroupViewList()\r\n        {\r\n            List<CollectionGroupViewModel> modelList = new List<CollectionGroupViewModel>();\r\n\r\n            for (int i = 0; i < 10; i++)\r\n            {\r\n                CollectionGroupViewModel model = new CollectionGroupViewModel();\r\n\r\n                model.TenantID = i + 1000;\r\n                model.Market = \"UK\";\r\n                model.GroupName = \"Collection Group 1\";\r\n                model.GTS = \"yes\";\r\n                model.ProcessingCenter = \"Processing Centre 1\";\r\n\r\n                modelList.Add(model);\r\n            }\r\n\r\n            return modelList;\r\n        }\r\n\r\n        public static CollectionGroupViewModel GetEditCollectionGroupViewModel(int tenantID)\r\n        {\r\n            List<CollectionGroupViewModel> modelList = GetCollectionGroupViewList();\r\n\r\n            EditCollectionGroupViewModel model = modelList.Where(x => x.TenantID == tenantID).Single();\r\n            model.ProcessingCenter = ?;\r\n            return model;\r\n        }\r\nWhat I want is, I want to copy the following properties from the parent class to the child class.\nTenantID, Market, GroupName, GTS\n\r\nAnd I want to edit the following property before sending the result.\nmodel.ProcessingCenter = ?;\n\r\nAny idea how to do it?\n\r\nThanks in advance\r\n\t\t    ", "id": "831616", "title": "how to copy parent object to child object", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["C#3.5"]}, {"answers": [{"content": "\r\n    I gave you the link to the documentation for str types earlier today. Many of the functions return a modified copy, but as you can see there is no specific copy method. But you have not explained where the error occurs.\n\r\n[edit]\r\nTake a look at the documentation at NLTK :: nltk.classify.naivebayes[^]. The classify method calls prob_classify passing in the parameter from your call. One of the next actions is to call copy on that parameter. But the str object does not have a copy method, as already shown. So the conclusion is that you are passing an invalid parameter to classify.\r\n[/edit]\r\n", "id": "2_5340162_2", "owner_tier": 0.7, "score": 0}, {"content": "\r\n    found the solution its\n\n\r\nx2b = input(\"name: \")\r\nprint(classifier.classify(gender_features(x2b)))\n", "id": "2_5340211_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/5340144/Attributeerror-str-object-has-no-attribute-copy-in", "question": {"content": "\r\n\t\t\t    so it's saying the 'str' object has no attribute 'copy. from a normal input are their ways to fix it \r\nand any ways to make my code better\r\nthank you for your time\n\nWhat I have tried:\n\r\nthis is my code\n\n\r\nlines_seen = set() # holds lines already seen\r\n\r\n#check for duplicates\r\nwith open(\"male.txt\", \"r+\") as f:\r\n    d = f.readlines()\r\n    f.seek(0)\r\n    for i in d:\r\n        if i not in lines_seen:\r\n            f.write(i)\r\n            lines_seen.add(i)\r\n    f.truncate()\r\n\r\nwith open(\"female.txt\", \"r+\") as f:\r\n    d = f.readlines()\r\n    f.seek(0)\r\n    for i in d:\r\n        if i not in lines_seen:\r\n            f.write(i)\r\n            lines_seen.add(i)\r\n    f.truncate()\r\n\r\ndef gender_features(word):\r\n\treturn {'last_letter': word[-1]}\r\n\r\n# output : {'last_letter': 'r'}\r\n# importing libraries\r\nimport random\r\nfrom nltk.corpus import names\r\nimport nltk\r\n#nltk.download()\r\n\r\ndef gender_features(word):\r\n\treturn {'last_letter':word[-1]}\r\n\r\n# preparing a list of examples and corresponding class labels.\r\nlabeled_names = ([(name, 'male') for name in names.words('male.txt')]+\r\n\t\t\t[(name, 'female') for name in names.words('female.txt')])\r\n\r\nrandom.shuffle(labeled_names)\r\n\r\n# we use the feature extractor to process the names data.\r\nfeaturesets = [(gender_features(n), gender)\r\n\t\t\tfor (n, gender)in labeled_names]\r\n\r\n# Divide the resulting list of feature\r\n# sets into a training set and a test set.\r\ntrain_set, test_set = featuresets[500:], featuresets[:500]\r\n\r\n# The training set is used to\r\n# train a new \"naive Bayes\" classifier.\r\nclassifier = nltk.NaiveBayesClassifier.train(train_set)\r\nx2b = input(\"name: \")\r\nprint(classifier.classify(x2b))\r\n\r\n# output should be 'male'\r\nprint(nltk.classify.accuracy(classifier, train_set))\r\n\r\n# it shows the accuracy of our classifier and\r\n# train_set. which must be more than 99 %\r\nclassifier.show_most_informative_features(10)\n", "id": "5340144", "title": "Attributeerror: 'str' object has no attribute 'copy' in input nltk Python", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["Python", "errors", "NLTK"]}, {"answers": [{"content": "\r\n    I assume your UPDto and PDto is different types with different properties, in this situation you might need to consider Deep object coping. Following link might help you to do the Deep object copying,\n\nDeep copy of objects in C#[^]\n\r\nHope it helps :)\r\n", "id": "2_233338_1", "owner_tier": 0.3, "score": 5.0}, {"content": "\r\n    Hi Mohammad,\r\n Thanks for your solution. But I believe that is not what I need. The same can\r\nbe acheived through the foreach loop mentioned in the question.\n\r\nclass PDTO\r\n{\r\n public string Prop1{get; set;}\r\n}\r\nclass UPDTO\r\n{\r\n public PDTO oPDTO {get; set;}\r\n}\n\r\nclass MyClass\r\n{\r\n  Method1()\r\n  {\r\n   List<PDTO> oListPDTO = new List<PDTO>();\r\n   List<UPDTO> oListUPDTO = new List<UPDTO>();\n\r\n   foreach (PDTO obj in oListPDTO)\r\n   {\r\n     UPDTO oUPDTO = new UPDTO();\r\n     oUPDTO.oPDTO = obj;\r\n      oListUPDTO.Add(oUPDTO);\r\n   }\r\n  }\r\n}\n\r\nIs there a better way of doing this instead of foreach loop??????\n\n\r\nThanks,\r\nMukesh KV\r\n", "id": "2_233380_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/233331/Copy-list-object-into-object-of-another-list-objec", "question": {"content": "\r\n\t\t\t    Hi all,\r\n I have two list objects, say List<UPDTO>  and List<PDTO>\n\r\nclass PDTO\r\n{\r\n public string Prop1{get; set;}\r\n}\n\r\nclass UPDTO\r\n{\r\n public PDTO oPDTO {get; set;}\r\n}\n\n\r\nI have data in  List<PDTO>. And I want this to get copied to the object (PDTO) that I have in List<UPDTO>. Could you please let me know the solution?\n\r\nWe can do the same like the below:\n\r\nforeach (PDTO oPDTO1 in oListPDTO)\r\n{\r\n    oListUPDTO.Add(new UPDTO() { oPDTO = oPDTO1 });\r\n}\r\nIs there any better way of doing this?\n\n\r\nThanks,\r\nMukesh KV\r\n\t\t    ", "id": "233331", "title": "Copy list object into object of another list object", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["C#", "C#4.0"]}, {"answers": [{"content": "\r\n    I'm not a Python expert so my thoughts might not be exact.\n\r\nYour list() function is returning a reference to the private member. Because the function is a member too, it has access to the array. As a result, the calling side \"sees\" a reference which is it allowed to use and change.\n\r\nDo you know C++? It is similar there:\nC++\n\r\nclass Test {\r\npublic:\r\n    Test(int a = 0) { m_a = a; }\r\n    int& get() { return m_a; }\r\nprivate:\r\n    int m_a;\r\n};\r\n\r\nint main()\r\n{\r\n    Test test(1);\r\n    // Allowed because get() returns a reference\r\n    test.get() = 2;\r\n    // This will print 2\r\n    printf(\"%d\\n\", test.get());\r\n    \r\n    return 0;\r\n}\r\nThe solution is to not return the list at all or return a copy of the list (see Programming FAQ \u2014 Python 3.6.6rc1 documentation: How do I copy an object in Python?[^] ):\nPython\n\r\n# Using slicing\r\nreturn self.__items[:]\r\n# Return a new list\r\nreturn list(self.__items)\r\n# Using copy.copy() or copy.deepcopy()\r\nreturn copy.deepcopy(self.__items)\r\n[EDIT]\r\nThe best solution would be returning a read only reference like with the C++ const keyword. But Python does (and will) not support such due to its design and ideology. \n\r\nWith Python, the caller of such functions is responsible for not doing something \"wrong\" with the returned references. Such should be stated clearly in the documentation for the function.\r\n[/EDIT]\r\n", "id": "2_1249553_2", "owner_tier": 0.5, "score": 2.5}, {"content": "\r\n    See 9. Classes \u2014 Python 3.4.8 documentation: Private Variables[^]. I suggest going to the first page of that tutorial, and working your way through it; a really useful tutorial.\r\n", "id": "2_1249544_1", "owner_tier": 0.7, "score": 1.0}], "link": "https://www.codeproject.com/Questions/1249542/How-do-I-prevent-updates-to-private-data-in-Python", "question": {"content": "\r\n\t\t\t    Simple code in Python2.7 with a \"private\" data item \"items\". I hear there is nothing really one can do in Python to declare an attribute truly \"private\" ... this code manages to change the first elemement of the items list from an instance of Group to a string. Why and how can I stop it / re-code ?? I feel the pain in Python circles when people like me talk about \"private\" , but stick with me please because I'm trying to protect myself here from doing something I \"culturally\" shouldnt be doing - i.e. writing to other classes and instances (as quoted here: class - Does Python have \u201cprivate\u201d variables in classes? - Stack Overflow)\n\n\n\r\nclass Groups():\r\n    \r\n  def __init__(self):\r\n    self.__items = []\r\n  \r\n  def add(self, name, hidden=None, position=None):\r\n    if name not in self.__items:\r\n      if position is None:\r\n        print(\"appending %s\" % name)\r\n        self.__items.append(Group(name=name, hidden=hidden, position=position))\r\n      else:\r\n        print(\"inserting %s\" % name)\r\n        self.__items.insert(position, Group(name=name, hidden=hidden, position=position))\r\n      print('after add, len=',len(self.__items))\r\n  \r\n  def list(self):\r\n    print(\"list():\")\r\n    print \"\".join(\"   item: \"+x.name for x in self.__items)\r\n    return self.__items\r\n\r\ng=Groups()\r\nprint(\"adding ITEM\")\r\ng.add(\"ITEM\")\r\ng.list()\r\nprint(\"changing..\")\r\ng.list()[0]=\"Changed\" \r\ng.list() Should now raise an exception\n\r\nThe list() method is returning items by reference allowing direct access to the list, rather than passing by-value (i.e. a copy of the items). Further, the name mangling __items seems to be innefectual in that I can still modify the data by using list()[0] =\n\r\nBy the way, what I am trying to do here is abstract the implementation of __list. Today it is a simple Python list, tomorrow I might make it a class, but I want to abstract this in the Groups class.\n\r\nI just need some education here me thinks.\n\nWhat I have tried:\n\r\nnothing - not sure what to do as I am learning Python.\r\n\t\t    ", "id": "1249542", "title": "How do I prevent updates to \"private\" data in Python?", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["Python2.7"]}, {"answers": [{"content": "\r\n    In order to copy the text with its styles, you will need to write your own function, as there is no python-docx function that does such a thing. This is the function I wrote:\n\nPython\n\r\ndef get_para_data(output_doc_name, paragraph):\r\n    \"\"\"\r\n    Write the run to the new file and then set its font, bold, alignment, color etc. data.\r\n    \"\"\"\r\n\r\n    output_para = output_doc_name.add_paragraph()\r\n    for run in paragraph.runs:\r\n        output_run = output_para.add_run(run.text)\r\n        # Run's bold data\r\n        output_run.bold = run.bold\r\n        # Run's italic data\r\n        output_run.italic = run.italic\r\n        # Run's underline data\r\n        output_run.underline = run.underline\r\n        # Run's color data\r\n        output_run.font.color.rgb = run.font.color.rgb\r\n        # Run's font data\r\n        output_run.style.name = run.style.name\r\n    # Paragraph's alignment data\r\n    output_para.paragraph_format.alignment = paragraph.paragraph_format.alignment\n\nHow The Function Works\r\n 1. Adds a new paragraph object to the file.\r\n 2. Adds a new run to that paragraph.\r\n 3. Checks whether each of the styles bold, italic and underline is True, False, None. If it's True, the run will be in that style, if it's False, it won't be in that style, and if it's None, it will be inherited by the default style of the paragraph it's in. Then it applies the styles to the run.\r\n 3. Checks what's the color of the run in RGB and applies the found color to the run.\r\n 4. Checks what's the font of the run and applies the found font to the run.\r\n 5. Checks what's the alignment of the run and applies the found alignment setting to the run.\n\n\nHow to Use the Function:\r\nYou need to give it the name you gave your output document and the paragraphs you want to copy. \nFor Example:\n\nPython\n\r\n# Imports\r\n\r\ninput_doc = Document('InputDoc.docx')\r\noutput_doc = Document()\r\n\r\n# Call the function\r\nget_para_data(output_doc, input_doc.paragraphs[3])\r\n\r\n# Save the new file\r\noutput_doc.save('OutputDoc.docx')\nIf you'd like to copy the entire document I suggest you do this:\n\nPython\n\r\nfor para in input_doc.paragraphs:\r\n    get_para_data(output_doc, para)\r\n\r\noutput_doc.save('OutputDoc.docx')\n", "id": "2_1231500_2", "owner_tier": 0.1, "score": 1.0}, {"content": "\r\n    You need to get the style information from the paragraph, see Text-related objects \u2014 python-docx 0.8.6 documentation[^].\r\n", "id": "2_1230785_1", "owner_tier": 0.7, "score": 1.0}, {"content": "\r\n    #clone your document\r\nimport docx\r\nfrom copy import deepcopy\n\r\ndoc1 = docx.Document('original_file.docx')\n\r\ncopy_the_content = deepcopy(doc1)\n\r\ncopy_the_content.save('new_file.docx')\r\n", "id": "2_5306259_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/1230778/How-do-I-copy-the-contents-of-a-word-document", "question": {"content": "\r\n\t\t\t    I want to write a program that copies text from a Word document and pastes it to another. I'm trying to do that using the python-docx library. I was able to do that with the following code, but it does not copy the bold, italic, underlined nor colored parts as they are and only their text:\nPython\n\r\nfrom docx import Document\r\n\r\n\r\ninput = Document('SomeDoc.docx')\r\n\r\nparagraphs = []\r\nfor para in input.paragraphs:\r\n    p = para.text\r\n    paragraphs.append(p)\r\n\r\noutput = Document()\r\nfor item in paragraphs:\r\n    output.add_paragraph(item)\r\noutput.save('OutputDoc.docx')\n\nWhat I have tried:\n\r\nI've tried copying the paragraph object directly into the output document, but it doesn't work either:\nPython\n\r\nfrom docx import Document\r\n\r\n\r\ninput = Document('SomeDoc.docx')\r\noutput = Document()\r\n\r\nfor para in input.paragraphs:\r\n    output.add_paragraph(para)\r\noutput.save('OutputDoc.docx')\n", "id": "1230778", "title": "How do I copy the contents of a word document?", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["MS-Word", "Python3.6"]}, {"answers": [{"content": "\r\n    Let's see:\n\nC#\n\r\nclass A {\r\n   internal A A; // non-private fields is the bad coding style, but this is just for example\r\n   internal Name;\r\n} //A\r\n\r\nA a = new A();\r\nA b = a; // a and b reference the same object:\r\n// if you change a.Name, b.Name will change\r\n\r\nb = a.MemberwiseClone();\r\n// not a and b are distinctly different objects\r\n// they can have different names:\r\na.Name = \"This is a\";\r\nb.Name = \"This is b\"; // different, you can check it up after this statement.\r\n\r\n// Now, how about a.A?\r\n// After cloning, it still references the same object, because A is a reference type:\r\nA a = new A();\r\na.A = new A();\r\na.A.Name = \"inner\";\r\n\r\nb = a.MemberwiseClone();\r\nb.A.Name = \"another inner\";\r\n// it will change a.A.Name! Why?\r\n// because we cloned a, but not a.A\n\r\nNow, look at the last comment in the code sample shown above. It means that cloning is not deep.\r\nSee also:\nhttp://msdn.microsoft.com/en-us/library/system.object.memberwiseclone.aspx[^],\nhttp://msdn.microsoft.com/en-us/library/system.icloneable.aspx[^],\nhttp://en.wikipedia.org/wiki/Clone_%28computing%29[^].\n\r\nFinally, please see my recent answers on deep cloning: How to implement ICloneable for a List Class?[^].\n\n\u2014SA\n", "id": "2_655607_1", "owner_tier": 0.7, "score": 2.5}, {"content": "\r\n    The difference is very straight forward.\n\nDataTable.Clone method clones the structure of the dataTable, including all dataTable schemas and constraints. Not data.\n\nDataTable.Copy method copies both the structure and data.\n\r\nRegards..\r\n", "id": "2_655606_1", "owner_tier": 0.5, "score": 1.165}, {"content": "\r\n    visit here to understand more...\n\nhttp://www.dotnetfunda.com/forums/thread7557-difference-between-dataset-clone-dataset-copy.aspx[^]\r\n", "id": "2_655621_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    \"Both the Copy and the Clone methods create a new DataTable with the same structure as the original DataTable. The new DataTable created by the Copy method has the same set of DataRows as the original table, but the new DataTable created by the Clone method does not contain any DataRows.\"\n\r\nFrom DataTable.Clone Method documentation. In summary, Clone method creates a new DataTable with same structure and constraints but without data and Copy method does same but includes data too.\n\nhttp://social.msdn.microsoft.com/Forums/vstudio/en-US/10d99d29-2851-4f12-84b6-d95e08c13bf4/whats-the-difference-between-clone-and-a-copy[^]\n\n\nhttp://stackoverflow.com/questions/198496/difference-between-the-system-array-copyto-and-system-array-clone[^]\r\nThis is ther main difference\n\n\n\n\r\n1- CopyTo require to have a destination array when Clone return a new array.<br />\r\n2- CopyTo let you specify an index (if required) to the destination array.\n\r\nI think you will find difference now....:)\r\n", "id": "2_655645_2", "owner_tier": 0.1, "score": 0}], "link": "https://www.codeproject.com/Questions/655602/Difference-between-Clone-and-Copy-method", "question": {"content": "\r\n\t\t\t    Both the Copy and the Clone methods create a new DataTable with the same structure as the original DataTable.\r\nClone method can not create datarow but Copy method create both structure and datarow. Why should we use Clone method instead of Copy method. please explain me. Advance thanks for helping me.\r\n\t\t    ", "id": "655602", "title": "Difference between Clone and Copy method", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["ASP.NET"]}, {"answers": [{"content": "\r\n    Whether you are calling a default copy constructor or assignment operator the compiler can only create a shallow copy by default. A shallow copy means that each member of the class is copied individually using the assignment operator for that member.  This is important in the case of pointers because the pointer is copied but what it points to is not. If memory has been allocated and used this creates a problem.\n\nC++\n\r\n#include <string>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n// Use pointer to memory for string\r\nclass myClass \r\n{\r\npublic:\r\n\tmyClass(const char *cstring) { mystring = new char[30]; strcpy(mystring, cstring);};\r\n\tmyClass() : mystring(NULL) {};\r\n\t~myClass() {delete [] mystring;};\r\n\r\n\tchar *mystring;\r\n};\r\n\r\n// Use std::string class\r\nclass myClass2 \r\n{\r\npublic:\r\n\tmyClass2(const char *cstring) { mystring = cstring;};\r\n\tmyClass2() : mystring(\"\") {};\r\n\t~myClass2() {};\r\n\r\n\tstring mystring;\r\n};\r\n\r\nint main()\r\n{\r\n\r\nmyClass c1(\"Welcome\");\r\nmyClass  c2;\r\nc2 = c1; \r\n// Shallow copy - c2::mystring pointer is assigned same value as c1::mystring \r\n// pointer so points to same memory - DANGER\r\n// This is deceptive if you examine c1 and c2 in the debugger because they both seem\r\n// to contain \"Welcome\" - not so - they both have a pointer which points to the same\r\n// memory.\r\n\r\n// This must be carefully managed. For example:\r\n//#define TEST\r\n#ifdef TEST\r\nmyClass *pc2 = new myClass;\r\n*pc2 = c1;\r\n\r\ncout << c1.mystring << endl; // All good.\r\ncout << pc2->mystring << endl; // All good.\r\ndelete pc2;\r\ncout << c1.mystring << endl; // Problem - why?\r\n// Consequence of shallow copy.\r\n#endif\r\n\r\nmyClass c1a(\"Welcome\");\r\nmyClass  c2a = c1a; // Same as above - different construct same result.\r\n\r\n\r\n// Now using myClass2\r\nmyClass2 c1_2(\"Welcome\");\r\nmyClass2  c2_2;\r\nc2_2 = c1_2; \r\n// Shallow copy - but c2::mystring is now a copy of c1::mystring because\r\n// of assignment operator for std::string.\r\n\r\n// Now\r\n//#define TEST2\r\n#ifdef TEST2\r\nmyClass2 *pc2_2 = new myClass2;\r\n*pc2_2 = c1_2;\r\n\r\ncout << c1_2.mystring << endl; // All good.\r\ncout << pc2_2->mystring << endl; // All good.\r\ndelete pc2_2;\r\ncout << c1_2.mystring << endl; // No Problem.\r\n#endif\r\n\r\n\r\n return 0;\r\n }\n\r\nThis is a very good expose:\nhttp://www.learncpp.com/cpp-tutorial/912-shallow-vs-deep-copying/[^]\r\n", "id": "2_743892_8", "owner_tier": 0.1, "score": 1.5}, {"content": "\r\n    Consider the following C++ program.\nC++\n\r\n#include<iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nclass Test\r\n{\r\npublic:\r\n   Test() {}\r\n   Test(const Test &t)\r\n   {\r\n      cout<<\"Copy constructor called \"<<endl;\r\n   }\r\n   Test& operator = (const Test &t)\r\n   {\r\n      cout<<\"Assignment operator called \"<<endl;\r\n   }\r\n};\r\nint main()\r\n{\r\n  Test t1, t2;\r\n  t2 = t1;\r\n  Test t3 = t1;\r\n  getchar();\r\n  return 0;\r\n}\r\nOutput:\n \n\r\nAssignment operator called\r\nCopy constructor called\r\nCopy constructor is called when a new object\r\nis created from an existing object, as a copy\r\nof the existing object (see this G-Fact). And\r\nassignment operator is called when an\r\nalready initialized object is assigned a new\r\nvalue from another existing object.\nC++\n\r\nt2 = t1;  // calls assignment operator, same as \"t2.operator=(t1);\"\r\nTest t3 = t1;  // calls copy constructor, same as \"Test t3(t1);\"\n", "id": "2_743831_2", "owner_tier": 0.1, "score": 1.5}], "link": "https://www.codeproject.com/Questions/743830/Confusion-in-Copy-Constructor-and-assignment-opera", "question": {"content": "\r\n\t\t\t    I am now tired but still not able to understand Copy constructor and assignment operator clearly.\r\nAnd at last, i am here, in one of my best site, in a hope that i'll clear all my concepts.\n\r\nNow coming to the point, i know default copy constructor do shallow copying but when we copy object using assignment operator then will it become a deep copy...???\n\r\nLet us suppose, we have a class, MyClass and a constructor is defined in it without any argument, and main is coded as:\n\nC++\n\r\nMyClass c1(\"Welcome\");\r\nMyClass  c2;\r\nc2 = c1;\n\r\nSo, the 3rd line \"c1=c2\" is deep copy??\r\nAnd if it is also a shallow copy that what's the difference between this \"c2=c1\" and \"MyClass c2(c1)\"(Simple copy constructor).\n\r\nAnd what will happen if i'll edit it as:\nC++\n\r\nMyClass c1(\"Welcome\");\r\nMyClass  c2 = c1;\n\r\nThanks in advance...:-)\r\n\t\t    ", "id": "743830", "title": "Confusion in Copy Constructor and assignment operator", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["C++"]}, {"answers": [{"content": "\r\n    You probably want to clone your original list instead\n\nHow do I clone a generic list in C#? - Stack Overflow[^]\r\n", "id": "2_1239160_1", "owner_tier": 0.5, "score": 3.0}, {"content": "\r\n    You could create a copy constructor in your object that accepts an object of the same type:\n\n\n\r\npublic MyObject(MyObject obj)\r\n{\r\n    this.Property1 = obj.Property1;\r\n    this.Property2 = obj.Property2;\r\n    ...\r\n}\n\r\nAnd then do this when you want to copy it:\n\n\n\r\nList<MyObject> list2 = list1.ConvertAll(x => new MyObject(x));\n\r\nOR inherit ICloneable, and \n\nC#\n\r\npublic class MyObject : ICloneable<MyObject>\r\n{\r\n    public MyObject Clone()\r\n    {\r\n        return new MyObject{ /* set properties */ };\r\n    }\r\n}\n\r\nAnd do this:\n\n\n\r\nList<MyObject> list2 = list1.ConvertAll(x => x.Clone());\n\r\nOR\n\r\nYou could serialize the existing objects into a stream and deserialize them back into a new list of objects.\r\n", "id": "2_1239162_1", "owner_tier": 0.7, "score": 2.0}, {"content": "\r\n    Make it a structure instead of a class or Create a clone method within your class and Return this.MemeberwiseClone;\r\n", "id": "2_5324918_1", "owner_tier": 0.1, "score": 0.3333333333333333}], "link": "https://www.codeproject.com/Questions/1239153/Csharp-copy-list-of-objects-without-reference", "question": {"content": "\r\n\t\t\t    Hello, \n\r\nMy problem is about the copy of object without reference.\n\nWhat I have tried:\n\r\nI try to copy a list of object like this :\nC#\n\r\nList<MyObject> myNewList = new List<MyObject>(myOldList);\n\r\nThe problem is that my new list reference the older list. \n\r\nHere is my object \"MyObject\" :\n\nC#\n\r\n/// <summary>\r\n    /// Model to represent a trip.\r\n    /// </summary>\r\n    [Serializable]\r\n    public class TripModel : BaseModel, IEquatable<TripModel>, IComparableModel\r\n    {\r\n        /// <summary>\r\n        /// Initialises a new instance of the <see cref=\"TripModel\" /> class.\r\n        /// </summary>\r\n        public TripModel()\r\n        {\r\n            this.PropertyBags = new SimpleSerializableDictionary<string, string>();\r\n            this.TripPlans = new SimpleSerializableDictionary<TripEnums.TripPlanType, TripPlanModel>();\r\n            this.PreviewMode = GeneralEnums.PreviewMode.Unchanged;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the direction of the trip.\r\n        /// </summary>\r\n        public TripEnums.TripDirection Direction\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the instantiation mode of the trip.\r\n        /// </summary>\r\n        public TripEnums.TripInstantiationMode InstantiationMode\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the number of the next trip.\r\n        /// </summary>\r\n        public int NextTripNumber\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the number of the previous trip.\r\n        /// </summary>\r\n        public int PreviousTripNumber\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the property bags of the trip.\r\n        /// </summary>\r\n        public SimpleSerializableDictionary<string, string> PropertyBags\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the service ID of the trip.\r\n        /// </summary>\r\n        public string ServiceId\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the state of the trip.\r\n        /// </summary>\r\n        public TripEnums.TripState State\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the ID of the trip.\r\n        /// </summary>\r\n        public string TripId\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the number of the trip.\r\n        /// </summary>\r\n        public int TripNumber\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        public GeneralEnums.PreviewMode PreviewMode\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the trip plans of the trip.\r\n        /// </summary>\r\n        public SimpleSerializableDictionary<TripEnums.TripPlanType, TripPlanModel> TripPlans\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Indicates whether the current object is equal to another object of the same type.\r\n        /// </summary>\r\n        /// <param name=\"other\">An object to compare with this object.</param>\r\n        /// <returns>Returns true if the two objects are equal false otherwise.</returns>\r\n        public bool Equals(TripModel other)\r\n        {\r\n            if (other == null)\r\n            {\r\n                return false;\r\n            }\r\n\r\n            return this.TripNumber == other.TripNumber\r\n                   && this.ServiceId == other.ServiceId\r\n                   && this.TripId == other.TripId\r\n                   && this.Direction == other.Direction\r\n                   && this.State == other.State\r\n                   && this.InstantiationMode == other.InstantiationMode\r\n                   && this.PreviousTripNumber == other.PreviousTripNumber\r\n                   && this.NextTripNumber == other.NextTripNumber\r\n                   && object.Equals(this.PropertyBags, other.PropertyBags)\r\n                   && object.Equals(this.TripPlans, other.TripPlans);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Determines whether the specified System.Object is equal to the current System.Object.\r\n        /// </summary>\r\n        /// <param name=\"obj\">The System.Object to compare with the current System.Object.</param>\r\n        /// <returns>Returns true if the two objects are equal false otherwise.</returns>\r\n        public override bool Equals(object obj)\r\n        {\r\n            return obj != null && this.Equals(obj as TripModel);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Serves as a hash function for <see cref=\"TripModel\" />.\r\n        /// </summary>\r\n        /// <returns>A hash code for the current <see cref=\"TripModel\" />.</returns>\r\n        public override int GetHashCode()\r\n        {\r\n            return\r\n                new\r\n                {\r\n                    this.TripNumber,\r\n                    this.ServiceId,\r\n                    this.TripId,\r\n                    this.Direction,\r\n                    this.State,\r\n                    this.InstantiationMode,\r\n                    this.PreviousTripNumber,\r\n                    this.NextTripNumber,\r\n                    this.PropertyBags,\r\n                    this.TripPlans\r\n                }.GetHashCode();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Adds an information to the object indicating \r\n        /// if the object has been updated, deleted, inserted\r\n        /// or unchanged.\r\n        /// </summary>\r\n        /// <param name=\"previewMode\"></param>\r\n        public void AddModification(GeneralEnums.PreviewMode previewMode)\r\n        {\r\n            this.PreviewMode = previewMode;\r\n        }\r\n\r\n\r\n    }\n\n\r\nThank you for your help...\r\n\t\t    ", "id": "1239153", "title": "C# copy list of objects without reference", "traffic_rate": 0}, "saved_time": 1721101368, "source": "codeproject", "tags": ["C#"]}, {"answers": [{"content": "As danben previously said, you're just copying the same dict into 3 variables, so that each one refers to the same object. To get the behaviour you want, you should instantiate a different dict in each variable:", "id": 2439352, "owner_tier": 0.5, "score": 0.0166666665}, {"content": "I agree with what is said above. The key here is that, in Python, assignments represent references to the object.\nI was trying to grasp the concept myself and I think is it important to understand in which case a new object is created and when is the existing one changed. In the example above, the line: doesn't create a new object. It only changes the object which is referenced by dict_a, dict_b, and dict_c. If, instead, you wrote: it would create a new object which would be referenced by dict_c. Dict_a and dict_b would still be pointing to the empty object. In that case, if you run: you would get:", "id": 62374952, "owner_tier": 0.1, "score": -1.6666666666666666e-10}, {"content": "Even though  is the right way to go in most cases, when it get more than 3 it looks weird Imagine In cases where I wanna initialize more than 3 things, I use", "id": 2445989, "owner_tier": 0.5, "score": 0.16666666649999998}, {"content": "This is because in Python, variables (names) are just references to individual objects.  When you assign dict_a = dict_b, you are really copying a memory address (or pointer, if you will) from dict_b to dict_a.  There is still one instance of that dictionary. To get the desired behavior, use either the dict.copy method, or use copy.deepcopy if your dict may have nested dicts or other nested objects.", "id": 2438943, "owner_tier": 0.9, "score": 0.9999999998333333}, {"content": "Your first assignment assigns the same dictionary object to the variables dict_a, dict_b, and dict_c. It is equivalent to dict_c = {}; dict_b = dict_c; dict_a = dict_c.", "id": 2438945, "owner_tier": 0.3, "score": 0.0166666665}], "link": "https://stackoverflow.com/questions/2438938/does-python-make-a-copy-of-objects-on-assignment", "question": {"content": "When I try this code: I expected that it would just initialise the dict_a, dict_b and dict_c dictionaries, and then assign a key in dict_c, resulting in But it seems to have a copy-through effect instead: Why? See also:", "id": 2438938, "title": "Does Python make a copy of objects on assignment?", "traffic_rate": 13}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "For class objects, I find it's best to add their own copy method.  This allows a work around for internal, non-pickelable objects in the deepcopy: In your working code, it would then become: This is a toy problem of course.  In reality, you would do this if you have complex objects within your class which cannot be readily copied directly with the copy.deepcopy() type operation.  If it were a simple problem, just use b = copy.deepcopy(a) without the explicit definition in the class.", "id": 75163196, "owner_tier": 0.5, "score": -1.1363636363636364e-10}, {"content": "Using this you can almost copy everything from one object to another: However, if you run the code above, you will see these errors: You can only copy these read-only properties by doing it on the class static initialization, like the other built-in magic python methods as __str__ just above: Now this new version completely works coping everything: The disadvantage of it is that you need to write the Python code manually to overcome the read only attributes. However, you can write python code on the fly with metaprogramming: So, if you work over this initial code just above, you can write a script which generates the code it needs to. Hence, you can dynamically and completely copy any Python object.", "id": 48970465, "owner_tier": 0.5, "score": 0.01136363625}, {"content": "If your class does not modify __getitem__ or __setitem__ for special attribute access all your attributes are stored in __dict__ so you can do: If you use python properties you should look at inspect.getmembers() and filter out the ones you want to copy.", "id": 244116, "owner_tier": 0.9, "score": 0.6590909089772727}, {"content": "If you have to do this, I guess the nicest way is to have a class attribute something like : Then iterate them explicitly and use setattr(new, attr, getattr(old, attr)). I still believe it can be solved with a better design though, and don't recommend it.", "id": 252393, "owner_tier": 0.9, "score": 0.022727272613636364}, {"content": "At the risk of being modded down, is there a decent any use-case for this?  Unless we know exactly what it's for, we can't sensibly call it as \"broken\" as it seems. Perhaps try this: That's the sane way of copying things between instances.", "id": 248608, "owner_tier": 0.9, "score": -1.1363636363636364e-10}, {"content": "Try destination.__dict__.update(source.__dict__).", "id": 244654, "owner_tier": 0.9, "score": 0.9999999998863637}], "link": "https://stackoverflow.com/questions/243836/how-to-copy-all-properties-of-an-object-to-another-object-in-python", "question": {"content": "Is there a library method to copy all the properties between two (already present) instances of the same class, in Python? I mean, something like Apache Commons' PropertyUtilsBean.copyProperties()", "id": 243836, "title": "How to copy all properties of an object to another object, in Python?", "traffic_rate": 13}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "You're right,  using deepcopy from the built-in copy module is the way to go, since you want the exact replica of the Object Foo. Here, passing the object Foo(5) will return a Foo object, passing it without any args will return __name__.Foo", "id": 72220352, "owner_tier": 0.3, "score": 0.9999999900000002}], "link": "https://stackoverflow.com/questions/72219980/how-to-copy-a-class-object-in-python", "question": {"content": "This is quite a simple question, however I cannot seem to figure out how to do it. I simply need to make a copy of a class object, for example: I tried to do both A.copy() and A.deepcopy(), but I get \"'Foo' object has no attribute 'copy'\"\nThis may be a super simple fix, however I have never used the copy module before and am not aware of why this may be an issue.\nFor reference, I need the copied object to be mutable (without affecting the original) so I figured the best way would be to use .deepcopy().", "id": 72219980, "title": "How to copy a class object in python", "traffic_rate": 3103}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python", "class", "object", "copy"]}, {"answers": [{"content": "So, if I change values of the fields of the new object, the old object should not be affected by that. You mean a mutable object then. In Python 3, lists get a copy method (in 2, you'd use a slice to make a copy): Shallow copies are just copies of the outermost container. list.copy is a shallow copy: You don't get a copy of the interior objects. They're the same object - so when they're mutated, the change shows up in both containers. Deep copies are recursive copies of each interior object. Changes are not reflected in the original, only in the copy. Immutable objects do not usually need to be copied. In fact, if you try to, Python will just give you the original object: Tuples don't even have a copy method, so let's try it with a slice: But we see it's the same object: Similarly for strings: and for frozensets, even though they have a copy method: Immutable objects should be copied if you need a mutable interior object copied. As we can see, when the interior object of the copy is mutated, the original does not change. Custom objects usually store data in a __dict__ attribute or in __slots__ (a tuple-like memory structure.) To make a copyable object, define __copy__ (for shallow copies) and/or __deepcopy__ (for deep copies). Note that deepcopy keeps a memoization dictionary of id(original) (or identity numbers) to copies. To enjoy good behavior with recursive data structures, make sure you haven't already made a copy, and if you have, return that. So let's make an object: And copy makes a shallow copy: And deepcopy now makes a deep copy:", "id": 46939443, "owner_tier": 0.9, "score": 0.49999999996855343}, {"content": "To get a fully independent copy of an object you can use the copy.deepcopy() function. For more details about shallow and deep copying please refer to the other answers to this question and the nice explanation in this answer to a related question.", "id": 4794254, "owner_tier": 0.9, "score": 0.9999999999685535}, {"content": "Shallow copy with copy.copy() Deep copy with copy.deepcopy() Documentation: https://docs.python.org/3/library/copy.html Tested on Python 3.6.5.", "id": 52160051, "owner_tier": 0.9, "score": 0.08490566034591195}, {"content": "I believe the following should work with many well-behaved classed in Python: (Of course, I am not talking here about \"deep copies,\" which is a different story, and which may be not a very clear concept -- how deep is deep enough?) According to my tests with Python 3, for immutable objects, like tuples or strings, it returns the same object (because there is no need to make a shallow copy of an immutable object), but for lists or dictionaries it creates an independent shallow copy. Of course this method only works for classes whose constructors behave accordingly. Possible use cases: making a shallow copy of a standard Python container class.", "id": 48906171, "owner_tier": 0.5, "score": -3.1446541038514446e-11}], "link": "https://stackoverflow.com/questions/4794244/how-can-i-create-a-copy-of-an-object-in-python", "question": {"content": "I would like to create a copy of an object. I want the new object to possess all properties of the old object (values of the fields). But I want to have independent objects. So, if I change values of the fields of the new object, the old object should not be affected by that.", "id": 4794244, "title": "How can I create a copy of an object in Python?", "traffic_rate": 146}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python", "oop", "object", "copy"]}, {"answers": [{"content": "If you want to make a copy then one way is using deepcopy: All = does is to assign another reference to the same object in memory. The deepcopy creates a whole new object in memory with the values of A and B will reference it. if you do the following you will see different prints:", "id": 42143502, "owner_tier": 0.9, "score": 0.9999999993333333}], "link": "https://stackoverflow.com/questions/42143461/make-copy-of-object-instance-in-python", "question": {"content": "I would like to make a copy of a python class object which does not change when the original object changes. Here is my simple working example: From my understanding, when I set B = A, this just means B points to the object A. Hence when I change A it changes B as well. Is it possible to instead make B a new instance with all the same properties as A, but does not change when I change A? In my above example, I would like the value for B to stay at 1 when I increment A.  If A and B were lists instead of objects I would write B = list(A). I guess I am asking if there is a similar method for class objects? Thank you in advance for your help!", "id": 42143461, "title": "Make copy of object instance in Python", "traffic_rate": 22762}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python", "oop"]}, {"answers": [{"content": "In general, you can use the copy module to produce copies of Python objects. copy.copy() will produce a shallow copy; a new instance is created but all attributes are simply copied over. If any of your attributes are mutable and you mutate those objects you'll see those changes reflected on both objects. copy.deepcopy() will produce a copy recursively; any mutable objects will themselves be cloned. If your class implements a __copy__ method it'll be used to create a shallow copy of the object; return a new instance with attributes copied over and altered as needed. Similarly, you can implement a __deepcopy__ method to implement a custom deep copy method; it'll be passed the memo state, pass this on to recursive copy.deepcopy() calls. Note that you cannot use this to copy a class object however. Classes are meant to be singletons; you don't need to create a copy in that case. You can use subclassing instead, or a class factory function, to produce distinct class objects.", "id": 29398459, "owner_tier": 0.9, "score": 0.9999999994736841}], "link": "https://stackoverflow.com/questions/29398336/how-to-copy-instances-of-a-custom-defined-class-in-python-3-3", "question": {"content": "I am trying to copy instances of a custom class in Python 3.3, similar to how dict.copy() and list.copy() work. How do I go about this? Here is an example of my custom class:", "id": 29398336, "title": "How to copy instances of a custom defined class in Python 3.3?", "traffic_rate": 15121}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python", "python-3.x"]}, {"answers": [{"content": "Does Python make a copy of objects on assignment? This is because in Python, variables (names) are just references to individual objects. When you assign dict_a = dict_b, you are really copying a memory address (or pointer, if you will) from dict_b to dict_a. There is still one instance of that dictionary. In your example, df and instance.df is the same thing of dict_a and dict_b, which is only holding the reference of the instance. How to delete every reference of an object in Python? No no no. Python has a garbage collector that has very strong territory issues - it won't mess with you creating objects, you don't mess with it deleting objects. Simply put, it can't be done, and for a good reason. This is by design and intentional, delete the variable of df, would not eliminate the existence of the instance, it only remove the reference from you df, therefore, as long as instance.df is still holding the instance, you could still access it even you deleted the variable df.", "id": 73328910, "owner_tier": 0.3, "score": 0.0}], "link": "https://stackoverflow.com/questions/73328857/does-python-copy-objects-on-instance-attribute-assignment", "question": {"content": "Consider some Python 3 code where we have a very large object, and I need to store a reference to this object within a class due to third-party libraries. In this case, the object df is a very large numpy array (>20 GB) and my system's memory is already almost maxed out. Does assigning df as an instance attribute duplicate the memory required, or simply act as a reference to the existing object? In code: I'm hitting some memory issues later on and trying to debug where it might be coming from. My intuition tells me that Python knows to not copy the object, however if we do something like del df then instance.df is still defined.", "id": 73328857, "title": "Does Python copy objects on instance attribute assignment?", "traffic_rate": 410}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python", "memory", "bigdata"]}, {"answers": [{"content": "I have mostly figured it out. The only problem which I cannot overcome is knowing an acceptable set of initialization arguments (arguments for __init__) for all classes. So I have to make the following two assumtions: 1) I have a set of default arguments for class C which I call argsC.\n2) All objects in C can be initialized with empty arguments. In which case I can\nFirst:\nInitialize a new instance of the class C from it's instance which I want to copy c: Second:\nGo through all the attributes of c and set the attributes c_copy to be a copy of the attributes of c where object_copy is a recursive application of the function we are building. Last:\nDelete all attributes in c_copy but not in c: Putting this all together we have: So putting it all together we have: {'a': 11, 'r': [[1], 2, 3]} {'a': 11, 'r': [[1], 2, 3]} {'a': 11, 'r': [[1, 33], 2, 3]} {'a': 11, 'r': [[1], 2, 3]} Which is the desired outcome. It uses deepcopy if it can, but for the cases where it would raise an exception, it can do without.", "id": 48528831, "owner_tier": 0.5, "score": -3.1250002585636594e-10}, {"content": "One way to do that is by implementing __copy__ in the C Class like so: ", "id": 48339837, "owner_tier": 0.5, "score": 0.21874999968749997}, {"content": "Yes you can make a copy of class instance using deepcopy: This creates the copy of class instance 'c' in 'd' .", "id": 48339768, "owner_tier": 0.5, "score": 0.9999999996875}], "link": "https://stackoverflow.com/questions/48338847/how-to-copy-a-python-class-instance-if-deepcopy-does-not-work", "question": {"content": "I would like to make a copy of a class instance in python. I tried copy.deepcopy but I get the error message: RuntimeError: Only Variables created explicitly by the user (graph leaves) support the deepcopy protocol at the moment So suppose I have something like: And now I want to make an identical deep copy of c, is there an easy way?", "id": 48338847, "title": "How to copy a Python class instance if deepcopy() does not work?", "traffic_rate": 51}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python", "class", "deep-copy"]}, {"answers": [{"content": "If you take a look at dir(test1), you'll see that one of the elements is 'copy'. In other words, you're not just copying the type attribute. You're copying the copy method. test2 gets test2.copy set to test1.copy, a bound method that will copy test1. Don't use dir for this. Look at the instance's __dict__, which only contains instance-specific data.", "id": 45765988, "owner_tier": 0.9, "score": -9.99999993922529e-09}, {"content": "Your copy() method copied the copy method (not the function from the class) from test1, which means that self in test2.copy() is still test1.", "id": 45765979, "owner_tier": 0.9, "score": 0.9999999900000001}], "link": "https://stackoverflow.com/questions/45765946/cant-do-a-copy-of-an-object-in-python-3-with-attributes", "question": {"content": "I'm using some objects in python with dynamic properties, all with numbers and strings. Also I created a simple method to make a copy of an object. One of the property is a list, but I don't need it to be deep copied. This method seems to work fine, but I found an odd problem. This piece of code shows it: Where is my conceptual error? Thanks.", "id": 45765946, "title": "Can&#39;t do a copy of an object in python 3 with attributes", "traffic_rate": 172}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python-3.x", "oop"]}, {"answers": [{"content": "If you want to create a copy of the class and assign that to a new object, you can use copy: Depending on the structure of your class, you may want to do a deepcopy instead. A shallow copy will only copy references to the objects found in your initial class. A deepcopy will attempt to recursively copy all objects within your original class. There can be issues with this if you have some recursive structure within your classes, but for the most part this won't be an issue. See this for more info - https://docs.python.org/2/library/copy.html", "id": 40478341, "owner_tier": 0.5, "score": 0.9999999966666667}], "link": "https://stackoverflow.com/questions/40478253/python-copy-class-object-to-another-class", "question": {"content": "I have a class defined as follows: I have a dictionary which contains the key value pairs which has key indices and values are table objects. Now I want to get the table object and copy the details to another object, something like: How do I change the class or copy the details to another object?", "id": 40478253, "title": "Python: Copy class object to another class", "traffic_rate": 3591}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "stackoverflow", "tags": ["python", "oop"]}, {"answers": [{"content": "You need to copy the array\n\n`current_data =` [`self.data`](https://self.data)`[:]`\n\nor\n\n`current_data = self.data.copy()`\n\notherwise your variable refers to the same one, and it is reversed in place.", "id": "jfqhcgl", "owner_tier": 0.1, "score": 0.9999999983333333}, {"content": "You're not copying. Simple assignment *never* copies in Python. You would need to copy the data explicitly.", "id": "jfqhmtd", "owner_tier": 0.5, "score": -1.6666666565375483e-09}], "link": "https://www.reddit.com/r/learnpython/comments/12htd7g/copying_an_attribute_of_an_object_into_a_variable/", "question": {"content": "Hi! I feel like this is a very basic concept that I am doing wrong. I have a function of an object that has to access an attribute of the same object, copy it and reverse it. (I'ts an array)\n\n&#x200B;\n\n    def back_propagation(self, expected_values):\n    \n    \n         current_data = self.data\n    \n         current_data.reverse()\n\nHowever, when I do this [self.data](https://self.data) also gets reversed. What am I doing wrong? How can I fix this? Thank you!", "id": "12htd7g", "title": "Copying an attribute of an object into a variable", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "`copy.copy` only copies the outer list, not the inner lists. It simply creates new references to those inner lists. Compare, for example, `id(masterList[0])`, `id(nested[0])`, and `id(empty[0])`.\n\nThere's a difference between `copy.copy` and `copy.deepcopy` for any object that contains references to other objects. `copy.copy` creates a new object with the same references. `copy.deepcopy` creates a new object with references to new objects.\n\nOk that makes sense! Thank you. In that case why would I not want to use deepcopy every time?\n\nBecause there might be a situation where a shallow copy is desired (you might need the new object to contain the same references) or at least is sufficient (consider that copying large nested structures might be quite wasteful in terms of runtime and memory). For nested lists specifically, maybe shallow copies are less often needed, but `copy.copy` and `copy.deepcopy` work on all Python objects.\n\nBut while using deepcopy might give worse performance, using copy or play = might lead to unexpected side effects that can be highly confusing. Ibprefer to start with trying to avoid mutability and start optimizing if it matters.", "id": "j15dozd", "owner_tier": 0.3, "score": 0.9999999991666666}, {"content": "https://www.reddit.com/r/learnpython/comments/zr8uxy/how_the_value_of_a30_is_changed_to_b_while_a1/", "id": "j169f4u", "owner_tier": 0.5, "score": -8.333333282687742e-10}], "link": "https://www.reddit.com/r/learnpython/comments/zrz5t9/not_understanding_copy_vs_deepcopy/", "question": {"content": "I'm on chapter 4 of Automate the Boring Stuff with Python, about lists. He explains the difference between mutable and immutable datatypes, and how if you assign the same list to two different variables and change the list in one, it will do the same to the other variable since they are referencing the same list.\n\nTo avoid this problem he introduces the copy.copy() functions from the copy module, and explains that...\n\n>If the list you need to copy contains lists, then use the copy.deepcopy() function instead of copy.copy(). The deepcopy() function will copy these inner lists as well.\n\nHowever I tried to test this and I see no difference:\n\n    import copy\n    \n    list1 = ['A', 'B', 'C']\n    list2 = ['E', 'F', 'G']\n    list3 = ['H', 'I', 'J']\n    list4 = ['K', 'L', 'M']\n    list5 = ['N', 'O', 'P']\n    list6 = ['Q', 'R', 'S']\n    \n    alpha = [list1, list2, list3]\n    beta = [list4, list5, list6]\n    masterList = [alpha, beta]\n    \n    print(masterList)\n    print(id(masterList))\n    print()\n    \n    nocopy = masterList\n    print(nocopy)\n    print(id(nocopy))\n    print()\n    \n    empty = copy.copy(masterList)\n    print(empty)\n    print(id(empty))\n    print()\n    \n    nested = copy.deepcopy(masterList)\n    print(nested)\n    print(id(nested))\n    print()\n\nThe result is the following:\n\n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614336\n    \n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614336\n    \n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614784\n    \n    [[['A', 'B', 'C'], ['E', 'F', 'G'], ['H', 'I', 'J']], [['K', 'L', 'M'], ['N', 'O', 'P'], ['Q', 'R', 'S']]]\n    2117790614912\n\nI see the copy functions have different IDs, but the copy.copy() function copied the lists inside the lists... what am I not understanding? Can someone show me an example of when these two would be different? Why wouldn't I just always use deepcopy to be safe?", "id": "zrz5t9", "title": "Not understanding copy vs deepcopy", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": ">In simple terms, after a bit of experimentation, deep copy is a copy where you can do shenanigans without messing with the original object. Shallow copy is essentially a copy which affects the original. That makes sense\n\nWell, that's not _exactly_ correct. Let's see what [the Python docs say about this](https://docs.python.org/3/library/copy.html):\n\n> The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):\n\n> * A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.\n\n> * A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.\n\nSo, the first indication here is that it only matters for objects that contain other objects.\n\nA deep copy is basically a recursive copy operation, where it continues to copy each sub-object and sub-object of the sub-objects until it reaches a point where there's nothing else to copy.\n\nA shallow copy just copies the references from the target to the clone. So, if you then modified a field in a sub-object, the change would be reflected in the original, since they are both pointing to the object that has the field that has been modified.\n\nBut it comes down to understanding how references work. Here's an example of a _shallow_ copy, but shows that not everything you do affects the copy target:\n\n    from copy import copy\n    \n    class Person:\n        def __init__(self, fname, lname):\n            self.firstName = fname\n            self.lastName = lname\n    \n    p1 = Person('Jack', 'Smith')\n    p2 = copy(Person)\n    p2.firstName = 'James'\n    \n    print(p1.firstName) #prints Jack\n    print(p2.firstName) #prints James\n\nIn this example, `copy` performs a shallow copy on our `Person` object, and copies the references to the string from `p1` into `p2`. But then we _reassign_ the `firstName` field. That means we set a brand new reference, and as such, the change wouldn't be reflected back to the original object, because now they are pointing at two completely different strings.", "id": "h3q3k0i", "owner_tier": 0.9, "score": 0.9999999900000001}, {"content": "if you have a list of immutable objects (strings, ints, bools) then you can just shallow copy them to avoid the overhead of making new instances", "id": "h3q00e4", "owner_tier": 0.7, "score": -9.99999993922529e-09}, {"content": "\u201cMaking a shallow copy of an object won\u2019t clone child objects. Therefore, the copy is not fully independent of the original\u201d. Maybe this little blurb can lead to some use cases.\n\nEdit: you may also want to create a copy of the original object at a point in time and then modify the original without modifying the copy. So like taking a snapshot, just being aware that the copy will still affect the original\n\nI was thinking on that blurb and coming up fairly blank - it makes sense to me they exist, what they may be, I wouldn't really be sure (in my case, I mainly use Python in the context of data analysis and engineering, so there are some language features I may not lean on too heavily). On the point of the edit though that makes sense - cheers!", "id": "h3q0a08", "owner_tier": 0.5, "score": 0.9999999900000001}], "link": "https://www.reddit.com/r/learnprogramming/comments/obtkt6/python_what_is_the_use_case_for_shallow_copy/", "question": {"content": "Before going further, to clarify: the question is not what is the difference between shallow copy and deep copy.  \n\n\nIn simple terms, after a bit of experimentation, deep copy is a copy where you can do shenanigans without messing with the original object. Shallow copy is essentially a copy which affects the original. That makes sense. Here's my question:  \n\n\nIf shallow copies affect the original, why wouldn't we just act on the original object? What would be a practical case where using it makes sense? The fact it exists means there's some case where it is useful but haven't a clue myself what that case may be! :)", "id": "obtkt6", "title": "Python - what is the use case for shallow copy?", "traffic_rate": 759.40625}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "Try making a list that contains lists as it's items.\n\nThen try shallow copy and deep copy and modify one of the nested lists.\n\nYou should see a difference then.\n\n'''\n\n\\>>> c = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n\n\\>>> d= c.copy()\n\n\\>>> e=c\n\n\\>>> f=list(c)\n\n\\>>> g=c\\[:\\]\n\n\\>>> c\n\n\\[\\[1, 2, 3\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> c\\[0\\].append(\"COOL\")\n\n\\>>> c\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> d\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> e\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> f\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> g\n\n\\[\\[1, 2, 3, 'COOL'\\], \\[4, 5, 6\\], \\[7, 8, 9\\]\\]\n\n\\>>> d is c\n\nFalse\n\n\\>>> e is c\n\nTrue\n\n\\>>> f is c\n\nFalse\n\n\\>>> g is c\n\nFalse\n\n\\>>>\n\n'''\n\n&#x200B;\n\nFrom this,  only operator that stood out was e = c. They both have the same ids. whereas the other pairs had different pair of ids. Does this mean \"= operator\" is the only one that used deep copy?  I am really sorry, if I sound dumb. Thanks for the previous reply!!\n\nBut you did not use deep copy anywhere.\n\n    >>> a = [[1,2,3],[4,5,6]]\n    >>> b = a.copy()\n    >>> b[0][0]=333\n    >>> a\n    [[333, 2, 3], [4, 5, 6]]\n    >>> import copy\n    >>> c = copy.deepcopy(a)\n    >>> c[0][0]=555\n    >>> c\n    [[555, 2, 3], [4, 5, 6]]\n    >>> a\n    [[333, 2, 3], [4, 5, 6]]\n    >>>\n\nMost regular copies create shallow copies, only deep copy creates a full copy of the contained items as well.\n\nYou can see in example above, .copy() created for b was shallow, meaning it copied the reference to the inner lists, but not the inner lists themselves. so changing b\\[0\\] resulted in a\\[0\\] being changed.\n\nOn the other hand, c is a deepcopy, so changing anything there does not reflect on a.\n\nThe assignment operator, in Python, doesn't copy.  Ever.  It adds a reference to a object, basically giving it a new name (as a variable), or putting that reference into a container (like a list or dictionary).\n\n&#x200B;\n\nThe lists that have different ids from c, are shallow copies.  However, when you append 'COOL' you are not adding it to one of the copied lists, you are adding it to a list that is inside *all* the lists, even the copies.  Do the following for all the lists (c, d, e, f, g):\n\n    [id(x) for x in c]  # then change 'c' to 'd', then 'e', etc\n\nYou will see that the ids are the same, since even the copies refer to the same objects inside them, and thus they all contain the same list objects.\n\n&#x200B;\n\nA \"deep\" copy would make copies of those inner lists to.  So, try this next:\n\n    from copy import deepcopy\n    h = deepcopy(c)\n    [id(x) for x in h]  # now you will see it contains different list objects\n\nThis was what I needed. Thank you so much for putting up with my doubts!", "id": "fr09n2b", "owner_tier": 0.7, "score": 0.9999999975}, {"content": "A shallow list copy makes a copy of exactly one object: the list.  The objects inside the list are added to the new list, but they are the same objects.  A deep copy makes a copy of the list, and a copy of each mutable object inside the list, and a copy of each object that the mutable objects inside the list hold, etc.\n\nSlicing with \\[:\\] is a shallow copy (It's older than the list.copy() method, which came later as a more intuitive addition; but they both do the same thing).\n\nlist() constructor can make a list for any sequence, so it's a bit more than just a shallow copy; it can also change the type of the sequence (into a list).\n\nAssignment (=) does not copy.  Repeat, assigning an object doesn't copy it.  It's more like giving another name to an object.  That's why when you assign a list, you still get the same list, just with two names referring to it.\n\n&#x200B;\n\nObjects have id's.  Here's a list and it's id number:\n\n    >>> l = [1, 2, 3]\n    >>> id(l)\n    4321308016\n    \n    # But, if I assign the list, the new name still refers to the same object'\n    # The id is the same for both:\n    >>> l2 = l\n    >>> id(l2)\n    4321308016\n    \n    # However, if I make a copy of the list, that makes a new list object,\n    # with a different object id.  It's a different list, with the same content\n    >>> l3 = l.copy()\n    >>> id(l3)\n    4322278608\n\nThank you so much for the reply! \n\nSo from what you are saying, any changes in the shallow copied list  will result in a change on the former list as well? I mean for an example \"List1= List2.copy()\"... if a change is made in the List2, will it be seen on the List1 only when they are shallow copied? Whereas you can't see the change, when deep copied?  \n\n&#x200B;\n\nCan I assume the techniques that I have mentioned in my question, all use shallow copy principle?\n\n>So from what you are saying, any changes in the shallow copied list  will result in a change on the former list as well?\n\nNo.  That's an actual copy, so changing the copied list won't affect the original list.\n\n&#x200B;\n\nIt's when a list is just assigned (using '=') that no copy is made, so changing List1 or List2 affects the other (because there is no \"other\" object; it's the *same* list object, not a copy).\n\n&#x200B;\n\nDeep copying is for when a list holds a list.  A copy of the list means both copies still hold the same list inside, and so changing that *inner* list appears to affect both (because there is really only 1 inner list object, that both outer list copies refer to).  By making a \"deep\" copy of a list that holds a list, you get copies of both the outer and inner list objects.\n\n&#x200B;\n\n>Can I assume the techniques that I have mentioned in my question, all use shallow copy principle?\n\nThe assignment isn't a copy.\n\n&#x200B;\n\nThe slice, list.copy(), and list() constructors make shallow copies.  To get a deep copy, you generally need copy.deepcopy (from the 'copy' module), although some custom objects could provide their own helpers for making a deep copy.\n\nThank you! I understood the mechanics finally!", "id": "fr0bk8n", "owner_tier": 0.7, "score": 0.9999999975}, {"content": "1) Yes `.copy()` is a shallow copy it basically copies the values from the list to a new part of memory and returns the reference. An example of the effects of shallow copy:\n\na = [1, 2, 3]\n\nb = [a, 4]\n\nc = b.copy()\n\nc[1] = 5\n\nprint(b[1]) # still 4\n\nc[0][0] = 6\n\nprint(a[0]) # now 6\n\nprint(b[0][0]) # also 6\n\n2) `[:]`,  `list()` and `.copy` do the same when it comes to copying a list `=` on the other hand  just copies the reference. When you create an array imagine it's like placing  down a house and writing down the address of that House  that's what is stored in the variable. When you change something in the list it's like going to the saved address and changing the window of that house. Now when you copy the variable using an equal sign it's like copying the address to the house instead of placing down a new house. Now when you do a shallow copy you are kinda placing down a new identical house and storing that address. Now when you do another shallow copy imagine that house you are copying is holding addresses of other houses, when you duplicate the house you don't actually go into the house, go to those addresses and copy those houses too you just copy the single house a deep copy would go through all the referenced houses and copy them too. I hope that analogy helped/made sense!\n\nInteresting to see different perspectives on this concept! Thank you so much for the reply!", "id": "fr0ctw6", "owner_tier": 0.3, "score": -2.4999999848063226e-09}], "link": "https://www.reddit.com/r/learnpython/comments/glwyw2/shallow_and_deep_copy/", "question": {"content": "I am fairly new to the Python realm. What is the difference between shallow and deep copy? I know the theoritical part of it but Im not actually able to understand while practicing it. \n\n1)Does the **list.copy()** work on shallow copy technique? How does it work? \n\n2)How does it differ from the other copying techniques like the = operator; slicing [:] ; list() constructor? \n\nI have experimented it on the interactive python using two lists list1 and list2. When using \"List2 = List1\", I was able to see changes I made to the List2 on the List1. Whereas  copying the contents of List1 to the List2 using \" List2 = List1.copy()\" , didn't do so. \n\nPlease enlighten me! Thanks in advance!", "id": "glwyw2", "title": "Shallow and Deep Copy", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "It sounds like you are attempting to mock up the parts of the code you need to test.\n\nI am not sure why a simple sequence of copy, mutate, compare doesn't  effectively test the independence of the two copies.\n\nThe sub-objects that deepcopy needs to operate on all have refcounts; might `sys.getrefcount` or `gc.get_referrers` help?\n\n\nNot sure how that would work in my case. The child classes are all mocked - and therefore deepcopy on the instance simply returns the same object.\n\nNot sure how that would work in my case. The child classes are all mocked - and therefore deepcopy on the instance simply returns the same object.\n\nYou should only mock up the parts of the system that are irrelevant to the current test. Your test should run the code that does the child object's deepcopying, so you should'nt mock them for this test.\n\nYou should only mock up the parts of the system that are irrelevant to the current test. If your test involves the code that does the child object's deepcopying, so you shouldn't mock them for this test.\n\nExactly - and I am not trying to test that the object gets copyied correctly - that is tested elsewhere in the suite. Here I am trying to prove that the parent class does the right thing - and that includes invoking deep copy on it's children - regardless of what those children are. \n\nI think the ONLY solution is to refactor the code on ALL of my classes (current around 20) so that they have a copy method - and they are responsible for deepcopying themselves. That way I can prove that the parent class calls the copy method and can test each class with mocked out children.\n\nMy intuition is that you should test each class with **all** of it's dependencies mocked out - and then also do integration testing where you test the API with everything in place (with maybe only external sources mocked up so you can control data and error conditions).\n\nThank you for trying to help - it is appreciated.", "id": "dnqjvnd", "owner_tier": 0.3, "score": 0.9999999979999998}, {"content": "You could always add a `copied` parameter in `__init__`.\n\nshudders a little - I would prefer I didn't have special attributes just to support testing.\n\nIt's definitely not the ideal solution. You could write a new class in your test, add the attribute, and only have it exist in the test, but again that's a lot of work.", "id": "dnqmfvb", "owner_tier": 0.5, "score": 0.19999999799999998}, {"content": "    for member_new, member_old in zip(object_new, object_old):\n        if type(member_new) not in immutable_types:\n            assert member_new == member_old\n            assert member_new is not member_old\n        if member_new and member_old are iterable:\n            recurse\n\n> it doesn't prove that the new instance is a copy.\n\npast checking equality and checking IDs, you can't prove or deny if something is a copy or not (and there isn't a reason to)\n\n- - -\n\nyou can always just make your objects practically \"immutable\" and call it done, sidestep the whole issue and have a better resiliency against future similar issues\n\nLet me try to explain \nI have a parent class - call it Q, and a set of other classes which are child classes of Q - call them A,B,C,D. I don't want to test A,B,C & D - I do that elsewhere. Here I want to test Q - and prove that when i do operations on Q that it does the right things on A,B,C & D - I do that by mocking out A,B,C & D; and this works in all cases apart from deepcopy. I can't find a way to prove that Q attempts to deepcopy A,B,C,D - but since they are mocked out deepcopy on them returns the same instance, but there is no way to assert any calls on the __deepcopy__ method ", "id": "dnr07ts", "owner_tier": 0.5, "score": -1.999999987845058e-09}], "link": "https://www.reddit.com/r/Python/comments/73ibxr/how_to_prove_that_an_object_was_copied/", "question": {"content": "I am trying to test my current software, and I have one part of the API where a method (call it the clone method) called on one instance will return  a new instance with some changes.\n\nBy necessity the new instance must be a deep copy of the old instance, since the user might change the old instance (after the copy operation) and that must not effect the new instance - so any attribute of the old instance which refers to a mutable object MUST be deep copied.\n\nThe problem I have is in proving that deep copy.\n\nI am using the unittest module, and the unittest.mock classes and methods heavily during my testing. \n\nMy original plan was to use either Mock or MagicMock as values for the attributes, and and then try to make assertions against the __deepcopy__ method but neither Mock or MagicMock support the __deepcopy__ method.\n\nI can't just rely on the attributes refering to different objects after the clone method is called - as all that does is prove that a new instance is created - it doesn't prove that the new instance is a copy.\n\nHas anyone got any ideas that I can try ?", "id": "73ibxr", "title": "How to prove that an object was copied", "traffic_rate": 207.9358484294499}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "[`copy.deepcopy`](https://docs.python.org/3/library/copy.html?highlight=deepcopy#copy.deepcopy) will produce the result you want.\n\nThe problem with it is that it is slow and it's almost never needed because you can normally get away with shallow-copies/defining new variables instead.\nYou would only need `deepcopy` if you need to change the dicts/other objects contained inside your list without them changing on the outside too.\n\nAlso, if you elaborate what your doing/why you need the copy I can probably tell you whether a shallow copy is sufficient or how you can probably get away with no copies.\nPersonally, I've never needed a `deepcopy` in practice and shallow copies are rare-events, normally I just define a new list, with all the changes I need.", "id": "g8alzv7", "owner_tier": 0.3, "score": 0.9999999980000001}, {"content": "I actually don\u2019t know the best answer to this. But why not just make a copy function that creates and returns a new object with all the fun stuff copied?", "id": "g8alj0v", "owner_tier": 0.5, "score": -1.999999987845058e-09}], "link": "https://www.reddit.com/r/learnpython/comments/j8fjke/there_are_too_many_versions_of_copy_in_python_how/", "question": {"content": " I have a list of objects that I instantiated from my own Class definition. The Class has lots of properties which might be any type (int, string, list, tuple, dictionary, other objects, etc.). How do I make an EXACT copy of this list that I can modify and not affect the original list?\n\nUsage: I have an important list that I want to preserve, but I need to mess with it for this one operation. When I'm done, I want to restore the original list.", "id": "j8fjke", "title": "There are too many versions of COPY in Python. How do I make an EXACT copy of a list?", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "The difference between a deep copy and a shallow copy is whether or not nested mutable structures are (recursively) copied (deep) or just referenced (shallow). \n\nAll elements of your list are immutable. Therefore, there is no difference between a shallow and a deep copy.\n\nA proper demonstration of the difference is this:\n\n    import copy\n\n    my_list = [['first'], ['second'], ['third']]\n\n    my_deep_copy = copy.deepcopy(my_list)\n    my_deep_copy[1][0] = 'new value'\n    print(my_list)\n\n    my_shallow_copy = copy.copy(my_list)\n    my_shallow_copy[1][0] = 'new value'\n    print(my_list)\n\nNote how it requires nested mutable structures.\n\nThank you! I didn't know that the nested arrays would impact that.  I just tried it out and it works the way that I expected it to with my example.", "id": "isq6467", "owner_tier": 0.5, "score": 0.9999999998684211}, {"content": "Setting the value at an index mutates the list, not the item at the index. The underlying values are still the same data:\n\n    from copy import copy\n    myL = ['first', 'second', 'third']\n    myLReg = copy(myL)\n    myL[0] is myLReg[0] # True\n    myLReg[0] = 'first'\n    myL[0] is myLReg[0] # False\n    myL[0] == myLReg[0] # True\n\nmyL and myLReg are different lists, so mutating one does not affect the other.", "id": "isqpzer", "owner_tier": 0.3, "score": 0.052631578815789476}, {"content": "Hello, I'm a Reddit bot who's here to help people nicely format their coding questions. This makes it as easy as possible for people to read your post and help you.\n\nI think I have detected some formatting issues with your submission:\n\n1. Inline formatting (`` `my code` ``) used across multiple lines of code. This can mess with indentation.\n\nIf I am correct, please edit the text in your post and try to follow [these instructions](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) to fix up your post's formatting.\n\n___\n\n^(Am I misbehaving? Have a comment or suggestion? Reply to this comment or raise an issue )^[here](https://github.com/0Hughman0/pyredditformatbot/issues).", "id": "isq16nn", "owner_tier": 0.1, "score": 0.026315789342105263}, {"content": "myLReg is a *new list object* with \"pointers\" to the same strings in myL, but in a new memory area. Modifying myLReg by overwriting myLReg[1] with a new value, only alters *the new object's* contents. The 'second' string object still exists in memory, and myL's list of contents still references it, but the object bound to myLReg contains a different, independent list of objects.", "id": "isqa361", "owner_tier": 0.5, "score": 0.03947368407894737}, {"content": "It's also worth noting that `copy` has no effect on immutable objects anyway:\n\n    import copy\n\n    string = \"hello world\"\n    string_copy = copy.copy(string)\n\n    print(id(string), id(string_copy), sep=\"\\n\")\n    # Prints\n    #1833251401584\n    #1833251401584\n\nThere's no point in copying a immutable object, so Python doesn't.", "id": "isqhn8q", "owner_tier": 0.9, "score": -1.3157894656875383e-10}, {"content": "I'm not too familiar with copy but I'll give it a shot.\nAre you wanting to change myL or myLReg?\nYou're changing myLReg but returning the other one.\nWhat happens when you return the myLReg in your console.log?\n\nSo I wanted to learn how to make a deep copy of myL but tried the \"shallow copy\" first.  So What I wanted to do was show that when I make a shallow copy of myL and assign it to myLReg and change a value in myLReg that myL would also change since it's simply a reference to myL.  According to these docs that should be the case but it looks like it only changes myLReg since myLReg outputs \\['first', 'new value', 'third'\\].\n\nThat's not what a shallow copy is. That's just a reference, as you say. A shallow copy is one that only copies the first level of references, as opposed to a deep copy which copies all levels. Consider:\n\n    >>> d = {\"a\": {\"b\": \"c\"}, \"d\": \"e\"}\n    >>> d2 = copy.copy(d)\n    >>> d2[\"d\"] = \"f\"\n    >>> d2[\"a\"][\"b\"] = \"g\"\n    >>> d2\n    {'a': {'b': 'g'}, 'd': 'f'}\n    >>> d\n    {'a': {'b': 'g'}, 'd': 'e'}\n\nAs you see, with the shallow copy \"\"d is changed but \"b\" is not.\n\nAh. I think copy makes them independent of one another.\nThis article might be a little clearer in how it works\nhttps://realpython.com/copying-python-objects/", "id": "isq3qq3", "owner_tier": 0.3, "score": 0.026315789342105263}], "link": "https://www.reddit.com/r/learnpython/comments/y6mq7i/python_copycopy_appears_to_make_a_deep_copy/", "question": {"content": "I am following the python docs for copy functions to learn how to make a deep copy of a list or dictionary.  ([https://docs.python.org/3/library/copy.html](https://docs.python.org/3/library/copy.html)) However, when I use copy.copy(list) and change one of the values it doesn't modify the original list like I thought.  \n\n\nExample\n\n`import copy`\n\n`myL = ['first', 'second', 'third']`\n\n`myLReg = copy.copy(myL)`\n\n`myLReg[1] = 'new value'`\n\n`console.log(myL)`\n\nWhat I expect the output to be is `['first', 'new value', 'third']` but I get `['first', 'second', 'third']`\n\n&#x200B;\n\nAm I understanding the docs wrong, is there a bug, or something else?\n\n&#x200B;\n\nThis is the behavior I expected from copy.deepcopy(myL)", "id": "y6mq7i", "title": "Python copy.copy() appears to make a deep copy", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "Besides the answers you got, I wanted to mention that the way you use classes is not how instance variables are created.\n\nYou are creating class variables instead of instance variables.\n\nhttps://www.javatpoint.com/class-variable-vs-instance", "id": "jwonoc9", "owner_tier": 0.7, "score": 0.9999999983333333}, {"content": "> The link discusses the problems of copy. If we copy a list into another variable b and  \nthen add any element in b then original list should also append that element. But when I am doing the above in the following list, it doesn\u2019t work:\n\nI think you've misunderstood something. The article focuses on the fact that if you assign a list to another name, what's copied is the reference to the list, not the list itself. If you want an analogy, it's like writing down the address of a house and sharing it with someone else instead of building an exact replica of the house.\n\nIn your example code, you're not doing that. `list.copy` produces a new list, although it's a shallow copy - in other words the contents are actually still the same. That doesn't matter in the example, though, because you're only storing immutable data, like strings and numbers. So adding or removing things from either list won't change anything in the other.", "id": "jwoijuv", "owner_tier": 0.7, "score": 0.49999999833333336}, {"content": "What do you mean it doesn't work? What are you getting, and what do you expect to get?\n\nHave you read this yet? All python programmers should read this to help understand mutability and assignment: \n[mutable presto-chango](https://nedbatchelder.com/text/names.html)", "id": "jwohpbd", "owner_tier": 0.7, "score": 0.16666666500000002}, {"content": "The first example in the link you posted makes what they're doing confusing because it uses the phrase \"copy assignment\".\n\nI've never heard anyone use that phrase for b = a.\n\nWhen you do b = a, you are assigning another reference to the object that contains the list that is also referenced as a.\n\nIt's like one person referring to you by your first name and another person referring to you by your last name.\n\ncopy() creates a new object that has no references or connections to the object it was copied from.\n\nThe Python docs explain the difference between assignment and copying better.\n\n[https://docs.python.org/3/library/copy.html](https://docs.python.org/3/library/copy.html)\n\n>Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other. This module provides generic shallow and deep copy operations (explained below).", "id": "jwp38nz", "owner_tier": 0.7, "score": -1.6666666565375483e-09}, {"content": "One key idea is that there are objects and there are names. Object must have at least one name. Object may have more names than one. You can only do something with an object via one of its names.\n\nx = 1 # create object 1, assign name 'x' to it\n\ny = 2 # create object 2, assign name 'y' to it\n\nx\\*2 # use name x to use the assigned object in a multiplication\n\nz = x # create a new name 'z' and assign it to object assigned to x", "id": "jwq3o9n", "owner_tier": 0.1, "score": -1.6666666565375483e-09}], "link": "https://www.reddit.com/r/learnpython/comments/15uafc6/python_side_effects_of_copy/", "question": {"content": "Hi.Following link at:[Side effect of copy](https://www.python-engineer.com/posts/how-to-copy-list/)The link discusses the problems of copy. If we copy a list into another variable b andthen add any element in b then original list should also append that element. But when I am doing the above in the following list, it doesn\u2019t work:\n\n    import numpy as np \n    class PyThonCopyListStringArr: \n        List1 = [2, 5, 6, 19, 4, 21, 65, 82, 22] \n        String1 = [\"223\",\"456\", \"324\", \"986\",\"999\", \"256\"] \n        arr = np.array([ 34,25,67,55, 83, 65, 46, 86, 39]) \n        def appendList(self): \n            b = PyThonCopyListStringArr.List1.copy(); \n            b.append(400) \n            print(\"b =\"+str(b)) print(\"List1 = \"+ str(PyThonCopyListStringArr.List1)) \n    if name == \"main\": \n        obj = PyThonCopyListStringArr() \n        obj.appendList()\n\nFollowing is my output:\n\n    b =[2, 5, 6, 19, 4, 21, 65, 82, 22, 400]\n    List1 = [2, 5, 6, 19, 4, 21, 65, 82, 22]\n\nWhy both the outputs are different?\n\n&#x200B;\n\nSomebody please guide me.\n\nZulfi.", "id": "15uafc6", "title": "Python: Side Effects of copy", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "This kind of confusion is mostly because you're thinking about python's object model wrong, or don't fully understand it. Perhaps this is a better way to think about things. Say you have this data structure:\n\n    x = [\n        [1,2,3],\n        [4,5,6],\n        ]\n\nThis statement creates 3 lists: 2 inner lists and one outer list. A reference to the outer list is then made available under the name x.\n\nWhen you execute this statement:\n\n    y = x\n\nno data gets copied. You still have the same 3 lists in memory somewhere. All this did is make the outer list availible under the name y, in addition to its previous name x.\n\nWhen you execute this statement:\n\n    y = list(x)\n\nor\n\n    y = x[:]\n\nThis creates a new list with the same contents as x. List x contained a reference to the 2 inner lists, so the new list will also contain a reference to those same 2 inner lists. Only one list is copied\u2014the outer list.\n\nNow there are 4 lists in memory, the two inner lists, the outer list, and the copy of the outer list. The original outer list is available under the name x, and the new outer list is made available under the name y.\n\nThe inner lists have *not* been copied! You can access and edit the inner lists from either x or y at this point!\n\nIf you have a two dimensional (or higher) list, or any kind of nested data structure, and you want to make a full copy of everything, then you want to use the deepcopy() function in the copy module. Your solution also works for 2-D lists, as iterates over the items in the outer list and makes a copy of each of them, then builds a new outer list for all the inner copies.\n\nHope this explanation helps.\n\nGreat answer. \n\nthanks, this is an excellent answer for a concept I never quite understood!\n\nAs a follow-up, the python tutor site helps visualize what's happening.\n\nAfter the line y=x, you can see that [both y and x reference the same list](http://pythontutor.com/visualize.html#code=x+%3D+%5B%0A+++++%5B1,2,3%5D,%0A+++++%5B4,5,6%5D,%0A+++++%5D%0A%0Ay+%3D+x%0A%0Ay+%3D+list\\(x\\)%0A%0Ay+%3D+%5Blist\\(inner\\)+for+inner+in+x%5D&mode=display&cumulative=false&heapPrimitives=false&drawParentPointers=false&textReferences=false&py=2&curInstr=3)\n\nAfter y=list(x), you can see that there are two outer lists, but [they both reference the same inner lists](http://pythontutor.com/visualize.html#code=x+%3D+%5B%0A+++++%5B1,2,3%5D,%0A+++++%5B4,5,6%5D,%0A+++++%5D%0A%0Ay+%3D+x%0A%0Ay+%3D+list\\(x\\)%0A%0Ay+%3D+%5Blist\\(inner\\)+for+inner+in+x%5D&mode=display&cumulative=false&heapPrimitives=false&drawParentPointers=false&textReferences=false&py=2&curInstr=4)\n\nAnd finally, after a proper copy, you can see that there are [two outer lists and two inner lists, properly copied](http://pythontutor.com/visualize.html#code=x+%3D+%5B%0A+++++%5B1,2,3%5D,%0A+++++%5B4,5,6%5D,%0A+++++%5D%0A%0Ay+%3D+x%0A%0Ay+%3D+list\\(x\\)%0A%0Ay+%3D+%5Blist\\(inner\\)+for+inner+in+x%5D%0Adel+inner&mode=display&cumulative=false&heapPrimitives=false&drawParentPointers=false&textReferences=false&py=2&curInstr=8). (I delete \"inner\" because it leaks out of the scope of the generator expression and adds arrows to the diagram that aren't relevant to the discussion.)", "id": "c8wywto", "owner_tier": 0.3, "score": 0.9565217389130435}, {"content": "> I am sure there is a reason for this design in Python but why is it so difficult to clone a list?\n\nYea! At the heart of python is the concept of mutable and immutable datatypes. Ints, strings, floats, tuples, frozen sets -- all immutable. Lists & sets? Mutable.\n\nIf you want a copy, look at the copy module. copy.copy() and copy.deepcopy() are the tools you need.\n\nWhat you're doing with the some_list[:] is called a shallow copy (or copy.copy()). That is, select all of the elements from some_list; the result of which is a list.\n\nCopying in python isn't hard; if you're coming from other languages, just think of python as a language that passes by reference by default.\n\nTo get a complete copy; simply:\n\n    import copy\n    copy_of_list = copy.deepcopy(your_list)\n\nWhile deepcopy is not evil or anything, it's almost certainly not what a beginner needs. In my experience, if a beginner asks about deep copying, it's almost always an [XY problem](http://www.perlmonks.org/index.pl?node_id=542341). So if you're tempted to use deepcopy, please think hard about what you're really trying to do. If deepcopy is really your solution, though, by all means use it.\n\nIf the OP really wanted a copy of a 2-d array, I would recommend:\n\n    bar = [list(x) for x in foo]\n\nor:\n\n    bar = map(list, foo)\n\nBut again, I'm skeptical that that's what the OP really needed.\n\nIt doesn't pass by reference, and it's dangerous (well, not really) to think that it does. It passes by value, where the value is sometimes a reference. If it passed by reference, you could do something like:\n\n    def swap(a, b):\n        a, b = b, a\n\n    a = 1  # or some other value with a different type\n    b = 2\n    swap(a, b)\n    print a, b  # would print 2 1\n\nThis is not possible in Python. There is no way you can code `swap` such that it affects the _value_ of the object in the caller. Compare this with C++:\n\n    void swap(int &a, int &b) {\n        int temp = a;\n        a = b;\n        b = temp;\n    }\n\n    void main() {\n        int a = 1, b = 2;\n        swap(a, b)\n        cout << a << endl;  // prints 2\n    }\n\nThe `swap` function here changes the value in the caller. Even if you do something like this to swap a list in Python:\n    \n    >>> a = [1]                       \n    >>> b = [2]                                                              \n    >>> hex(id(a))  # this is the actual value of a, not [1]\n    '0xb736f24cL'                     \n    >>> hex(id(b))                    \n    '0xb736f56cL'                     \n    >>> def swap(a, b):               \n    ...     a[:], b[:] = b[:], a[:]   \n    ...                               \n    >>> swap(a, b)                    \n    >>> hex(id(a))  # a still has the same value\n    '0xb736f24cL'                     \n    >>> hex(id(b))                    \n    '0xb736f56cL'                     \n    >>> a  # only the contents of a are different\n    [2]\n\nWhat you're saying is accurate, afaik, however:\n\n    def swap(a, b):\n       a, b = b, a\n\nIs operating in its own scope (despite using the same variable names). Unless you're returning the local scope from the function and capturing once again with:\n\n    a, b = swap(a, b)\n\nThere should be no change.\n\nThe full swap would then look like:\n\n    1, 2 = a, b\n    def swap(a, b):\n        a, b = b, a\n        return a, b\n    a, b = swap(a, b)\n    print a, b\n    #results in 2, 1\n\nedit: proof from an interactive interpreter:\n\n    a, b = 1, 2\n    id(a), id(b)\n    (31017312, 31017300)\n    a, b = swap(a, b)\n    id(a), id(b)\n    (31017300, 31017312)\n\nTo prove that the implementation of python I'm using isn't using cached integer values for a and b, it works with ranges outside of -3 to 250 or so that is pretty common.\n\n    >>> a, b = 12345, 67890\n    >>> id(a), id(b)\n    (34047788, 34046848)\n    >>> a, b = swap(a, b)\n    >>> print a, b\n    67890 12345\n    >>> id(a), id(b)\n    (34046848, 34047788)\n\nNo, you are objectively wrong. Python ***always*** passes by reference. There is *no such thing* as a primitive value in python. Even ints, floats, etc. are passed by reference, as they are actually subclasses of `object`. Your misunderstanding lies in your comprehension of literals in python.\n\nIn C, `a=5` copies the value `5` into the memory location denoted by `a` (which is on the stack if you're assigning like this). In Python, `a=5` is totally different, because `a` is `PyObject` pointer and `5` is actually a constructor that sometimes creates and always returns a pointer to an `int` object that holds the value `5`.\n\nAdditionally, the reason that your code doesn't swap has to do with variable scope. All function arguments in Python are copied into the function's stack frame. So if `a` is the name of an argument, assigning some value to `a` does literally nothing to its original value. If you want to manipulate `a`, you have to dereference it first, a la `a.foo = bar` (as the dot operator in Python is much like the `->` operator in C).\n\nTo clarify the last part, when a Python function starts, it copies all the function's arguments into the function's stack frame. Remember that since all things in Python are objects on the heap, only pointers have to be copied, not the large objects themselves. So if `a` is the name of an argument, `a` actually refers to a pointer *in the current function's stack frame*. Therefore, assigning a value to `a` will necessarily not do anything outside the function. However, doing something to `*a` (to put it in C syntax) will, in fact, affect the object outside of the current function's stack frame. However, if `*a` is a static integer object, trying to operate on `*a` would be kind of like trying to do `5 = 6` or `\"hello\" = \"goodbye\"`. You can't assign to \"literal\" objects like that.\n\nExactly, you need to return something. That's why it's not pass by reference, but pass by value, where the value is sometimes a reference. That's the point.\n\n>No, you are objectively wrong. Python ***always*** passes by reference. \n\nI wrote some stuff out, but it might be easier to just read the documentation:\n\nhttp://docs.python.org/2/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference\n\n>There is *no such thing* as a primitive value in python.\n\nSure, OK, this is something I am objectively wrong about. I'm far too used to having this discussion about Java, so it's easy to get confused (given the extremely similar semantics). However, that doesn't change anything I've said except this line here:\n\n> It passes by value, where the value is sometimes a reference.\n\nWhat it should say is this:\n\n> It passes by value, where the value is always a reference.\n\nOK, moving on:\n\n>Additionally, the reason that your code doesn't swap has to do with variable scope. \n\nThe callee has no access to the parents' variables, so it cannot be pass by reference. They're all copied values, where sometimes (OK, always, in Python) that value is a reference. You're not given an implicit reference to the variable, which you can alter. You're given a copy of the variable, where the variable's value is a reference. So, the original `PyObject` pointers `a` and `b` are not available to the callee. Therefore, it is impossible to affect their values, which are `PyObject` pointers to integers. There's no way you can cause them to be pointed to a different object from within the callee.\n\nTake a closer look at the Python and C++ examples I provided earlier:\n\n    def swap(a, b):\n        a, b = b, a\n    \n     a = 1\n     b = 2\n     swap(a, b)\n\nThe `a` on line 4 is different from the `a` on line 2. I think that's obvious to everyone. Compare that to this C++ example:\n\n    void swap(int &x, int &y) {\n        int &temp = x;  // I left out this & in my other comment\n        x = y;\n        y = temp;\n    }\n    \n    void main() {\n        int a = 1;\n        int b = 2;\n        int c = 3;\n        swap(a, b);\n    }\n\nThe `a` on line 8 is in fact the same variable as the `x` on line 2, which is the same variable as the variable `temp` declared on line 2. It's not a pointer or a reference. It's literally the same variable. `void swap(int &x, int &y)` doesn't have access to other variables like `c` in `main`; they're out of scope. It has _implicit_ access to `a` and `b` because they've been passed by reference. There's no way to do this in Python. You can't pass a variable from caller to callee such that the callee has the exact same variable. It's always another `PyObject` pointer, one that points to the same object, but is not the same `PyObject` pointer as before.\n\n>All function arguments in Python are copied into the function's stack frame. \n\nYes, so it is definitely not call by reference. In call by reference you would not copy the arguments into the new stack frame, since...well...it's the same variable. There's no need for any copying. What would you copy? It makes no sense to copy function arguments in a call by reference scenario. It's the same variable in the caller and callee; there is _no_ copying to be done. That would mean the callee gets a different variable, a copy of the original, which is not what call by reference is.\n\n>So if `a` is the name of an argument, assigning some value to `a` does literally nothing to its original value.\n\nThat's because you have copied it, passing it by value. It doesn't matter what I named it. I see choosing `a` and `b` everywhere was a mistake that obscures what I'm trying to say.\n\n> If you want to manipulate `a`, you have to dereference it first, a la `a.foo = bar` (as the dot operator in Python is much like the `->` operator in C).\n\nCorrect; the `.` operator in both Python and Java is the same as the `->` in C or C++. That only reinforces the notion that you have passed a value which is a reference; otherwise, why are you dereferencing it? Pass by reference does not mean you literally pass a reference; it means that the variable the child gets is the exact same variable the parent has. Consider this sample in C:\n\n    void modify(struct foo the_foo) {\n        the_foo.bar = 1;\n    }\n\n    void main() {\n        struct foo my_foo;\n        my_foo.bar = 2;\n        modify(my_foo);\n        printf(\"%d\", my_foo.bar);\n    }\n\nI think we both agree that `my_foo` cannot be modified by `modify`, because its value, which is the entire struct, is copied on to the call stack of `modify`. Contrast this with a call-by-reference version in C++:\n\n    void modify(struct foo &the_foo) {  // note change here\n        the_foo.bar = 1;  // but no change here\n    }\n\n    void main() {\n        struct foo my_foo;\n        my_foo.bar = 2;\n        modify(my_foo);\n        printf(\"%d\", my_foo.bar);\n    }\n\nSo the choice of syntax isn't really relevant. Actually, I'm really not sure what to say regarding the bit about syntax; it's more or less meaningless here. I could define a language that uses `->` to access members of things passed by reference or value.\n\nSide note: Apparently it's common to call this \"call by sharing\" in Python, but it's pretty much always called \"call by value\" in Java and really just about everywhere else; Python differs in that the only thing that can be passed around is a `PyObject` pointer, whereas in Java you can still pass primitive values. I rarely have to explain to people that Python isn't \"call by reference\" so \"call by sharing\" is unusual to me, but not inaccurate. The object is shared via a reference that is copied from caller to callee; the caller can never give the callee access to its own reference. Regardless, it's universally agreed upon that Python is not call by reference, for the reasons I have described above.\n\nI don't think we actually disagree on anything besides the fact that everything is an object (and as you stated, you simply mixed up Python and Java). \n\nThe thing about syntax was just me saying \"You can't do this in python, but pretend you can and that you do it with C syntax.\"\n\nAlso, we are sometimes using different definitions of \"reference\". You are often thinking of it as a C++ reference, whereas I am thinking of the more generic usage of \"reference\" (i.e. a pointer). \n\nI wrote all that stuff because I thought you were saying \"Integers are passed by value, therefore you cannot modify the original integer.\" which is obviously not the correct justification.\n\n>Also, we are sometimes using different definitions of \"reference\". \n\nNo, the problem is in the definition you're using for \"pass by reference\". It is not the generally-accepted definition of \"pass by reference\".\n\n>You are often thinking of it as a C++ reference, \n\nNo, or I would not say that Python \"passes by value, where the value is always a reference\".\n\nYour definition of \"pass by reference\" is the issue here. \"Pass by reference\" is not the same as \"pass by value where the value is always a reference\". \"Pass by reference\" only means one thing--the callee gets the same variable as the caller, the exact same variable. This is what we disagree on. At most, it could be call by sharing. It can't be call by reference.\n\n>I wrote all that stuff because I thought you were saying \"Integers are passed by value, therefore you cannot modify the original integer.\" which is obviously not the correct justification.\n\nWhile it is true that I mistakenly thought (or at least wrote) that integers were primitives passed by value as in Java, that's not actually relevant to anything I said. I didn't really think about what they really were in Python, since, like I said, it wasn't relevant to the point I was trying to make (which is that Python is never pass by reference).\n\n>No, the problem is in the definition you're using for \"pass by reference\". \n\nYou are correct. My bad. I did not realize that the C++ definition of \"pass by reference\" applied everywhere. But really, that's a pretty ridiculous definition, considering that \"passing by reference\" apparently just means \"pass a compiler-managed `*const` to something on the stack\". It is literally nothing but any other kind of pointer passing except for that it is managed more extensively by the compiler in C++ and it generally points to a stack variable.", "id": "c8wyodk", "owner_tier": 0.5, "score": 0.9999999997826087}, {"content": "    bar = list(foo)\n\ndoesn't work?  That surprises me.\n\nIt didn't when I tried it on a 2d list.\n\nhttp://i.imgur.com/1Q7aYID.png\n\n\nI think what you're looking for is\n\n    import copy\n    bar = copy.deepcopy(foo)\n\nThis is what you need to do for lists with more than 1 dimension, apparently.\n\nThanks.  I figured out how to do it earlier but my question is *WHY* does python make it so difficult.  It would make so much more sense to just go\n\n    bar2dList = foo2dList\n\nJust like you would with variables.\n\nLike someone above said, that (li1=li2) makes a shallow copy. That is, li1 is a variable. li2 is then just a variable that points to the memory that li1 was pointing at (think c++ pointer, if you're familiar), not a new list object. Since you're changing li1, li2 reflects that change because they both represent the same memory bit. \n\nSo why did the developers of python chose to have lists and sets do this but not variables?\n\nThere is no difference in how assignment works across types.  The difference is that you can never observe the shallow copy if the object is immutable, because it's impossible to modify it.  Most objects in Python are immutable.  In your original example in your post, when you write `bar = 2`, you are not modifying anything; all numbers are immutable in Python.  You're creating a new number object and giving it the name `bar`.  No mutation has occurred, which means the object that `foo` refers to is still the number 1.\n\nLists, sets, and dicts are the only commonly encountered types that are mutable, so they are the ones that confuse people that don't understand the object model.  But it's not like they are any different than all the other types in terms of what happens when they are assigned.\n\n\ni know no one's really answered your question as to *why* it's like this. most people are just telling you *that* it is like this, which doesn't really make for an explanation. i'm trying to figure it out myself.\n\nanyway, in terms of the explanation, it can be kind of weird to think about exactly *why* some things are implemented in a given language some particular way as opposed to anything else. in this case, it probably has to do something with efficient memory usage. typically, each design decision has a list of pros and cons\nassociated with it.\n\nmy guess: in most cases, this kind of behavior is fine for lists and ends up saving a lot of time and memory (compared to deep-copying any time a list is referenced). the trade off, of course, is that python looks a little less beautiful syntactically when you *do* want to deep copy something. i don't think it's more complicated than that. i don't think it's a bug or an oversight on the part of the developers.\n\nedit: after reading up on this a bit more, i'd like to emphasize that copying a list isn't really \"so damn difficult.\" you could maybe argue that the fact that lists don't just 'work like they should,' but i think the overall decision here fits pretty well within the [zen of python](http://www.python.org/dev/peps/pep-0020/) after all.", "id": "c8wxxu5", "owner_tier": 0.9, "score": 0.41304347804347824}, {"content": "You found a way to do it, but another way would be to use extend.\n\n    a = range(10)\n    b = []\n    b.extend(a)\n\n\n\nNo I tried extend too and that didnt help with a 2d list.\n\nThat wouldn't make a deep copy. It only works in your example because the range function produces a non-nested list of immutable objects, which means a shallow copy is all you need. ", "id": "c8wyx0a", "owner_tier": 0.3, "score": 0.04347826065217392}, {"content": "in c variables contain data.  in python variables are pointers to data.\n\nconsider what happens in a python dictionary if you have a key pointing at a list and then add another key pointing to that same list.\n\nall the variables you are using are really just keys in a dict.", "id": "c8wzxcy", "owner_tier": 0.5, "score": -2.1739130302663674e-10}, {"content": "I just spent 45 minutes trying to copy a 2D array thinking it should be a freaking cakewalk and knowing that somebody somewhere 10 years ago once spent a full day on it makes me feel better. Thank you", "id": "ipfl7d9", "owner_tier": 0.1, "score": -2.1739130302663674e-10}], "link": "https://www.reddit.com/r/learnpython/comments/1afldr/why_is_copying_a_list_so_damn_difficult_in_python/", "question": {"content": "I am sure there is a reason for this design in Python but why is it so difficult to clone a list?  Copying a variable is easy\n\n    foo = 1\n    bar = foo\n    bar = 2\n    print bar # returns 2\n    print foo # returns 1\n\nBut trying to do the same thing, which is what makes sense in my mind coming from other languages, does not work.  You have to add the list splice otherwise it doesn't work.  \n\nThen I spent a day trying to figure out how to copy a 2d list and that was even more frustrating.  I had the following code and none of these worked to properly copy a list without modifying the original.\n\n    foo = [[1,2], [3,4], [5,6]]\n    bar = foo # doesnt work\n    bar = foo[:] # doesnt work\n    bar = list(foo) # doesnt work\n    bar = list(foo[:]) # doesnt work\n    bar = []\n    bar += foo # doesnt work\n    bar = []\n    bar.append(foo) # doesnt work\n    for i, x in enumerate(foo):\n        bar[i] = x[:]\n    # didnt work\n\nI am sure I tried a few more methods and none of them worked.  It was finally this method that was the only way I could find to copy a 2d list, modify the new one without affecting the original list\n\n    bar = [x[:] for x in foo]\n\nSo why is copying a list in python just so hard?  \n", "id": "1afldr", "title": "Why is copying a list so damn difficult in python?", "traffic_rate": 153.1714814814815}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": ">Does Python just have multiple ways to copy a list in the same way??? \n\nAlthough most of the approaches mentioned can be used to copy lists, that doesn't mean that's what they're for! Every operation has a different purpose:\n\n> 1. Using the slicing technique \n\nThe purpose of slicing is to select an arbitrary subset of a list. Slices can be used to either obtain a copy of this subset, or to modify the selected subset. For example:\n\n    foo = [1, 2, 3, 4, 5]\n    print(foo[1:3])   # will print: [2, 3]\n\n    foo[1:3] = ['a', 'b', 'c', 'd']\n    print(foo)        # will print: [1, a, b, c, d, 4, 5]\n  \n \n> 2. Using the extend() method \n\nThe purpose of extend is to add a whole other collection of items onto the end of an existing list. Although slicing can be used for this too, .extend() is less error prone since you don't have to worry about calculating the correct indexes.\n\n\n> 3. List copy using =(assignment operator)\n\nGeeksforgeeks is wrong here. The = operator doesn't make a copy. Rather, you simply have two different variables refer to the exact same list. \n\n\n> 4. Using the method of Shallow Copy \n\nPython's copy module wasn't made for lists. The copy() and deepcopy() functions are able to make copies of **any** arbitrary Python object. For example:\n\n    from copy import copy\n\n    class Person:\n\n        def __init__(self, fname, lname):\n            self.first_name = fname\n            self.last_name = lname\n\n        def print_greeting(self):\n            print(f\"Hello! My name is {self.first_name} {self.last_name}.\")\n\n\n    foo = Person(\"Jack\", \"Johnson\")\n    foo.print_greeting()  # Will print: Hello! My name is Jack Johnson.\n\n    bar = copy(foo)\n    bar.print_greeting()  # Will print: Hello! My name is Jack Johnson.\n\n    foo.first_name = \"John\"\n    foo.last_name = \"Jackson\"\n   \n    foo.print_greeting()   # Will print: Hello! My name is John Jackson\n    bar.print_greeting()   # Will print: Hello! My name is Jack Johnson\n\n\nAs you see, the copy operation actually made a copy of our Person object. The fact that it works for lists is just a consequence, but that doesn't make it *the* way of copying lists.\n\n>5. Using list comprehension \n\nList comprehensions are for constructing a new list based on the data in existing collections. Basically, they're meant to be a concise way to compose map() and filter() operations. You can also use it to quickly construct the cartesian product of multiple collections.\n\n>6. Using the append() method \n\nThe append operation is simply for adding a single item onto a list. Nothing more. Manually writing your own for-loop to append items one by one is perhaps the most clucky & verbose way to copy a list. \n\n>7. Using the copy() method \n\nThis is the only operation whose specific purpose is to copy a Python list. It's finely tuned just for that. Thus, it'll offer you the best performance. \n\n>8. Using the method of Deep Copy \n\nSee #4. The deepcopy() function can make a copy of any arbitrary object, not just a list. \n\n>9. The list() function (not mentioned on geeksforgeeks).\n\nThis is simply the list class constructor. Since 'list' is a class, it has to have a constructor, so might as well make it useful. It can accept any arbitrary collection - a set, a dictionary, a generator, a custom collection class, basically any object that has \\_\\_iter\\_\\_ defined on it. It uses the iterator interface to copy each item one by one into the new Python list.\n\nI am so glad that all those methods weren't actually meant for copying a list TT And apparently, I shouldn't trust G4G the way I was doing before. \n\n>The copy() and deepcopy() functions are able to make copies of any arbitrary Python object\n\nYou mentioned how copy() and deepcopy() weren't just meant for lists but for any arbitrary Python object, which I guess means every Python object??? But if that is the case, choosing when to use what gets a bit more complicated. Because from what I understand you use deepcopy() when dealing with compound objects of mutable datatypes, right? so, I can use copy() for \\[1, 2, 3, 4\\], but should use deepcopy() for \\[1, 2, \\[3, 4\\]\\].\n\nbut when talking about dictionaries you are dealing with keys that need to be of an immutable datatype, but you can only use a tuple if all the elements inside of it are also immutable. and I guess frozensets would be allowed as well. but dictionary values can be of any datatype. So, when dealing with a basic dictionary, would copy() be okay? or should you always use deepcopy() on dictionaries? or does that change according to the datatype of the values?\n\nAnd what about sets? I guess sets wouldn't need deepcopy(), right? because even though sets are mutable, set values must always be of an immutabel type. So, that's like a list with a bunch of integers or strings. \n\nAnd tuples are immutable, but their values can be of a mutable datatype.\n\nSo, what I am trying to say is, I understand what the conditions are for lists when choosing to use copy() or deepcopy(), but what are those conditions when dealing with dictionaries, tuples and sets?\n\nYour daily reminder that GeeksForGeeks is a garbage-quality site that does not verify if what they post is correct or not. I've sent them an email regarding this specific issue, but you should never trust G4G.\n\nYou're really overthinking copy() vs. deepcopy().\n\nUse copy() if you want a copy of an existing data structure, without copying the items within it. \n\nUse deepcopy() if you want to recursively copy both the data structure and all the data contained within.\n\nDictionary keys and set items don't necessarily have to be immutable. The important thing is that each item's hash code doesn't change, and also that for any two items x and y in the set, whether x == y is true or false doesn't change.\n\nGoing back to the Person example from before:\n\n    from copy import copy, deepcopy\n\n    class Person:\n\n        def __init__(self, fname, lname):\n            self.first_name = fname\n            self.last_name = lname\n\n        def __repr__(self):\n            return self.first_name + \" \" + self.last_name\n\n\n    anderson = Person(\"Alice\", \"Anderson\")\n    baker = Person(\"Bob\", \"Baker\")\n    cooper = Person(\"Charles\", \"Cooper\")\n    danvers = Person(\"Debby\", \"Danvers\")\n    ellison = Person(\"Eve\", \"Ellison\")\n\n    red_team = {anderson, baker, cooper}\n\n    # Example 1) The = operator doesn't copy anything.\n    # crimson_team and red_team refer to the exact same set.\n\n    crimson_team = red_team\n    crimson_team.add(danvers)\n\n    print(crimson_team)     # Will print: {Charles Cooper, Alice Anderson, Bob Baker, Debby Danvers}\n    print(red_team)         # Will print: {Charles Cooper, Alice Anderson, Bob Baker, Debby Danvers}\n                            # Notice that Danvers appears in both.\n                            \n                            \n    # Example 2) copy() creates a shallow copy only.\n\n    green_team = copy(red_team)\n    green_team.add(ellison)\n\n    print(red_team)     # Will print: {Charles Cooper, Alice Anderson, Bob Baker, Debby Danvers}\n    print(green_team)   # Will print: {Debby Danvers, Eve Ellison, Charles Cooper, Alice Anderson, Bob Baker}\n                        # Notice that Ellison only appears in green_team.\n                        \n    # If we change Baker's name from Bob to Bill, however:\n    baker.first_name = \"Billy\"\n\n    print(red_team)         # Will print: {Charles Cooper, Alice Anderson, Billy Baker, Debby Danvers}\n    print(crimson_team)     # Will print: {Charles Cooper, Alice Anderson, Billy Baker, Debby Danvers}\n    print(green_team)       # Will print: {Debby Danvers, Eve Ellison, Charles Cooper, Alice Anderson, Billy Baker}\n                            # Notice his name has changed across *all* sets.\n                            \n                            \n    # Example 3) deepcopy() will make copies of the people too.\n\n    blue_team = deepcopy(red_team)\n\n    anderson.first_name = \"Amanda\"\n\n    print(red_team)     # Will print: {Charles Cooper, Amanda Anderson, Billy Baker, Debby Danvers}\n    print(blue_team)    # Will print: {Billy Baker, Debby Danvers, Charles Cooper, Alice Anderson}\n                        # Notice that blue_team kept Anderson's old name, Alice.\n\nG4G is like what w3schools was circa 10-15 years ago, where they have good articles mixed in with garbage ones. \n\nw3schools got much better over time, I think G4G will as well.\n\n>Use copy() if you want a copy of an existing data structure, without copying the items within it.  \n>  \n>Use deepcopy() if you want to recursively copy both the data structure and all the data contained within.\n\nI will keep this in mind then! I guess I can't really think of a situation where I would choose a shallow copy over a deep copy, which is why I wanted to know about when you should use which where. But your example is great! thanks lots!\n\nI wish I shared your optimism. I've contacted them multiple times regarding bad material, and they've never fixed any issues. I was told during one conversation that they don't remove material; even if it's outright wrong. The best they'll do is add a note after the bad material; and even that took them half a year to do.\n\nI won't be happy until there's an equivalent to https://www.w3fools.com/ for G4G.", "id": "iuy0k2s", "owner_tier": 0.7, "score": 0.9999999989999999}, {"content": "I've always assumed that `[:]` making a full copy was a \"happy accident\". They made it so that omitting the first argument results in the start defaulting to the start of the list, and omitting the second argument results in the end defaulting to the end of the list. The consequence then of omitting both is that the entire list is copied.\n\n***\n\nAnd I posted this in another comment, but **do not use G4G**. Their \"articles\" contain a lot of misinformation; as is the case here. The section on `=` is nonsense. They seemed to have tried to \"correct\" it by writing\n\n> Note: There is an issue with this method if you modify in the new list then the old list is also modified due to the new list is referencing \n\nBut that just shows that they don't understand what \"copy\" even means.\n\nI never even thought of using slicing in that way before I researched this. \n\nI actually though that when you assign a variable to a slice of a list, that that variable would just refer to the same object, but only a certain amount of the variables inside of that object. so, I thought that a slice of a list would have the same id as the list itself. but apparently a whole new object is created. Which makes using slicing as a copy method make so much sense now.\n\nalso, I saw your comment! thanks for letting me know! I often went for G4G because it explained these concept in a very easy way, which I appreciated a lot as a beginner. but I appreciate factual articles more, so I guess I'll have to be more careful when reading those articles.\n\nThe word I think you're looking for how you thought slices work is a \"view\". No, slices don't create a view. `islice` can kind of be used for that purpose.\n\nAnd yes, they have the odd good article, and their stuff is very simply explained, but with that, a lot is wrong. Also avoid askpython.com. They're even worse, and are growing in search results unfortunately.", "id": "iuybnhs", "owner_tier": 0.9, "score": 0.399999999}, {"content": "You might be overthinking it. \n\nAnything that does not specify deep copy, is most likely shallow copy. \n\nMany functions are written for many different purposes, and shallow copy might just be one of their unintended use when you ask it to do nothing.  Their speed depends on their actual code/implementation/weird interaction with interpreter etc, and how optimized they are, but they are generally in the same realm and usually not worth worrying about.", "id": "iuxvxrs", "owner_tier": 0.5, "score": -9.99999993922529e-10}], "link": "https://www.reddit.com/r/AskProgramming/comments/ylc4o8/why_choose_to_copy_a_list_with_slices_instead_of/", "question": {"content": "Hi there! beginner Python programmer here\\~\n\nI've been thinking more and more about what Python is doing in the background because I've noticed that it improves the way I think of writing programs. And because I had to copy a list in one of my school assignments, I got curious about what the best way to go about it is. \n\nI looked it up and got a bunch of articles explaining about copy() and deepcopy() in detail, explaining how deepcopy is used when dealing with lists with mutable elements, etc. So, I guess I understand what those two are doing to an extent. \n\nHowever, when it comes to copying a list with slicing (cloning) or by using list(), all I've been able to find is that cloning is much faster because it just copies a piece of memory onto a new location, and with list() the function needs to be called first. That I understand. But when would I want to use the one method over the other? Or when would I rather use list() instead of copy()?? does list() copy shallow or deep??? would I only want to use cloning when my goal is speed? does one use up more memory than the other? Those are questions that pop into my head.\n\nAnd it doesn't stop there because I found this one article ( [Python | Cloning or Copying a list - GeeksforGeeks](https://www.geeksforgeeks.org/python-cloning-copying-list/) ) that explains FIVE other ways to copy a list... Does Python just have multiple ways to copy a list in the same way??? or is it because Python language updates that caused there to be overlap?? Or does every technique have a specific purpose/result, even if the difference might be slight?? \n\nI have also found a few articles that might have discussed this in greater detail, but they were just too complicated for me to understand. I have only been doing this for a few weeks", "id": "ylc4o8", "title": "Why choose to copy a list with slices instead of copy(), deepcopy(), or list()??", "traffic_rate": 28.040370751802264}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "reddit"}, {"answers": [{"content": "\r\n    The error is caused by a problem within the rsync program:\nQuote:23 Partial transfer due to error.\r\nSee rsync(1) - Linux man page[^]\r\n", "id": "2_5293376_1", "owner_tier": 0.7, "score": 0}], "link": "https://www.codeproject.com/Questions/5293367/How-to-copy-the-data-b-w-two-paths-using-ctypes", "question": {"content": "\n\n\r\npractice.c\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nchar *transfer(char *f1, char *f2){\r\n    char cmd[500];\r\n    sprintf(cmd, \"rsync -av %s %s\", f1, f2);\r\n    system(cmd);\r\n}\r\n\r\nint main(void){\r\n    transfer(\"/home/bilal/Pictures/New\", \"/home/bilal/Music\");\r\n    return 0;\r\n}\r\n\r\npractice.py\r\n\r\nfrom ctypes import cdll\r\n\r\ntransfer = cdll.LoadLibrary(\"/Path/to/practice.so\")\r\ntransfer.transfer(\"/home/bilal/Pictures/New\", \"/home/bilal/Music\")\r\n\r\nError\r\nrsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1330) [sender=3.2.3]\r\nsent 26,209,993 bytes  received 92,218 bytes  3,506,961.47 bytes/sec\r\ntotal size is 140,764,280,507,967  speedup is 5,351,804.09\n\nWhat I have tried:\n\r\nIn this code, I am trying to copy the data from the first path to the second path and I am using ctypes to call the C file in python but when I run the Python code, it gives me so many lines of error. I don't know what is the problem with it and I am just pasting some lines of error. I hope you will understand.\r\n\t\t    ", "id": "5293367", "title": "How to copy the data b/w two paths using ctypes?", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["C", "Python"]}, {"answers": [{"content": "\r\n    Please, follow these links:\nPython PyQt clipboard example - Python[^], \npython - PyQt clipboard doesn't copy to system clipboard - Stack Overflow[^]\nPyQt5 - QClipboard[^]\r\n", "id": "2_5315509_1", "owner_tier": 0.5, "score": 5.0}], "link": "https://www.codeproject.com/Questions/5315504/How-do-I-copy-text-to-clipboard-in-pyqt6", "question": {"content": "\n\n\r\nHow do i copy text to clipboard in pyqt6\r\ni want to copy a text in line edit on clicking a button\n\nWhat I have tried:\n\nPython\n\r\ncb = QApplication.clipboard()\r\n        cb.clear(mode=cb.Clipboard())\r\n        cb.setText(self.blogurl.text(), mode=cb.Clipboard()) \r\ni have tried this code but it is showing error :\n\n\r\nAttributeError: 'QClipboard' object has no attribute 'Clipboard'\n", "id": "5315504", "title": "How do I copy text to clipboard in pyqt6", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["Python", "PyQt"]}, {"answers": [{"content": "\r\n    Um...the child class EditCollectionGroupViewModel derives from the parent CollectionGroupViewModel class - so it already contains all the properties for the parent.\n\r\nYou don't need to copy values, unless you are trying to create a new child based on the parent. In that case, I'd create a child constructor which accepted a parent as the parameter and copied the values.\n\nC#\n\r\npublic EditCollectionGroupViewModel(CollectionGroupViewModel parent)\r\n   {\r\n   TenantID = parent.TenantID; \r\n   ...\r\n   }But a better way would be to create an instance of teh child class in teh first place instead of the parent:\nC#\n\r\nfor (int i = 0; i < 10; i++)\r\n{\r\n    CollectionGroupViewModel model = new EditCollectionGroupViewModel();\r\n\r\n    model.TenantID = i + 1000;\r\n    model.Market = \"UK\";\r\n    model.GroupName = \"Collection Group 1\";\r\n    model.GTS = \"yes\";\r\n    model.ProcessingCenter = \"Processing Centre 1\";\r\n\r\n    modelList.Add(model);\r\n}\r\n\n", "id": "2_831621_1", "owner_tier": 0.9, "score": 1.0}], "link": "https://www.codeproject.com/Questions/831616/how-to-copy-parent-object-to-child-object", "question": {"content": "\r\n\t\t\t    hi friends,\r\nI have below model structure\nC#\n\r\npublic class CollectionGroupViewModel\r\n{\r\n        public int TenantID { get; set; }\r\n\r\n        public string Market { get; set; }\r\n\r\n        public string GroupName { get; set; }\r\n\r\n        public string GTS { get; set; }\r\n\r\n        public string ProcessingCenter { get; set; }\r\n\r\n}\r\n\r\npublic class EditCollectionGroupViewModel : CollectionGroupViewModel\r\n{\r\n        public IList<SelectListItem> ProcessingCenter { get; set; }\r\n}\r\nI have class to create Mock data as follows:\nXML\n\r\npublic static List<CollectionGroupViewModel> GetCollectionGroupViewList()\r\n        {\r\n            List<CollectionGroupViewModel> modelList = new List<CollectionGroupViewModel>();\r\n\r\n            for (int i = 0; i < 10; i++)\r\n            {\r\n                CollectionGroupViewModel model = new CollectionGroupViewModel();\r\n\r\n                model.TenantID = i + 1000;\r\n                model.Market = \"UK\";\r\n                model.GroupName = \"Collection Group 1\";\r\n                model.GTS = \"yes\";\r\n                model.ProcessingCenter = \"Processing Centre 1\";\r\n\r\n                modelList.Add(model);\r\n            }\r\n\r\n            return modelList;\r\n        }\r\n\r\n        public static CollectionGroupViewModel GetEditCollectionGroupViewModel(int tenantID)\r\n        {\r\n            List<CollectionGroupViewModel> modelList = GetCollectionGroupViewList();\r\n\r\n            EditCollectionGroupViewModel model = modelList.Where(x => x.TenantID == tenantID).Single();\r\n            model.ProcessingCenter = ?;\r\n            return model;\r\n        }\r\nWhat I want is, I want to copy the following properties from the parent class to the child class.\nTenantID, Market, GroupName, GTS\n\r\nAnd I want to edit the following property before sending the result.\nmodel.ProcessingCenter = ?;\n\r\nAny idea how to do it?\n\r\nThanks in advance\r\n\t\t    ", "id": "831616", "title": "how to copy parent object to child object", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["C#3.5"]}, {"answers": [{"content": "\r\n    I gave you the link to the documentation for str types earlier today. Many of the functions return a modified copy, but as you can see there is no specific copy method. But you have not explained where the error occurs.\n\r\n[edit]\r\nTake a look at the documentation at NLTK :: nltk.classify.naivebayes[^]. The classify method calls prob_classify passing in the parameter from your call. One of the next actions is to call copy on that parameter. But the str object does not have a copy method, as already shown. So the conclusion is that you are passing an invalid parameter to classify.\r\n[/edit]\r\n", "id": "2_5340162_2", "owner_tier": 0.7, "score": 0}, {"content": "\r\n    found the solution its\n\n\r\nx2b = input(\"name: \")\r\nprint(classifier.classify(gender_features(x2b)))\n", "id": "2_5340211_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/5340144/Attributeerror-str-object-has-no-attribute-copy-in", "question": {"content": "\r\n\t\t\t    so it's saying the 'str' object has no attribute 'copy. from a normal input are their ways to fix it \r\nand any ways to make my code better\r\nthank you for your time\n\nWhat I have tried:\n\r\nthis is my code\n\n\r\nlines_seen = set() # holds lines already seen\r\n\r\n#check for duplicates\r\nwith open(\"male.txt\", \"r+\") as f:\r\n    d = f.readlines()\r\n    f.seek(0)\r\n    for i in d:\r\n        if i not in lines_seen:\r\n            f.write(i)\r\n            lines_seen.add(i)\r\n    f.truncate()\r\n\r\nwith open(\"female.txt\", \"r+\") as f:\r\n    d = f.readlines()\r\n    f.seek(0)\r\n    for i in d:\r\n        if i not in lines_seen:\r\n            f.write(i)\r\n            lines_seen.add(i)\r\n    f.truncate()\r\n\r\ndef gender_features(word):\r\n\treturn {'last_letter': word[-1]}\r\n\r\n# output : {'last_letter': 'r'}\r\n# importing libraries\r\nimport random\r\nfrom nltk.corpus import names\r\nimport nltk\r\n#nltk.download()\r\n\r\ndef gender_features(word):\r\n\treturn {'last_letter':word[-1]}\r\n\r\n# preparing a list of examples and corresponding class labels.\r\nlabeled_names = ([(name, 'male') for name in names.words('male.txt')]+\r\n\t\t\t[(name, 'female') for name in names.words('female.txt')])\r\n\r\nrandom.shuffle(labeled_names)\r\n\r\n# we use the feature extractor to process the names data.\r\nfeaturesets = [(gender_features(n), gender)\r\n\t\t\tfor (n, gender)in labeled_names]\r\n\r\n# Divide the resulting list of feature\r\n# sets into a training set and a test set.\r\ntrain_set, test_set = featuresets[500:], featuresets[:500]\r\n\r\n# The training set is used to\r\n# train a new \"naive Bayes\" classifier.\r\nclassifier = nltk.NaiveBayesClassifier.train(train_set)\r\nx2b = input(\"name: \")\r\nprint(classifier.classify(x2b))\r\n\r\n# output should be 'male'\r\nprint(nltk.classify.accuracy(classifier, train_set))\r\n\r\n# it shows the accuracy of our classifier and\r\n# train_set. which must be more than 99 %\r\nclassifier.show_most_informative_features(10)\n", "id": "5340144", "title": "Attributeerror: 'str' object has no attribute 'copy' in input nltk Python", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["Python", "errors", "NLTK"]}, {"answers": [{"content": "\r\n    I assume your UPDto and PDto is different types with different properties, in this situation you might need to consider Deep object coping. Following link might help you to do the Deep object copying,\n\nDeep copy of objects in C#[^]\n\r\nHope it helps :)\r\n", "id": "2_233338_1", "owner_tier": 0.3, "score": 5.0}, {"content": "\r\n    Hi Mohammad,\r\n Thanks for your solution. But I believe that is not what I need. The same can\r\nbe acheived through the foreach loop mentioned in the question.\n\r\nclass PDTO\r\n{\r\n public string Prop1{get; set;}\r\n}\r\nclass UPDTO\r\n{\r\n public PDTO oPDTO {get; set;}\r\n}\n\r\nclass MyClass\r\n{\r\n  Method1()\r\n  {\r\n   List<PDTO> oListPDTO = new List<PDTO>();\r\n   List<UPDTO> oListUPDTO = new List<UPDTO>();\n\r\n   foreach (PDTO obj in oListPDTO)\r\n   {\r\n     UPDTO oUPDTO = new UPDTO();\r\n     oUPDTO.oPDTO = obj;\r\n      oListUPDTO.Add(oUPDTO);\r\n   }\r\n  }\r\n}\n\r\nIs there a better way of doing this instead of foreach loop??????\n\n\r\nThanks,\r\nMukesh KV\r\n", "id": "2_233380_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/233331/Copy-list-object-into-object-of-another-list-objec", "question": {"content": "\r\n\t\t\t    Hi all,\r\n I have two list objects, say List<UPDTO>  and List<PDTO>\n\r\nclass PDTO\r\n{\r\n public string Prop1{get; set;}\r\n}\n\r\nclass UPDTO\r\n{\r\n public PDTO oPDTO {get; set;}\r\n}\n\n\r\nI have data in  List<PDTO>. And I want this to get copied to the object (PDTO) that I have in List<UPDTO>. Could you please let me know the solution?\n\r\nWe can do the same like the below:\n\r\nforeach (PDTO oPDTO1 in oListPDTO)\r\n{\r\n    oListUPDTO.Add(new UPDTO() { oPDTO = oPDTO1 });\r\n}\r\nIs there any better way of doing this?\n\n\r\nThanks,\r\nMukesh KV\r\n\t\t    ", "id": "233331", "title": "Copy list object into object of another list object", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["C#", "C#4.0"]}, {"answers": [{"content": "\r\n    I'm not a Python expert so my thoughts might not be exact.\n\r\nYour list() function is returning a reference to the private member. Because the function is a member too, it has access to the array. As a result, the calling side \"sees\" a reference which is it allowed to use and change.\n\r\nDo you know C++? It is similar there:\nC++\n\r\nclass Test {\r\npublic:\r\n    Test(int a = 0) { m_a = a; }\r\n    int& get() { return m_a; }\r\nprivate:\r\n    int m_a;\r\n};\r\n\r\nint main()\r\n{\r\n    Test test(1);\r\n    // Allowed because get() returns a reference\r\n    test.get() = 2;\r\n    // This will print 2\r\n    printf(\"%d\\n\", test.get());\r\n    \r\n    return 0;\r\n}\r\nThe solution is to not return the list at all or return a copy of the list (see Programming FAQ \u2014 Python 3.6.6rc1 documentation: How do I copy an object in Python?[^] ):\nPython\n\r\n# Using slicing\r\nreturn self.__items[:]\r\n# Return a new list\r\nreturn list(self.__items)\r\n# Using copy.copy() or copy.deepcopy()\r\nreturn copy.deepcopy(self.__items)\r\n[EDIT]\r\nThe best solution would be returning a read only reference like with the C++ const keyword. But Python does (and will) not support such due to its design and ideology. \n\r\nWith Python, the caller of such functions is responsible for not doing something \"wrong\" with the returned references. Such should be stated clearly in the documentation for the function.\r\n[/EDIT]\r\n", "id": "2_1249553_2", "owner_tier": 0.5, "score": 2.5}, {"content": "\r\n    See 9. Classes \u2014 Python 3.4.8 documentation: Private Variables[^]. I suggest going to the first page of that tutorial, and working your way through it; a really useful tutorial.\r\n", "id": "2_1249544_1", "owner_tier": 0.7, "score": 1.0}], "link": "https://www.codeproject.com/Questions/1249542/How-do-I-prevent-updates-to-private-data-in-Python", "question": {"content": "\r\n\t\t\t    Simple code in Python2.7 with a \"private\" data item \"items\". I hear there is nothing really one can do in Python to declare an attribute truly \"private\" ... this code manages to change the first elemement of the items list from an instance of Group to a string. Why and how can I stop it / re-code ?? I feel the pain in Python circles when people like me talk about \"private\" , but stick with me please because I'm trying to protect myself here from doing something I \"culturally\" shouldnt be doing - i.e. writing to other classes and instances (as quoted here: class - Does Python have \u201cprivate\u201d variables in classes? - Stack Overflow)\n\n\n\r\nclass Groups():\r\n    \r\n  def __init__(self):\r\n    self.__items = []\r\n  \r\n  def add(self, name, hidden=None, position=None):\r\n    if name not in self.__items:\r\n      if position is None:\r\n        print(\"appending %s\" % name)\r\n        self.__items.append(Group(name=name, hidden=hidden, position=position))\r\n      else:\r\n        print(\"inserting %s\" % name)\r\n        self.__items.insert(position, Group(name=name, hidden=hidden, position=position))\r\n      print('after add, len=',len(self.__items))\r\n  \r\n  def list(self):\r\n    print(\"list():\")\r\n    print \"\".join(\"   item: \"+x.name for x in self.__items)\r\n    return self.__items\r\n\r\ng=Groups()\r\nprint(\"adding ITEM\")\r\ng.add(\"ITEM\")\r\ng.list()\r\nprint(\"changing..\")\r\ng.list()[0]=\"Changed\" \r\ng.list() Should now raise an exception\n\r\nThe list() method is returning items by reference allowing direct access to the list, rather than passing by-value (i.e. a copy of the items). Further, the name mangling __items seems to be innefectual in that I can still modify the data by using list()[0] =\n\r\nBy the way, what I am trying to do here is abstract the implementation of __list. Today it is a simple Python list, tomorrow I might make it a class, but I want to abstract this in the Groups class.\n\r\nI just need some education here me thinks.\n\nWhat I have tried:\n\r\nnothing - not sure what to do as I am learning Python.\r\n\t\t    ", "id": "1249542", "title": "How do I prevent updates to \"private\" data in Python?", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["Python2.7"]}, {"answers": [{"content": "\r\n    In order to copy the text with its styles, you will need to write your own function, as there is no python-docx function that does such a thing. This is the function I wrote:\n\nPython\n\r\ndef get_para_data(output_doc_name, paragraph):\r\n    \"\"\"\r\n    Write the run to the new file and then set its font, bold, alignment, color etc. data.\r\n    \"\"\"\r\n\r\n    output_para = output_doc_name.add_paragraph()\r\n    for run in paragraph.runs:\r\n        output_run = output_para.add_run(run.text)\r\n        # Run's bold data\r\n        output_run.bold = run.bold\r\n        # Run's italic data\r\n        output_run.italic = run.italic\r\n        # Run's underline data\r\n        output_run.underline = run.underline\r\n        # Run's color data\r\n        output_run.font.color.rgb = run.font.color.rgb\r\n        # Run's font data\r\n        output_run.style.name = run.style.name\r\n    # Paragraph's alignment data\r\n    output_para.paragraph_format.alignment = paragraph.paragraph_format.alignment\n\nHow The Function Works\r\n 1. Adds a new paragraph object to the file.\r\n 2. Adds a new run to that paragraph.\r\n 3. Checks whether each of the styles bold, italic and underline is True, False, None. If it's True, the run will be in that style, if it's False, it won't be in that style, and if it's None, it will be inherited by the default style of the paragraph it's in. Then it applies the styles to the run.\r\n 3. Checks what's the color of the run in RGB and applies the found color to the run.\r\n 4. Checks what's the font of the run and applies the found font to the run.\r\n 5. Checks what's the alignment of the run and applies the found alignment setting to the run.\n\n\nHow to Use the Function:\r\nYou need to give it the name you gave your output document and the paragraphs you want to copy. \nFor Example:\n\nPython\n\r\n# Imports\r\n\r\ninput_doc = Document('InputDoc.docx')\r\noutput_doc = Document()\r\n\r\n# Call the function\r\nget_para_data(output_doc, input_doc.paragraphs[3])\r\n\r\n# Save the new file\r\noutput_doc.save('OutputDoc.docx')\nIf you'd like to copy the entire document I suggest you do this:\n\nPython\n\r\nfor para in input_doc.paragraphs:\r\n    get_para_data(output_doc, para)\r\n\r\noutput_doc.save('OutputDoc.docx')\n", "id": "2_1231500_2", "owner_tier": 0.1, "score": 1.0}, {"content": "\r\n    You need to get the style information from the paragraph, see Text-related objects \u2014 python-docx 0.8.6 documentation[^].\r\n", "id": "2_1230785_1", "owner_tier": 0.7, "score": 1.0}, {"content": "\r\n    #clone your document\r\nimport docx\r\nfrom copy import deepcopy\n\r\ndoc1 = docx.Document('original_file.docx')\n\r\ncopy_the_content = deepcopy(doc1)\n\r\ncopy_the_content.save('new_file.docx')\r\n", "id": "2_5306259_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/1230778/How-do-I-copy-the-contents-of-a-word-document", "question": {"content": "\r\n\t\t\t    I want to write a program that copies text from a Word document and pastes it to another. I'm trying to do that using the python-docx library. I was able to do that with the following code, but it does not copy the bold, italic, underlined nor colored parts as they are and only their text:\nPython\n\r\nfrom docx import Document\r\n\r\n\r\ninput = Document('SomeDoc.docx')\r\n\r\nparagraphs = []\r\nfor para in input.paragraphs:\r\n    p = para.text\r\n    paragraphs.append(p)\r\n\r\noutput = Document()\r\nfor item in paragraphs:\r\n    output.add_paragraph(item)\r\noutput.save('OutputDoc.docx')\n\nWhat I have tried:\n\r\nI've tried copying the paragraph object directly into the output document, but it doesn't work either:\nPython\n\r\nfrom docx import Document\r\n\r\n\r\ninput = Document('SomeDoc.docx')\r\noutput = Document()\r\n\r\nfor para in input.paragraphs:\r\n    output.add_paragraph(para)\r\noutput.save('OutputDoc.docx')\n", "id": "1230778", "title": "How do I copy the contents of a word document?", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["MS-Word", "Python3.6"]}, {"answers": [{"content": "\r\n    Let's see:\n\nC#\n\r\nclass A {\r\n   internal A A; // non-private fields is the bad coding style, but this is just for example\r\n   internal Name;\r\n} //A\r\n\r\nA a = new A();\r\nA b = a; // a and b reference the same object:\r\n// if you change a.Name, b.Name will change\r\n\r\nb = a.MemberwiseClone();\r\n// not a and b are distinctly different objects\r\n// they can have different names:\r\na.Name = \"This is a\";\r\nb.Name = \"This is b\"; // different, you can check it up after this statement.\r\n\r\n// Now, how about a.A?\r\n// After cloning, it still references the same object, because A is a reference type:\r\nA a = new A();\r\na.A = new A();\r\na.A.Name = \"inner\";\r\n\r\nb = a.MemberwiseClone();\r\nb.A.Name = \"another inner\";\r\n// it will change a.A.Name! Why?\r\n// because we cloned a, but not a.A\n\r\nNow, look at the last comment in the code sample shown above. It means that cloning is not deep.\r\nSee also:\nhttp://msdn.microsoft.com/en-us/library/system.object.memberwiseclone.aspx[^],\nhttp://msdn.microsoft.com/en-us/library/system.icloneable.aspx[^],\nhttp://en.wikipedia.org/wiki/Clone_%28computing%29[^].\n\r\nFinally, please see my recent answers on deep cloning: How to implement ICloneable for a List Class?[^].\n\n\u2014SA\n", "id": "2_655607_1", "owner_tier": 0.7, "score": 2.5}, {"content": "\r\n    The difference is very straight forward.\n\nDataTable.Clone method clones the structure of the dataTable, including all dataTable schemas and constraints. Not data.\n\nDataTable.Copy method copies both the structure and data.\n\r\nRegards..\r\n", "id": "2_655606_1", "owner_tier": 0.5, "score": 1.165}, {"content": "\r\n    visit here to understand more...\n\nhttp://www.dotnetfunda.com/forums/thread7557-difference-between-dataset-clone-dataset-copy.aspx[^]\r\n", "id": "2_655621_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    \"Both the Copy and the Clone methods create a new DataTable with the same structure as the original DataTable. The new DataTable created by the Copy method has the same set of DataRows as the original table, but the new DataTable created by the Clone method does not contain any DataRows.\"\n\r\nFrom DataTable.Clone Method documentation. In summary, Clone method creates a new DataTable with same structure and constraints but without data and Copy method does same but includes data too.\n\nhttp://social.msdn.microsoft.com/Forums/vstudio/en-US/10d99d29-2851-4f12-84b6-d95e08c13bf4/whats-the-difference-between-clone-and-a-copy[^]\n\n\nhttp://stackoverflow.com/questions/198496/difference-between-the-system-array-copyto-and-system-array-clone[^]\r\nThis is ther main difference\n\n\n\n\r\n1- CopyTo require to have a destination array when Clone return a new array.<br />\r\n2- CopyTo let you specify an index (if required) to the destination array.\n\r\nI think you will find difference now....:)\r\n", "id": "2_655645_2", "owner_tier": 0.1, "score": 0}], "link": "https://www.codeproject.com/Questions/655602/Difference-between-Clone-and-Copy-method", "question": {"content": "\r\n\t\t\t    Both the Copy and the Clone methods create a new DataTable with the same structure as the original DataTable.\r\nClone method can not create datarow but Copy method create both structure and datarow. Why should we use Clone method instead of Copy method. please explain me. Advance thanks for helping me.\r\n\t\t    ", "id": "655602", "title": "Difference between Clone and Copy method", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["ASP.NET"]}, {"answers": [{"content": "\r\n    Whether you are calling a default copy constructor or assignment operator the compiler can only create a shallow copy by default. A shallow copy means that each member of the class is copied individually using the assignment operator for that member.  This is important in the case of pointers because the pointer is copied but what it points to is not. If memory has been allocated and used this creates a problem.\n\nC++\n\r\n#include <string>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n// Use pointer to memory for string\r\nclass myClass \r\n{\r\npublic:\r\n\tmyClass(const char *cstring) { mystring = new char[30]; strcpy(mystring, cstring);};\r\n\tmyClass() : mystring(NULL) {};\r\n\t~myClass() {delete [] mystring;};\r\n\r\n\tchar *mystring;\r\n};\r\n\r\n// Use std::string class\r\nclass myClass2 \r\n{\r\npublic:\r\n\tmyClass2(const char *cstring) { mystring = cstring;};\r\n\tmyClass2() : mystring(\"\") {};\r\n\t~myClass2() {};\r\n\r\n\tstring mystring;\r\n};\r\n\r\nint main()\r\n{\r\n\r\nmyClass c1(\"Welcome\");\r\nmyClass  c2;\r\nc2 = c1; \r\n// Shallow copy - c2::mystring pointer is assigned same value as c1::mystring \r\n// pointer so points to same memory - DANGER\r\n// This is deceptive if you examine c1 and c2 in the debugger because they both seem\r\n// to contain \"Welcome\" - not so - they both have a pointer which points to the same\r\n// memory.\r\n\r\n// This must be carefully managed. For example:\r\n//#define TEST\r\n#ifdef TEST\r\nmyClass *pc2 = new myClass;\r\n*pc2 = c1;\r\n\r\ncout << c1.mystring << endl; // All good.\r\ncout << pc2->mystring << endl; // All good.\r\ndelete pc2;\r\ncout << c1.mystring << endl; // Problem - why?\r\n// Consequence of shallow copy.\r\n#endif\r\n\r\nmyClass c1a(\"Welcome\");\r\nmyClass  c2a = c1a; // Same as above - different construct same result.\r\n\r\n\r\n// Now using myClass2\r\nmyClass2 c1_2(\"Welcome\");\r\nmyClass2  c2_2;\r\nc2_2 = c1_2; \r\n// Shallow copy - but c2::mystring is now a copy of c1::mystring because\r\n// of assignment operator for std::string.\r\n\r\n// Now\r\n//#define TEST2\r\n#ifdef TEST2\r\nmyClass2 *pc2_2 = new myClass2;\r\n*pc2_2 = c1_2;\r\n\r\ncout << c1_2.mystring << endl; // All good.\r\ncout << pc2_2->mystring << endl; // All good.\r\ndelete pc2_2;\r\ncout << c1_2.mystring << endl; // No Problem.\r\n#endif\r\n\r\n\r\n return 0;\r\n }\n\r\nThis is a very good expose:\nhttp://www.learncpp.com/cpp-tutorial/912-shallow-vs-deep-copying/[^]\r\n", "id": "2_743892_8", "owner_tier": 0.1, "score": 1.5}, {"content": "\r\n    Consider the following C++ program.\nC++\n\r\n#include<iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nclass Test\r\n{\r\npublic:\r\n   Test() {}\r\n   Test(const Test &t)\r\n   {\r\n      cout<<\"Copy constructor called \"<<endl;\r\n   }\r\n   Test& operator = (const Test &t)\r\n   {\r\n      cout<<\"Assignment operator called \"<<endl;\r\n   }\r\n};\r\nint main()\r\n{\r\n  Test t1, t2;\r\n  t2 = t1;\r\n  Test t3 = t1;\r\n  getchar();\r\n  return 0;\r\n}\r\nOutput:\n \n\r\nAssignment operator called\r\nCopy constructor called\r\nCopy constructor is called when a new object\r\nis created from an existing object, as a copy\r\nof the existing object (see this G-Fact). And\r\nassignment operator is called when an\r\nalready initialized object is assigned a new\r\nvalue from another existing object.\nC++\n\r\nt2 = t1;  // calls assignment operator, same as \"t2.operator=(t1);\"\r\nTest t3 = t1;  // calls copy constructor, same as \"Test t3(t1);\"\n", "id": "2_743831_2", "owner_tier": 0.1, "score": 1.5}], "link": "https://www.codeproject.com/Questions/743830/Confusion-in-Copy-Constructor-and-assignment-opera", "question": {"content": "\r\n\t\t\t    I am now tired but still not able to understand Copy constructor and assignment operator clearly.\r\nAnd at last, i am here, in one of my best site, in a hope that i'll clear all my concepts.\n\r\nNow coming to the point, i know default copy constructor do shallow copying but when we copy object using assignment operator then will it become a deep copy...???\n\r\nLet us suppose, we have a class, MyClass and a constructor is defined in it without any argument, and main is coded as:\n\nC++\n\r\nMyClass c1(\"Welcome\");\r\nMyClass  c2;\r\nc2 = c1;\n\r\nSo, the 3rd line \"c1=c2\" is deep copy??\r\nAnd if it is also a shallow copy that what's the difference between this \"c2=c1\" and \"MyClass c2(c1)\"(Simple copy constructor).\n\r\nAnd what will happen if i'll edit it as:\nC++\n\r\nMyClass c1(\"Welcome\");\r\nMyClass  c2 = c1;\n\r\nThanks in advance...:-)\r\n\t\t    ", "id": "743830", "title": "Confusion in Copy Constructor and assignment operator", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["C++"]}, {"answers": [{"content": "\r\n    You probably want to clone your original list instead\n\nHow do I clone a generic list in C#? - Stack Overflow[^]\r\n", "id": "2_1239160_1", "owner_tier": 0.5, "score": 3.0}, {"content": "\r\n    You could create a copy constructor in your object that accepts an object of the same type:\n\n\n\r\npublic MyObject(MyObject obj)\r\n{\r\n    this.Property1 = obj.Property1;\r\n    this.Property2 = obj.Property2;\r\n    ...\r\n}\n\r\nAnd then do this when you want to copy it:\n\n\n\r\nList<MyObject> list2 = list1.ConvertAll(x => new MyObject(x));\n\r\nOR inherit ICloneable, and \n\nC#\n\r\npublic class MyObject : ICloneable<MyObject>\r\n{\r\n    public MyObject Clone()\r\n    {\r\n        return new MyObject{ /* set properties */ };\r\n    }\r\n}\n\r\nAnd do this:\n\n\n\r\nList<MyObject> list2 = list1.ConvertAll(x => x.Clone());\n\r\nOR\n\r\nYou could serialize the existing objects into a stream and deserialize them back into a new list of objects.\r\n", "id": "2_1239162_1", "owner_tier": 0.7, "score": 2.0}, {"content": "\r\n    Make it a structure instead of a class or Create a clone method within your class and Return this.MemeberwiseClone;\r\n", "id": "2_5324918_1", "owner_tier": 0.1, "score": 0.3333333333333333}], "link": "https://www.codeproject.com/Questions/1239153/Csharp-copy-list-of-objects-without-reference", "question": {"content": "\r\n\t\t\t    Hello, \n\r\nMy problem is about the copy of object without reference.\n\nWhat I have tried:\n\r\nI try to copy a list of object like this :\nC#\n\r\nList<MyObject> myNewList = new List<MyObject>(myOldList);\n\r\nThe problem is that my new list reference the older list. \n\r\nHere is my object \"MyObject\" :\n\nC#\n\r\n/// <summary>\r\n    /// Model to represent a trip.\r\n    /// </summary>\r\n    [Serializable]\r\n    public class TripModel : BaseModel, IEquatable<TripModel>, IComparableModel\r\n    {\r\n        /// <summary>\r\n        /// Initialises a new instance of the <see cref=\"TripModel\" /> class.\r\n        /// </summary>\r\n        public TripModel()\r\n        {\r\n            this.PropertyBags = new SimpleSerializableDictionary<string, string>();\r\n            this.TripPlans = new SimpleSerializableDictionary<TripEnums.TripPlanType, TripPlanModel>();\r\n            this.PreviewMode = GeneralEnums.PreviewMode.Unchanged;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the direction of the trip.\r\n        /// </summary>\r\n        public TripEnums.TripDirection Direction\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the instantiation mode of the trip.\r\n        /// </summary>\r\n        public TripEnums.TripInstantiationMode InstantiationMode\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the number of the next trip.\r\n        /// </summary>\r\n        public int NextTripNumber\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the number of the previous trip.\r\n        /// </summary>\r\n        public int PreviousTripNumber\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the property bags of the trip.\r\n        /// </summary>\r\n        public SimpleSerializableDictionary<string, string> PropertyBags\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the service ID of the trip.\r\n        /// </summary>\r\n        public string ServiceId\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the state of the trip.\r\n        /// </summary>\r\n        public TripEnums.TripState State\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the ID of the trip.\r\n        /// </summary>\r\n        public string TripId\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the number of the trip.\r\n        /// </summary>\r\n        public int TripNumber\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        public GeneralEnums.PreviewMode PreviewMode\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets or sets the trip plans of the trip.\r\n        /// </summary>\r\n        public SimpleSerializableDictionary<TripEnums.TripPlanType, TripPlanModel> TripPlans\r\n        {\r\n            get;\r\n            set;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Indicates whether the current object is equal to another object of the same type.\r\n        /// </summary>\r\n        /// <param name=\"other\">An object to compare with this object.</param>\r\n        /// <returns>Returns true if the two objects are equal false otherwise.</returns>\r\n        public bool Equals(TripModel other)\r\n        {\r\n            if (other == null)\r\n            {\r\n                return false;\r\n            }\r\n\r\n            return this.TripNumber == other.TripNumber\r\n                   && this.ServiceId == other.ServiceId\r\n                   && this.TripId == other.TripId\r\n                   && this.Direction == other.Direction\r\n                   && this.State == other.State\r\n                   && this.InstantiationMode == other.InstantiationMode\r\n                   && this.PreviousTripNumber == other.PreviousTripNumber\r\n                   && this.NextTripNumber == other.NextTripNumber\r\n                   && object.Equals(this.PropertyBags, other.PropertyBags)\r\n                   && object.Equals(this.TripPlans, other.TripPlans);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Determines whether the specified System.Object is equal to the current System.Object.\r\n        /// </summary>\r\n        /// <param name=\"obj\">The System.Object to compare with the current System.Object.</param>\r\n        /// <returns>Returns true if the two objects are equal false otherwise.</returns>\r\n        public override bool Equals(object obj)\r\n        {\r\n            return obj != null && this.Equals(obj as TripModel);\r\n        }\r\n\r\n        /// <summary>\r\n        /// Serves as a hash function for <see cref=\"TripModel\" />.\r\n        /// </summary>\r\n        /// <returns>A hash code for the current <see cref=\"TripModel\" />.</returns>\r\n        public override int GetHashCode()\r\n        {\r\n            return\r\n                new\r\n                {\r\n                    this.TripNumber,\r\n                    this.ServiceId,\r\n                    this.TripId,\r\n                    this.Direction,\r\n                    this.State,\r\n                    this.InstantiationMode,\r\n                    this.PreviousTripNumber,\r\n                    this.NextTripNumber,\r\n                    this.PropertyBags,\r\n                    this.TripPlans\r\n                }.GetHashCode();\r\n        }\r\n\r\n        /// <summary>\r\n        /// Adds an information to the object indicating \r\n        /// if the object has been updated, deleted, inserted\r\n        /// or unchanged.\r\n        /// </summary>\r\n        /// <param name=\"previewMode\"></param>\r\n        public void AddModification(GeneralEnums.PreviewMode previewMode)\r\n        {\r\n            this.PreviewMode = previewMode;\r\n        }\r\n\r\n\r\n    }\n\n\r\nThank you for your help...\r\n\t\t    ", "id": "1239153", "title": "C# copy list of objects without reference", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:42:48 GMT", "source": "codeproject", "tags": ["C#"]}]}