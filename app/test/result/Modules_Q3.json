{"result": [{"answers": [], "link": "https://stackoverflow.com/questions/744373/what-happens-when-using-mutual-or-circular-cyclic-imports", "question": {"content": "In Python, what happens when two modules attempt to import each other? More generally, what happens if multiple modules attempt to import in a cycle? See also What can I do about \"ImportError: Cannot import name X\" or \"AttributeError: ... (most likely due to a circular import)\"? for the common problem that may result, and advice on how to rewrite code to avoid such imports. See Why do circular imports seemingly work further up in the call stack but then raise an ImportError further down? for technical details on why and how the problem occurs.", "id": 744373, "title": "What happens when using mutual or circular (cyclic) imports?", "traffic_rate": 80}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "python-import", "circular-dependency", "cyclic-reference"]}, {"answers": [], "link": "https://stackoverflow.com/questions/74020217/how-can-i-have-two-modules-interact-with-each-other-without-having-a-circular-im", "question": {"content": "I am making a small game with several files including : Entity.py , Map.py. I want Map to be able to manage an Entity position, so I have to import Entity in Map, but I also want Entity to be able to know the map on which it is, so I have to import Map in Entity. Obviously this leads to circular imports, and I know a lot of answers to this problem is \"You just have to modify your design pattern\" and ofc I could do that, but I want to know if there is a way in python to have this kind of structure that I got used to be able to use in Java.", "id": 74020217, "title": "How can I have two modules interact with each other without having a circular import on Python?", "traffic_rate": 0}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "circular-dependency"]}, {"answers": [], "link": "https://stackoverflow.com/questions/70805354/how-to-setup-imports-and-dependencies-between-modules-in-the-same-python-package", "question": {"content": "I am writing a library in python. It has one package and 3 modules, such as If I just leave the __init__.py empty, my users must figure out which functions are in which modules, which is annoying. The fact that I have three modules is an implementation detail that is not important. Maybe I should import the main functions into the __init__.py, like this so that my users can just do Is that best practice? What about the alternative to put ALL symbols into the __init__.py, such as And if there are any functions that I don't want to expose, I will prefix them with underscore. Is that better?  It certainly is easier for me. What if the fileio.py needs to call some functions in the utils.py?  I could put into the fileio.py, but won't that create a circular or redundant reference? What's the best way to handle this?", "id": 70805354, "title": "How to setup imports and dependencies between modules in the same python package", "traffic_rate": 1370}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "module", "package"]}, {"answers": [], "link": "https://stackoverflow.com/questions/28800006/python-import-of-modules-with-mutual-dependency", "question": {"content": "I have two files rest_api.py and Contact.py. Contact is similar to a domain object (contains Contact class), while rest_api has functions for setting up the application. In rest_api I have the following lines: In Contact I try to do the following: This fails with the following error:\nImportError: cannot import name Contact What is the correct way of importing contact, so that it can also use variables/functions from rest_api? p.s If I move the collection code to a different file, and import that file instead things work, but I assume there is some other way..", "id": 28800006, "title": "Python: import of Modules with mutual dependency", "traffic_rate": 0}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python"]}, {"answers": [], "link": "https://stackoverflow.com/questions/59977711/python-import-module-which-need-to-import-other-module", "question": {"content": "I made a module that makes a linear regression model and draws a graph.\nSo the module needs to import some packages such as sklearn and matplotlib.\nAnd I want to import this module to another python file and use it. I think either of the two python files needs to import the above packages..\nwhich of them needs to import? In below case, my_module.py should import LinearRegression? or my_module2.py should? ex)", "id": 59977711, "title": "Python - Import module which need to import other module", "traffic_rate": 78}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "import", "module"]}, {"answers": [], "link": "https://stackoverflow.com/questions/44538400/how-do-i-import-files-that-mutually-import-each-other", "question": {"content": "how do i import a function and a dictionary that mutually imports each other. These two files are already in the same directory thus, there is no nid to import sys. Also, i this it is recursive that is why it is unable to import. How do i import a dictionary from each other's file without making it recursive and causing an error? I did go to this website here but it did not answer my question nor did it provide any example code to guide me thus, i created this question with a test code to explain my issue. let's say i have these two files: boxA and boxR, each has a dictionary keyA and keyR and functions named generatekeyA and generatekeyR in boxA: in boxR: Let me explain the codes above. I have 2 files that generate keys for me after which, i have to export the output into a json file. output.json file prints out keyA's own serial no and secret id and only keyR's secretid and viceversa into output2.json file. but the thing is that eventhough i research on recursive outputs, i still do not understand how to fix it because it does not provide any sample code as a guide. What is the best way to approach this such that i do not have to make much changes to the file(s)? Error tells me that it could be a recursive error:", "id": 44538400, "title": "How do i import files that mutually import each other?", "traffic_rate": 3808}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "python-3.x", "dictionary", "recursion", "tinydb"]}, {"answers": [], "link": "https://stackoverflow.com/questions/32829691/python-modules-partially-importing-from-each-other", "question": {"content": "I'm breaking up a large-ish (for me anyway!) project into 2 or 3 modules, including a 'main' module with the top level menu etc.   It will import a two or three 'sub-modules' for different aspects of the application.   However those modules will need various settings etc from the main module.   Yes, they could be passed as arguments but there are quite a few of them and they are liable to change.  Different modules will need different sub-sets of the settings. I'd like to be able to have the subordinate modules simply 'reach back' for their settings as needed (sort of global across modules as it were). Here is a mickie-mouse example of what I mean: test1: test2: And the results is Presumably this is due to potential circularity.  (Though, if its able to detect the circularity - not hard in this case!, ie that taskA has already been imported, you'd think its able to simply break out of the circularity, as opposed to throwing an error).  Is there a way to achieve this?   There's several obvious ways to code around it - keep it as one module; pass the settings as arguments (but that will have pitfalls if 'test2' has to modify any of the settings, if only as Im still getting my head around python's handling of mutable objects and binding); move all the settings to a separate module (test0) accessed by both test1 and test2. Given that these modules are intimately connected (I believe the term is strongly coupled), logically it should all be one module.  Except that its getting big.   My question is twofold ... how best to do what I want; but also to understand why Python cant handle mutual imports.", "id": 32829691, "title": "Python modules (partially) importing from each other", "traffic_rate": 9}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "python-module"]}, {"answers": [], "link": "https://stackoverflow.com/questions/11698530/two-python-modules-require-each-others-contents-can-that-work", "question": {"content": "I have a Bottle webserver module with the following line: And the foobar.formtools module contains this line: Of course, both result in the following errors (respectively): ImportError: cannot import name auto_process_form_insert\n  ImportError: cannot import name redirect Is it simply a fact that in Python two modules can't import each other and all module imports must be hierarchical in nature, or am I doing something wrong? Alternatively, is there a workaround short of placing all these nice functions in new modules?", "id": 11698530, "title": "Two Python modules require each other&#39;s contents - can that work?", "traffic_rate": 66505}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "python-module"]}, {"answers": [], "link": "https://stackoverflow.com/questions/9642451/python-files-import-from-each-other", "question": {"content": "I would like for two of my python files to import some methods from each other.  This seems to be giving me import errors.  Example:  file_A.py: file_B.py: The reason I am trying to do this is because I would like to organize my project in the way it intuitively makes sense to me as opposed to organizing it with respect to what makes sense to the compiler. Is there a way to do this? Thanks!", "id": 9642451, "title": "Python files - import from each other", "traffic_rate": 12842}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python", "import", "compilation", "package", "importerror"]}, {"answers": [{"content": "That what u need is a really bad practice accordin to pep8. Dont do it. Its better to import only that what you going to use and nothing more and manual imports are that what should claim.", "id": 72543798, "owner_tier": 0.1, "score": 0.0}], "link": "https://stackoverflow.com/questions/72543383/import-one-module-that-imports-all-other-modules-in-each-module-is-that-sensibl", "question": {"content": "In C/C++ microcontroller programming I got a lot of folders with source and header files. I got one header file (driverlib.h) that includes ALL other header files (Around 50+). In each source (.c) file I just include this driverlib.h file and I don't have to worry about any includes. Otherwise it would be a pain to include a bunch of header files in each source file. Now I want to know, if the same thing is possible in Python. I have got an example project below: Is it possible to create a driverlib.py in the main directory that just imports all other modules and then import it in each module? Like this: driverlib.py player.py in models/:", "id": 72543383, "title": "Import one module that imports ALL other modules in each module. Is that sensible and even possible?", "traffic_rate": 32}, "saved_time": 1721102465, "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "In flask you can use \u201cblueprints\u201d and the \u201capp factory\u201d pattern to break circular dependencies. https://flask.palletsprojects.com/en/2.2.x/patterns/appfactories/", "id": "iwc8d3f", "owner_tier": 0.3, "score": 0.9999999900000002}], "link": "https://www.reddit.com/r/learnpython/comments/yusmby/how_to_correctly_structure_a_project_in_python_to/", "question": {"content": " \n\nThis weekend i went and started playing around with flask, i was following along with some guy making a crud blog post to get the hang of things, but the video is kinda dated by now and i have been getting circular import errors with pretty much the same code as the lecturer in the video.\n\ninstead of trying to fix just this problem, does somebody know of a guide/article/book/course that explains how to best structure a project in python? my logic here is better to learn the fundamentals instead of asking for examples how to structure every separate project...", "id": "yusmby", "title": "How to correctly structure a project in python to avoid circular imports?", "traffic_rate": 153.13037037037037}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "I design my things so I don't get circular dependencies. Typically the things that require circularity can be spun off to a third module.\n\n+1 \n\nI avoid circular dependencies too. Most of the time they occur because your API is not well organized. If they can't be avoided, I use an import statement local to my function or method.\n\nIn your case, it sounds like you miss another module (util?) that would have a function that return users instances, or whatever the Producer stuff needs.\n\nUnlike some other folks here, I think it's a good practice to split the code in several modules, and avoid having tons of classes in the same module. When it grows, it helps. Ending up with a several-thousand lines module quickly become a nightmare whereas small modules are easier to read, tests etc.\n\nJava \"one class per module\" is a bit too much, but avoiding big modules is better. \n\n\n\n ", "id": "c0p32yp", "owner_tier": 0.7, "score": 0.9574468082978723}, {"content": "Why do they live in separate files when they're so obviously related? Why do you have a method called `User.create` when it seems so useless (reminder: you're not coding in java here)? What the fuck does `UserProducer` do, why isn't it done by `User` or by `User`'s metaclass? If `UserProducer` is supposed to interact with the database and `User` is just a dataholder, why the hell do you not create `User` instances via `UserProducer`? \n\n> I don't want to put them in the same file either, as that would get bloaty quite quickly.\n\nIf two classes in a Python file get bloaty pretty quickly, I say you have issues in your python.\n\nThis. From what the op describes, the API sounds weird and unpythonic. Fix that and the problems will likely go away. \n\n[deleted]\n\n> what does Java have to do with this?\n\nThe instance creation and initialization processes are performed by \"regular\" methods in Python (as in Ruby or Smalltalk), so you generally don't need explicit factory methods (you just override those which already exist). And when you do, you usually use factory *functions* as not everything needs to be a method.\n\nLikewise, the idea that things get bloaty when you have two classes in the same file is a caracteristic of java-thinking, and so's the multiplication of weirdly related classes.\n\nAll in all, OP's comment/query feels a lot like someone's coding in Java, it just happens that the serialization language is Python.\n\nWhen you hear one person ask about how to order a pizza to fight the muchies at 4:20am and a second person tells them to quit smoking pot, do you ask, \"What does pot have to do with this?\"\n\nThe code above exhibits a pathology of the sort endemic to brains damaged by too much Java use. \n\nYou rarely need such explicit factories in Python", "id": "c0p319r", "owner_tier": 0.9, "score": 0.999999999787234}, {"content": "    class User:\n        def create():\n             import UserProducer as P\n             P.verb()\n\n\nSubsequent runs hit the import cache.\n\nyou can also throw the import in __init__() and set self.P = P", "id": "c0p335s", "owner_tier": 0.7, "score": 0.4468085104255319}, {"content": "Move User.create() to UserProducer.createUser().\n\nCode creating user will depend on the UserProducer module. UserProducer depends on User module.\n\n\nThey're sufficiently different that it wouldn't make sense.\n\nUserProducer is basically a database query class. I think I'm gonna have to rename it to UserProducerByEmail or something like that.\n\nThe base class of UserProducer used to be called QueryRunner at some point.\n\nYou must remove the dependency of the user class on the database layer - it does not make sense.\n\nThis stuff is *inside* the database layer. The User class is a proxy for a database object.\n\nOk, your database layer has a class that search users, and a user class.\n\nRemove the dependency from user producer/finder on user. It will return user data from the database, e.g. (name, email, etc.), and the user class will use this data to initialize a user object.\n\nClient code depends on user class, user class depends on user finder to locate/fetch user data, user finder does not depend on user.\n\nThe real question is how to avoid circular dependencies, not how to deal with them in Python.\n\n\nBut using UserProducer from the controller layer is actually very convenient.\n\nFor example, when a user is on the \"forgot my password, please send me a new one via email\" page, he/she will enter her email address and it's convenient to use UserProducer right from the controller to search according to the email address and get a User instance back.\n\nPlus I'm using CouchDB here and I've got strong coupling between the User class and the database. Usage is something like:\n\n    user = User()\n    user.checkout(db_key) # I should rename this to user.pull()\n    datasnap = user.snapshot()\n    if len(datasnap.name.value) == 0:\n        user.write({\"name\" : \"John Doe\"})\n\nWhat I've basically done is designed a DB layer based on CouchDB that looks and feels a lot like using a modern source code version control system like git.\n\nIt actually feels very nice to use. There's an early alpha (I'm successfully using it in a private production system) with zero examples up on github:\n\nhttp://github.com/elver/siil", "id": "c0p3lpn", "owner_tier": 0.1, "score": 0.40425531893617017}, {"content": "You need to avoid using from foo import bar statement.\n\nin your model you can do something like this:\n\n    import app.model.user_producer as mo_up\n\nnow you will be able to use it like mo_up.UserProducer inside other class without any issues.\n\nI have a model that depends on 30 other models at same time, so i can assure you that this works.\n\nAlso as someone mentioned you can import inside a function but i think my solution is better.\n\nI think this is a problem related to the way packages work, not the circular import issue itself. The problem occurs when you mix 'from import bar' with 'import foo.bar' in your package. Using 'from' imports is just fine, just as the absolute imports you suggest, it's mixing these patterns that is the actual problem.\n\nThe problem starts because there might be code in the __init__.py in the package foo that imports from somewhere within the package. If you then import from the package in other modules in that package, you can run into circular import problems as in some cases the __init__.py needs to be loaded to finish the import of 'bar', but __init__.py imports from bar, argh.\n\nThe problem occurs when you mix 'import foo.bar' with 'from foo import bar', however, not if you just use either one of them. This is due to some subtle details of module initialization I can't recall of the top of my head. I looked into it once as some developers have converged on the 'import foo.bar' pattern as a solution to this issue and think it is the *only* solution, but they're wrong. I like my 'from' imports.\n\n", "id": "c0p3045", "owner_tier": 0.5, "score": 0.2553191487234042}, {"content": "\"Doctor, it hurts when I do this.\"\r\n\r\n\"So don't do that.\"\r\n", "id": "c0p3to8", "owner_tier": 0.7, "score": 0.08510638276595744}, {"content": "Hi. `import` statements need not be at the top of the code, you can place them anywhere. In general, if only one function requires a module, place the import inside that function, this may help avoid circular imports.\n\nThis has nothing to do with the problem. Circular imports are only problematic when you use the *from x import y* format. As long as you use only *import z*, you'll be fine with anything circular.\n\nImports should only be at the top so it's easier to see what are the dependancies.\n\nAs inelegant as this sounds, I think you may be on to something.\n\nThis is bad practise.\n\nThis will fail to discover missing modules until well into runtime.  It's ok, but only with a note in the module doc-string to indicate that the import is possible.\n\nUnless the import is delayed because of speed, it's better to import at the top of the module and then bind the variables later.  E.g., instead of\n    def foo():\n        from OtherMod import bar\nprefer\n    import OtherMod\n    def foo():\n        bar = OtherMod.bar\n\nThe problem is a bit more subtle than you are suggesting.\n\nI use 'from x import y' all the time, and I don't get bitten by circular imports very often. I think that's in part because I design my modules not to be mutually dependent anyway (that's good design practice).\n\nThe only case where it's really hard to avoid is when you got a package that does imports from modules in the package in __init__.py, and you do imports in the package's modules too. You can easily get circular dependencies that way, but you only get the import errors when you mix from imports with absolute imports. Consistently sticking to either pattern gets you out of the issue.\n\n\nWhat are you talking about? Python still won't let you have a circular import no matter how you spell it. \n\nI also think that this is a bad practice (I upvoted you). \n\nMost of the time you'd better refactor the code so that there's no circular dependency. But this is a useful trick in case you need to get thing done now, or when a part of third party framework/library is involved in the issue.\n\nYou need to handle missing modules where/whenever they're identified.\n\nWhat's the difference between:\n\n    try:\n        import foo\n    except ImportError:\n        blah\n\n    def bar():\n        foo.baz()\n\nand\n\n    def bar():\n        try:\n            import foo\n        except ImportError:\n            blah\n        foo.baz()\n\nSure it will.  You'll only run into problems if you have code that runs *during the import* that *uses* the objects.\nSo long as each is merely *defining* classes and functions that call it when invoked / instantiated, rather than actually *using* them *during* the import (inheriting from a class would be the most likely possibility), then you'll be fine if they just import each other.  (And don't make assumptions about the name already being there as in the \"from X import Y\" form).  What will happen is:\n\n    your_program.py:\n\n        import user   # Trigger the import of user.\n           <Checks module cache - not there, so:>\n           <Create a new empty module object>\n           <Add this to the cache of modules>\n           <Start executing user.py in this module's namespace>\n\n    user.py:\n        import userproducer\n        <Exactly the same process as above: start executing userproducer.py>\n\n    userproducer.py:\n        import user\n           <Checks for 'user' in list of imported modules>\n           <This time, FINDS IT, and returns it (in its current, empty state)>\n\n        #from user import User  # <- This would fail with a NameError however.\n\n        class UserProducer(object):\n             def getUser(): return user.User() # No problem.  user.User doesn't exist yet, but we don't \n                                               # care so long as its there by the time we are CALLED.\n\n\n        #some_user = UserProducer().getUser()  # <- eg. this would be a problem if uncommented.\n\n        #class SubclassedUser(user.User): pass # <- as would this\n\n        <finish executing module1, resume in module1.py>\n\n    module1.py:\n        <Continue executing, module2 being fully imported now>\n        class User(object): \n             ...\n\n(And of course, it happens the other way round if you imported userproducer first)\n\n\n\nThe first fails on import whether bar is called or not, while in the second case you only discover the failed import when bar is called. Where this really becomes a problem is cases like...\n\n    try:\n        # Something that succeeds 99.9% of the time for the module developer.\n    except:\n        import loging # Note the misspelling.\n        ...\n\nUnit tests *should* catch simple cases, but that's a big \"should.\" The deeper the imports are buried the lower the odds that they're covered.", "id": "c0p2zqt", "owner_tier": 0.5, "score": 0.6170212763829787}, {"content": "How do **you** deal with it?\n\nTears and half a bottle of whiskey.\n\nTears, not so good.  Half a bottle of whiskey, FUCK YEAH!", "id": "c0p3gxo", "owner_tier": 0.7, "score": 0.29787234021276593}, {"content": "I used to think it was necessary but I think I follow hylje's ideas more often now.\n\nThanks for the heads up.", "id": "c0p3tj6", "owner_tier": 0.7, "score": 0.06382978702127659}, {"content": "Circular dependencies are Evil. Here's how to fix'em: \n\nSay you have modules A and B that are circularly dependent. You identify the part that is causing the circular dependency. You can either *demote* that part such that A and B depend on this module C, or you can *escalate* it such that C depends on A and B.", "id": "c0p5kx3", "owner_tier": 0.5, "score": 0.04255319127659574}, {"content": "Reading your situation, I think you've got to suck it up and merge. If there's no hierarchy and neither functions without the other, then don't they belong together?\n\nIt can be done without any big issues. As i replied in other comment ;-)", "id": "c0p2zsc", "owner_tier": 0.5, "score": 0.04255319127659574}, {"content": "To Avoid the bitter experience of this condition, I always \"import\", and never use from\neg\n# from foo.bar import widget << will give problems \nimport foo.bar\nwidget = foo.bar.widget()", "id": "c0p5jy5", "owner_tier": 0.3, "score": 0.021276595531914893}, {"content": "A few solutions work, none are pretty.  All this jumble about poorly designed code isn't always true.\n\n* Put the import into the function that needs it.\n* Move the import to the bottom of the module.\n* Use dependency injection.  ie: pass the class you need into it.\n* Move common functions to a third module (best one IMO).", "id": "c0p4sg6", "owner_tier": 0.7, "score": -2.1276595744680853e-10}, {"content": "Put those entangled classes in same file or glue them together in third file. Need for circular imports means bad design.", "id": "c0p82go", "owner_tier": 0.7, "score": -2.1276595744680853e-10}, {"content": "Use \"from module import object\" statements at the exact position you need them inside functions and methods. Never at the top of modules. You want to use the \"from module import object\" form instead of \"import module\" to avoid polluting the namespace. Remember \"from module import object\" inside functions and methods only. You'll never have to worry about circular imports again. Not to mention, you'll only import what needs to be imported when it's needed and nothing more. This is one trick used to improve the startup speed of applications.\n\n> You want to use the \"from module import object\" form instead of \"import module\" to avoid polluting the namespace.\n\nA little correction, `import module` does not pollute namespace, `from module import *` does.\n\nI didn't make myself clear.\n\nFor example, he should use \n\n    from gtk import Window\n\n**not** \n\n    from gtk import *\n", "id": "c0p4ah4", "owner_tier": 0.3, "score": 0.08510638276595744}], "link": "https://www.reddit.com/r/Python/comments/bxpyo/how_do_you_deal_with_pythons_inability_to_handle/", "question": {"content": "I've got two classes in separate files: User and UserProducer\n\nUserProducer searches through the database based on some criteria and returns matching User objects from it.\n\nUser.create() uses UserProducer to check if any users with the same e-mail address have already registered.\n\nBoth, quite obviously, need access to each other. But if I have them in separate files, then they both cannot import the other.\n\nI don't want to put them in the same file either, as that would get bloaty quite quickly.\n\nWhat would be the Pythonic solution?", "id": "bxpyo", "title": "How do you deal with Python's inability to handle circular imports?", "traffic_rate": 207.942496260595}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "I never experienced this problem. When are circular imports a problem? And if there actually are circular dependencies, how would you solve it?\n\nImporting for type annotations does this to me a lot\n\nCode with circular imports in python does not work. I have come across this problem several times, and depending on the project size it becomes problematic to identify where exactly the problem is. This tool shows you the chain of the imports that are causing the problem, it is up for developer to fix it e.g. restructure the imports or move the imports into the function call.\n\n> When are circular imports a problem?\n\nIt could be due to either improper module layout (e.g. classes aren't in the proper place), or because there's an intrinsic strict dependency on two entities that you want to keep separated for other reasons. It can happen. Rarely, but it does, also for legitimate reasons. It can also happen accidentally with a \"long cycle\", that means it's not a direct circular, but two or three modules down the import hierarchy, you happen to import the very same module you started from.\n\n> And if there actually are circular dependencies, how would you solve it?\n\nIn general, when it happens it's because you have a routine (method or function) that needs something. You simply put the import inside it.\n\n\nI've had this in Django where the views of course import the models, and the Celery tasks also import the models, and the views also import the Celery tasks, and maybe you want to start a Celery task from your model's `save` method and -- oops! You've got a circular import.\n\nThe solution is to move one of the import statements into the method that is using it, with an appropriate comment. Personally I would always want the model import at the top of the file if code in the file uses that model. Which means I'd edit the `blog.models` module, moving the `import blog.tasks` from the top into a method.\n\nIt often happens when merging branches in VCS, which is when OP's tool will come in handy.\n\nThe problem and ways around it are discussed in the Python FAQ:\n\nhttps://docs.python.org/3/faq/programming.html#how-can-i-have-modules-that-mutually-import-each-other\n\nhttps://docs.python.org/3/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module\n\n\nYeah I all the time have co-dependent libraries which, due to supporting too many use cases, regularly import from each other in both directions. Usually it's wanting to use classes from one library in another and then wanting to do the same thing in reverse. Like a car lib and a traffic lib each calling into the other for things. If I had a grand plan for how to solve every kind of problem with the API of one or the other library, I wouldn't have the problem, but of course my API is a continual work in progress.", "id": "dd20mrj", "owner_tier": 0.5, "score": 0.9999999996}], "link": "https://www.reddit.com/r/Python/comments/5qtah6/pycycle_find_and_fix_circular_imports_in_python/", "question": {"content": "", "id": "5qtah6", "title": "Pycycle: Find and fix circular imports in python projects", "traffic_rate": 207.942496260595}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "Java (and many other JVM languages) supports circular dependencies, with late binding during class loading. There are edge cases, of cause, with class initialization lock, exceptions in initializers and so on. C# and many .Net languages have somewhat similar behavior (can't tell much about assemblies, though).\n\nMain pro is that you don't have to design your code specially to avoid circular dependencies. That really comes into play when you have rather complex data types (such as, say, AST in the compiler).\n\n[deleted]\n\nMy primary experience is with JVM. Do .Net assemblies allow circular dependencies? That is, can you have a class CA assembly AA depending on class CB from assembly AB, and vice a versa?\n\nOops, my bad, my comment was talking about the scope of a single project/assembly.\n\nBut yeah, AFAIK it does, but it's strictly discouraged. Most circular dependencies between assemblies suggest it should simply be a single assembly, or otherwise refactored.", "id": "iwfjd1a", "owner_tier": 0.3, "score": 0.9999999995652173}, {"content": "Haskell supports it, but GHC requires hs-boot files to manually break cycles (basically what a header file provides in C). https://downloads.haskell.org/ghc/latest/docs/users_guide/separate_compilation.html#how-to-compile-mutually-recursive-modules", "id": "iwf22ok", "owner_tier": 0.9, "score": 0.6086956517391304}, {"content": "What I like about JavaScript is that it's unopinonated about a lot of things. Wanna use circular dependencies? Go ahead.\n\nIn practice, most people use linters to detect and prevent circular dependency in the main branch.\n\nDisabling circular dependency can make refactoring a bit harder, and it can lead to some \"monofiles\" where everything is in scope: https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts\n\nI still think it's circular dependency is nice-to-have feature, just to be able to delay some refactoring, but I wouldn't care that much if it wasn't in the language.", "id": "iwfai2p", "owner_tier": 0.5, "score": 0.30434782565217394}, {"content": "D supports circular dependencies but [disallows _static constructors_ from depending on each other circularly](https://dlang.org/spec/module.html#order_of_static_ctor). This is ensured at runtime before calling `main`.  \nZimbu has [primitives specially crafted to control circular dependencies!](https://moolenaar.net/z/zimbu/spec/zimbu.html#Startup%32Sequence).\n\nCan you narrow down what you mean in Zimbu, showing a specific example? That seems interesting!\n\nZimbu's modules and classes have a `.Ready` property you can query in initialisers, and initialisation can be tried multiple times. This allows you to manually break cycles.\n\n    CLASS C\n        C $cycle\n        string $name\n    }\n    MODULE A\n        C obj = NEW()\n        FUNC Init() status\n            IF B.Ready\n                obj.cycle = B.obj\n                obj.name = B.obj.name\n                return OK\n            }\n            return FAIL\n        }\n    }\n    MODULE B\n        C obj = NEW()\n        FUNC Init() status\n            obj.cycle = A.obj\n            obj.name = \"CYCLE\"\n            return OK\n        }\n    }\n\nHere, `A.Init` may be called twice by the runtime, which is necessary as both `obj` aliases are assigned to independently.  \nAlso yes, Zimbu uses `}` instead of `end`.", "id": "iwfapyh", "owner_tier": 0.5, "score": 0.47826086913043475}, {"content": "Python allows circular dependencies.  I think it's stupid and error-prone.  I think it's better to break dependencies with interfaces, each in it's own file.\n\n> Python allows circular dependencies\n\nNo it doesn't... You get an ImportError if you do that\n\nHow do you model like my ActiveRecord example (first example) without circular dependencies and without the class-as-string hack?\n\nThere are cases where you get an import error, but you don't if you're careful.\n\nI admit that's worse, but python does allow circular imports.\n\nEdit with concrete example:\n\n```\n# a.py\nimport b\n\nattr = 'a'\n\n# print(b.attr)  # doesn't work if executed first - b is not yet loaded completely\n\nif __name__ == '__main__':\n    print(b.attr)  # works\n\n\n# b.py\nimport a\n\nattr = 'b'\n\n# print(a.attr)  # doesn't work if executed first - a is not yet loaded completely\n\nif __name__ == '__main__':\n    print(a.attr)\n```\n\ncaveat: the `__main__` module is neither the `a` nor the `b` module, but at the end, the Python VM will have complete `a` and `b` modules that were loaded through cyclic imports and can access each other's members.\n\nPython modules work somewhat like first creating a module object, then memoizing it so subsequent imports get the same object back, then executing the file to populate the module object's fields. When a circular import occurs, it will get back a memoized module object that doesn't yet have its fields populated. As long as the circular import doesn't need to access the fields in the top-level code, this works fine. For example, this code works without issue:\n\n    # a.py\n    import b\n    def a_func(n):\n        return b.b_func(n-1) if n > 0 else 0\n\n    # b.py\n    import a\n    def b_func(n):\n        return a.a_func(n-1) if n > 0 else 0\n\nThe example works because running the file `a.py` or `b.py` doesn't require accessing any of the imported fields, it just defines functions that will access those fields when called at a later point in time. You only need to access those when _calling_ `a_func` or `b_func`, at which point both files would have finished defining all their exported functions. It's slightly awkward because it means that `from a import a_func` will break circular imports even though `import a` works fine.", "id": "iwez2eo", "owner_tier": 0.1, "score": 0.5652173908695651}, {"content": "I think it's a must. Let's say you have 2 function definitions calling each other (mutually recursive). Then if those 2 functions are in the same module, there's no problem, but if they are in different modules of the same project, that's somehow a problem? That's just sloppy compiler design is all. The compiler should first read the interfaces (function signatures etc) of all modules, then compile those modules knowing those signatures. If a language doesn't support cyclical imports, then the compiler authors just weren't smart enough to do that.\n\nIf it were so straightforwardly beneficial, every language would do it, but it's not. Here are a couple reasons to avoid it:\n\n1. Cyclic dependencies mean the \"downstream\" effects of a change can be much larger than in a DAG. It gets especially bad if the resultant coupling cuts across _teams_. This can make coding/debugging harder.\n\n2. It slows down compilation. It makes it harder to compile in parallel, since mutually-dependent information must be processed and ready before proceeding. This is partly why Go disallows cyclic imports.\n\nHigher order functions can be mutually recursive across modules without mutual dependencies quite easily. Maybe the cycle should be broken by abstracting out which function is recurred over in one of the modules?\n\nOtherwise I'm not clear on what the value is of having these things in separate modules in the first place?\n\nStrong bidirectional coupling between module interfaces is spaghetti rubbish. It's not a failure of language designers to choose not to go out of their way to support bad design.\n\nIt seems to be a very hard problem to solve, implementing circular dependencies. Do you know how to do [this](https://stackoverflow.com/q/74453129/169992)?\n\n> Cyclic dependencies mean the \"downstream\" effects of a change can be much larger than in a DAG.\n\nA cycle of modules is effectively one module, isn't it? you can always replace all cycles with a single node and end up with a DAG. Yes, that's slower to compile than if there were no cycle, but it's not slower to compile than the programmer manually merging the cycle into a single module - which is the alternative that I saw suggested here most often.\n\nThe question then becomes: are dependency cycles a useful tool for allowing programmers to structure their code more granularly than into \"units without cyclic dependencies\", or is it a feature that leads to sloppy architecture and technical debt?\n\n---\n\nAlso, in many languages (including the ones brought up by OP: Ruby & JS) a module is one file iiuc. I would argue that cyclic dependencies between files are definitely useful (I may not want to have to browse a whole module linearly just becuase that's how files work), and the problem is making files the module boundary.", "id": "iwfiojn", "owner_tier": 0.3, "score": 0.913043477826087}, {"content": "**Don't.**\n\nHow do you model like my ActiveRecord example (first example) without circular dependencies and without the class-as-string hack?\n\n I had the same question when I decided to disallow circular dependencies; I thought it would be too damning to place all ActiveRecords in the same file.\n\nMy current solution is straightforward; I treat the folder as a module instead of the file as a module.\n\nEvery file in the same folder is just a textual separation of the same module. So compilation is easy; concatenate every file in the same module. \n\nThis approach allows me to separate mutually recursive classes/functions into different files without complicating the module system of my language.\n\nIf a page is just a collection of comments and has no other responsibilities then they should be in the same module.\n\nOtherwise the model is wrong ... The comment should belong to a comment-list or something. The page then has a reference to the comment-list. And if the comment list needs a reference to its owner then \"page\" is too specific, it should refer to a more abstract \"container\" which is a shared dependency of both the page and comments modules.\n\nBasically whenever you think you have a circular dependency between modules, you either have to lump them together into the same module or break the cycle by abstracting an interface out as a common dependency and referring to that.\n\n**You don't model this.**\n\nIn real world apps., this is not used. Usually circular recursion appear with functions, not types.\n\nIf your types were classes instead of structures, this would be solved with inheritance:\n\n    // additional library/ module X\n\n    type class A;\n    type class B;\n \n    // A library\n\n    import X;\n     \n    type class C: A\n    {\n      C1: B;\n      C2: B;\n    }\n\n    // B library\n    \n    import X;\n    \n    type class D: B\n    {\n      D1: A;\n      D2: A;\n    }\n\nCircular reference is removed ...\n\nInteresting, but still within the concatenated module you have circular dependencies between classes. So parsing has to wait or something?\n\nWhat do you mean by \u201cparsing has to wait or something\u201d?\n\nIf you have this in one file:\n\n    class Post < ActiveRecord::Base\n      has_many :comments, class: Comment\n    end\n\n    class Comment < ActiveRecord::Base\n      belongs_to :post, class: Post\n    end\n\nWhen it gets to `class: Comment`, comment isn't yet defined, so you have to wait until comment is defined to resolve the meaning here.\n\nSo the problem seems to remain, that it is still tricky to resolve circular dependencies, no matter if they are in separate modules or in the same module/file.\n\nThey mean that you don\u2019t always know what a symbol means when you first encounter it because it\u2019s definition might be later in the class/file. So you need to do interpretation of references as a separate step from parsing.\n\nI\u2019m guessing you don't have separate phases in your compiler, so it\u2019s hard to see how it works.\n\nIn my compiler, name resolution and type checking are only done after parsing.\n\nSo using your example, the parsed AST already contains the definition of Post and Comment before being fed to the type checker.\n\nCool, thanks, that kind of makes sense, will have to think more about that.", "id": "iwf52yt", "owner_tier": 0.7, "score": 0.9999999995652173}, {"content": "Here is what I am thinking so far... For reference, `class` is a class definition and `data` is an object tree like JS objects.\n\n    # ./data.foo\n    import ./forms\n      take class person-node\n\n    data a\n      data b, borrow class person-node\n      data c, <person>\n      data d, clone a/b/fields/length\n      data e, <hello>\n\n    # ./forms.foo\n    import /hosts\n      take host a\n \n    # as you can see, makes \"class person-node\", etc.\n    class {a/c}-node\n      field {a/e}\n      field x-{a/d}\n      field {a/b/name}-name # person-node-name\n\nThat shows how things can reference things back and forth in a complex way. Now imagine that was across multiple files. The ideal would be to avoid this, but if you are going to allow \"simple class/ORM\"-like circular dependencies, you might as well support \"anything\"? Not sure.\n\nEven if they were in the same file, you still have the problem of resolving the circular dependencies within the single file... So problem stands.\n\nCircular dependencies within the same file are not hard to resolve and should be expected; otherwise, how can users define recursive or mutually recursive functions?\n\nAny resources on how to resolve circular dependencies? :)\n\nhttps://www.reddit.com/r/ProgrammingLanguages/comments/yfzmmw/typechecking_mutually_recursive_functions_and/iu6tmwp/?utm_source=share&utm_medium=ios_app&utm_name=iossmf&context=3", "id": "iwfbq5g", "owner_tier": 0.1, "score": 0.4347826082608695}, {"content": "In C# a module may contain multiple types. All types may be in a single source file or spread across multiple source files. The module is the compilation unit, and all source files of a module is presented at once to the compiler. \n\nTypes *within* a module may refer to each other, or they may refer to types in an \"imported\" module (a dependency). Circular dependencies between modules are *not allowed*.\n\nYour example (using *Entity Framework*):\n\n    // file Post.cs\n    class Post \n    {\n        public ICollection<Post> Posts { get; set; }\n    }\n    \n    // file Comment.cs\n    class Comment \n    {\n        public Post{ get; set; }\n    }\n    \n\nThe actual database relation will be inferred, although that can also be controlled specifically through code.\n\nIn C# all files of a module are automatically \"imported\", as are any referenced modules.\n\nOne of the main reasons I prefer F# to C# is that it avoids circular dependencies *by default*. In F#, code files are compiled in a specific order, and there are no relations between the types. There are a couple of escape hatches, which are to use the `and` keyword between types, or to use `namespace rec` or `module rec`, but I avoid using these wherever possible.\n\nYes, I remember that in my C# project at the previous job: I had weird build errors, and had to scratch my head quite a bit before I understood what the stupid C# compiler wanted from me. It wanted all the same code, but arranged differently into modules. I was literally SMH at how bad Microsoft programmers were.\n\n>One of the main reasons I prefer F# to C# is that it avoids circular dependencies by default. In F#, code files are compiled in a specific order, and there are no relations between the types.\n\nI don't see that as an advantage at all. I do a fair bit of F# coding (creating a compiler for my language), and this constantly annoys me. You need to explicitly specify that a   function is recursive, and if you have a set of functions that are mutually recursive, they absolutely need to be grouped together. The fact that *the order* in which the files are presented to the compiler is also annoying. \n\nMaybe it's because I'm used to be able to group functions and types according to domain concepts rather than according to technical references which the compiler must know about.\n\nI have done C# for 20 years now. I have never seen this as a problem. Rather, the language allows me to arrange types and files quite freely.\n\nGiven that modules (assemblies in .NET parlance) are the packaging unit, circular references would be really bad. But within a module it makes a lot of sense to allow the programmer to present all the files at once.\n\nIMHO equating a type/class with a module (e.g. a single type in a single module) leads to a quagmire of dependencies.\n\nIt's annoying at first, but it pushes you towards writing better code.\n\nI've never broken a cyclic dependency and come out with a solution which was worse than the one with the cycle.\n\nThe language I'm working on does not allow cycles *at all*. The result is that all code forms a DAG. A future goal is to be able to content-address any part of the code, similar to what Unison does. The presence of cycles makes this problem much more difficult.", "id": "iwfek3m", "owner_tier": 0.1, "score": 0.6521739126086956}, {"content": "I'd say it's absolutely necessary. Allowing circular dependencies allows you to focus more on the actual code rather than figuring out how to correctly order and structure your files/modules\n\nThere's a thing called technical debt. Circular dependencies are a good way to accumulate it.\n\nYeah allowing circular dependencies allows people to not have to think about dependencies and coupling and inter-module architecture and structure ... Which usually means people do a shitty job of those things.\n\nYou *should* be thinking carefully about which modules depend on each other. Allowing circular dependencies just hides bad design choices.\n\nExample please? I've never been in a situation where manually ordered dependencies was better in the long run\n\nAnything which is a solution to the [expression problem](https://en.wikipedia.org/wiki/Expression_problem) would be an example.\n\nA cyclic dependency is brittle. Your edit doesn't just affect the piece of code you are editing, but all dependencies which are part of the cycle are impacted.\n\n> Your edit doesn't just affect the piece of code you are editing\n\nAs long as something is exported from a module, it will have that property.\nIt does not have to be part of a cycle.\n\nIf `B` depends on `A`, and I make an edit to `B`, this should affect all descendants of `B`, but not all descendants of `A`.\n\nIf you have a cyclic dependency between `A` and `B`, now an edit to `B` will not only affect descendants of `B`, but also all descendants of `A`, even though no edits were made to `A` directly. `A` must also be recompiled. `A` and `B` are not really separate modules, but a combined module `AB`.\n\nPart of the goal of OOP is to manage complexity by isolating code into smaller units which can be individually tested and maintained. When you have cyclic dependencies you are not isolating anything, you just have a complex sub system whose parts cannot be individually tested - you can only test this sub system as a whole, and the sub system is at least as complex as all of the modules involved in the cycle.", "id": "iwfkcph", "owner_tier": 0.3, "score": 0.7391304343478261}, {"content": "Most circular relations can be resolved by abstracting out an interface for one or more types. For example:\n\n    Comment =\n        Text : String\n        ...\n   \n    Post =\n        Subject: String\n        Comments : Comment[]\n        ...\n\n    PostComment < Comment\n         Post : Post\n\nWhen instantiating the `Comments` field of the `Post` type, it is instantiated with `PostComment` objects which are *upcast* to `Comment`.\n\nWith generics you can avoid the need to downcast `Comment` back to `PostComment`\n\n    Post<TComment> , TComment < Comment =\n        Subject : String\n        Comments : TComment[]\n\n    PostComment < Comment\n        Post : Post<PostComment>\n\n---\n\nIf you consider how you arrange the data in a relational database, through *normalization*, it is done to avoid the kind of cyclic dependencies which are common in OOP. Instead of taking a reference, the information is combined with a `join`.\n\nThis is why there exists an [Object-Relational Impedance Mismatch](https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch). When we normalize the post/comment relation in a relational database, we would usually place the `post` field as a foreign key in the `comments` table, since a post can have many comments, but a comment belongs to one post. However, in OOP, we typically want to say `post.comments`, which is an inversion of this relationship.\n\nIMO, enabling cyclic dependencies just takes you further away from how the data is stored in the relational DB, widening the impedance mismatch, but you should be trying to minimize it, or instead opt for an object/graph database as your storage, which models your data closer to how you represent it in the OOP language.\n\nIf we say `post.comments` in our OOP language, at which point in time is the relevant `join` operation performed in the relational database? Do we perform it eagerly when instantiating the `post` object, or do we perform it lazily when accessing the `.comments` member, or do we just not use `joins` and instead perform a query every time, and make poor use of what the database provides us?\n\nIMO, one problem that most OOP languages have is they couple object representation and *construction* into the same concept, but if we are to instantiate a `Post` with `PostComment` objects, this coupling of concepts causes a circular dependency. If we separate the concepts (for example, using abstract factories), we can eliminate the dependency.\n\n     PostFactory =\n         .create ( ... ) : Post = \n             new Post (\"Subject\", [ new PostComment(...) :> Comment, ...])\n\nWhile `Post` itself has no dependency on `PostComment` (only on `Comment`), there is nothing restricting `PostFactory` from depdending on the `PostComment` because it is completely separated from `Post`.\n\nThe approach I've taken in my language is to completely forbid every kind of cyclic dependency in the static context. The relationship between all types forms a forest of DAGs, and there are no ways to violate this to introduce cycles.", "id": "iwfipmi", "owner_tier": 0.5, "score": -4.3478260605327347e-10}, {"content": "It seems that there are basically two views on this topic:\n\n1. YOU MUST DO IT!!!\n2. YOU MUST NOT DO IT!!!\n\nEcstasy supports modules, and circular dependencies among any number of modules. Modules are a unit of compilation, and when circular dependencies exist, the modules can be compiled as part of the same compilation phase.\n\nI wrote this recently, describing the process:\n\n--\n\nFor the second case, of multiple compilation units, the use case tends to be far more complex: The reason to compile multiple compilation units together is that they are co-dependent (i.e. cyclic graphs that span multiple compilation units). To solve this problem, you will need to build your top level compiler orchestration such that it advances each compilation unit one stage at a time, and such that each stage can complete based on the previous stage having already completed for the other compilation units.\n\nThe second case is far more complex in terms of design, but the implementation is relatively simple. What I mean by that is that you need to reason through the stages of compilation, so that each stage for each compilation unit is only allowed to ask questions that would be answerable by the sum of previous stages of other compilation units. Within a compilation unit, it may be possible to ask question that are only answerable by the completion of processing within the current stage, but even this ([for example](https://github.com/xtclang/xvm/blob/master/javatools/src/main/java/org/xvm/compiler/ast/StageMgr.java)) becomes far more complex. Finally, it is even possible for a stage within a compilation unit to depend on questions that can only be answered by another compilation unit once it progresses to a certain point within that same stage, but again that will dramatically increase implementation complexity, so if at all possible stick to the rule: each stage for each compilation unit is only allowed to ask questions (at least when asking other compilation units!) that would be answerable by the sum of previous stages of compilation.", "id": "iwi35gq", "owner_tier": 0.5, "score": -4.3478260605327347e-10}, {"content": "Euphoria doesn't care if there are circular dependencies, mostly because it only adds each import once, no matter how many times it is referenced.\n\nPro: You don't have to care which files you put your data in, so you can stay relatively modular per file.\n\nI don't really know if there are any cons to this feature.  Recently it even has support for namespaces, so things with ambiguity no longer matter either.\n\nI suppose one con is the interpreter (or compiler, if you use the Euphoria to C translator) has to do more work to keep track of what has been imported, and there's slightly more overhead, but I don't see how it's ever a bad thing.", "id": "iwsqpqp", "owner_tier": 0.5, "score": -4.3478260605327347e-10}, {"content": "It's probably a misfeature to allow cyclic dependencies across modules. A strongly-connected-component in the dependency graph tends to indicate there's a separable concern that's been spread thinly across a collection of files, rather than clearly isolated in its own file.\n\nIn the Ruby-on-Rails example, the simple (but incomplete) answer is that Rails is misguided. Relational databases are hotbeds of interlocking mutually-dependent data. You cannot understand the pieces in isolation. The value is in the relationships between the records. So the definitions concerning each strongly-connected-component must naturally appear together.", "id": "jic790u", "owner_tier": 0.3, "score": -4.3478260605327347e-10}], "link": "https://www.reddit.com/r/ProgrammingLanguages/comments/yvkysh/languages_which_support_circular_dependency/", "question": {"content": "I am working on a programming language/compiler, and have felt the pain a few times in JavaScript-land (my primary language) of not being able to import/require circular dependencies. For example, in Ruby on Rails models, the database schema is inherently circular. This Ruby code wont work (or it didn't work a long time ago when I last used Ruby on Rails):\n\n    # post.rb\n    class Post < ActiveRecord::Base\n      has_many :comments, class: Comment\n    end\n\n    # comment.rb\n    class Comment < ActiveRecord::Base\n      belongs_to :post, class: Post\n    end\n\nIt doesn't work because of the circular dependencies.\n\nInstead you do something like this:\n\n    # post.rb\n    class Post < ActiveRecord::Base\n      has_many :comments, class_name: 'Comment'\n    end\n\n    # comment.rb\n    class Comment < ActiveRecord::Base\n      belongs_to :post, class_name: 'Post'\n    end\n\nThen internally, once all the models are loaded, it converts the string to the class and wires it up.\n\nIn JavaScript I have at times wanted to essentially do this (though my examples were better use-cases, which I can't find/remember):\n\n    // b.js\n    import * as a from './a'\n\n    a.log()\n\n    export function add(a, b) {\n      return a + b\n    }\n\n    // a.js\n    import * as b from './b'\n\n    export function log() {\n      console.log(b.add(1, 2))\n    }\n\nThe only way to do that is more like this, where in one super module you set functions on the referenced modules, kind of a hack.\n\n    // b.js\n    const a = require('./a')\n\n    // DO THE HACK:\n    a.log = function() {\n      console.log(add(1, 2))\n    }\n\n    export function add(a, b) {\n      return a + b\n    }\n\n    // a.js\n\n    export function log2() {\n      // assume it's been set elsewhere.\n      a.log()\n    }\n\n    // main.js\n    // load b first, since it configures A.\n    const b = require('./b')\n    const a = require('./a')\n\n    a.log2()\n\nMy first question is:\n\n- What programming languages support circular referencing imports like this? Either popular langs or esolangs. It appears [C allows this](https://www.quora.com/Do-any-programming-languages-support-importing-modules-with-circular-dependencies-or-other-kinds-of-circular-dependencies-unlike-JavaScript-modules/answer/Jurriaan-Hage) to some degree. Maybe Makefiles do too? [More here](https://stackoverflow.com/questions/2284968/do-all-dynamic-languages-have-the-circular-import-issue).\n\nMy other two questions are:\n\n- What are the cons with having this feature of circular reference importing?\n- How far can it go, and/or what are the limitations in allowing this?\n\nFor the limitations question, I am imagining something complex like this:\n\n\n    # main\n    import a from './a'\n\n    log(a.doA())\n\n    # a\n    import x from './x'\n    import y from './y'\n\n    function doA() {\n      return y.add2(x.mult(1, 2), x.mult(2, 3))\n    }\n\n    function addMult(a, b) {\n      return (a * 2) + (b * 3)\n    }\n\n    # x\n    import a from './a'\n    import y from './y'\n\n    function mult(a, b) {\n      return y.add2(a.addMult(a) * a.addMult(b))\n    }\n\n    function mul2(a, b) {\n      return 2 * (a + b)\n    }\n\n    # y\n    import x from './x'\n\n    function add2(a, b) {\n      return 2 + x.mul2(a, b)\n    }\n\nBasically I am trying to draw an example where there are cycles dependent on cycles, and/or things that resolve in a sort of loop.\n\n\n    # b\n    import A1, A2, A3, A4 from './a'\n    \n    type B1 {\n      x: A1\n      y: A2\n    }\n\n    type B2 {\n      x: A3,\n      y: A4,\n    }\n\n    type B3 {\n      x: A1,\n      y: A4,\n    }\n\n    # a\n    import B1, B2 from './b'\n    \n    type A1 {\n      x: B2,\n      y: B2,\n    }\n\n    type A2 {\n      x: B3,\n      y: B2,\n    }\n\n    type A3 {\n      x: B1,\n      y: B2,\n    }\n\n    type A4 {\n      x: B3,\n      y: B1,\n    }\n\nHere, b.B1 depends on a.A1 and a.A2. But a.A1 depends on b.B2, which depends on a.A3 and a.A4, which depends on b.B3 and previous ones etc.. So it's like it would have to either parse going back and forth between the modules (which can have many links in a circle), or it has to resolve all things in each module first, without linking, then link partially as it goes, then at the end mark everything as completely linked. Something like that. How does/should it work?\n\nNote, my examples clearly can benefit from refactoring. But in many cases, it does make sense to have circular dependencies. So the ideal would be to avoid circular dependencies if possible, otherwise fall back to using them. But maybe that feature should be omitted to avoid spaghetti code, not sure how it has turned out in the wild.\n\n[Here's a comment](https://www.reddit.com/r/ProgrammingLanguages/comments/yvkysh/comment/iwfbq5g/?utm_source=reddit&utm_medium=web2x&context=3) on what I'm currently thinking...\n\nRelevant:\n\n- https://stackoverflow.com/questions/1897537/why-are-circular-references-considered-harmful\n- https://marian-caikovski.medium.com/cyclic-dependencies-a-convenient-feature-of-modern-javascript-eca7c07fe272", "id": "yvkysh", "title": "Languages which support circular dependency imports, and the pros and cons of that feature?", "traffic_rate": 16.86659877800407}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "If there's really no way of refactoring things to remove the dependency, then the much simpler fix is to move the import inside `something_else` - that way it's only executed when it's called, rather than when internal itself is imported.\n\nDo you mean moving the import statement?\n\nYes.\n\nOk so that error is gone, but now one of the functions in the file is giving an error when you call it saying it hasn't received 'self' as an argument. That's supposed to be automatic??!!\n\nOnly if it's a method in a class. Show the code and the error.\n\nThe code is is linked in the post. Here's photos of the error and the function (which is a method in a class) https://imgur.com/a/BGBquaJ\n\nIn `eventprocessor.redraw`, you didn't instantiate the LightMap object. You need to call it as `lights = lighting.LightMap()`, with the parentheses.\n\nThis fixed it! Thanks so much!!!!! It works now!\n\n[It looks soooo preeeettttyyyyyyy](https://youtu.be/z1trePyMiMY)", "id": "fv4iy79", "owner_tier": 0.5, "score": 0.9999999987499999}], "link": "https://www.reddit.com/r/learnpython/comments/has120/how_to_fix_circular_dependencies_in_modules/", "question": {"content": "Edit: this is working now! Thanks for all your help <3 !!!\n\nSo I've run into an issue with my code where two modules are interdependent, and as a result, one of them loads before another, leading to an `AttributeError: module 'my_module' has no attribute 'my_function_a'`. If I import them in the opposite order, I get the same error but for functions in the other module. The structure of the two modules is logical, and I don't want to move functions between modules as this will be extremely confusing when I'm working with code later down the track (put simply, the function to turn on the lights would no longer be in the module for controlling the lights, or something).\n\nOrdinarily, in C++ I would work around this by prototyping functions so that they are declared (even if they're not defined yet), but apparently this isn't possible in Python.\n\nAnother workaround suggested by Stack Overflow (I didn't post for fear of downvotes, but I found a similar issue) suggested doing the following:\n\n    from importlib import reload # reload  \n    reload(my_module)\n\nBut this does now work as the software which hosts my script does not allow access to the `importlib` module for security reasons. No, I can't use a different host, as that defeats the purpose of the script.\n\nThe basic layout for the relevant parts of my project is as follows:\n\n    Project directory:\n     - Main.py # Where all callbacks from interface are handled and redirected\n     - Lighting.py # Controls lights\n        - class: Lights (1 instance: state)\n            [calls toMidiMessage(), and other functions in Internal.py]\n     - Internal.py # Manages internal state of device\n        - function: toMidiMessage()\n        - function: something_else()\n            [uses constants in Lighting.py]\n\nIf needed, [here's the link](https://github.com/MiguelGuthridge/Novation-LaunchKey49-Mk2-Script/tree/lighting) to the GitHub branch with the changes that broke the script.\n\nHow can I go about fixing this circular dependency without disrupting any code that is already existing? It's important to note that access to a lot of Python modules is restricted for security purposes in the scripting interface my script connects to, which limits my options for using external modules to fix my options. Any ideas would be greatly appreciated.", "id": "has120", "title": "How to fix circular dependencies in modules?", "traffic_rate": 153.13037037037037}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "So basically this entire conversation so far is, ironically, running in circles. Some of our regulars are trying to explain that this is simply a project layout issue, while others are clearly not understanding what they're talking about.\n\nI can see both sides of the argument. It's not always intuitive, especially to less experienced developers, how to design a project without circular dependencies. On the other hand, it's also not an easy problem to generalise, meaning the more experienced developers kind of just intuitively know what to do and it's not always easy to explain how or why, especially in a general case.\n\nI don't know if I have an explanation that would satisfy OP and the others, but the key is splitting up the project in a way that suits it. Instead of depending on a class from another module, maybe take it as an argument and write your code to be called from higher up the stack, where the circular dependency is a non-issue (so basically dependency injection). Or if type hinting, consider writing an abstract base class that has no dependencies but describes the concrete ones well enough typing-wise.\n\nReally, it's just a matter of learning the tools of the trade. It's a lot easier to discuss a concrete example than an abstract one, so if you have a real project with a circular dependency let us have a look and tell you how to solve it. Follow our example long enough and you, too, will learn how to solve these problems in the future.\n\nThanks for your time trying to take distance in this situation.\n\nBut the explanation \" I have a lot of experience and we have always done like that \" is not sufficient to give a response to a deep paradigm question about python dealing with dependencies. I write it again for you.\n\nWhy can't we set loops (=circular dependencies)  in the dependencies graph when it would be much more satisfying than having a classic tree-shaped dependencies graph.\n\nFurthermore, it his possible to do so, because of the possibility to gather manually all dependencies creating a loop in a single file.  But it gets worth as the files are getting longer.\n\nSo the question: why can't we have many file acting like one, with a function to gather them ( carry for instance )\n\nThe note about dependency injection and ABCs is a good suggestion for the generalized problem. I usually have something like a base.py in my packages with the abstract base class. I can then import the base class(es) for type hints without importing the implementations, avoiding that type of issue\n\nAnother piece of advice is have is to use `typing.TYPE_CHECKING`. This helps me use type hints without depending on circular dependencies\n\nI have a real-world project with a circular dependency. Please take a look [here](https://www.reddit.com/r/learnpython/comments/162kjgj/a_satisfying_solution_to_avoid_circular/jxxqk79/).\n\n> But the explanation \" I have a lot of experience and we have always done like that \" is not sufficient to give a response to a deep paradigm question about python dealing with dependencies.\n\nThis isn't a case of \"if it works, don't fix it\", but rather a \"from experience I've learned way A does not work, but way B does, so just use way B here instead of way A\". In other words, they're not just saying that because their way works and they're not interested in considering alternatives, the whole issue is that there _is_ no other way that wouldn't result in spaghetti code. And our problem is trying to convey that so that those after us understand that which, clearly, doesn't seem to be working out.\n\n> Why can't we set loops (=circular dependencies) in the dependencies graph when it would be much more satisfying than having a classic tree-shaped dependencies graph.\n\n> Furthermore, it his possible to do so, because of the possibility to gather manually all dependencies creating a loop in a single file. But it gets worth as the files are getting longer.\n\nI don't understand your reasoning. A circular dependency clearly indicates that the program is halting because it cannot fully initialise the stuff it needs, caused by the program compilation step becoming stuck.\n\nIf file A depends on file B, and file B depends on file A, when you import file A in your program, Python begins to parse through it an finds that it needs to import file B. However, because file B needs things from file A, and file A hasn't finished importing yet because it's waiting for file B, the program gets stuck.\n\n...Perhaps a more concrete example is in order.\n\n    # user.py\n    from computer import Computer\n\n    class User:\n        def __init__(self, name: str):\n            self.name = name\n            self.computer = Computer(users=[self])\n\n\n    # computer.py\n    from user import User\n\n    class Computer:\n        def __init__(self, users: list[User] | None = None):\n            self.users = users if users is not None else []\n\n        def print_usernames(self):\n            for user in self.users:\n                print(user.name)\n\nThis would fail, because no matter which file you import first, they both need Python to read the entire other file before being able to be imported themselves, and unless you can show me an example of designing an import system that wouldn't need a tree-like design I have no idea what you're getting at.\n\nThe way you need to approach these problems is to think about what information you actually need, and where. If you don't actually need multiple modules sharing data, then don't - you could use abstract interface classes, dependency injection, or similar approaches to handle it. And if they're tightly coupled and you can't de-couple them, keep them in the same file.\n\nFor example, in the example above it would make sense to just remove `User`'s dependency on `Computer` and let it as the \"parent\" to handle everything.\n\n> So the question: why can't we have many file acting like one, with a function to gather them ( carry for instance )\n\nFrom a purely theoretical standpoint, it's not impossible. C#, for example, has partial classes where you can define their methods across multiple source files. The problems arise when you actually need to import something, because in Python every module has its own namespace.\n\nWell, for instance in your example, `misc2` is clearly tightly coupled with `signature`, so I see little reason to keep them separate. I wouldn't call these \"miscellaneous\" functions any more, they're clearly designed to work with your `signature.Signature` subclass.\n\nWhile I'm talking about this project of yours, its structure in general is a little confusing. Why do you have a top-level `__init__.py`, and why is it trying to have you import the Git repository root directory as a package? Generally the root would just contain metadata, with `pyproject.toml` telling Python how to install the contained package(s). I mean, right now even the `docs` and `tests` are included.\n\nTalking from my experience it is good to stay away from circular dependencies and I cannot recall any counterexample. One could think about dependencies between modules in the hierarchical (tree) way. And the metric for creating such trees is the level of abstraction of a given entity. So you compare how much \"low level\" is the module and if it should import another module that seems to have a pretty \"higher level\" of abstraction. In your case, let me rename \\`Computer\\` to \\`UsersComputer\\` since that seems to be the purpose of this class. Having that, we can easily state that the \\`UsersComputer\\` is more \"high level\" than \\`User\\` and any logic of doing something with \\`UsersComputer\\` should not be placed in the \\`User\\` class. Not following this rule can bring some problems. In the example, you dont have coherent \\`Computer\\` -> \\`User\\` relations since \\`ComputerInstance1\\` could have \\`John\\` and \\`Paul\\` as users, and the user \\`Jenny\\` could have \\`ComputerInstance1\\` as a property and the code allows that. Then you need additional checks or any additional logic that make code more complex.\n\nThe code works correctly by moving `from computer import Computer` below the User class. I haven't fully thought it through yet but I think such simple circularity issues can always be resolved by placing the imports at the right spot. For more complex circularity the involved files are that heavily intertwined that they really must be a single file in the first place.\n\nI think OP expects that Python should sort of make two passes, first to treat the source as kind of a header file and grab classes and functions, and then in a second pass to fill in the code. That's not what is happening of course because Python code is way too dynamic and importing a file literally just executes its code from top to bottom.\n\nMany things to say here. As you say in the end, it is a purely theoretical standpoint. So 'experience' does not add up here.\n\n> the whole issue is that there is no other way that wouldn't result in spaghetti code.\n\nBut their is a solution. If I can gather modules that create a circular dependency in the same file by myself, Python can do it, and it will work. It just need a specific function: why not *carry ?*\n\nI understand very well why *import* stuck the system at circular dependencies. That's why I suppose the existence of another function. \n\nThen you are asking me for an example of design needing this circular dependency. But your is fitting perfectly.\n\nNote that if your intricated classes where in the same file, it would works perfectly.\n\nremoving User dependency on Computer would mean that User.computer is not an instance of Computer... Even if the Class Computer exists... This isn't satisfying. If you mean to change it to an object and deal with it as is, it would work, but it still ugly.\n\nSo then, why not keeping them in the same file ? Multiply your class numbers by ten, every one intricated with others. Then you understand why you don't want a 1000 lines file.\n\nThen, when the minimal number of classes is sufficient for the pure logic of the algorithm, more Abstract Classes just to avoid circular dependencies are unpleasant.\n\nIt is why python not dealing with circular dependencies sounds bad.\n\nI'm not a big fan of throwing those functions into the `signature.py` file. I generally like to have a separate file for each class, *and* that file is already very long. Plus, I wouldn't say that `split_arguments` is very tightly coupled with `Signature`.\n\nIt's not a bad idea, but it's also not exactly optimal. Ideally, I'd make a file for each class, and then 1 file for all the random functions. That would make every single thing in the module trivial to find. You wouldn't have to ask yourself \"Is `function_foo` most tightly coupled to `ClassX`, `ClassY`, or `ClassZ`?\" every time you're looking for something.\n\n(As for the project-level `__init__.py`, that was committed by mistake. I'll delete it.)", "id": "jxxt0jq", "owner_tier": 0.7, "score": 0.9999999996428571}, {"content": ">I am facing a problem python-ers are facing for ages. And I am very surprised that their is no satisfying solutions for it.\n\nI don't think your premise is correct. The solution to circular imports is well known, and that is to structure the program so that circular imports are not required.\n\nThere are also a number of workarounds to allow circular imports to work, (such as lazy / delayed imports), which I agree are not very satisfying, and are generally discouraged.\n\n&#x200B;\n\n>Considering a complex-structured project with many classes depending one on the other...\n\nIt sounds like refactoring would be a good idea. Break the code down into well-defined modules and packages that represent different components / functionalities.\n\nConsider the principle of separation of concerns. Each class or module should have a single responsibility.\n\nUse design patterns such as Factory, Observer, and Dependency Injection where appropriate. This can help to reduce complex relationships between classes and promote better code organization.\n\nDefine clear interfaces or abstract classes to reduce direct coupling.\n\n&#x200B;\n\n>the only way not to gather them in a single frightening long file is to use tricky modules solutions that leads to very long imports or imports not in the beginning of the file.\n\nThat is, in a nutshell, why your code needs to be refactored and reorganised.", "id": "jxyb9hi", "owner_tier": 0.3, "score": 0.1785714282142857}, {"content": "https://docs.python.org/3/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module \n\n> Circular imports are fine where both modules use the \u201cimport <module>\u201d form of import. They fail when the 2nd module wants to grab a name out of the first (\u201cfrom module import name\u201d) and the import is at the top level.\n\nAnd so the import syntax is getting longer uselessly.\n\nOne could say that \" that's not that important, do with longer syntax\", but it matters\n\nThat's a bit misleading.\n\n> Circular imports are fine where both modules use the \u201cimport <module>\u201d form of import.\n\nThe imports themselves may be fine, but you'll still get an error if you try to \"grab a name out of\" the module. Something like `module.name()` in the global scope will crash your program. You can *sometimes* avoid circular import problems by replacing a `from x import y` with a `import x`, but not always.\n\nI think this is the right answer. I don't understand why it should work in the form  \"import module_a as a\" and not in the form \"from module_a import function_a\", though.\n\nYou ask\n\n> Do you know if such a function exists? Do I have to do it myself?\n\nwhich implies that you're willing to go to great lengths (lots of letters) to pull this off. Now the solution turns out to be quite straightforward after all but you complain about writing a couple more letters? Can you give a concrete case with two files where things don't work out due to circular dependencies. Keep in mind that the behavior of import is pretty close to copypasting the contents inside the current file so depending on your needs you must place the import at the right spot. E.g. file a.py\n\n    class MyClass: 1\n    import b\n\nFile b.py:\n\n    from a import MyClass\n\nThis works fine because Myclass is defined before the circularity kicks in. Any other situation that bothers you?\n\nOh yeah it just defers evaluation which might be enough for many purposes.\n\nI haven't looked into the code but I suspect it's similar to how\n\n    def f():\n        g()\n\nis always valid even when g is not defined (yet). The system will complain though if you ask for g right now:\n\n    def f(g=g):\n        g()\n\nWhat if MyClass needs to call something in File b?\n\nMmmh it's not my area of expertise really. I guess we could do something like this:\n\n    from b import f\n\n    class MyClass:\n        def func(self):\n            f()\n\n    MyClass().func()\n\nAnd\n\n    def f(): print(5)\n\n    from a import MyClass\n\n(which will print twice due to the import unless we filter by \\_\\_name__). I mean the issue of circularity even exists if we put everything in a single file. Things must be defined before they can be accessed. Ideally we would have header files I guess. If you want to finely intertwine two files it would make more sense to put everything in the same file.", "id": "jxxuhm8", "owner_tier": 0.3, "score": 0.3928571425}, {"content": "Not sure i understand the question/problem but i noticed you  talked about something like this:\n\n```python\n#file1.py\n\nfrom file2 import test2\n\nclass test:\n    def p1(self):\n        i = test2()\n        i.p2(self)\n\n    def hello(self):\n        print(\"hello\")\n```\n\n```python\n#file2.py\n\nclass test2:\n    def p2(self, test_obj):\n        test_obj.hello()\n```\n\nWhat i just did was to pass the class object into another function, now the class is accessible from that function.\n\nIt's almost that. Just add a an import for file1 in file2 and you have a typical circular dependency.\n\nA solution is to gather themselves in one file, so you don't need imports, but this solution get worth as the file length increases. Furthermore, I don't find other solutions including imports satisfying, due to syntax length and counterintuitive behaviour.\n\n&#x200B;\n\nThat's why I am looking for something as the carry function described before\n\nWhat i just showed does that, file2 calls the hello function in file1 even tho file1 already imported file2", "id": "jxxnqdp", "owner_tier": 0.1, "score": 0.1071428567857143}, {"content": "I am figuring out that my question ask for a more general one. Can the dependency graph contains loops? And if so, can we set a carry function that interprets this loop as a comprehensive module, so we have our tree shaped dependency graph again ?", "id": "jxxt92u", "owner_tier": 0.1, "score": -3.571428549723318e-10}, {"content": "The most satisfying solution I have found to avoiding circular dependencies is not using a programming language that inherently devolves itself into a spaghetti fest of cryptic error throwing nonsense without needing to spend an excessive amount of extracurricular time on going through the ironically circular and non-evolving process of troubleshooting and discussion of refactoring and tons of potential workarounds. If you need to have decades long discussions and develop decades worth of workarounds to \"solve\" a singular issue, you have actually not \"solved\" anything. The people will hate my message the most because it's true.", "id": "lamovdq", "owner_tier": 0.1, "score": -3.571428549723318e-10}, {"content": "After reading the comments here, I have a toy question.\n\nSay, I have a Cat class and a Dog class. Cats have a list of Dog friends, and Dogs have a list of Cat friends. Shouldn't Cats and Dogs have their own separate files in Python?", "id": "jy1tnir", "owner_tier": 0.3, "score": -3.571428549723318e-10}, {"content": "In general it is better practice for classes and modules to form a dependence hierarchy and sticking to the 'S' in SOLID principles as classes and functions with too many responsibilities are very difficult to revisit for maintenance.\n\nThat said, there are some situations where small cyclic dependencies may be beneficial when a hierarchy of object instances has predetermined types and needs to be traversed both up and down. Since Python is dynamically typed there is no need to import a class definition to use it, but for highlighting and type analysis tools you can use TYPE_CHECKING:\n\n\nstudent.py\n```\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from teacher import Teacher\n\nclass Student:\n    def __init__(self, subjects):\n        self.teacher: Teacher | None = None\n        self.subjects = subjects\n```\n\nteacher.py\n```\nfrom student import Student\nfrom typing import Sequence\n\nclass Teacher:\n    def __init__(self, students: Sequence[Student]):\n        self.students: list[Student] = list()\n        for student in students:\n            self.add_student(student)\n    \n    def add_student(self, student: Student):\n        student.teacher = self\n        self.students.add(student)\n```", "id": "kae2vlp", "owner_tier": 0.1, "score": -3.571428549723318e-10}], "link": "https://www.reddit.com/r/learnpython/comments/162kjgj/a_satisfying_solution_to_avoid_circular/", "question": {"content": "Good morning,\nAs written in the title I am facing a problem python-ers are facing for ages. And I am very surprised that their is no satisfying solutions for it. \nConsidering a complex-structured project with many classes depending one on the other, the only way not to gather them in a single frightening long file is to use tricky modules solutions that leads to very long imports or imports not in the beginning of the file.\nI am looking to get out of this situation, having a function such as myclass = carry(file, myclass) that replace the \"from file import myclass\" with a different behaviour: every file element ( class, function, variables ) are carried once, and running any of those would be similar to run them together as they where in a single file.\n\nDo you know if such a function exists? Do I have to do it myself?\nThanks for your time reading this.", "id": "162kjgj", "title": "A satisfying solution to avoid circular dependencies", "traffic_rate": 153.13037037037037}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "Only tangentially related to the article, but it mentions sys.exit() being called on an error condition. I think this is the absolute most annoying thing a library can do. Unless I'm calling a \"clean up and shut down\" function, libraries shouldn't be killing my interpreter. \n\nA few years ago I was working with the python Netflix bindings, and they had a condition where this happened. I filed a bug report, and eventually forked the library to make it act like a decent library. The original was provided by Netflix, so I was surprised that it didn't follow better development practices. \n\nActually, it really was `raise SystemExit(...)` rather than `sys.exit()`. But I certainly believe that no library should do such a thing.\n\nYou think that's bad? The Gtk library will cause a SIG error terminating the program from the C side if it can't find the settings under the DBus path specified by your app when you create a GSettings object. It won't tell you there was an error fetching the settings, it just terminates the whole thing.\n\nI didn't know one should not do sys.exit on libraries... Good to know\n\nFabric does this with fabric.api.local(cmd_str). I was using it in a distributed production environment. Lame.\n\ndoesn't `sys.exit()` just raise `SystemExit()` anyway?\n\nThe PulseAudio library did a [silent system exit](http://ubuntuforums.org/showthread.php?t=612606) if it could not allocate memory. Useful! I mean, how are you going to play those mp3s without available memory?\n\n[deleted]\n\nYes.\n\nIn Python, `sys.exit` doesn't instantly kill your program, it just raises a `SystemExit` exception. You can handle that exception outside the library code in the normal way if you want to.\n\nIt's important to allow for this if you have a top-level error handler that catches and logs all otherwise unhandled exceptions, or anything along those lines.\n\nWhether raising `SystemExit` is an appropriate behaviour for library code either is a different question, but it's certainly not the same situation as, say, a C library just quitting out without giving the calling code any say in the matter.\n\nBut its not as simple as you say. Its not a standard exception in the sense that it doesn't inherit from the \"Exception\" class. Therefore:\n\n    except Exception as e: \n\ndoesn't catch SystemExit and KeyboardInterrupt. So I'd still argue its bad API design to use SystemExit as its not a standard Exception", "id": "cgknpzr", "owner_tier": 0.7, "score": 0.9999999999315068}, {"content": "Sometimes it's a choice between \"do something at import time\" or \"deal with an endless flood of mailing list posts from stupid users who don't read the docs\". So, yeah.\n\nGot a concrete example? I'm interested in it; perhaps something could be improved without import side-effects.", "id": "cgkz20d", "owner_tier": 0.5, "score": 0.027397260205479453}, {"content": "This is interesting. I just redesign my classes, such that all class instantiation and any code plumbing will reside in __init__.py (naturally). I will take this as a precautious", "id": "cgkn8uu", "owner_tier": 0.1, "score": 0.006849315000000001}, {"content": "Ha, screw that.  All my modules will now make syscalls and change the state of the system kernel in random and unpredictable ways.  Ah hail inappropriate use of ctypes.", "id": "cgltl0d", "owner_tier": 0.7, "score": 0.006849315000000001}, {"content": "It seems to me that any reasonable person would wrap any side-effecty code in an import in a try-except to allow for graceful failure. I routinely compile Cython code from the \\__init__.py of a module but provide fallbacks if Cython isn't available or compilation fails for some other reason. Is this bad practice? Seems to me there's no real downsides as long as you are careful.\n\nIf the failure results in an ImportError that's one thing, but if importing the module can cause a segfault (I'm looking at you, gtk / gi.repository.Gtk) then that's bad. Opening windows, writing to stdout/stderr instead of a logger, or even just not returning promptly could be bad in their own way.\n\nYou people have been programming in Python so long, you forgot what a segfault is. This isn't something intentional that they can avoid, like raising an exception, this is a legitimate bug in the code.\n\nIt's going to always happen when you import C libraries that haven't been tested for millions of years. \n\nSure, but if you'll be working with a C library that has potential to segfault, wouldn't you want to know during the import rather than halfway through some important task?\n\nThe problem with GTK (and related things) is that there are two official mutually incompatible versions of the bindings that can interfere with each other. I don't think it's too much to ask to detect if the other version has been already been imported and raise an ImportError.\n\nWell, if you're able to fix it so that it doesn't segfault on import, sure, otherwise you wouldn't be using it still.\n\nMy point is that there is no practical way to say that in this section of the code, it does not seg fault. You might run into it regardless of what you think, and coded for. If you're working with a C library, it might just happen anytime you call it.\n\n> but if you'll be working with a C library that has potential to segfault, wouldn't you want to know during the import rather than halfway through some important task?\n\nThe answer to this question is actually not black and white.\n\nSometimes a library that you include for purpose X imports a library for purpose Y that you actually do not need for your program. This help(\"modules\") example is the most extreme case, but not the only case.\n\n[deleted]\n\nNo, that makes complete sense if it's a known issue. I'm just trying to make the point that a fatal error like a segfault is separate from the usual Python exception that you can handle, and they're guaranteed when developing in C. It's not necessarily something you can avoid in the same way that the article talks about side effects when importing modules.\n\nWell, at least they fixed one of them.", "id": "cgkp3jq", "owner_tier": 0.5, "score": 0.19178082184931505}, {"content": "Useful exception:\n\n    from __future__ import print_function\n\nThat doesn't have side-effects outside the module being imported, so it's fine. Under my classification, it does not have side-effects.\n\nYou're right. I was misunderstanding there. ", "id": "cgkpk4c", "owner_tier": 0.3, "score": 0.06849315061643835}, {"content": "Question: What about classes that auto-register subclasses in some sort of repository or other data structure?  Those class declarations have global side effects, but this is one of the commonest use cases for metaclasses.  The easy way out is to always put all the subclasses in one module, but that's unrealistic in the general case.\n\nThis past couple of weeks I've been writing code that actually does exactly that. Given that it is still all contained in the one area which I own, and that it doesn't cause any things to *break* (though it may be done in such a way that importing a thing twice does explode where it normally wouldn't) I don't consider that *terribly* bad, though it's more magic than I'd like.\n\nExtra tip: often (though not always) registration metaclasses can be replaced by looking at the subclasses of an object\u2014`MyType.__subclasses__()` gives you all the direct subclasses (apply recursively to get all descendants).\n\n> Extra tip: often (though not always) registration metaclasses can be replaced by looking at the subclasses of an object\u2014`MyType.__subclasses__()` gives you all the direct subclasses (apply recursively to get all descendants).\n\nThat's a good idea in the general case, but if you want to allow a potentially unbounded number of subclasses (i.e. if the client of your API decides to subclass `MyType` a lot), that recursive operation is going to get expensive.", "id": "cgl3nqx", "owner_tier": 0.7, "score": 0.020547945136986302}, {"content": "I came across this interesting example recently, where an import side-effect deadlocked the interpeter.\n\nIf you use Gevent 1.0, and you import a module that causes, as a side-effect, the resolution of a domain name, you can deadlock:\n\nhttps://jira.mongodb.org/browse/PYTHON-607", "id": "cgl5emn", "owner_tier": 0.1, "score": -6.849315026866637e-11}, {"content": "I know I'm being pedantic, but `import` is meant to have side-effects, ie. dropping a whole bunch of things into the namespace. I would humbly submit that anything that requires no side-effects is probably using the wrong tool here.\n\nThat ain't a *side*-effect; that's the designed effect.\n\n[deleted]\n\ni agree with you on this\n\nThis thread has been linked to from elsewhere on reddit.\n\n\n - [/r/SubredditDrama] [from nerd.argument import slapfight: Minor drama in /r/python about what a side effect is.](http://np.reddit.com/r/SubredditDrama/comments/22axlm/from_nerdargument_import_slapfight_minor_drama_in/)\n\n\n*^I ^am ^a ^bot. ^Comments? ^Complaints? [^Send ^them ^to ^my ^inbox!](http://www.reddit.com/message/compose/?to=totes_meta_bot)*\n\n\n\nIn programming, a side-effect is anything other than a return value.\n\nI know, but I don't think that matters. `import` changes the state of your app, by design.\n\nin functional programming maybe, elsewhere it's the desired effect vs. anything else that happens.\n\nInserting names into the namespace is fine, running code that can crash, throw errors, launch the nukes, or anything else is not. His point isn't about side effects in the haskell sense. \n\nWell, I said I was being pedantic. I don't think importing a module should do those things (except perhaps display warnings - I think that's fine). But I think that if we're talking about best practices, importing modules in order to inspect them would not usually qualify.", "id": "cgknlvt", "owner_tier": 0.5, "score": 0.1027397259589041}], "link": "https://www.reddit.com/r/Python/comments/229f7q/say_no_to_import_sideeffects_in_python/", "question": {"content": "", "id": "229f7q", "title": "Say \u201cno\u201d to import side\u2010effects in Python", "traffic_rate": 207.942496260595}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "When a package contains multiple submodules, the \\_\\_init\\_\\_.py file in the top-level directory can be left empty if you want to make all the submodules available when you import the package.", "id": "irbb9tg", "owner_tier": 0.1, "score": 0.9999999900000001}, {"content": "So, when you import a module it basically executes the whole module which means declaring functions and classes.\n\nFor the auto imports part, this is all your editor's doing.\n\nSo, when you import a module it has to load it. But once is load it there's no additional cost of importing it. So if B imports C, importing C on A will only make it available in the A namesoace. Otherwise it won't know where to load the functions from even if it has been imported once.", "id": "irboiny", "owner_tier": 0.5, "score": -9.99999993922529e-09}, {"content": "I believe you only have access to whatever you import within each script file.\n\nOf course, if you expose the module via member variables, or in other ways, you can share the module declaration in a wider scope. I do this very occasionally when I want to allow different modules with identical interfaces all over the place.\n\nI think I have actually done this exactly once actually. It is odd, but possible.", "id": "ircj9kn", "owner_tier": 0.5, "score": -9.99999993922529e-09}], "link": "https://www.reddit.com/r/AskProgramming/comments/xxcgjf/python_when_do_i_need_to_import_a_module_when_its/", "question": {"content": "I'm noticing some inconsistent behavior and I'm trying to understand the rules. \n\nIf i'm writing script A. Script A imports from script B. Script B imports script C. \n\nIf my understanding of importing is correct, when you import a script, you might as well have copied and pasted the entire script at the beginning of your module (which is why any methods you don't want to be called immediately get put behind a \"if name == main\" line). \n\nSo if script B imports script c, and script A imports script B, does script A need to import script C?\n\nSometimes it seems I can get away with it. Othertimes it either yells at me or automatically adds the import at the top. \n\nJust today I did something that worked, realized i forgot to make a new branch, reapplied my work, and now it isn't functioning. \n\nI just can't seem to figure out when I need to add an import when that module was already imported by a mutual import.", "id": "xxcgjf", "title": "[Python] When do I need to import a module when its already imported by a different module", "traffic_rate": 28.025540679711636}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "One approach that can work is using a submodule git configuration, this might help explain it: https://shunsvineyard.info/2019/12/23/using-git-submodule-and-develop-mode-to-manage-python-projects/\n\nWell, depending on if I understood the post anyway. If this is more like a circular import problem, you'll probably want to redesign the structure of your project(s).\n\nAnd Poetry will work fine, as long as `pyproject.toml` uses the Poetry masonry core API (which it does by default nowadays) anyone can install the project even if they don't have Poetry installed.\n\n> One approach that can work is using a submodule git configuration, this might help explain it: https://shunsvineyard.info/2019/12/23/using-git-submodule-and-develop-mode-to-manage-python-projects/\n\nI think we're okay with having both package directories in the same repository. The bigger concern is (1) making sure that we have separate testing environments for separate packages and that we can switch into and out of them and (2) develop them using the local (not yet published) version of the other package.\n\n> Well, depending on if I understood the post anyway. If this is more like a circular import problem, you'll probably want to redesign the structure of your project(s).\n\nNo it's not a circual import problem. The dependencies aren't cyclical.\n\n> And Poetry will work fine, as long as pyproject.toml uses the Poetry masonry core API (which it does by default nowadays) anyone can install the project even if they don't have Poetry installed.\n\nThis is great to hear. Leaning towards Poetry\n\nThen I'd suggest treating them separately, even if they \"physically\" exist in the same place.\n\nAt work we have a project that has a sub-project meant to control the first one, both with their own installation and dependency files. You could, for instance, have two `pyproject.toml` files, one for each project, and in the main project you can have a Makefile that builds both into wheels (if needed).", "id": "hbzbqi2", "owner_tier": 0.7, "score": 0.9999999966666667}], "link": "https://www.reddit.com/r/learnpython/comments/pjur5l/how_to_develop_multiple_interdependent_python/", "question": {"content": "What I'm looking for:\n- Developing multiple Python packages in tandem\n- The packages have interdependencies among themselves (EDIT: I didn't mean interdependencies - they have dependencies but the dependencies are *NOT* cyclic)\n- Will publish to PyPI (or Conda) for easy install\n- All code is pure Python\n- No complex build step for any of the packages\n- Willing to use something like poetry as long as package users don't have to use poetry themselves\n- Separate testing environments for the different packages\n\nAny input/utorials/docs/blog posts/tools/sample repositories would be appreciated.", "id": "pjur5l", "title": "How to develop multiple inter-dependent Python packages?", "traffic_rate": 153.17222222222222}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "Observe:\n\nGiven a `functools.py`\n\n    def partial():\n        pass\n\n    def something_else():\n        pass\n\n    print('unrelated to partial')\n\nthen\n\n    >>> import functools\n    'unrelated to partial'\n    \n    (restart)\n\n    >>> from functools import partial\n    'unrelated to partial'\n\nPython has to execute the entire module in order to even import a single name from it (it doesn't know the names until it is executed!), so you're not saving anything by just importing `partial`.\n\nok thx", "id": "cnlfvp1", "owner_tier": 0.3, "score": 0.6666666633333334}, {"content": "import functools", "id": "cnlcf30", "owner_tier": 0.1, "score": -3.3333333130750966e-09}, {"content": "It isn't necessary. Also it isn't possible either, since your question is trying to do two mutually exclusive things.\nTaken literally I can answer you like this\n\n    import functools #importing the namespace \"functools\"\n    from functools import partial #importing only partial from functools\n    #Observe the functools namespace is preserved\n\nThus your question is answered, if there happens to be some reason you want to import the function only while keeping the namespace like interface.\n\n    class functools(object):\n         from functools import partial\n\nYou could do that, but I wouldn't recommend it,. Since it's just plain over engineering, I can think of times this method can be used, like if you want to create a wrapper for other commonly used functions scattered around different modules, but that itself might not be as efficient as you could hope for, definitely don't do that if you expect real time performance. Now that I think of it, there really aren't that many uses to the solutions to your problem, But I'm suspecting that you actually just want to find out how far python can bend, so go ahead experiment if you like, just don't forget those experiments laying around on your desktop. ", "id": "cnlp48n", "owner_tier": 0.1, "score": -3.3333333130750966e-09}, {"content": "import functools.partial\n\nMe thinks you didn't try that one:\n\n    >>> import functools.partial\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    ImportError: No module named partial\n\n\nCaught me.  I did not check it first.\n\nyeah that would only work if you go import module.module\n\nCan anyone tell me if it works in python3 though?\n\n`import spam.eggs` works in Python 3 provided spam is a package and eggs is a module.\n\n`os.path` appears to be a weird exception and I don't quite understand how it works:\n\n    py> import os.path\n    py> import os\n    py> os.__package__\n    ''\n\nEdit: that means that `import functools.partial` won't work.\n\nedit again: it works because the `os` module includes this line:\n\n    sys.modules['os.path'] = path\n", "id": "cnlbt7y", "owner_tier": 0.1, "score": 0.9999999966666667}], "link": "https://www.reddit.com/r/Python/comments/2s1n9a/how_do_i_import_only_partial_from_functools_while/", "question": {"content": "So i don't want to import the whole functools.\nbut if i do \"from functools import partial\" then i will have partial in the module namespace. i want to keep it as functools.partial.\n\nhow doth one doeth that?", "id": "2s1n9a", "title": "How do i import only partial from functools while keeping the functools namespace", "traffic_rate": 207.97124813029748}, "saved_time": 1721102465, "source": "reddit", "tags": []}, {"answers": [{"content": "\r\n    What you are using is definitely an antipattern. Allowing cyclic dependency between DLLs is a bad idea not only in case of DLLs but also in case of static libs. If 2 DLLs reference each other then they keep each others reference count on 1 btw, that isn't the end of the world because you probably end their life with ExitProcess at the end.\r\nChange your project this way: You have lib1 and lib2. Let only lib1 to depend on lib2. To communicate back from lib2 to lib1 do the following: Define an interface in your source code that is visible to both libs. In lib1 create an implementation of this interface. When lib 1 communicates to lib2 for example by calling lib2::Init() you pass an interface pointer to lib2 so lib2 will be able to call code inside lib1.\r\n", "id": "2_625043_1", "owner_tier": 0.3, "score": 2.0}, {"content": "\r\n    I have done this type of thing before.  It is a bit of a pain but it can be done.  I will describe the linkage between 2 DLLs, which I think you can generalize.  Set up the linkage so that A.dll compiles and links properly to B.dll.  In B.dll, use function pointers to the A.dll APIs, and when you need to call A.dll from B.dll, have stub code for each API call do a LoadLibrary on A.dll and lookup the API(s) with GetProcAddress().  This bookkeeping only needs to be done once and can be cached in a static table.  Use of extern \"C\" linkage in A.dll is not mandatory but will simplify the name lookup mess.\r\n", "id": "2_625046_1", "owner_tier": 0.3, "score": 3.0}], "link": "https://www.codeproject.com/Questions/625018/Mutually-dependent-Dlls-built-in-Visual-Studio", "question": {"content": "\r\n\t\t\t    I am building 9 32bit Dlls under a Visual Studio solution. \r\nFor the sake of argument each one of them is dependent on all the others. In other words each one imports symbols from the other 8 and exports symbols imported by each of the other 8.\n\r\nAt the moment I do this by having 2 build configurations. The first tries to compile and link all the dlls.\r\nAll the compilations succeed but of course all the linking fails. The build however outputs .exp files and .lib files for each DLL\n\r\nThe second configuration is then run which compiles everything again and then ignores most of the files it's just made and links the libs and export files from the first configuration to build the actually Dlls.\n\r\nThis works but it is a horrible hack and takes twice as long as necessary.\n\r\nWhat I need is a way to either get Visual Studio to sort this out for me or to stop the first configuration from trying to link and the second configuration form wasting its time compiling everything again.\n\r\nI asked a similar question in the VS forum about a year ago and was told that this could be fixed by using the project dependency settings. It can't, as you can't create circular dependencies.\n\r\nWhat I'm doing is the same as described here[^] but with Visual Studio.\r\n\t\t    ", "id": "625018", "title": "Mutually dependent Dlls built in Visual Studio", "traffic_rate": 0}, "saved_time": 1721102465, "source": "codeproject", "tags": ["C++", "Windows", "Visual-Studio", "VS2010"]}, {"answers": [], "link": "https://stackoverflow.com/questions/744373/what-happens-when-using-mutual-or-circular-cyclic-imports", "question": {"content": "In Python, what happens when two modules attempt to import each other? More generally, what happens if multiple modules attempt to import in a cycle? See also What can I do about \"ImportError: Cannot import name X\" or \"AttributeError: ... (most likely due to a circular import)\"? for the common problem that may result, and advice on how to rewrite code to avoid such imports. See Why do circular imports seemingly work further up in the call stack but then raise an ImportError further down? for technical details on why and how the problem occurs.", "id": 744373, "title": "What happens when using mutual or circular (cyclic) imports?", "traffic_rate": 80}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "python-import", "circular-dependency", "cyclic-reference"]}, {"answers": [], "link": "https://stackoverflow.com/questions/74020217/how-can-i-have-two-modules-interact-with-each-other-without-having-a-circular-im", "question": {"content": "I am making a small game with several files including : Entity.py , Map.py. I want Map to be able to manage an Entity position, so I have to import Entity in Map, but I also want Entity to be able to know the map on which it is, so I have to import Map in Entity. Obviously this leads to circular imports, and I know a lot of answers to this problem is \"You just have to modify your design pattern\" and ofc I could do that, but I want to know if there is a way in python to have this kind of structure that I got used to be able to use in Java.", "id": 74020217, "title": "How can I have two modules interact with each other without having a circular import on Python?", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "circular-dependency"]}, {"answers": [], "link": "https://stackoverflow.com/questions/70805354/how-to-setup-imports-and-dependencies-between-modules-in-the-same-python-package", "question": {"content": "I am writing a library in python. It has one package and 3 modules, such as If I just leave the __init__.py empty, my users must figure out which functions are in which modules, which is annoying. The fact that I have three modules is an implementation detail that is not important. Maybe I should import the main functions into the __init__.py, like this so that my users can just do Is that best practice? What about the alternative to put ALL symbols into the __init__.py, such as And if there are any functions that I don't want to expose, I will prefix them with underscore. Is that better?  It certainly is easier for me. What if the fileio.py needs to call some functions in the utils.py?  I could put into the fileio.py, but won't that create a circular or redundant reference? What's the best way to handle this?", "id": 70805354, "title": "How to setup imports and dependencies between modules in the same python package", "traffic_rate": 1370}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "module", "package"]}, {"answers": [], "link": "https://stackoverflow.com/questions/28800006/python-import-of-modules-with-mutual-dependency", "question": {"content": "I have two files rest_api.py and Contact.py. Contact is similar to a domain object (contains Contact class), while rest_api has functions for setting up the application. In rest_api I have the following lines: In Contact I try to do the following: This fails with the following error:\nImportError: cannot import name Contact What is the correct way of importing contact, so that it can also use variables/functions from rest_api? p.s If I move the collection code to a different file, and import that file instead things work, but I assume there is some other way..", "id": 28800006, "title": "Python: import of Modules with mutual dependency", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python"]}, {"answers": [], "link": "https://stackoverflow.com/questions/59977711/python-import-module-which-need-to-import-other-module", "question": {"content": "I made a module that makes a linear regression model and draws a graph.\nSo the module needs to import some packages such as sklearn and matplotlib.\nAnd I want to import this module to another python file and use it. I think either of the two python files needs to import the above packages..\nwhich of them needs to import? In below case, my_module.py should import LinearRegression? or my_module2.py should? ex)", "id": 59977711, "title": "Python - Import module which need to import other module", "traffic_rate": 78}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "import", "module"]}, {"answers": [], "link": "https://stackoverflow.com/questions/44538400/how-do-i-import-files-that-mutually-import-each-other", "question": {"content": "how do i import a function and a dictionary that mutually imports each other. These two files are already in the same directory thus, there is no nid to import sys. Also, i this it is recursive that is why it is unable to import. How do i import a dictionary from each other's file without making it recursive and causing an error? I did go to this website here but it did not answer my question nor did it provide any example code to guide me thus, i created this question with a test code to explain my issue. let's say i have these two files: boxA and boxR, each has a dictionary keyA and keyR and functions named generatekeyA and generatekeyR in boxA: in boxR: Let me explain the codes above. I have 2 files that generate keys for me after which, i have to export the output into a json file. output.json file prints out keyA's own serial no and secret id and only keyR's secretid and viceversa into output2.json file. but the thing is that eventhough i research on recursive outputs, i still do not understand how to fix it because it does not provide any sample code as a guide. What is the best way to approach this such that i do not have to make much changes to the file(s)? Error tells me that it could be a recursive error:", "id": 44538400, "title": "How do i import files that mutually import each other?", "traffic_rate": 3808}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "python-3.x", "dictionary", "recursion", "tinydb"]}, {"answers": [], "link": "https://stackoverflow.com/questions/32829691/python-modules-partially-importing-from-each-other", "question": {"content": "I'm breaking up a large-ish (for me anyway!) project into 2 or 3 modules, including a 'main' module with the top level menu etc.   It will import a two or three 'sub-modules' for different aspects of the application.   However those modules will need various settings etc from the main module.   Yes, they could be passed as arguments but there are quite a few of them and they are liable to change.  Different modules will need different sub-sets of the settings. I'd like to be able to have the subordinate modules simply 'reach back' for their settings as needed (sort of global across modules as it were). Here is a mickie-mouse example of what I mean: test1: test2: And the results is Presumably this is due to potential circularity.  (Though, if its able to detect the circularity - not hard in this case!, ie that taskA has already been imported, you'd think its able to simply break out of the circularity, as opposed to throwing an error).  Is there a way to achieve this?   There's several obvious ways to code around it - keep it as one module; pass the settings as arguments (but that will have pitfalls if 'test2' has to modify any of the settings, if only as Im still getting my head around python's handling of mutable objects and binding); move all the settings to a separate module (test0) accessed by both test1 and test2. Given that these modules are intimately connected (I believe the term is strongly coupled), logically it should all be one module.  Except that its getting big.   My question is twofold ... how best to do what I want; but also to understand why Python cant handle mutual imports.", "id": 32829691, "title": "Python modules (partially) importing from each other", "traffic_rate": 9}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "python-module"]}, {"answers": [], "link": "https://stackoverflow.com/questions/11698530/two-python-modules-require-each-others-contents-can-that-work", "question": {"content": "I have a Bottle webserver module with the following line: And the foobar.formtools module contains this line: Of course, both result in the following errors (respectively): ImportError: cannot import name auto_process_form_insert\n  ImportError: cannot import name redirect Is it simply a fact that in Python two modules can't import each other and all module imports must be hierarchical in nature, or am I doing something wrong? Alternatively, is there a workaround short of placing all these nice functions in new modules?", "id": 11698530, "title": "Two Python modules require each other&#39;s contents - can that work?", "traffic_rate": 66505}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "python-module"]}, {"answers": [], "link": "https://stackoverflow.com/questions/9642451/python-files-import-from-each-other", "question": {"content": "I would like for two of my python files to import some methods from each other.  This seems to be giving me import errors.  Example:  file_A.py: file_B.py: The reason I am trying to do this is because I would like to organize my project in the way it intuitively makes sense to me as opposed to organizing it with respect to what makes sense to the compiler. Is there a way to do this? Thanks!", "id": 9642451, "title": "Python files - import from each other", "traffic_rate": 12842}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python", "import", "compilation", "package", "importerror"]}, {"answers": [{"content": "That what u need is a really bad practice accordin to pep8. Dont do it. Its better to import only that what you going to use and nothing more and manual imports are that what should claim.", "id": 72543798, "owner_tier": 0.1, "score": 0.0}], "link": "https://stackoverflow.com/questions/72543383/import-one-module-that-imports-all-other-modules-in-each-module-is-that-sensibl", "question": {"content": "In C/C++ microcontroller programming I got a lot of folders with source and header files. I got one header file (driverlib.h) that includes ALL other header files (Around 50+). In each source (.c) file I just include this driverlib.h file and I don't have to worry about any includes. Otherwise it would be a pain to include a bunch of header files in each source file. Now I want to know, if the same thing is possible in Python. I have got an example project below: Is it possible to create a driverlib.py in the main directory that just imports all other modules and then import it in each module? Like this: driverlib.py player.py in models/:", "id": 72543383, "title": "Import one module that imports ALL other modules in each module. Is that sensible and even possible?", "traffic_rate": 32}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "In flask you can use \u201cblueprints\u201d and the \u201capp factory\u201d pattern to break circular dependencies. https://flask.palletsprojects.com/en/2.2.x/patterns/appfactories/", "id": "iwc8d3f", "owner_tier": 0.3, "score": 0.9999999900000002}], "link": "https://www.reddit.com/r/learnpython/comments/yusmby/how_to_correctly_structure_a_project_in_python_to/", "question": {"content": " \n\nThis weekend i went and started playing around with flask, i was following along with some guy making a crud blog post to get the hang of things, but the video is kinda dated by now and i have been getting circular import errors with pretty much the same code as the lecturer in the video.\n\ninstead of trying to fix just this problem, does somebody know of a guide/article/book/course that explains how to best structure a project in python? my logic here is better to learn the fundamentals instead of asking for examples how to structure every separate project...", "id": "yusmby", "title": "How to correctly structure a project in python to avoid circular imports?", "traffic_rate": 153.13037037037037}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "I design my things so I don't get circular dependencies. Typically the things that require circularity can be spun off to a third module.\n\n+1 \n\nI avoid circular dependencies too. Most of the time they occur because your API is not well organized. If they can't be avoided, I use an import statement local to my function or method.\n\nIn your case, it sounds like you miss another module (util?) that would have a function that return users instances, or whatever the Producer stuff needs.\n\nUnlike some other folks here, I think it's a good practice to split the code in several modules, and avoid having tons of classes in the same module. When it grows, it helps. Ending up with a several-thousand lines module quickly become a nightmare whereas small modules are easier to read, tests etc.\n\nJava \"one class per module\" is a bit too much, but avoiding big modules is better. \n\n\n\n ", "id": "c0p32yp", "owner_tier": 0.7, "score": 0.9574468082978723}, {"content": "Why do they live in separate files when they're so obviously related? Why do you have a method called `User.create` when it seems so useless (reminder: you're not coding in java here)? What the fuck does `UserProducer` do, why isn't it done by `User` or by `User`'s metaclass? If `UserProducer` is supposed to interact with the database and `User` is just a dataholder, why the hell do you not create `User` instances via `UserProducer`? \n\n> I don't want to put them in the same file either, as that would get bloaty quite quickly.\n\nIf two classes in a Python file get bloaty pretty quickly, I say you have issues in your python.\n\nThis. From what the op describes, the API sounds weird and unpythonic. Fix that and the problems will likely go away. \n\n[deleted]\n\n> what does Java have to do with this?\n\nThe instance creation and initialization processes are performed by \"regular\" methods in Python (as in Ruby or Smalltalk), so you generally don't need explicit factory methods (you just override those which already exist). And when you do, you usually use factory *functions* as not everything needs to be a method.\n\nLikewise, the idea that things get bloaty when you have two classes in the same file is a caracteristic of java-thinking, and so's the multiplication of weirdly related classes.\n\nAll in all, OP's comment/query feels a lot like someone's coding in Java, it just happens that the serialization language is Python.\n\nWhen you hear one person ask about how to order a pizza to fight the muchies at 4:20am and a second person tells them to quit smoking pot, do you ask, \"What does pot have to do with this?\"\n\nThe code above exhibits a pathology of the sort endemic to brains damaged by too much Java use. \n\nYou rarely need such explicit factories in Python", "id": "c0p319r", "owner_tier": 0.9, "score": 0.999999999787234}, {"content": "    class User:\n        def create():\n             import UserProducer as P\n             P.verb()\n\n\nSubsequent runs hit the import cache.\n\nyou can also throw the import in __init__() and set self.P = P", "id": "c0p335s", "owner_tier": 0.7, "score": 0.4468085104255319}, {"content": "Move User.create() to UserProducer.createUser().\n\nCode creating user will depend on the UserProducer module. UserProducer depends on User module.\n\n\nThey're sufficiently different that it wouldn't make sense.\n\nUserProducer is basically a database query class. I think I'm gonna have to rename it to UserProducerByEmail or something like that.\n\nThe base class of UserProducer used to be called QueryRunner at some point.\n\nYou must remove the dependency of the user class on the database layer - it does not make sense.\n\nThis stuff is *inside* the database layer. The User class is a proxy for a database object.\n\nOk, your database layer has a class that search users, and a user class.\n\nRemove the dependency from user producer/finder on user. It will return user data from the database, e.g. (name, email, etc.), and the user class will use this data to initialize a user object.\n\nClient code depends on user class, user class depends on user finder to locate/fetch user data, user finder does not depend on user.\n\nThe real question is how to avoid circular dependencies, not how to deal with them in Python.\n\n\nBut using UserProducer from the controller layer is actually very convenient.\n\nFor example, when a user is on the \"forgot my password, please send me a new one via email\" page, he/she will enter her email address and it's convenient to use UserProducer right from the controller to search according to the email address and get a User instance back.\n\nPlus I'm using CouchDB here and I've got strong coupling between the User class and the database. Usage is something like:\n\n    user = User()\n    user.checkout(db_key) # I should rename this to user.pull()\n    datasnap = user.snapshot()\n    if len(datasnap.name.value) == 0:\n        user.write({\"name\" : \"John Doe\"})\n\nWhat I've basically done is designed a DB layer based on CouchDB that looks and feels a lot like using a modern source code version control system like git.\n\nIt actually feels very nice to use. There's an early alpha (I'm successfully using it in a private production system) with zero examples up on github:\n\nhttp://github.com/elver/siil", "id": "c0p3lpn", "owner_tier": 0.1, "score": 0.40425531893617017}, {"content": "You need to avoid using from foo import bar statement.\n\nin your model you can do something like this:\n\n    import app.model.user_producer as mo_up\n\nnow you will be able to use it like mo_up.UserProducer inside other class without any issues.\n\nI have a model that depends on 30 other models at same time, so i can assure you that this works.\n\nAlso as someone mentioned you can import inside a function but i think my solution is better.\n\nI think this is a problem related to the way packages work, not the circular import issue itself. The problem occurs when you mix 'from import bar' with 'import foo.bar' in your package. Using 'from' imports is just fine, just as the absolute imports you suggest, it's mixing these patterns that is the actual problem.\n\nThe problem starts because there might be code in the __init__.py in the package foo that imports from somewhere within the package. If you then import from the package in other modules in that package, you can run into circular import problems as in some cases the __init__.py needs to be loaded to finish the import of 'bar', but __init__.py imports from bar, argh.\n\nThe problem occurs when you mix 'import foo.bar' with 'from foo import bar', however, not if you just use either one of them. This is due to some subtle details of module initialization I can't recall of the top of my head. I looked into it once as some developers have converged on the 'import foo.bar' pattern as a solution to this issue and think it is the *only* solution, but they're wrong. I like my 'from' imports.\n\n", "id": "c0p3045", "owner_tier": 0.5, "score": 0.2553191487234042}, {"content": "\"Doctor, it hurts when I do this.\"\r\n\r\n\"So don't do that.\"\r\n", "id": "c0p3to8", "owner_tier": 0.7, "score": 0.08510638276595744}, {"content": "Hi. `import` statements need not be at the top of the code, you can place them anywhere. In general, if only one function requires a module, place the import inside that function, this may help avoid circular imports.\n\nThis has nothing to do with the problem. Circular imports are only problematic when you use the *from x import y* format. As long as you use only *import z*, you'll be fine with anything circular.\n\nImports should only be at the top so it's easier to see what are the dependancies.\n\nAs inelegant as this sounds, I think you may be on to something.\n\nThis is bad practise.\n\nThis will fail to discover missing modules until well into runtime.  It's ok, but only with a note in the module doc-string to indicate that the import is possible.\n\nUnless the import is delayed because of speed, it's better to import at the top of the module and then bind the variables later.  E.g., instead of\n    def foo():\n        from OtherMod import bar\nprefer\n    import OtherMod\n    def foo():\n        bar = OtherMod.bar\n\nThe problem is a bit more subtle than you are suggesting.\n\nI use 'from x import y' all the time, and I don't get bitten by circular imports very often. I think that's in part because I design my modules not to be mutually dependent anyway (that's good design practice).\n\nThe only case where it's really hard to avoid is when you got a package that does imports from modules in the package in __init__.py, and you do imports in the package's modules too. You can easily get circular dependencies that way, but you only get the import errors when you mix from imports with absolute imports. Consistently sticking to either pattern gets you out of the issue.\n\n\nWhat are you talking about? Python still won't let you have a circular import no matter how you spell it. \n\nI also think that this is a bad practice (I upvoted you). \n\nMost of the time you'd better refactor the code so that there's no circular dependency. But this is a useful trick in case you need to get thing done now, or when a part of third party framework/library is involved in the issue.\n\nYou need to handle missing modules where/whenever they're identified.\n\nWhat's the difference between:\n\n    try:\n        import foo\n    except ImportError:\n        blah\n\n    def bar():\n        foo.baz()\n\nand\n\n    def bar():\n        try:\n            import foo\n        except ImportError:\n            blah\n        foo.baz()\n\nSure it will.  You'll only run into problems if you have code that runs *during the import* that *uses* the objects.\nSo long as each is merely *defining* classes and functions that call it when invoked / instantiated, rather than actually *using* them *during* the import (inheriting from a class would be the most likely possibility), then you'll be fine if they just import each other.  (And don't make assumptions about the name already being there as in the \"from X import Y\" form).  What will happen is:\n\n    your_program.py:\n\n        import user   # Trigger the import of user.\n           <Checks module cache - not there, so:>\n           <Create a new empty module object>\n           <Add this to the cache of modules>\n           <Start executing user.py in this module's namespace>\n\n    user.py:\n        import userproducer\n        <Exactly the same process as above: start executing userproducer.py>\n\n    userproducer.py:\n        import user\n           <Checks for 'user' in list of imported modules>\n           <This time, FINDS IT, and returns it (in its current, empty state)>\n\n        #from user import User  # <- This would fail with a NameError however.\n\n        class UserProducer(object):\n             def getUser(): return user.User() # No problem.  user.User doesn't exist yet, but we don't \n                                               # care so long as its there by the time we are CALLED.\n\n\n        #some_user = UserProducer().getUser()  # <- eg. this would be a problem if uncommented.\n\n        #class SubclassedUser(user.User): pass # <- as would this\n\n        <finish executing module1, resume in module1.py>\n\n    module1.py:\n        <Continue executing, module2 being fully imported now>\n        class User(object): \n             ...\n\n(And of course, it happens the other way round if you imported userproducer first)\n\n\n\nThe first fails on import whether bar is called or not, while in the second case you only discover the failed import when bar is called. Where this really becomes a problem is cases like...\n\n    try:\n        # Something that succeeds 99.9% of the time for the module developer.\n    except:\n        import loging # Note the misspelling.\n        ...\n\nUnit tests *should* catch simple cases, but that's a big \"should.\" The deeper the imports are buried the lower the odds that they're covered.", "id": "c0p2zqt", "owner_tier": 0.5, "score": 0.6170212763829787}, {"content": "How do **you** deal with it?\n\nTears and half a bottle of whiskey.\n\nTears, not so good.  Half a bottle of whiskey, FUCK YEAH!", "id": "c0p3gxo", "owner_tier": 0.7, "score": 0.29787234021276593}, {"content": "I used to think it was necessary but I think I follow hylje's ideas more often now.\n\nThanks for the heads up.", "id": "c0p3tj6", "owner_tier": 0.7, "score": 0.06382978702127659}, {"content": "Circular dependencies are Evil. Here's how to fix'em: \n\nSay you have modules A and B that are circularly dependent. You identify the part that is causing the circular dependency. You can either *demote* that part such that A and B depend on this module C, or you can *escalate* it such that C depends on A and B.", "id": "c0p5kx3", "owner_tier": 0.5, "score": 0.04255319127659574}, {"content": "Reading your situation, I think you've got to suck it up and merge. If there's no hierarchy and neither functions without the other, then don't they belong together?\n\nIt can be done without any big issues. As i replied in other comment ;-)", "id": "c0p2zsc", "owner_tier": 0.5, "score": 0.04255319127659574}, {"content": "To Avoid the bitter experience of this condition, I always \"import\", and never use from\neg\n# from foo.bar import widget << will give problems \nimport foo.bar\nwidget = foo.bar.widget()", "id": "c0p5jy5", "owner_tier": 0.3, "score": 0.021276595531914893}, {"content": "A few solutions work, none are pretty.  All this jumble about poorly designed code isn't always true.\n\n* Put the import into the function that needs it.\n* Move the import to the bottom of the module.\n* Use dependency injection.  ie: pass the class you need into it.\n* Move common functions to a third module (best one IMO).", "id": "c0p4sg6", "owner_tier": 0.7, "score": -2.1276595744680853e-10}, {"content": "Put those entangled classes in same file or glue them together in third file. Need for circular imports means bad design.", "id": "c0p82go", "owner_tier": 0.7, "score": -2.1276595744680853e-10}, {"content": "Use \"from module import object\" statements at the exact position you need them inside functions and methods. Never at the top of modules. You want to use the \"from module import object\" form instead of \"import module\" to avoid polluting the namespace. Remember \"from module import object\" inside functions and methods only. You'll never have to worry about circular imports again. Not to mention, you'll only import what needs to be imported when it's needed and nothing more. This is one trick used to improve the startup speed of applications.\n\n> You want to use the \"from module import object\" form instead of \"import module\" to avoid polluting the namespace.\n\nA little correction, `import module` does not pollute namespace, `from module import *` does.\n\nI didn't make myself clear.\n\nFor example, he should use \n\n    from gtk import Window\n\n**not** \n\n    from gtk import *\n", "id": "c0p4ah4", "owner_tier": 0.3, "score": 0.08510638276595744}], "link": "https://www.reddit.com/r/Python/comments/bxpyo/how_do_you_deal_with_pythons_inability_to_handle/", "question": {"content": "I've got two classes in separate files: User and UserProducer\n\nUserProducer searches through the database based on some criteria and returns matching User objects from it.\n\nUser.create() uses UserProducer to check if any users with the same e-mail address have already registered.\n\nBoth, quite obviously, need access to each other. But if I have them in separate files, then they both cannot import the other.\n\nI don't want to put them in the same file either, as that would get bloaty quite quickly.\n\nWhat would be the Pythonic solution?", "id": "bxpyo", "title": "How do you deal with Python's inability to handle circular imports?", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "I never experienced this problem. When are circular imports a problem? And if there actually are circular dependencies, how would you solve it?\n\nImporting for type annotations does this to me a lot\n\nCode with circular imports in python does not work. I have come across this problem several times, and depending on the project size it becomes problematic to identify where exactly the problem is. This tool shows you the chain of the imports that are causing the problem, it is up for developer to fix it e.g. restructure the imports or move the imports into the function call.\n\n> When are circular imports a problem?\n\nIt could be due to either improper module layout (e.g. classes aren't in the proper place), or because there's an intrinsic strict dependency on two entities that you want to keep separated for other reasons. It can happen. Rarely, but it does, also for legitimate reasons. It can also happen accidentally with a \"long cycle\", that means it's not a direct circular, but two or three modules down the import hierarchy, you happen to import the very same module you started from.\n\n> And if there actually are circular dependencies, how would you solve it?\n\nIn general, when it happens it's because you have a routine (method or function) that needs something. You simply put the import inside it.\n\n\nI've had this in Django where the views of course import the models, and the Celery tasks also import the models, and the views also import the Celery tasks, and maybe you want to start a Celery task from your model's `save` method and -- oops! You've got a circular import.\n\nThe solution is to move one of the import statements into the method that is using it, with an appropriate comment. Personally I would always want the model import at the top of the file if code in the file uses that model. Which means I'd edit the `blog.models` module, moving the `import blog.tasks` from the top into a method.\n\nIt often happens when merging branches in VCS, which is when OP's tool will come in handy.\n\nThe problem and ways around it are discussed in the Python FAQ:\n\nhttps://docs.python.org/3/faq/programming.html#how-can-i-have-modules-that-mutually-import-each-other\n\nhttps://docs.python.org/3/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module\n\n\nYeah I all the time have co-dependent libraries which, due to supporting too many use cases, regularly import from each other in both directions. Usually it's wanting to use classes from one library in another and then wanting to do the same thing in reverse. Like a car lib and a traffic lib each calling into the other for things. If I had a grand plan for how to solve every kind of problem with the API of one or the other library, I wouldn't have the problem, but of course my API is a continual work in progress.", "id": "dd20mrj", "owner_tier": 0.5, "score": 0.9999999996}], "link": "https://www.reddit.com/r/Python/comments/5qtah6/pycycle_find_and_fix_circular_imports_in_python/", "question": {"content": "", "id": "5qtah6", "title": "Pycycle: Find and fix circular imports in python projects", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "Java (and many other JVM languages) supports circular dependencies, with late binding during class loading. There are edge cases, of cause, with class initialization lock, exceptions in initializers and so on. C# and many .Net languages have somewhat similar behavior (can't tell much about assemblies, though).\n\nMain pro is that you don't have to design your code specially to avoid circular dependencies. That really comes into play when you have rather complex data types (such as, say, AST in the compiler).\n\n[deleted]\n\nMy primary experience is with JVM. Do .Net assemblies allow circular dependencies? That is, can you have a class CA assembly AA depending on class CB from assembly AB, and vice a versa?\n\nOops, my bad, my comment was talking about the scope of a single project/assembly.\n\nBut yeah, AFAIK it does, but it's strictly discouraged. Most circular dependencies between assemblies suggest it should simply be a single assembly, or otherwise refactored.", "id": "iwfjd1a", "owner_tier": 0.3, "score": 0.9999999995652173}, {"content": "Haskell supports it, but GHC requires hs-boot files to manually break cycles (basically what a header file provides in C). https://downloads.haskell.org/ghc/latest/docs/users_guide/separate_compilation.html#how-to-compile-mutually-recursive-modules", "id": "iwf22ok", "owner_tier": 0.9, "score": 0.6086956517391304}, {"content": "What I like about JavaScript is that it's unopinonated about a lot of things. Wanna use circular dependencies? Go ahead.\n\nIn practice, most people use linters to detect and prevent circular dependency in the main branch.\n\nDisabling circular dependency can make refactoring a bit harder, and it can lead to some \"monofiles\" where everything is in scope: https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts\n\nI still think it's circular dependency is nice-to-have feature, just to be able to delay some refactoring, but I wouldn't care that much if it wasn't in the language.", "id": "iwfai2p", "owner_tier": 0.5, "score": 0.30434782565217394}, {"content": "D supports circular dependencies but [disallows _static constructors_ from depending on each other circularly](https://dlang.org/spec/module.html#order_of_static_ctor). This is ensured at runtime before calling `main`.  \nZimbu has [primitives specially crafted to control circular dependencies!](https://moolenaar.net/z/zimbu/spec/zimbu.html#Startup%32Sequence).\n\nCan you narrow down what you mean in Zimbu, showing a specific example? That seems interesting!\n\nZimbu's modules and classes have a `.Ready` property you can query in initialisers, and initialisation can be tried multiple times. This allows you to manually break cycles.\n\n    CLASS C\n        C $cycle\n        string $name\n    }\n    MODULE A\n        C obj = NEW()\n        FUNC Init() status\n            IF B.Ready\n                obj.cycle = B.obj\n                obj.name = B.obj.name\n                return OK\n            }\n            return FAIL\n        }\n    }\n    MODULE B\n        C obj = NEW()\n        FUNC Init() status\n            obj.cycle = A.obj\n            obj.name = \"CYCLE\"\n            return OK\n        }\n    }\n\nHere, `A.Init` may be called twice by the runtime, which is necessary as both `obj` aliases are assigned to independently.  \nAlso yes, Zimbu uses `}` instead of `end`.", "id": "iwfapyh", "owner_tier": 0.5, "score": 0.47826086913043475}, {"content": "Python allows circular dependencies.  I think it's stupid and error-prone.  I think it's better to break dependencies with interfaces, each in it's own file.\n\n> Python allows circular dependencies\n\nNo it doesn't... You get an ImportError if you do that\n\nHow do you model like my ActiveRecord example (first example) without circular dependencies and without the class-as-string hack?\n\nThere are cases where you get an import error, but you don't if you're careful.\n\nI admit that's worse, but python does allow circular imports.\n\nEdit with concrete example:\n\n```\n# a.py\nimport b\n\nattr = 'a'\n\n# print(b.attr)  # doesn't work if executed first - b is not yet loaded completely\n\nif __name__ == '__main__':\n    print(b.attr)  # works\n\n\n# b.py\nimport a\n\nattr = 'b'\n\n# print(a.attr)  # doesn't work if executed first - a is not yet loaded completely\n\nif __name__ == '__main__':\n    print(a.attr)\n```\n\ncaveat: the `__main__` module is neither the `a` nor the `b` module, but at the end, the Python VM will have complete `a` and `b` modules that were loaded through cyclic imports and can access each other's members.\n\nPython modules work somewhat like first creating a module object, then memoizing it so subsequent imports get the same object back, then executing the file to populate the module object's fields. When a circular import occurs, it will get back a memoized module object that doesn't yet have its fields populated. As long as the circular import doesn't need to access the fields in the top-level code, this works fine. For example, this code works without issue:\n\n    # a.py\n    import b\n    def a_func(n):\n        return b.b_func(n-1) if n > 0 else 0\n\n    # b.py\n    import a\n    def b_func(n):\n        return a.a_func(n-1) if n > 0 else 0\n\nThe example works because running the file `a.py` or `b.py` doesn't require accessing any of the imported fields, it just defines functions that will access those fields when called at a later point in time. You only need to access those when _calling_ `a_func` or `b_func`, at which point both files would have finished defining all their exported functions. It's slightly awkward because it means that `from a import a_func` will break circular imports even though `import a` works fine.", "id": "iwez2eo", "owner_tier": 0.1, "score": 0.5652173908695651}, {"content": "I think it's a must. Let's say you have 2 function definitions calling each other (mutually recursive). Then if those 2 functions are in the same module, there's no problem, but if they are in different modules of the same project, that's somehow a problem? That's just sloppy compiler design is all. The compiler should first read the interfaces (function signatures etc) of all modules, then compile those modules knowing those signatures. If a language doesn't support cyclical imports, then the compiler authors just weren't smart enough to do that.\n\nIf it were so straightforwardly beneficial, every language would do it, but it's not. Here are a couple reasons to avoid it:\n\n1. Cyclic dependencies mean the \"downstream\" effects of a change can be much larger than in a DAG. It gets especially bad if the resultant coupling cuts across _teams_. This can make coding/debugging harder.\n\n2. It slows down compilation. It makes it harder to compile in parallel, since mutually-dependent information must be processed and ready before proceeding. This is partly why Go disallows cyclic imports.\n\nHigher order functions can be mutually recursive across modules without mutual dependencies quite easily. Maybe the cycle should be broken by abstracting out which function is recurred over in one of the modules?\n\nOtherwise I'm not clear on what the value is of having these things in separate modules in the first place?\n\nStrong bidirectional coupling between module interfaces is spaghetti rubbish. It's not a failure of language designers to choose not to go out of their way to support bad design.\n\nIt seems to be a very hard problem to solve, implementing circular dependencies. Do you know how to do [this](https://stackoverflow.com/q/74453129/169992)?\n\n> Cyclic dependencies mean the \"downstream\" effects of a change can be much larger than in a DAG.\n\nA cycle of modules is effectively one module, isn't it? you can always replace all cycles with a single node and end up with a DAG. Yes, that's slower to compile than if there were no cycle, but it's not slower to compile than the programmer manually merging the cycle into a single module - which is the alternative that I saw suggested here most often.\n\nThe question then becomes: are dependency cycles a useful tool for allowing programmers to structure their code more granularly than into \"units without cyclic dependencies\", or is it a feature that leads to sloppy architecture and technical debt?\n\n---\n\nAlso, in many languages (including the ones brought up by OP: Ruby & JS) a module is one file iiuc. I would argue that cyclic dependencies between files are definitely useful (I may not want to have to browse a whole module linearly just becuase that's how files work), and the problem is making files the module boundary.", "id": "iwfiojn", "owner_tier": 0.3, "score": 0.913043477826087}, {"content": "**Don't.**\n\nHow do you model like my ActiveRecord example (first example) without circular dependencies and without the class-as-string hack?\n\n I had the same question when I decided to disallow circular dependencies; I thought it would be too damning to place all ActiveRecords in the same file.\n\nMy current solution is straightforward; I treat the folder as a module instead of the file as a module.\n\nEvery file in the same folder is just a textual separation of the same module. So compilation is easy; concatenate every file in the same module. \n\nThis approach allows me to separate mutually recursive classes/functions into different files without complicating the module system of my language.\n\nIf a page is just a collection of comments and has no other responsibilities then they should be in the same module.\n\nOtherwise the model is wrong ... The comment should belong to a comment-list or something. The page then has a reference to the comment-list. And if the comment list needs a reference to its owner then \"page\" is too specific, it should refer to a more abstract \"container\" which is a shared dependency of both the page and comments modules.\n\nBasically whenever you think you have a circular dependency between modules, you either have to lump them together into the same module or break the cycle by abstracting an interface out as a common dependency and referring to that.\n\n**You don't model this.**\n\nIn real world apps., this is not used. Usually circular recursion appear with functions, not types.\n\nIf your types were classes instead of structures, this would be solved with inheritance:\n\n    // additional library/ module X\n\n    type class A;\n    type class B;\n \n    // A library\n\n    import X;\n     \n    type class C: A\n    {\n      C1: B;\n      C2: B;\n    }\n\n    // B library\n    \n    import X;\n    \n    type class D: B\n    {\n      D1: A;\n      D2: A;\n    }\n\nCircular reference is removed ...\n\nInteresting, but still within the concatenated module you have circular dependencies between classes. So parsing has to wait or something?\n\nWhat do you mean by \u201cparsing has to wait or something\u201d?\n\nIf you have this in one file:\n\n    class Post < ActiveRecord::Base\n      has_many :comments, class: Comment\n    end\n\n    class Comment < ActiveRecord::Base\n      belongs_to :post, class: Post\n    end\n\nWhen it gets to `class: Comment`, comment isn't yet defined, so you have to wait until comment is defined to resolve the meaning here.\n\nSo the problem seems to remain, that it is still tricky to resolve circular dependencies, no matter if they are in separate modules or in the same module/file.\n\nThey mean that you don\u2019t always know what a symbol means when you first encounter it because it\u2019s definition might be later in the class/file. So you need to do interpretation of references as a separate step from parsing.\n\nI\u2019m guessing you don't have separate phases in your compiler, so it\u2019s hard to see how it works.\n\nIn my compiler, name resolution and type checking are only done after parsing.\n\nSo using your example, the parsed AST already contains the definition of Post and Comment before being fed to the type checker.\n\nCool, thanks, that kind of makes sense, will have to think more about that.", "id": "iwf52yt", "owner_tier": 0.7, "score": 0.9999999995652173}, {"content": "Here is what I am thinking so far... For reference, `class` is a class definition and `data` is an object tree like JS objects.\n\n    # ./data.foo\n    import ./forms\n      take class person-node\n\n    data a\n      data b, borrow class person-node\n      data c, <person>\n      data d, clone a/b/fields/length\n      data e, <hello>\n\n    # ./forms.foo\n    import /hosts\n      take host a\n \n    # as you can see, makes \"class person-node\", etc.\n    class {a/c}-node\n      field {a/e}\n      field x-{a/d}\n      field {a/b/name}-name # person-node-name\n\nThat shows how things can reference things back and forth in a complex way. Now imagine that was across multiple files. The ideal would be to avoid this, but if you are going to allow \"simple class/ORM\"-like circular dependencies, you might as well support \"anything\"? Not sure.\n\nEven if they were in the same file, you still have the problem of resolving the circular dependencies within the single file... So problem stands.\n\nCircular dependencies within the same file are not hard to resolve and should be expected; otherwise, how can users define recursive or mutually recursive functions?\n\nAny resources on how to resolve circular dependencies? :)\n\nhttps://www.reddit.com/r/ProgrammingLanguages/comments/yfzmmw/typechecking_mutually_recursive_functions_and/iu6tmwp/?utm_source=share&utm_medium=ios_app&utm_name=iossmf&context=3", "id": "iwfbq5g", "owner_tier": 0.1, "score": 0.4347826082608695}, {"content": "In C# a module may contain multiple types. All types may be in a single source file or spread across multiple source files. The module is the compilation unit, and all source files of a module is presented at once to the compiler. \n\nTypes *within* a module may refer to each other, or they may refer to types in an \"imported\" module (a dependency). Circular dependencies between modules are *not allowed*.\n\nYour example (using *Entity Framework*):\n\n    // file Post.cs\n    class Post \n    {\n        public ICollection<Post> Posts { get; set; }\n    }\n    \n    // file Comment.cs\n    class Comment \n    {\n        public Post{ get; set; }\n    }\n    \n\nThe actual database relation will be inferred, although that can also be controlled specifically through code.\n\nIn C# all files of a module are automatically \"imported\", as are any referenced modules.\n\nOne of the main reasons I prefer F# to C# is that it avoids circular dependencies *by default*. In F#, code files are compiled in a specific order, and there are no relations between the types. There are a couple of escape hatches, which are to use the `and` keyword between types, or to use `namespace rec` or `module rec`, but I avoid using these wherever possible.\n\nYes, I remember that in my C# project at the previous job: I had weird build errors, and had to scratch my head quite a bit before I understood what the stupid C# compiler wanted from me. It wanted all the same code, but arranged differently into modules. I was literally SMH at how bad Microsoft programmers were.\n\n>One of the main reasons I prefer F# to C# is that it avoids circular dependencies by default. In F#, code files are compiled in a specific order, and there are no relations between the types.\n\nI don't see that as an advantage at all. I do a fair bit of F# coding (creating a compiler for my language), and this constantly annoys me. You need to explicitly specify that a   function is recursive, and if you have a set of functions that are mutually recursive, they absolutely need to be grouped together. The fact that *the order* in which the files are presented to the compiler is also annoying. \n\nMaybe it's because I'm used to be able to group functions and types according to domain concepts rather than according to technical references which the compiler must know about.\n\nI have done C# for 20 years now. I have never seen this as a problem. Rather, the language allows me to arrange types and files quite freely.\n\nGiven that modules (assemblies in .NET parlance) are the packaging unit, circular references would be really bad. But within a module it makes a lot of sense to allow the programmer to present all the files at once.\n\nIMHO equating a type/class with a module (e.g. a single type in a single module) leads to a quagmire of dependencies.\n\nIt's annoying at first, but it pushes you towards writing better code.\n\nI've never broken a cyclic dependency and come out with a solution which was worse than the one with the cycle.\n\nThe language I'm working on does not allow cycles *at all*. The result is that all code forms a DAG. A future goal is to be able to content-address any part of the code, similar to what Unison does. The presence of cycles makes this problem much more difficult.", "id": "iwfek3m", "owner_tier": 0.1, "score": 0.6521739126086956}, {"content": "I'd say it's absolutely necessary. Allowing circular dependencies allows you to focus more on the actual code rather than figuring out how to correctly order and structure your files/modules\n\nThere's a thing called technical debt. Circular dependencies are a good way to accumulate it.\n\nYeah allowing circular dependencies allows people to not have to think about dependencies and coupling and inter-module architecture and structure ... Which usually means people do a shitty job of those things.\n\nYou *should* be thinking carefully about which modules depend on each other. Allowing circular dependencies just hides bad design choices.\n\nExample please? I've never been in a situation where manually ordered dependencies was better in the long run\n\nAnything which is a solution to the [expression problem](https://en.wikipedia.org/wiki/Expression_problem) would be an example.\n\nA cyclic dependency is brittle. Your edit doesn't just affect the piece of code you are editing, but all dependencies which are part of the cycle are impacted.\n\n> Your edit doesn't just affect the piece of code you are editing\n\nAs long as something is exported from a module, it will have that property.\nIt does not have to be part of a cycle.\n\nIf `B` depends on `A`, and I make an edit to `B`, this should affect all descendants of `B`, but not all descendants of `A`.\n\nIf you have a cyclic dependency between `A` and `B`, now an edit to `B` will not only affect descendants of `B`, but also all descendants of `A`, even though no edits were made to `A` directly. `A` must also be recompiled. `A` and `B` are not really separate modules, but a combined module `AB`.\n\nPart of the goal of OOP is to manage complexity by isolating code into smaller units which can be individually tested and maintained. When you have cyclic dependencies you are not isolating anything, you just have a complex sub system whose parts cannot be individually tested - you can only test this sub system as a whole, and the sub system is at least as complex as all of the modules involved in the cycle.", "id": "iwfkcph", "owner_tier": 0.3, "score": 0.7391304343478261}, {"content": "Most circular relations can be resolved by abstracting out an interface for one or more types. For example:\n\n    Comment =\n        Text : String\n        ...\n   \n    Post =\n        Subject: String\n        Comments : Comment[]\n        ...\n\n    PostComment < Comment\n         Post : Post\n\nWhen instantiating the `Comments` field of the `Post` type, it is instantiated with `PostComment` objects which are *upcast* to `Comment`.\n\nWith generics you can avoid the need to downcast `Comment` back to `PostComment`\n\n    Post<TComment> , TComment < Comment =\n        Subject : String\n        Comments : TComment[]\n\n    PostComment < Comment\n        Post : Post<PostComment>\n\n---\n\nIf you consider how you arrange the data in a relational database, through *normalization*, it is done to avoid the kind of cyclic dependencies which are common in OOP. Instead of taking a reference, the information is combined with a `join`.\n\nThis is why there exists an [Object-Relational Impedance Mismatch](https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch). When we normalize the post/comment relation in a relational database, we would usually place the `post` field as a foreign key in the `comments` table, since a post can have many comments, but a comment belongs to one post. However, in OOP, we typically want to say `post.comments`, which is an inversion of this relationship.\n\nIMO, enabling cyclic dependencies just takes you further away from how the data is stored in the relational DB, widening the impedance mismatch, but you should be trying to minimize it, or instead opt for an object/graph database as your storage, which models your data closer to how you represent it in the OOP language.\n\nIf we say `post.comments` in our OOP language, at which point in time is the relevant `join` operation performed in the relational database? Do we perform it eagerly when instantiating the `post` object, or do we perform it lazily when accessing the `.comments` member, or do we just not use `joins` and instead perform a query every time, and make poor use of what the database provides us?\n\nIMO, one problem that most OOP languages have is they couple object representation and *construction* into the same concept, but if we are to instantiate a `Post` with `PostComment` objects, this coupling of concepts causes a circular dependency. If we separate the concepts (for example, using abstract factories), we can eliminate the dependency.\n\n     PostFactory =\n         .create ( ... ) : Post = \n             new Post (\"Subject\", [ new PostComment(...) :> Comment, ...])\n\nWhile `Post` itself has no dependency on `PostComment` (only on `Comment`), there is nothing restricting `PostFactory` from depdending on the `PostComment` because it is completely separated from `Post`.\n\nThe approach I've taken in my language is to completely forbid every kind of cyclic dependency in the static context. The relationship between all types forms a forest of DAGs, and there are no ways to violate this to introduce cycles.", "id": "iwfipmi", "owner_tier": 0.5, "score": -4.3478260605327347e-10}, {"content": "It seems that there are basically two views on this topic:\n\n1. YOU MUST DO IT!!!\n2. YOU MUST NOT DO IT!!!\n\nEcstasy supports modules, and circular dependencies among any number of modules. Modules are a unit of compilation, and when circular dependencies exist, the modules can be compiled as part of the same compilation phase.\n\nI wrote this recently, describing the process:\n\n--\n\nFor the second case, of multiple compilation units, the use case tends to be far more complex: The reason to compile multiple compilation units together is that they are co-dependent (i.e. cyclic graphs that span multiple compilation units). To solve this problem, you will need to build your top level compiler orchestration such that it advances each compilation unit one stage at a time, and such that each stage can complete based on the previous stage having already completed for the other compilation units.\n\nThe second case is far more complex in terms of design, but the implementation is relatively simple. What I mean by that is that you need to reason through the stages of compilation, so that each stage for each compilation unit is only allowed to ask questions that would be answerable by the sum of previous stages of other compilation units. Within a compilation unit, it may be possible to ask question that are only answerable by the completion of processing within the current stage, but even this ([for example](https://github.com/xtclang/xvm/blob/master/javatools/src/main/java/org/xvm/compiler/ast/StageMgr.java)) becomes far more complex. Finally, it is even possible for a stage within a compilation unit to depend on questions that can only be answered by another compilation unit once it progresses to a certain point within that same stage, but again that will dramatically increase implementation complexity, so if at all possible stick to the rule: each stage for each compilation unit is only allowed to ask questions (at least when asking other compilation units!) that would be answerable by the sum of previous stages of compilation.", "id": "iwi35gq", "owner_tier": 0.5, "score": -4.3478260605327347e-10}, {"content": "Euphoria doesn't care if there are circular dependencies, mostly because it only adds each import once, no matter how many times it is referenced.\n\nPro: You don't have to care which files you put your data in, so you can stay relatively modular per file.\n\nI don't really know if there are any cons to this feature.  Recently it even has support for namespaces, so things with ambiguity no longer matter either.\n\nI suppose one con is the interpreter (or compiler, if you use the Euphoria to C translator) has to do more work to keep track of what has been imported, and there's slightly more overhead, but I don't see how it's ever a bad thing.", "id": "iwsqpqp", "owner_tier": 0.5, "score": -4.3478260605327347e-10}, {"content": "It's probably a misfeature to allow cyclic dependencies across modules. A strongly-connected-component in the dependency graph tends to indicate there's a separable concern that's been spread thinly across a collection of files, rather than clearly isolated in its own file.\n\nIn the Ruby-on-Rails example, the simple (but incomplete) answer is that Rails is misguided. Relational databases are hotbeds of interlocking mutually-dependent data. You cannot understand the pieces in isolation. The value is in the relationships between the records. So the definitions concerning each strongly-connected-component must naturally appear together.", "id": "jic790u", "owner_tier": 0.3, "score": -4.3478260605327347e-10}], "link": "https://www.reddit.com/r/ProgrammingLanguages/comments/yvkysh/languages_which_support_circular_dependency/", "question": {"content": "I am working on a programming language/compiler, and have felt the pain a few times in JavaScript-land (my primary language) of not being able to import/require circular dependencies. For example, in Ruby on Rails models, the database schema is inherently circular. This Ruby code wont work (or it didn't work a long time ago when I last used Ruby on Rails):\n\n    # post.rb\n    class Post < ActiveRecord::Base\n      has_many :comments, class: Comment\n    end\n\n    # comment.rb\n    class Comment < ActiveRecord::Base\n      belongs_to :post, class: Post\n    end\n\nIt doesn't work because of the circular dependencies.\n\nInstead you do something like this:\n\n    # post.rb\n    class Post < ActiveRecord::Base\n      has_many :comments, class_name: 'Comment'\n    end\n\n    # comment.rb\n    class Comment < ActiveRecord::Base\n      belongs_to :post, class_name: 'Post'\n    end\n\nThen internally, once all the models are loaded, it converts the string to the class and wires it up.\n\nIn JavaScript I have at times wanted to essentially do this (though my examples were better use-cases, which I can't find/remember):\n\n    // b.js\n    import * as a from './a'\n\n    a.log()\n\n    export function add(a, b) {\n      return a + b\n    }\n\n    // a.js\n    import * as b from './b'\n\n    export function log() {\n      console.log(b.add(1, 2))\n    }\n\nThe only way to do that is more like this, where in one super module you set functions on the referenced modules, kind of a hack.\n\n    // b.js\n    const a = require('./a')\n\n    // DO THE HACK:\n    a.log = function() {\n      console.log(add(1, 2))\n    }\n\n    export function add(a, b) {\n      return a + b\n    }\n\n    // a.js\n\n    export function log2() {\n      // assume it's been set elsewhere.\n      a.log()\n    }\n\n    // main.js\n    // load b first, since it configures A.\n    const b = require('./b')\n    const a = require('./a')\n\n    a.log2()\n\nMy first question is:\n\n- What programming languages support circular referencing imports like this? Either popular langs or esolangs. It appears [C allows this](https://www.quora.com/Do-any-programming-languages-support-importing-modules-with-circular-dependencies-or-other-kinds-of-circular-dependencies-unlike-JavaScript-modules/answer/Jurriaan-Hage) to some degree. Maybe Makefiles do too? [More here](https://stackoverflow.com/questions/2284968/do-all-dynamic-languages-have-the-circular-import-issue).\n\nMy other two questions are:\n\n- What are the cons with having this feature of circular reference importing?\n- How far can it go, and/or what are the limitations in allowing this?\n\nFor the limitations question, I am imagining something complex like this:\n\n\n    # main\n    import a from './a'\n\n    log(a.doA())\n\n    # a\n    import x from './x'\n    import y from './y'\n\n    function doA() {\n      return y.add2(x.mult(1, 2), x.mult(2, 3))\n    }\n\n    function addMult(a, b) {\n      return (a * 2) + (b * 3)\n    }\n\n    # x\n    import a from './a'\n    import y from './y'\n\n    function mult(a, b) {\n      return y.add2(a.addMult(a) * a.addMult(b))\n    }\n\n    function mul2(a, b) {\n      return 2 * (a + b)\n    }\n\n    # y\n    import x from './x'\n\n    function add2(a, b) {\n      return 2 + x.mul2(a, b)\n    }\n\nBasically I am trying to draw an example where there are cycles dependent on cycles, and/or things that resolve in a sort of loop.\n\n\n    # b\n    import A1, A2, A3, A4 from './a'\n    \n    type B1 {\n      x: A1\n      y: A2\n    }\n\n    type B2 {\n      x: A3,\n      y: A4,\n    }\n\n    type B3 {\n      x: A1,\n      y: A4,\n    }\n\n    # a\n    import B1, B2 from './b'\n    \n    type A1 {\n      x: B2,\n      y: B2,\n    }\n\n    type A2 {\n      x: B3,\n      y: B2,\n    }\n\n    type A3 {\n      x: B1,\n      y: B2,\n    }\n\n    type A4 {\n      x: B3,\n      y: B1,\n    }\n\nHere, b.B1 depends on a.A1 and a.A2. But a.A1 depends on b.B2, which depends on a.A3 and a.A4, which depends on b.B3 and previous ones etc.. So it's like it would have to either parse going back and forth between the modules (which can have many links in a circle), or it has to resolve all things in each module first, without linking, then link partially as it goes, then at the end mark everything as completely linked. Something like that. How does/should it work?\n\nNote, my examples clearly can benefit from refactoring. But in many cases, it does make sense to have circular dependencies. So the ideal would be to avoid circular dependencies if possible, otherwise fall back to using them. But maybe that feature should be omitted to avoid spaghetti code, not sure how it has turned out in the wild.\n\n[Here's a comment](https://www.reddit.com/r/ProgrammingLanguages/comments/yvkysh/comment/iwfbq5g/?utm_source=reddit&utm_medium=web2x&context=3) on what I'm currently thinking...\n\nRelevant:\n\n- https://stackoverflow.com/questions/1897537/why-are-circular-references-considered-harmful\n- https://marian-caikovski.medium.com/cyclic-dependencies-a-convenient-feature-of-modern-javascript-eca7c07fe272", "id": "yvkysh", "title": "Languages which support circular dependency imports, and the pros and cons of that feature?", "traffic_rate": 16.86659877800407}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "If there's really no way of refactoring things to remove the dependency, then the much simpler fix is to move the import inside `something_else` - that way it's only executed when it's called, rather than when internal itself is imported.\n\nDo you mean moving the import statement?\n\nYes.\n\nOk so that error is gone, but now one of the functions in the file is giving an error when you call it saying it hasn't received 'self' as an argument. That's supposed to be automatic??!!\n\nOnly if it's a method in a class. Show the code and the error.\n\nThe code is is linked in the post. Here's photos of the error and the function (which is a method in a class) https://imgur.com/a/BGBquaJ\n\nIn `eventprocessor.redraw`, you didn't instantiate the LightMap object. You need to call it as `lights = lighting.LightMap()`, with the parentheses.\n\nThis fixed it! Thanks so much!!!!! It works now!\n\n[It looks soooo preeeettttyyyyyyy](https://youtu.be/z1trePyMiMY)", "id": "fv4iy79", "owner_tier": 0.5, "score": 0.9999999987499999}], "link": "https://www.reddit.com/r/learnpython/comments/has120/how_to_fix_circular_dependencies_in_modules/", "question": {"content": "Edit: this is working now! Thanks for all your help <3 !!!\n\nSo I've run into an issue with my code where two modules are interdependent, and as a result, one of them loads before another, leading to an `AttributeError: module 'my_module' has no attribute 'my_function_a'`. If I import them in the opposite order, I get the same error but for functions in the other module. The structure of the two modules is logical, and I don't want to move functions between modules as this will be extremely confusing when I'm working with code later down the track (put simply, the function to turn on the lights would no longer be in the module for controlling the lights, or something).\n\nOrdinarily, in C++ I would work around this by prototyping functions so that they are declared (even if they're not defined yet), but apparently this isn't possible in Python.\n\nAnother workaround suggested by Stack Overflow (I didn't post for fear of downvotes, but I found a similar issue) suggested doing the following:\n\n    from importlib import reload # reload  \n    reload(my_module)\n\nBut this does now work as the software which hosts my script does not allow access to the `importlib` module for security reasons. No, I can't use a different host, as that defeats the purpose of the script.\n\nThe basic layout for the relevant parts of my project is as follows:\n\n    Project directory:\n     - Main.py # Where all callbacks from interface are handled and redirected\n     - Lighting.py # Controls lights\n        - class: Lights (1 instance: state)\n            [calls toMidiMessage(), and other functions in Internal.py]\n     - Internal.py # Manages internal state of device\n        - function: toMidiMessage()\n        - function: something_else()\n            [uses constants in Lighting.py]\n\nIf needed, [here's the link](https://github.com/MiguelGuthridge/Novation-LaunchKey49-Mk2-Script/tree/lighting) to the GitHub branch with the changes that broke the script.\n\nHow can I go about fixing this circular dependency without disrupting any code that is already existing? It's important to note that access to a lot of Python modules is restricted for security purposes in the scripting interface my script connects to, which limits my options for using external modules to fix my options. Any ideas would be greatly appreciated.", "id": "has120", "title": "How to fix circular dependencies in modules?", "traffic_rate": 153.13037037037037}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "So basically this entire conversation so far is, ironically, running in circles. Some of our regulars are trying to explain that this is simply a project layout issue, while others are clearly not understanding what they're talking about.\n\nI can see both sides of the argument. It's not always intuitive, especially to less experienced developers, how to design a project without circular dependencies. On the other hand, it's also not an easy problem to generalise, meaning the more experienced developers kind of just intuitively know what to do and it's not always easy to explain how or why, especially in a general case.\n\nI don't know if I have an explanation that would satisfy OP and the others, but the key is splitting up the project in a way that suits it. Instead of depending on a class from another module, maybe take it as an argument and write your code to be called from higher up the stack, where the circular dependency is a non-issue (so basically dependency injection). Or if type hinting, consider writing an abstract base class that has no dependencies but describes the concrete ones well enough typing-wise.\n\nReally, it's just a matter of learning the tools of the trade. It's a lot easier to discuss a concrete example than an abstract one, so if you have a real project with a circular dependency let us have a look and tell you how to solve it. Follow our example long enough and you, too, will learn how to solve these problems in the future.\n\nThanks for your time trying to take distance in this situation.\n\nBut the explanation \" I have a lot of experience and we have always done like that \" is not sufficient to give a response to a deep paradigm question about python dealing with dependencies. I write it again for you.\n\nWhy can't we set loops (=circular dependencies)  in the dependencies graph when it would be much more satisfying than having a classic tree-shaped dependencies graph.\n\nFurthermore, it his possible to do so, because of the possibility to gather manually all dependencies creating a loop in a single file.  But it gets worth as the files are getting longer.\n\nSo the question: why can't we have many file acting like one, with a function to gather them ( carry for instance )\n\nThe note about dependency injection and ABCs is a good suggestion for the generalized problem. I usually have something like a base.py in my packages with the abstract base class. I can then import the base class(es) for type hints without importing the implementations, avoiding that type of issue\n\nAnother piece of advice is have is to use `typing.TYPE_CHECKING`. This helps me use type hints without depending on circular dependencies\n\nI have a real-world project with a circular dependency. Please take a look [here](https://www.reddit.com/r/learnpython/comments/162kjgj/a_satisfying_solution_to_avoid_circular/jxxqk79/).\n\n> But the explanation \" I have a lot of experience and we have always done like that \" is not sufficient to give a response to a deep paradigm question about python dealing with dependencies.\n\nThis isn't a case of \"if it works, don't fix it\", but rather a \"from experience I've learned way A does not work, but way B does, so just use way B here instead of way A\". In other words, they're not just saying that because their way works and they're not interested in considering alternatives, the whole issue is that there _is_ no other way that wouldn't result in spaghetti code. And our problem is trying to convey that so that those after us understand that which, clearly, doesn't seem to be working out.\n\n> Why can't we set loops (=circular dependencies) in the dependencies graph when it would be much more satisfying than having a classic tree-shaped dependencies graph.\n\n> Furthermore, it his possible to do so, because of the possibility to gather manually all dependencies creating a loop in a single file. But it gets worth as the files are getting longer.\n\nI don't understand your reasoning. A circular dependency clearly indicates that the program is halting because it cannot fully initialise the stuff it needs, caused by the program compilation step becoming stuck.\n\nIf file A depends on file B, and file B depends on file A, when you import file A in your program, Python begins to parse through it an finds that it needs to import file B. However, because file B needs things from file A, and file A hasn't finished importing yet because it's waiting for file B, the program gets stuck.\n\n...Perhaps a more concrete example is in order.\n\n    # user.py\n    from computer import Computer\n\n    class User:\n        def __init__(self, name: str):\n            self.name = name\n            self.computer = Computer(users=[self])\n\n\n    # computer.py\n    from user import User\n\n    class Computer:\n        def __init__(self, users: list[User] | None = None):\n            self.users = users if users is not None else []\n\n        def print_usernames(self):\n            for user in self.users:\n                print(user.name)\n\nThis would fail, because no matter which file you import first, they both need Python to read the entire other file before being able to be imported themselves, and unless you can show me an example of designing an import system that wouldn't need a tree-like design I have no idea what you're getting at.\n\nThe way you need to approach these problems is to think about what information you actually need, and where. If you don't actually need multiple modules sharing data, then don't - you could use abstract interface classes, dependency injection, or similar approaches to handle it. And if they're tightly coupled and you can't de-couple them, keep them in the same file.\n\nFor example, in the example above it would make sense to just remove `User`'s dependency on `Computer` and let it as the \"parent\" to handle everything.\n\n> So the question: why can't we have many file acting like one, with a function to gather them ( carry for instance )\n\nFrom a purely theoretical standpoint, it's not impossible. C#, for example, has partial classes where you can define their methods across multiple source files. The problems arise when you actually need to import something, because in Python every module has its own namespace.\n\nWell, for instance in your example, `misc2` is clearly tightly coupled with `signature`, so I see little reason to keep them separate. I wouldn't call these \"miscellaneous\" functions any more, they're clearly designed to work with your `signature.Signature` subclass.\n\nWhile I'm talking about this project of yours, its structure in general is a little confusing. Why do you have a top-level `__init__.py`, and why is it trying to have you import the Git repository root directory as a package? Generally the root would just contain metadata, with `pyproject.toml` telling Python how to install the contained package(s). I mean, right now even the `docs` and `tests` are included.\n\nTalking from my experience it is good to stay away from circular dependencies and I cannot recall any counterexample. One could think about dependencies between modules in the hierarchical (tree) way. And the metric for creating such trees is the level of abstraction of a given entity. So you compare how much \"low level\" is the module and if it should import another module that seems to have a pretty \"higher level\" of abstraction. In your case, let me rename \\`Computer\\` to \\`UsersComputer\\` since that seems to be the purpose of this class. Having that, we can easily state that the \\`UsersComputer\\` is more \"high level\" than \\`User\\` and any logic of doing something with \\`UsersComputer\\` should not be placed in the \\`User\\` class. Not following this rule can bring some problems. In the example, you dont have coherent \\`Computer\\` -> \\`User\\` relations since \\`ComputerInstance1\\` could have \\`John\\` and \\`Paul\\` as users, and the user \\`Jenny\\` could have \\`ComputerInstance1\\` as a property and the code allows that. Then you need additional checks or any additional logic that make code more complex.\n\nThe code works correctly by moving `from computer import Computer` below the User class. I haven't fully thought it through yet but I think such simple circularity issues can always be resolved by placing the imports at the right spot. For more complex circularity the involved files are that heavily intertwined that they really must be a single file in the first place.\n\nI think OP expects that Python should sort of make two passes, first to treat the source as kind of a header file and grab classes and functions, and then in a second pass to fill in the code. That's not what is happening of course because Python code is way too dynamic and importing a file literally just executes its code from top to bottom.\n\nMany things to say here. As you say in the end, it is a purely theoretical standpoint. So 'experience' does not add up here.\n\n> the whole issue is that there is no other way that wouldn't result in spaghetti code.\n\nBut their is a solution. If I can gather modules that create a circular dependency in the same file by myself, Python can do it, and it will work. It just need a specific function: why not *carry ?*\n\nI understand very well why *import* stuck the system at circular dependencies. That's why I suppose the existence of another function. \n\nThen you are asking me for an example of design needing this circular dependency. But your is fitting perfectly.\n\nNote that if your intricated classes where in the same file, it would works perfectly.\n\nremoving User dependency on Computer would mean that User.computer is not an instance of Computer... Even if the Class Computer exists... This isn't satisfying. If you mean to change it to an object and deal with it as is, it would work, but it still ugly.\n\nSo then, why not keeping them in the same file ? Multiply your class numbers by ten, every one intricated with others. Then you understand why you don't want a 1000 lines file.\n\nThen, when the minimal number of classes is sufficient for the pure logic of the algorithm, more Abstract Classes just to avoid circular dependencies are unpleasant.\n\nIt is why python not dealing with circular dependencies sounds bad.\n\nI'm not a big fan of throwing those functions into the `signature.py` file. I generally like to have a separate file for each class, *and* that file is already very long. Plus, I wouldn't say that `split_arguments` is very tightly coupled with `Signature`.\n\nIt's not a bad idea, but it's also not exactly optimal. Ideally, I'd make a file for each class, and then 1 file for all the random functions. That would make every single thing in the module trivial to find. You wouldn't have to ask yourself \"Is `function_foo` most tightly coupled to `ClassX`, `ClassY`, or `ClassZ`?\" every time you're looking for something.\n\n(As for the project-level `__init__.py`, that was committed by mistake. I'll delete it.)", "id": "jxxt0jq", "owner_tier": 0.7, "score": 0.9999999996428571}, {"content": ">I am facing a problem python-ers are facing for ages. And I am very surprised that their is no satisfying solutions for it.\n\nI don't think your premise is correct. The solution to circular imports is well known, and that is to structure the program so that circular imports are not required.\n\nThere are also a number of workarounds to allow circular imports to work, (such as lazy / delayed imports), which I agree are not very satisfying, and are generally discouraged.\n\n&#x200B;\n\n>Considering a complex-structured project with many classes depending one on the other...\n\nIt sounds like refactoring would be a good idea. Break the code down into well-defined modules and packages that represent different components / functionalities.\n\nConsider the principle of separation of concerns. Each class or module should have a single responsibility.\n\nUse design patterns such as Factory, Observer, and Dependency Injection where appropriate. This can help to reduce complex relationships between classes and promote better code organization.\n\nDefine clear interfaces or abstract classes to reduce direct coupling.\n\n&#x200B;\n\n>the only way not to gather them in a single frightening long file is to use tricky modules solutions that leads to very long imports or imports not in the beginning of the file.\n\nThat is, in a nutshell, why your code needs to be refactored and reorganised.", "id": "jxyb9hi", "owner_tier": 0.3, "score": 0.1785714282142857}, {"content": "https://docs.python.org/3/faq/programming.html#what-are-the-best-practices-for-using-import-in-a-module \n\n> Circular imports are fine where both modules use the \u201cimport <module>\u201d form of import. They fail when the 2nd module wants to grab a name out of the first (\u201cfrom module import name\u201d) and the import is at the top level.\n\nAnd so the import syntax is getting longer uselessly.\n\nOne could say that \" that's not that important, do with longer syntax\", but it matters\n\nThat's a bit misleading.\n\n> Circular imports are fine where both modules use the \u201cimport <module>\u201d form of import.\n\nThe imports themselves may be fine, but you'll still get an error if you try to \"grab a name out of\" the module. Something like `module.name()` in the global scope will crash your program. You can *sometimes* avoid circular import problems by replacing a `from x import y` with a `import x`, but not always.\n\nI think this is the right answer. I don't understand why it should work in the form  \"import module_a as a\" and not in the form \"from module_a import function_a\", though.\n\nYou ask\n\n> Do you know if such a function exists? Do I have to do it myself?\n\nwhich implies that you're willing to go to great lengths (lots of letters) to pull this off. Now the solution turns out to be quite straightforward after all but you complain about writing a couple more letters? Can you give a concrete case with two files where things don't work out due to circular dependencies. Keep in mind that the behavior of import is pretty close to copypasting the contents inside the current file so depending on your needs you must place the import at the right spot. E.g. file a.py\n\n    class MyClass: 1\n    import b\n\nFile b.py:\n\n    from a import MyClass\n\nThis works fine because Myclass is defined before the circularity kicks in. Any other situation that bothers you?\n\nOh yeah it just defers evaluation which might be enough for many purposes.\n\nI haven't looked into the code but I suspect it's similar to how\n\n    def f():\n        g()\n\nis always valid even when g is not defined (yet). The system will complain though if you ask for g right now:\n\n    def f(g=g):\n        g()\n\nWhat if MyClass needs to call something in File b?\n\nMmmh it's not my area of expertise really. I guess we could do something like this:\n\n    from b import f\n\n    class MyClass:\n        def func(self):\n            f()\n\n    MyClass().func()\n\nAnd\n\n    def f(): print(5)\n\n    from a import MyClass\n\n(which will print twice due to the import unless we filter by \\_\\_name__). I mean the issue of circularity even exists if we put everything in a single file. Things must be defined before they can be accessed. Ideally we would have header files I guess. If you want to finely intertwine two files it would make more sense to put everything in the same file.", "id": "jxxuhm8", "owner_tier": 0.3, "score": 0.3928571425}, {"content": "Not sure i understand the question/problem but i noticed you  talked about something like this:\n\n```python\n#file1.py\n\nfrom file2 import test2\n\nclass test:\n    def p1(self):\n        i = test2()\n        i.p2(self)\n\n    def hello(self):\n        print(\"hello\")\n```\n\n```python\n#file2.py\n\nclass test2:\n    def p2(self, test_obj):\n        test_obj.hello()\n```\n\nWhat i just did was to pass the class object into another function, now the class is accessible from that function.\n\nIt's almost that. Just add a an import for file1 in file2 and you have a typical circular dependency.\n\nA solution is to gather themselves in one file, so you don't need imports, but this solution get worth as the file length increases. Furthermore, I don't find other solutions including imports satisfying, due to syntax length and counterintuitive behaviour.\n\n&#x200B;\n\nThat's why I am looking for something as the carry function described before\n\nWhat i just showed does that, file2 calls the hello function in file1 even tho file1 already imported file2", "id": "jxxnqdp", "owner_tier": 0.1, "score": 0.1071428567857143}, {"content": "I am figuring out that my question ask for a more general one. Can the dependency graph contains loops? And if so, can we set a carry function that interprets this loop as a comprehensive module, so we have our tree shaped dependency graph again ?", "id": "jxxt92u", "owner_tier": 0.1, "score": -3.571428549723318e-10}, {"content": "The most satisfying solution I have found to avoiding circular dependencies is not using a programming language that inherently devolves itself into a spaghetti fest of cryptic error throwing nonsense without needing to spend an excessive amount of extracurricular time on going through the ironically circular and non-evolving process of troubleshooting and discussion of refactoring and tons of potential workarounds. If you need to have decades long discussions and develop decades worth of workarounds to \"solve\" a singular issue, you have actually not \"solved\" anything. The people will hate my message the most because it's true.", "id": "lamovdq", "owner_tier": 0.1, "score": -3.571428549723318e-10}, {"content": "After reading the comments here, I have a toy question.\n\nSay, I have a Cat class and a Dog class. Cats have a list of Dog friends, and Dogs have a list of Cat friends. Shouldn't Cats and Dogs have their own separate files in Python?", "id": "jy1tnir", "owner_tier": 0.3, "score": -3.571428549723318e-10}, {"content": "In general it is better practice for classes and modules to form a dependence hierarchy and sticking to the 'S' in SOLID principles as classes and functions with too many responsibilities are very difficult to revisit for maintenance.\n\nThat said, there are some situations where small cyclic dependencies may be beneficial when a hierarchy of object instances has predetermined types and needs to be traversed both up and down. Since Python is dynamically typed there is no need to import a class definition to use it, but for highlighting and type analysis tools you can use TYPE_CHECKING:\n\n\nstudent.py\n```\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from teacher import Teacher\n\nclass Student:\n    def __init__(self, subjects):\n        self.teacher: Teacher | None = None\n        self.subjects = subjects\n```\n\nteacher.py\n```\nfrom student import Student\nfrom typing import Sequence\n\nclass Teacher:\n    def __init__(self, students: Sequence[Student]):\n        self.students: list[Student] = list()\n        for student in students:\n            self.add_student(student)\n    \n    def add_student(self, student: Student):\n        student.teacher = self\n        self.students.add(student)\n```", "id": "kae2vlp", "owner_tier": 0.1, "score": -3.571428549723318e-10}], "link": "https://www.reddit.com/r/learnpython/comments/162kjgj/a_satisfying_solution_to_avoid_circular/", "question": {"content": "Good morning,\nAs written in the title I am facing a problem python-ers are facing for ages. And I am very surprised that their is no satisfying solutions for it. \nConsidering a complex-structured project with many classes depending one on the other, the only way not to gather them in a single frightening long file is to use tricky modules solutions that leads to very long imports or imports not in the beginning of the file.\nI am looking to get out of this situation, having a function such as myclass = carry(file, myclass) that replace the \"from file import myclass\" with a different behaviour: every file element ( class, function, variables ) are carried once, and running any of those would be similar to run them together as they where in a single file.\n\nDo you know if such a function exists? Do I have to do it myself?\nThanks for your time reading this.", "id": "162kjgj", "title": "A satisfying solution to avoid circular dependencies", "traffic_rate": 153.13037037037037}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "Only tangentially related to the article, but it mentions sys.exit() being called on an error condition. I think this is the absolute most annoying thing a library can do. Unless I'm calling a \"clean up and shut down\" function, libraries shouldn't be killing my interpreter. \n\nA few years ago I was working with the python Netflix bindings, and they had a condition where this happened. I filed a bug report, and eventually forked the library to make it act like a decent library. The original was provided by Netflix, so I was surprised that it didn't follow better development practices. \n\nActually, it really was `raise SystemExit(...)` rather than `sys.exit()`. But I certainly believe that no library should do such a thing.\n\nYou think that's bad? The Gtk library will cause a SIG error terminating the program from the C side if it can't find the settings under the DBus path specified by your app when you create a GSettings object. It won't tell you there was an error fetching the settings, it just terminates the whole thing.\n\nI didn't know one should not do sys.exit on libraries... Good to know\n\nFabric does this with fabric.api.local(cmd_str). I was using it in a distributed production environment. Lame.\n\ndoesn't `sys.exit()` just raise `SystemExit()` anyway?\n\nThe PulseAudio library did a [silent system exit](http://ubuntuforums.org/showthread.php?t=612606) if it could not allocate memory. Useful! I mean, how are you going to play those mp3s without available memory?\n\n[deleted]\n\nYes.\n\nIn Python, `sys.exit` doesn't instantly kill your program, it just raises a `SystemExit` exception. You can handle that exception outside the library code in the normal way if you want to.\n\nIt's important to allow for this if you have a top-level error handler that catches and logs all otherwise unhandled exceptions, or anything along those lines.\n\nWhether raising `SystemExit` is an appropriate behaviour for library code either is a different question, but it's certainly not the same situation as, say, a C library just quitting out without giving the calling code any say in the matter.\n\nBut its not as simple as you say. Its not a standard exception in the sense that it doesn't inherit from the \"Exception\" class. Therefore:\n\n    except Exception as e: \n\ndoesn't catch SystemExit and KeyboardInterrupt. So I'd still argue its bad API design to use SystemExit as its not a standard Exception", "id": "cgknpzr", "owner_tier": 0.7, "score": 0.9999999999315068}, {"content": "Sometimes it's a choice between \"do something at import time\" or \"deal with an endless flood of mailing list posts from stupid users who don't read the docs\". So, yeah.\n\nGot a concrete example? I'm interested in it; perhaps something could be improved without import side-effects.", "id": "cgkz20d", "owner_tier": 0.5, "score": 0.027397260205479453}, {"content": "This is interesting. I just redesign my classes, such that all class instantiation and any code plumbing will reside in __init__.py (naturally). I will take this as a precautious", "id": "cgkn8uu", "owner_tier": 0.1, "score": 0.006849315000000001}, {"content": "Ha, screw that.  All my modules will now make syscalls and change the state of the system kernel in random and unpredictable ways.  Ah hail inappropriate use of ctypes.", "id": "cgltl0d", "owner_tier": 0.7, "score": 0.006849315000000001}, {"content": "It seems to me that any reasonable person would wrap any side-effecty code in an import in a try-except to allow for graceful failure. I routinely compile Cython code from the \\__init__.py of a module but provide fallbacks if Cython isn't available or compilation fails for some other reason. Is this bad practice? Seems to me there's no real downsides as long as you are careful.\n\nIf the failure results in an ImportError that's one thing, but if importing the module can cause a segfault (I'm looking at you, gtk / gi.repository.Gtk) then that's bad. Opening windows, writing to stdout/stderr instead of a logger, or even just not returning promptly could be bad in their own way.\n\nYou people have been programming in Python so long, you forgot what a segfault is. This isn't something intentional that they can avoid, like raising an exception, this is a legitimate bug in the code.\n\nIt's going to always happen when you import C libraries that haven't been tested for millions of years. \n\nSure, but if you'll be working with a C library that has potential to segfault, wouldn't you want to know during the import rather than halfway through some important task?\n\nThe problem with GTK (and related things) is that there are two official mutually incompatible versions of the bindings that can interfere with each other. I don't think it's too much to ask to detect if the other version has been already been imported and raise an ImportError.\n\nWell, if you're able to fix it so that it doesn't segfault on import, sure, otherwise you wouldn't be using it still.\n\nMy point is that there is no practical way to say that in this section of the code, it does not seg fault. You might run into it regardless of what you think, and coded for. If you're working with a C library, it might just happen anytime you call it.\n\n> but if you'll be working with a C library that has potential to segfault, wouldn't you want to know during the import rather than halfway through some important task?\n\nThe answer to this question is actually not black and white.\n\nSometimes a library that you include for purpose X imports a library for purpose Y that you actually do not need for your program. This help(\"modules\") example is the most extreme case, but not the only case.\n\n[deleted]\n\nNo, that makes complete sense if it's a known issue. I'm just trying to make the point that a fatal error like a segfault is separate from the usual Python exception that you can handle, and they're guaranteed when developing in C. It's not necessarily something you can avoid in the same way that the article talks about side effects when importing modules.\n\nWell, at least they fixed one of them.", "id": "cgkp3jq", "owner_tier": 0.5, "score": 0.19178082184931505}, {"content": "Useful exception:\n\n    from __future__ import print_function\n\nThat doesn't have side-effects outside the module being imported, so it's fine. Under my classification, it does not have side-effects.\n\nYou're right. I was misunderstanding there. ", "id": "cgkpk4c", "owner_tier": 0.3, "score": 0.06849315061643835}, {"content": "Question: What about classes that auto-register subclasses in some sort of repository or other data structure?  Those class declarations have global side effects, but this is one of the commonest use cases for metaclasses.  The easy way out is to always put all the subclasses in one module, but that's unrealistic in the general case.\n\nThis past couple of weeks I've been writing code that actually does exactly that. Given that it is still all contained in the one area which I own, and that it doesn't cause any things to *break* (though it may be done in such a way that importing a thing twice does explode where it normally wouldn't) I don't consider that *terribly* bad, though it's more magic than I'd like.\n\nExtra tip: often (though not always) registration metaclasses can be replaced by looking at the subclasses of an object\u2014`MyType.__subclasses__()` gives you all the direct subclasses (apply recursively to get all descendants).\n\n> Extra tip: often (though not always) registration metaclasses can be replaced by looking at the subclasses of an object\u2014`MyType.__subclasses__()` gives you all the direct subclasses (apply recursively to get all descendants).\n\nThat's a good idea in the general case, but if you want to allow a potentially unbounded number of subclasses (i.e. if the client of your API decides to subclass `MyType` a lot), that recursive operation is going to get expensive.", "id": "cgl3nqx", "owner_tier": 0.7, "score": 0.020547945136986302}, {"content": "I came across this interesting example recently, where an import side-effect deadlocked the interpeter.\n\nIf you use Gevent 1.0, and you import a module that causes, as a side-effect, the resolution of a domain name, you can deadlock:\n\nhttps://jira.mongodb.org/browse/PYTHON-607", "id": "cgl5emn", "owner_tier": 0.1, "score": -6.849315026866637e-11}, {"content": "I know I'm being pedantic, but `import` is meant to have side-effects, ie. dropping a whole bunch of things into the namespace. I would humbly submit that anything that requires no side-effects is probably using the wrong tool here.\n\nThat ain't a *side*-effect; that's the designed effect.\n\n[deleted]\n\ni agree with you on this\n\nThis thread has been linked to from elsewhere on reddit.\n\n\n - [/r/SubredditDrama] [from nerd.argument import slapfight: Minor drama in /r/python about what a side effect is.](http://np.reddit.com/r/SubredditDrama/comments/22axlm/from_nerdargument_import_slapfight_minor_drama_in/)\n\n\n*^I ^am ^a ^bot. ^Comments? ^Complaints? [^Send ^them ^to ^my ^inbox!](http://www.reddit.com/message/compose/?to=totes_meta_bot)*\n\n\n\nIn programming, a side-effect is anything other than a return value.\n\nI know, but I don't think that matters. `import` changes the state of your app, by design.\n\nin functional programming maybe, elsewhere it's the desired effect vs. anything else that happens.\n\nInserting names into the namespace is fine, running code that can crash, throw errors, launch the nukes, or anything else is not. His point isn't about side effects in the haskell sense. \n\nWell, I said I was being pedantic. I don't think importing a module should do those things (except perhaps display warnings - I think that's fine). But I think that if we're talking about best practices, importing modules in order to inspect them would not usually qualify.", "id": "cgknlvt", "owner_tier": 0.5, "score": 0.1027397259589041}], "link": "https://www.reddit.com/r/Python/comments/229f7q/say_no_to_import_sideeffects_in_python/", "question": {"content": "", "id": "229f7q", "title": "Say \u201cno\u201d to import side\u2010effects in Python", "traffic_rate": 207.942496260595}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "When a package contains multiple submodules, the \\_\\_init\\_\\_.py file in the top-level directory can be left empty if you want to make all the submodules available when you import the package.", "id": "irbb9tg", "owner_tier": 0.1, "score": 0.9999999900000001}, {"content": "So, when you import a module it basically executes the whole module which means declaring functions and classes.\n\nFor the auto imports part, this is all your editor's doing.\n\nSo, when you import a module it has to load it. But once is load it there's no additional cost of importing it. So if B imports C, importing C on A will only make it available in the A namesoace. Otherwise it won't know where to load the functions from even if it has been imported once.", "id": "irboiny", "owner_tier": 0.5, "score": -9.99999993922529e-09}, {"content": "I believe you only have access to whatever you import within each script file.\n\nOf course, if you expose the module via member variables, or in other ways, you can share the module declaration in a wider scope. I do this very occasionally when I want to allow different modules with identical interfaces all over the place.\n\nI think I have actually done this exactly once actually. It is odd, but possible.", "id": "ircj9kn", "owner_tier": 0.5, "score": -9.99999993922529e-09}], "link": "https://www.reddit.com/r/AskProgramming/comments/xxcgjf/python_when_do_i_need_to_import_a_module_when_its/", "question": {"content": "I'm noticing some inconsistent behavior and I'm trying to understand the rules. \n\nIf i'm writing script A. Script A imports from script B. Script B imports script C. \n\nIf my understanding of importing is correct, when you import a script, you might as well have copied and pasted the entire script at the beginning of your module (which is why any methods you don't want to be called immediately get put behind a \"if name == main\" line). \n\nSo if script B imports script c, and script A imports script B, does script A need to import script C?\n\nSometimes it seems I can get away with it. Othertimes it either yells at me or automatically adds the import at the top. \n\nJust today I did something that worked, realized i forgot to make a new branch, reapplied my work, and now it isn't functioning. \n\nI just can't seem to figure out when I need to add an import when that module was already imported by a mutual import.", "id": "xxcgjf", "title": "[Python] When do I need to import a module when its already imported by a different module", "traffic_rate": 28.025540679711636}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "One approach that can work is using a submodule git configuration, this might help explain it: https://shunsvineyard.info/2019/12/23/using-git-submodule-and-develop-mode-to-manage-python-projects/\n\nWell, depending on if I understood the post anyway. If this is more like a circular import problem, you'll probably want to redesign the structure of your project(s).\n\nAnd Poetry will work fine, as long as `pyproject.toml` uses the Poetry masonry core API (which it does by default nowadays) anyone can install the project even if they don't have Poetry installed.\n\n> One approach that can work is using a submodule git configuration, this might help explain it: https://shunsvineyard.info/2019/12/23/using-git-submodule-and-develop-mode-to-manage-python-projects/\n\nI think we're okay with having both package directories in the same repository. The bigger concern is (1) making sure that we have separate testing environments for separate packages and that we can switch into and out of them and (2) develop them using the local (not yet published) version of the other package.\n\n> Well, depending on if I understood the post anyway. If this is more like a circular import problem, you'll probably want to redesign the structure of your project(s).\n\nNo it's not a circual import problem. The dependencies aren't cyclical.\n\n> And Poetry will work fine, as long as pyproject.toml uses the Poetry masonry core API (which it does by default nowadays) anyone can install the project even if they don't have Poetry installed.\n\nThis is great to hear. Leaning towards Poetry\n\nThen I'd suggest treating them separately, even if they \"physically\" exist in the same place.\n\nAt work we have a project that has a sub-project meant to control the first one, both with their own installation and dependency files. You could, for instance, have two `pyproject.toml` files, one for each project, and in the main project you can have a Makefile that builds both into wheels (if needed).", "id": "hbzbqi2", "owner_tier": 0.7, "score": 0.9999999966666667}], "link": "https://www.reddit.com/r/learnpython/comments/pjur5l/how_to_develop_multiple_interdependent_python/", "question": {"content": "What I'm looking for:\n- Developing multiple Python packages in tandem\n- The packages have interdependencies among themselves (EDIT: I didn't mean interdependencies - they have dependencies but the dependencies are *NOT* cyclic)\n- Will publish to PyPI (or Conda) for easy install\n- All code is pure Python\n- No complex build step for any of the packages\n- Willing to use something like poetry as long as package users don't have to use poetry themselves\n- Separate testing environments for the different packages\n\nAny input/utorials/docs/blog posts/tools/sample repositories would be appreciated.", "id": "pjur5l", "title": "How to develop multiple inter-dependent Python packages?", "traffic_rate": 153.17222222222222}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "Observe:\n\nGiven a `functools.py`\n\n    def partial():\n        pass\n\n    def something_else():\n        pass\n\n    print('unrelated to partial')\n\nthen\n\n    >>> import functools\n    'unrelated to partial'\n    \n    (restart)\n\n    >>> from functools import partial\n    'unrelated to partial'\n\nPython has to execute the entire module in order to even import a single name from it (it doesn't know the names until it is executed!), so you're not saving anything by just importing `partial`.\n\nok thx", "id": "cnlfvp1", "owner_tier": 0.3, "score": 0.6666666633333334}, {"content": "import functools", "id": "cnlcf30", "owner_tier": 0.1, "score": -3.3333333130750966e-09}, {"content": "It isn't necessary. Also it isn't possible either, since your question is trying to do two mutually exclusive things.\nTaken literally I can answer you like this\n\n    import functools #importing the namespace \"functools\"\n    from functools import partial #importing only partial from functools\n    #Observe the functools namespace is preserved\n\nThus your question is answered, if there happens to be some reason you want to import the function only while keeping the namespace like interface.\n\n    class functools(object):\n         from functools import partial\n\nYou could do that, but I wouldn't recommend it,. Since it's just plain over engineering, I can think of times this method can be used, like if you want to create a wrapper for other commonly used functions scattered around different modules, but that itself might not be as efficient as you could hope for, definitely don't do that if you expect real time performance. Now that I think of it, there really aren't that many uses to the solutions to your problem, But I'm suspecting that you actually just want to find out how far python can bend, so go ahead experiment if you like, just don't forget those experiments laying around on your desktop. ", "id": "cnlp48n", "owner_tier": 0.1, "score": -3.3333333130750966e-09}, {"content": "import functools.partial\n\nMe thinks you didn't try that one:\n\n    >>> import functools.partial\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    ImportError: No module named partial\n\n\nCaught me.  I did not check it first.\n\nyeah that would only work if you go import module.module\n\nCan anyone tell me if it works in python3 though?\n\n`import spam.eggs` works in Python 3 provided spam is a package and eggs is a module.\n\n`os.path` appears to be a weird exception and I don't quite understand how it works:\n\n    py> import os.path\n    py> import os\n    py> os.__package__\n    ''\n\nEdit: that means that `import functools.partial` won't work.\n\nedit again: it works because the `os` module includes this line:\n\n    sys.modules['os.path'] = path\n", "id": "cnlbt7y", "owner_tier": 0.1, "score": 0.9999999966666667}], "link": "https://www.reddit.com/r/Python/comments/2s1n9a/how_do_i_import_only_partial_from_functools_while/", "question": {"content": "So i don't want to import the whole functools.\nbut if i do \"from functools import partial\" then i will have partial in the module namespace. i want to keep it as functools.partial.\n\nhow doth one doeth that?", "id": "2s1n9a", "title": "How do i import only partial from functools while keeping the functools namespace", "traffic_rate": 207.97124813029748}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "reddit"}, {"answers": [{"content": "\r\n    What you are using is definitely an antipattern. Allowing cyclic dependency between DLLs is a bad idea not only in case of DLLs but also in case of static libs. If 2 DLLs reference each other then they keep each others reference count on 1 btw, that isn't the end of the world because you probably end their life with ExitProcess at the end.\r\nChange your project this way: You have lib1 and lib2. Let only lib1 to depend on lib2. To communicate back from lib2 to lib1 do the following: Define an interface in your source code that is visible to both libs. In lib1 create an implementation of this interface. When lib 1 communicates to lib2 for example by calling lib2::Init() you pass an interface pointer to lib2 so lib2 will be able to call code inside lib1.\r\n", "id": "2_625043_1", "owner_tier": 0.3, "score": 2.0}, {"content": "\r\n    I have done this type of thing before.  It is a bit of a pain but it can be done.  I will describe the linkage between 2 DLLs, which I think you can generalize.  Set up the linkage so that A.dll compiles and links properly to B.dll.  In B.dll, use function pointers to the A.dll APIs, and when you need to call A.dll from B.dll, have stub code for each API call do a LoadLibrary on A.dll and lookup the API(s) with GetProcAddress().  This bookkeeping only needs to be done once and can be cached in a static table.  Use of extern \"C\" linkage in A.dll is not mandatory but will simplify the name lookup mess.\r\n", "id": "2_625046_1", "owner_tier": 0.3, "score": 3.0}], "link": "https://www.codeproject.com/Questions/625018/Mutually-dependent-Dlls-built-in-Visual-Studio", "question": {"content": "\r\n\t\t\t    I am building 9 32bit Dlls under a Visual Studio solution. \r\nFor the sake of argument each one of them is dependent on all the others. In other words each one imports symbols from the other 8 and exports symbols imported by each of the other 8.\n\r\nAt the moment I do this by having 2 build configurations. The first tries to compile and link all the dlls.\r\nAll the compilations succeed but of course all the linking fails. The build however outputs .exp files and .lib files for each DLL\n\r\nThe second configuration is then run which compiles everything again and then ignores most of the files it's just made and links the libs and export files from the first configuration to build the actually Dlls.\n\r\nThis works but it is a horrible hack and takes twice as long as necessary.\n\r\nWhat I need is a way to either get Visual Studio to sort this out for me or to stop the first configuration from trying to link and the second configuration form wasting its time compiling everything again.\n\r\nI asked a similar question in the VS forum about a year ago and was told that this could be fixed by using the project dependency settings. It can't, as you can't create circular dependencies.\n\r\nWhat I'm doing is the same as described here[^] but with Visual Studio.\r\n\t\t    ", "id": "625018", "title": "Mutually dependent Dlls built in Visual Studio", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 04:01:05 GMT", "source": "codeproject", "tags": ["C++", "Windows", "Visual-Studio", "VS2010"]}]}