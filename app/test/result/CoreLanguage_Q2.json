{"result": [{"answers": [{"content": "I developed a Python package (https://github.com/LLyaudet/python-none-objects, https://pypi.org/project/python-none-objects/).\nIt supplies the following \"None\" objects to have simpler code:", "id": 78399549, "owner_tier": 0.3, "score": -5.46448087431694e-11}, {"content": "PyCharm warns that the default argument is mutable, which may seem obtuse, but what it means is that objects you create using the default are all sharing the same reference to that one default argument. Here's a bit of code that demonstrates the problem: If I then go on to create a few instances of the foo class without supplying a new list of stuff for each, then each instance will share a reference to that same default list! You can see I've added items to the stuff list for a but when I print the two instances the second time, b also has two items in it's stuff as well, ... in fact it's the same two items! The best way to get around this, but still supply defaults is to change your code just a bit and supply None as the default, then use or to coalesce that with a new list inside the constructor: Now if we repeat the construction of a and b and add stuff to a exactly as before, we get a different result: This is because the instance a and the instance b no longer share a reference to the same (default) list, but use new lists constructed when the instance was initialized.  While python hides most of the ugliness of pointers and references they are still there under-the-hood and sometimes we still need to be aware of them.  Incidentally, if you supply values (primitive types) as defaults, they don't have this issue because the value itself is placed in the instance, not a reference (e.g. stuff=1 rather than stuff=[]).", "id": 76484610, "owner_tier": 0.5, "score": 0.005464480819672131}, {"content": "This is a warning from the interpreter that because your default argument is mutable, you might end up changing the default if you modify it in-place, which could lead to unexpected results in some cases. The default argument is really just a reference to the object you indicate, so much like when you alias a list to two different identifiers, e.g., if the object is changed through any reference, whether during that call to the function, a separate call, or even outside the function, it will affect future calls the function. If you're not expecting the behavior of the function to change at runtime, this could be a cause for bugs. Every time the function is called, it's the same name being bound to the same object. (in fact, I'm not sure if it even goes through the whole name binding process each time? I think it just gets another reference.) You can see the effect of this by declaring the following and calling it a few times: Wait, what? yes, because the object referenced by the argument doesn't change between calls, changing one of its elements changes the default. If you use an immutable type, you don't have to worry about this because it shouldn't be possible, under standard circumstances, to change an immutable's data. I don't know if this holds for user-defined classes, but that is why this is usually just addressed with \"None\" (that, and you only need it as a placeholder, nothing more. Why spend the extra RAM on something more complicated?) In your case, you were saved by an implicit copy, as another answer pointed out, but it's never a good idea to rely on implicit behavior, especially unexpected implicit behavior, since it could change. That's why we say \"explicit is better than implicit\". Besides which, implicit behavior tends to hide what's going on, which could lead you or another programmer to removing the duct tape. You can avoid this bug magnet completely and satisfy the warning by, as others have suggested, using an immutable type such as None, checking for it at the start of the function, and if found, immediately replacing it before your function gets going: Since immutable types force you to replace them (Technically, you are binding a new object to the same name. In the above, the reference to None is overwritten when attachment is rebound to the new empty dictionary) instead of updating them, you know attachment will always start as None unless specified in the call parameters, thus avoiding the risk of unexpected changes to the default. (As an aside, when in doubt whether an object is the same as another object, compare them with is or check id(object). The former can check whether two references refer to the same object, and the latter can be useful for debugging by printing a unique identifier\u2014typically the memory location\u2014for the object.)", "id": 63329315, "owner_tier": 0.3, "score": 0.07650273218579234}, {"content": "If you don't alter the \"mutable default argument\" or pass it anywhere where it could be altered just ignore the message, because there is nothing to be \"fixed\". In your case you only unpack (which does an implicit copy) the \"mutable default argument\" - so you're safe. If you want to \"remove that warning message\" you could use None as default and set it to {} when it's None: Just to explain the \"what it means\": Some types in Python are immutable (int, str, ...) others are mutable (like dict, set, list, ...). If you want to change immutable objects another object is created - but if you change mutable objects the object remains the same but it's contents are changed. The tricky part is that class variables and default arguments are created when the function is loaded (and only once), that means that any changes to a \"mutable default argument\" or \"mutable class variable\" are permanent: PyCharm probably shows this Warning because it's easy to get it wrong by accident (see for example Why do mutable default arguments remember mutations between function calls? and all linked questions). However, if you did it on purpose (Good uses for mutable function argument default values?) the Warning could be annoying.", "id": 41686973, "owner_tier": 0.9, "score": 0.9999999999453552}, {"content": "To rephrase the warning: every call to this function, if it uses the default, will use the same object.  So long as you never change that object, the fact that it is mutable won't matter.  But if you do change it, then subsequent calls will start with the modified value, which is probably not what you want. One solution to avoid this issue would be to have the default be a immutable type like None, and set the parameter to {} if that default is used:", "id": 41686974, "owner_tier": 0.9, "score": 0.01639344256830601}, {"content": "Lists are mutable and as declaring default with def at declaration at compile time will assign a mutable list to the variable at some address \u00a0 To correct this:  \u00a0", "id": 59855340, "owner_tier": 0.3, "score": -5.46448087431694e-11}, {"content": "You can replace mutable default arguments with None. Then check inside the function and assign the default: This works because None evaluates to False so we then assign an empty dictionary. In general you may want to explicitly check for None as other values could also evaluate to False, e.g. 0, '', set(), [], etc, are all False-y. If your default isn't 0 and is 5 for example, then you wouldn't want to stomp on 0 being passed as a valid parameter:", "id": 41686977, "owner_tier": 0.7, "score": 0.08743169393442622}], "link": "https://stackoverflow.com/questions/41686829/why-does-pycharm-warn-about-mutable-default-arguments-how-can-i-work-around-the", "question": {"content": "I am using PyCharm (Python 3) to write a Python function which accepts a dictionary as an argument with attachment={}. In the IDE, attachment={} is colored yellow. Moving the mouse over it shows a warning. Default arguments value is mutable This inspection detects when a mutable value as list or dictionary is\ndetected in a default value for an argument. Default argument values are evaluated only once at function definition\ntime, which means that modifying the default value of the argument\nwill affect all subsequent calls of the function. What does this mean and how can I resolve it?", "id": 41686829, "title": "Why does PyCharm warn about mutable default arguments? How can I work around them?", "traffic_rate": 30}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "pycharm", "warnings"]}, {"answers": [{"content": "Why does c1 behave like a class variable? Because you specified default value for them and they're now a class attribute. In the Mutable Default Values section, it's mentioned: Python stores default member variable values in class attributes. But look at this: c1 doesn't have default value so it's not in class's namespace. Indeed by doing so(defining default value), Python stores that c1 and c2 inside both instance's namespace (n1.__dict__) and class's namespace (Y.__dict__). Those are the same objects, only the reference is passed: So now, If you want them to be different you have several options: In the second option, because I didn't specify default parameter(you can't mix both), nothing is going to be stored in the class's namespace. field(default=SOMETHING) is another way of saying = SOMETHING.", "id": 73599520, "owner_tier": 0.5, "score": 0.9999999975}], "link": "https://stackoverflow.com/questions/73598938/why-is-dataclass-field-shared-across-instances", "question": {"content": "First time using dataclass, also not really good at Python. The following behaviour conflicts with my understanding so far: This prints Why does c1 behave like a class variable? What can I do to keep n2.c1 != n1.c1, do I need to write an init function? I can get sensible results with this addition to Y: prints:", "id": 73598938, "title": "Why is dataclass field shared across instances", "traffic_rate": 1243}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "python-dataclasses"]}, {"answers": [], "link": "https://stackoverflow.com/questions/6838255/python-class-function-default-variables-are-class-objects", "question": {"content": "I was writing some code this afternoon, and stumbled across a bug in my code. I noticed that the default values for one of my newly created objects was carrying over from another object! For example: So I know it can be solved by doing this: What I would like to know is... Why? Why are Python classes structured so that the default values are saved across instances of the class?", "id": 6838255, "title": "Python class function default variables are class objects?", "traffic_rate": 1}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "The class defined in your lecture is dumb (not very dumb, just pointless and misleading, as you've clearly been misled by it). There is zero reason to define class attributes that happen to share the same value as the default arguments to the initializer. The only thing doing that accomplishes is: In all other ways, there is no relationship between the class level attributes and the defaults defined for the __init__ initializer method; the moment __init__ assigns to self.slices and self.temperature, it shadows the class level attributes so they cannot be directly accessed from that instance of the class (without deleting the instance attributes or bypassing the instance to look at the values on the class itself). So no, you can't do: because the arguments named slices and temperature have nothing to do with the class attributes. By removing their defaults, the user of your class is forced to provide their own values, and there is no default that will be provided (they could, I suppose, do Pizza(Pizza.slices, Pizza.temperature), but that's an insane way to handle defaults). To your updated question, even without the class variables, works just fine. Outside of any methods of the class, slices and temperature won't exist, but any other methods you define on Pizza will be able to access that instance's slice and temperature attributes by looking them up on self, just like __init__ did when it assigned to them (with self.slices or self.temperature), and anyone who creates an instance of Pizza, say, with mypizza = Pizza(12, 140), can do mypizza.slices to see the attribute for the instance they hold. A note on the class attributes: In normal cases, they're stupid and nonsensical. There is an exception for dataclasses though, where you define them at class level for the express purpose of helping the dataclasses module dynamically generate your code, removing the need to write a __init__ with separate defaults entirely. For example: is a perfectly reasonable way to write the baseline class, and it uses those annotations and defaulted assignments to generate as __init__ for you (along with reasonable default implementations of __repr__ and __eq__, and other special methods if you pass specific arguments to the @dataclass decorator, saving you a ton of boilerplate required for minimal expected class functionality). It does leave the class attributes in place, which is arguably a bad idea, but at least you're getting something useful out of the deal, it's not just repeating the same defaults in two essentially unrelated places, one of which is completely useless.", "id": 71947785, "owner_tier": 0.9, "score": 0.0}, {"content": "If you use: Then slices and temperature are parameters that must be specified. What you can do is create a variable, and then use that as the default for the function parameter. Just keep in mind that if you redefine that variable, it does not affect the default value for the function.", "id": 71934595, "owner_tier": 0.9, "score": 0.0}], "link": "https://stackoverflow.com/questions/71934568/python-are-these-default-values-being-passed-to-the-init-function-necessary", "question": {"content": "Here is a screenshot from a lecture that I am going through at school:  My question is, if the class data fields are already being defined: Do those values (16 and 75.0) also need to be passed to the __init__ method or can you just pass the variables names, because they are already assigned to those values? Not sure why/if you would need to pass the default values when they are the exact same as what the variables are already set to? so instead of: Could you just do: Updated new question\nIf you removed the initial class-level variables at the top, and are only defining them in the constructor class, are they only scoped to the constructor class? Or are they available throughout the entire class, even though you didn't define them at the very top (class-level)?? Example: Or, because you are defining them as \"self.slices\", they are by default passed to all of the other methods when you pass (self) into the other methods?", "id": 71934568, "title": "Python: Are these default values being passed to the __init__ function necessary?", "traffic_rate": 353}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "python-3.x"]}, {"answers": [{"content": "With dataclasses, a feature added in Python 3.7, there is now yet another (quite convenient) way to achieve setting default values on class instances. The decorator dataclass will automatically generate a few methods on your class, such as the constructor. As the documentation linked above notes, \"[t]he member variables to use in these generated methods are defined using PEP 526 type annotations\". Considering OP's example, we could implement it like this: When constructing an object of this class's type we could optionally overwrite the value.", "id": 62758003, "owner_tier": 0.3, "score": 0.010989010934065934}, {"content": "The two snippets do different things, so it's not a matter of taste but a matter of what's the right behaviour in your context. Python documentation explains the difference, but here are some examples: This binds num to the Foo instances. Change to this field is not propagated to other instances. Thus: This binds num to the Bar class. Changes are propagated! If I do not require a class variable, but only need to set a default value for my instance variables, are both methods equally good? Or one of them more 'pythonic' than the other? The code in exhibit B is plain wrong for this: why would you want to bind a class attribute (default value on instance creation) to the single instance? The code in exhibit A is okay. If you want to give defaults for instance variables in your constructor I would however do this: ...or even: ...or even: (preferrable, but if and only if you are dealing with immutable types!) This way you can do:", "id": 2681286, "owner_tier": 0.5, "score": 0.3956043955494506}, {"content": "Extending bp's answer, I wanted to show you what he meant by immutable types. First, this is okay: However, this only works for immutable (unchangable) types. If the default value was mutable (meaning it can be replaced), this would happen instead: Note that both a and b have a shared attribute. This is often unwanted. This is the Pythonic way of defining default values for instance variables, when the type is mutable: The reason my first snippet of code works is because, with immutable types, Python creates a new instance of it whenever you want one. If you needed to add 1 to 1, Python makes a new 2 for you, because the old 1 cannot be changed. The reason is mostly for hashing, I believe.", "id": 2681507, "owner_tier": 0.5, "score": 0.999999999945055}, {"content": "You can also declare class variables as None which will prevent propagation. This is useful when you need a well defined class and want to prevent AttributeErrors.\nFor example: Also if you need defaults: Of course still follow the info in the other answers about using mutable vs immutable types as the default in __init__.", "id": 30515149, "owner_tier": 0.5, "score": -5.494505461112797e-11}, {"content": "Using class members to give default values works very well just so long as you are careful only to do it with immutable values. If you try to do it with a list or a dict that would be pretty deadly. It also works where the instance attribute is a reference to a class just so long as the default value is None. I've seen this technique used very successfully in repoze which is a framework that runs on top of Zope. The advantage here is not just that when your class is persisted to the database only the non-default attributes need to be saved, but also when you need to add a new field into the schema all the existing objects see the new field with its default value without any need to actually change the stored data. I find it also works well in more general coding, but it's a style thing. Use whatever you are happiest with.", "id": 2681363, "owner_tier": 0.9, "score": 0.027472527417582417}, {"content": "Using class members for default values of instance variables is not a good idea, and it's the first time I've seen this idea mentioned at all. It works in your example, but it may fail in a lot of cases. E.g., if the value is mutable, mutating it on an unmodified instance will alter the default:", "id": 2681303, "owner_tier": 0.9, "score": -5.494505461112797e-11}], "link": "https://stackoverflow.com/questions/2681243/how-should-i-declare-default-values-for-instance-variables-in-python", "question": {"content": "Should I give my class members default values like this: or like this? In this question I discovered that in both cases, is a well-defined operation. I understand that the first method will give me a class variable while the second one will not. However, if I do not require a class variable, but only need to set a default value for my instance variables, are both methods equally good? Or one of them more 'pythonic' than the other? One thing I've noticed is that in the Django tutorial, they use the second method to declare Models. Personally I think the second method is more elegant, but I'd like to know what the 'standard' way is.", "id": 2681243, "title": "How should I declare default values for instance variables in Python?", "traffic_rate": 61}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "class", "oop"]}, {"answers": [{"content": "According to what's given here A Python variable is a symbolic name that is a reference or pointer to an object. Once an object is assigned to a variable, you can refer to the object by that name. But the data itself is still contained within the object. Here, A's reference is passed to B. So they point to the same data, but are just called by different names. So whatever operation you perform on B, you also perform on A. Hence, later when you assign A to C, the same data is referenced by C. If you don't want that to happen, use deepcopy:", "id": 61756644, "owner_tier": 0.1, "score": 0.0}], "link": "https://stackoverflow.com/questions/61756422/creating-new-object-keeps-data-even-with-default-value", "question": {"content": "I am struggling to understand why instance C keeps data of instance B, even though I initialized the instance variable var with the default empty list. Why is the default argument \"var = []\" ignored?. The print retuns Even stranger is this: prints How can the statement self.var = var append to the  list from the front?", "id": 61756422, "title": "Creating new object keeps data even with default value", "traffic_rate": 318}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python-3.x", "default-value", "instance-variables", "class-variables"]}, {"answers": [{"content": "Python passes parameters to functions by value; So for objects, the value passed is a reference to the object, not a new copy of the object. That, along with the following part of the official docs is what helped me understand it better (emphasis mine): Default parameter values are evaluated [...] when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. [...] A way around this is to use None as the default, and explicitly test for it in the body of the function [...] Putting it all together: If you define the default for a parameter to be a mutable object (such as []) then the \"pre-computed\" value is the reference to that object, so each call to the function will always reference the same object, which can then be mutated across multiple invocations of the function. However, since None is an immutable built-in type, the \"pre-computed\" value for a default of None is simply that. So the parameter will be None each time you call the function. Hopefully that helps! I do think that the tutorial could have had better wording, because I was also confused by that at first.", "id": 33573262, "owner_tier": 0.5, "score": 0.9999999997674418}, {"content": "I think this is happening because a list is a mutable object while the value None is immutable. For the first function, variable L is outside the function environment (in the function definition), and it refers to an empty list. Then you make changes to this list in the function environment, but since a list is mutable, the variable L that is outside the function environment refers to this now mutated list, and the change propagates each time you call the function. For the second function, variable L is also outside the function environment (in the function definition), but this time it refers to None, which is immutable. Now, every change you make in the function environment will not affect what L refers to outside the function environment. The variable L inside the function environment refers to something different as you change it. First, it refers to an empty list, and then a list that gets a value appended to it. You then return this list. The next time you call the function, you call it with the variable L that is outside the function environment, which has not changed and still refers to None. Hope this makes sense.", "id": 24053766, "owner_tier": 0.1, "score": -2.3255813812151838e-10}, {"content": "What happens is as follows: When a python function is called, it is evaluated in the environment in which it was defined and not the environment in which it was called although the second part is secondary ( no pun intended) for the purpose of answering your question. The default arguments are evaluated only once at the time of function definition. This creates a closure. Think of closure as function code + environment in which the function was been defined.  So in this case when the function was defined, L was assigned to [] and now every subsequent call to the function will use this value of L.  The tutorial also mentions: The default values are evaluated at the point of function definition in the defining scope (and the defining scope is part of the closure along with function code) http://docs.python.org/2/tutorial/controlflow.html#default-argument-values", "id": 20862647, "owner_tier": 0.7, "score": -2.3255813812151838e-10}], "link": "https://stackoverflow.com/questions/13087344/python-function-default-parameter-is-evaluated-only-once", "question": {"content": "I am a python beginner, reading 'python tutorial', it says if we have a function: This will print Because the default value is evaluated only once and list is a mutable object. I can understand it. And it says continue, if we don't want the default to be shared between subsquent calls, we can: and this will output: But why? How to explain this. We know default value is evaluated only once, and when we call f(2), L is not None and that if(in line 2) can not be true, so L.append(a) == [1, 2]. Could I guess the default value is evaluated again for some reason , but what is 'some reason', just because the python interpreter see if L is None: L = []", "id": 13087344, "title": "python function default parameter is evaluated only once?", "traffic_rate": 10}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "function", "parameters"]}, {"answers": [{"content": "This is a known Python gotcha. You have to avoid using a mutable object on the call of a function/method. The objects that provide the default values are not created at the time that the function/method is called. They are created at the time that the statement that defines the function is executed. (See the discussion at Default arguments in Python: two easy blunders: \"Expressions in default arguments are calculated when the function is defined, not when it\u2019s called.\") This behavior is not a wart in the Python language. It really is a feature, not a bug. There are times when you really do want to use mutable default arguments. One thing they can do (for example) is retain a list of results from previous invocations, something that might be very handy. But for most programmers \u2014 especially beginning Pythonistas \u2014 this behavior is a gotcha. So for most cases we adopt the following rules. So... we plan always to follow rule #1. Now, the question is how to do it... how to code functionF in order to get the behavior that we want. Fortunately, the solution is straightforward. The mutable objects used as defaults are replaced by None, and then the arguments are tested for None. So how can one do it correctly? One solution is avoid using mutable default values for arguments. But this is hardly satisfactory, as from time to time a new list is a useful default. There are some complex solutions like defining a decorator for functions that deep-copies all arguments. This is an overkill, and the problem can be solved easily as follows:", "id": 1534515, "owner_tier": 0.9, "score": -1.111111111111111e-09}, {"content": "Please read this answer for a discussion of how to setup a class from __init__().  You have encountered a well-known quirk of Python: you are trying to set up a mutable, and your mutable is being evaluated once when __init__() is compiled.  The standard workaround is:", "id": 1534461, "owner_tier": 0.9, "score": 0.22222222111111112}, {"content": "From http://docs.python.org/3.1/tutorial/controlflow.html: The default value is evaluated only\n  once. This makes a difference when the\n  default is a mutable object such as a\n  list, dictionary, or instances of most\n  classes.", "id": 1534448, "owner_tier": 0.5, "score": 0.11111111}, {"content": "Your problem is that the default value is evaluated at function definition time. This means that the same list object is shared between instances. See the answer to this question for more discussion.", "id": 1534444, "owner_tier": 0.9, "score": 0.6666666655555555}, {"content": "You should change to and all will be better. This is a detail in the way default arguments are handled if they're mutable. There's some more information in the discussion section of this page.", "id": 1534443, "owner_tier": 0.9, "score": 0.9999999988888888}], "link": "https://stackoverflow.com/questions/1534407/python-object-initialization-bug-or-am-i-misunderstanding-how-objects-work", "question": {"content": "This will print the reference to the object assigned to one._resources for both one and two objects. I would think that two would be an empty array as it is clearly setting it as such if it's not defined when creating the object. Uncommenting myobj.__init__(self, resources) does the same thing.  Using super(ext, self).__init__(resources) also does the same thing. The only way I can get it to work is if I use the following: I shouldn't have to manually set the default value when creating the object to make this work. Or maybe I do. Any thoughts? I tried this using Python 2.5 and 2.6.", "id": 1534407, "title": "Python object initialization bug. Or am I misunderstanding how objects work?", "traffic_rate": 0}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "mutable", "arguments"]}, {"answers": [{"content": "Taken from the the documentation: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. [...] If you don\u2019t want the default to be shared between subsequent calls, you can write the function like this instead:", "id": 24981298, "owner_tier": 0.5, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/24981239/why-is-a-default-value-set-for-a-python-3-function-overwritten-when-the-function", "question": {"content": "Can someone explain me why, when I call this function multiple times, L is never set to empty by default? But instead the result of any following call is L appended to all results of preceding calls? The function separates the data into blocks of 7 days, starting with the last date ([::-1]),\ncalculates the mean of each 7 days and appends the result as a value to\na list. Ignores incomplete blocks The default value for data is a list of dates in ordinal format.", "id": 24981239, "title": "Why is a default value set for a Python 3 function overwritten when the function gets called multiple times?", "traffic_rate": 900}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "list", "append", "default"]}, {"answers": [{"content": "You fell into a common newbie trap for Python.  Using a list as a default variable as you did with def __init__(self, list = [0,0,0,0,0,0,0,0,0,0]) means that all instances of that class share the same list instance as the value for that argument.  See also \"Least Astonishment\" and the Mutable Default Argument By the way, a common idiom if you want to use a container object such as a list as a default argument, is to instead use None and check for that.  For example: Or whatever.  Not quite as clearly self-documenting as default arguments but it works. As a side note, don't use list as a variable name, as it shadows the (somewhat commonly used) list builtin.", "id": 13389510, "owner_tier": 0.7, "score": 0.9999999985714286}], "link": "https://stackoverflow.com/questions/13389325/why-do-two-class-instances-appear-to-be-sharing-the-same-data", "question": {"content": "I was doing some work in Python when I ran into an unexpected problem.  I have a class, and two variables x and y.  x and y are meant to be separate copies of the class each with their own data.  So I set x equal to the class and give it some values, then do the same with y.  Once I try to use that data though, I realize that I overwrote my values for x.  It seems that I have not created two separate copies of the class to work with but instead two references to the same class.  So here is the general example in code: The end result is that 3 is printed instead of 2.  I want to create a separate \"version\" of the class to hold different data for each variable.  Not sure as to how though.  Using Python 3.3.  Here is the code for the class:", "id": 13389325, "title": "Why do two class instances appear to be sharing the same data?", "traffic_rate": 1195}, "saved_time": 1721101398, "source": "stackoverflow", "tags": ["python", "class"]}, {"answers": [{"content": "This is such a common question that it's in the official Python language FAQ: https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects\n\nTL;DR: when a function argument has a default value, the default value is a *property of the function itself* and therefore every time you call the function, you're getting a reference to the same object. (You're technically correct that in your function, `y` is a local variable. But in Python, variables *point to* objects, and the object that `y` points to is shared.)\n\nAlso [here](https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument).\n\nThank you so much.", "id": "jdnsv60", "owner_tier": 0.7, "score": 0.9999999989999999}, {"content": "Dont use list (unless you do this on purpose) as default value to function parameter, Python will use the same list instance for every function call.", "id": "jdnt216", "owner_tier": 0.5, "score": -9.99999993922529e-10}, {"content": "python evaluates default param values once, when the function is defined, and reuses them on subsequent calls. mutable values, like lists and divts, will be changing unless you make a copy inside the function, and operate on that", "id": "jdnt97l", "owner_tier": 0.5, "score": -9.99999993922529e-10}], "link": "https://www.reddit.com/r/learnprogramming/comments/121xc5q/python_weird_behavior_for_functions_default_values/", "question": {"content": "I was trying to implement the Fibonacci series recursively using python when I came across this weird behavior that I don't understand.\n\nI will not use the Fibonacci function as my example , I will use simpler example.\n\nconsider this function\n\n    def test(y=[0]):\n      for i in range(10): \n         y.append(0)\n       return y\n\n&#x200B;\n\nthis function has a default value for y which is an array that has only one item 0\n\nif I print out this function twice I expected to get the exact same result\n\n    print(test())\n    print(test())\n\nsince I am running the same function twice, in both cases I did't include a value for y. So I was expecting the output to be array with eleven zeros in both cases but this is what I get instead\n\n    [0,0,0,0,0,0,0,0,0,0,0]\n    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\nas if arr was a global variable and all the zeros from the first function were already appended to it before running the function for the next time.\n\nBut this is not the case, arr is local to the function. so can someone explain to me this weird behavior or tell me what to search for because I don't even have a clue for what to search for.", "id": "121xc5q", "title": "Python Weird behavior for functions default values", "traffic_rate": 759.40625}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "It's not that mutable arguments are reset with each call, it's that changing them at any point reassigns the variable to a *new instance*.\n\nE.g. in your second example, a is 5 by default. When you add 3 to it, it doesn't change the 5 in memory to 8, it creates a new spot in memory to hold that 8 and points the variable to that. (That's probably a bit of a simplification, but it gives you the idea).\n\nWith mutable arguments, rather than creating a new spot in memory, you might modify the original. Note that if you have the discipline to never modify that in place, it will never be a problem, but it's bad practice because it forces you to be more careful.\n\nI think I get what you are saying but it still doesnt add up for me\r  \n\r  \nI accept that the point in memory does not change, but haven't you still updated the variable by pointing it at the new spot in memory\r  \n\r  \nso heres the steps I'm imagining\r  \n\r  \n1. function is loaded\r  \n2. a is created\r  \n3. a is pointed at 5 in memory\r  \n4. function is run\r  \n5. a is pointed at 8 in memory\r  \n6. function is run\r  \n7. a is now pointed at 11 in memory  \n\n\nbut this isnt the case so I'm guessing that there must be 2 `a` variables in different scopes or something\n\n> but this isnt the case so I'm guessing that there must be 2 `a` variables in different scopes or something\n\nEssentially yes. Consider this differently though. The default argument is always initialized with the same *object*.\n\nWhen Python encounters \n\n    def func(a=[]):\n        a.append(3)\n        return a\n\nWhat happens? Like, you're defining something, `func`, but what does python actually do here? It compiles it to byte code. It creates the default argument object(`[]`). Now, whenever you enter the function, and use the default argument, it is pointing to that same object. Because a list is mutable, that object can change. So, if the function (or elsewhere) modifies the list, future calls will see that same object in the modified state. All calls look at the same object, so naturally, if that object gets modified, all calls see those modifications.\n\nWhat if it's immutable? Well, all calls look at the same object. What happens with the below lines of code?\n\n    a = 3\n    a += 1\n\n`a` gets assigned the object of `3`. Then, since `3` is immutable, 3 doesn't get touched. 3 is never modified. 3 existed before time, and will exist when the end of all things comes to pass. When everything you know and love has faded into dust and is long forgotten, `3` will remain. Unchanging. Unflinching. Uncaring. Prime. `a` gets assigned to a completely different object, `4`. `3` still exists. And `3` does not forget, and it does not forgive.\n\nLook at the below code:\n\n    a = 1\n    b = a\n    b += 1\n\n    print(f\"a: {a}\")\n\n    c = [1]\n    d = c\n    d += [1]\n\n    print(f\"c: {c}\")\n\n\nOutput:\n\n    a: 1\n    c: [1, 1]\n\nWith the non-mutable example, b can't mutate `1`, so it gets a new object. Anything that was pointing to the old object, still is, which hasn't changed. With the mutable example, `d` can mutate, so it does, and all references see that mutation.\n\n> I'm guessing that there must be 2 a variables in different scopes or something\n\nYes, exactly! That seems to be the missing link. `a` is a thing for you and me; what Python sees is a location in memory. Each call to the function uses the same location in memory for the default argument (in the same way that it uses the same location in memory for the function's instructions, rather than re-creating the function every time), but it uses a different chunk of memory for each call.\n\nA function is a set of instructions, really no different from a very long list of values, just like variable values. We generally don't want to make a new copy of those instructions each time, given that the *instructions* will never change. Default arguments are part of the function's definition, and thus are not re-created with each function call.\n\nBut each function call has to create a new instance of the function's local variables, including parameters (some languages provide a way around this).\n\nSo, in your example, `func` is created once - including its instructions and the `[]` default parameter - but local variables - meaning `a` - are created with each call. So the steps really look more like this:\n\n1. function is created\n   * instructions are created\n   * default parameters (`5`) are created\n1. function is called\n   1. `a` is created\n   1. `a` is pointed at the default parameter - `5` - in memory\n   1. `a` is changed to `8`\n      * The default parameter is not touched\n1. function is called\n   1. `a` is created\n   1. `a` is pointed at the default parameter - `5` - in memory\n   1. `a` is changed to `8`\n      * The default parameter is not touched\n1. Rinse & repeat\n\nPython *could* create a new instance of the default variables each time, but it was designed to not do that. Python also could create a new instance of each function each time it's called, but it was designed to not do that. These are arbitrary (but very common) language design choices.\n\nIt makes way more sense to think about it that way.  That the default behaviour is to try to mutate the object in memory and only if that is impossible, then the name is assigned to a new object instead\n\nAlso I love your writing style\n\nIts all coming together now, I think I get it\n\nfunc is an instance of the function class, that has a `default arguments` attribute, which points to an object in memory\n\nWhen func is invoked, it creates a local variable that also points to that object in memory.\n\nWhen you try to update an object, python will try to mutate it in memory, and if it cant it will create/point to a new object instead, which explains the behaviour in the examples\n\nI had a look at the func object and you can even mess with the defaults arguments manually\n\n    def func(a=5):\n    return a\n    \n    func.__defaults__ = (10,)\n    func()\n    >10", "id": "ik7593i", "owner_tier": 0.7, "score": 0.9999999993333333}, {"content": "Because there is a big difference between reassigning a variable using `=` and calling a mutative method like `append` on the object.\n\n`=` changes what object the variable is pointing to. It doesn't modify the object in any way, so no one else looking at that object will notice anything. This would be like multiple people pointing at an object. A new person pointing at the object has no affect on the object itself. `a += 1` makes `a` point to the object that resulted from `a + 1`, but this didn't change the old object that other code may be referring to.\n\n`append` actually modifies the object though. This would be like if multiple people were pointing at an object, and then someone came and destroyed the object. They would all see the change because they were all looking at the same object that was mutated. If multiple pieces of code are looking at the same object, you must be careful what you do to that object\n\n***\n\nAnd this isn't really about mutable vs immutable objects (other than that `+=` is mutative on lists). What really matters is what you're doing to the object. In theory, it's fine to have a mutable default argument *as long as you never mutate it or leak a reference to it* (like by returning it). If you have a list as a default argument and all you did was iterate it with a `for` loop, it's fine (at the moment). This is a potential source of a bug in the future though, so it's usually best to avoid mutable defaults altogether.\n\nThanks, I think I understand it now.  \n\n\n>\\+= is mutative on lists\n\nThats really surprising as it means a += b is not equivalent to a = a + b for mutable objects.  \n\n\nI just tested it  \n\n\n`def func(a=[]):`  \n`a = a + [3]`  \n`return a`\n\n`func()`  \n`> [3]`  \n`func()`  \n`> [3]`  \n\n\n`def func(a=[]):`  \n`a += [3]`  \n`return a`\n\n`func()`  \n`> [3]`  \n`func()`  \n`> [3, 3]`  \n\n\nthats super counterintuitive if you didnt know that,  feels like it would be a really annoying interview question\n\nYes, it's essentially just `.extend`. They use the same code behind the scenes. And ya, I agree, it can be confusing.\n\nIn all cases x = x + y is a generic combo of unoptimized calculation of a new value x+y, and then reassigning x. That's two separate steps that can't be optimized in any way.   \nBut in case of += and mutables it's possible to have a more optimized version that performs the action in place, without let's say duplicating a potentially huge object. It's worthwhile to have it as an option, because sometimes the generic, naive way is very expensive compared to the lightning fast in place op.\n\nLong story short if the mutable type might support in-place operations with optimization potential, expect augmented assignments like += to be exactly that, unless proven otherwise.", "id": "ik76h76", "owner_tier": 0.9, "score": 0.466666666}, {"content": "> I've read this is caused by python initializing those variables once when the code is loaded instead of every call to the function\n\n> If that's true, why is that only a problem for mutable variables? Why do other variables get reset for every call?\n\nBecause you can't do anything to change the value of an immutable variable, so there are no side effects to using the same variable across multiple calls.\n\nThe \"problem\" with mutable defaults isn't really a Python problem--it's a conceptual one in the programmer's mind. Python treats all defaults exactly the same way, but programmers tend to \"think\" about them incorrectly.\n\n    a = []\n    a.append(b)\n\nisn't changing the value of `a`, it's changing the object that `a` refers to--`a` stays \"constant\". However, most new programmers consider this type of \"change\" equivalent to:\n\n    a = 5\n    a = 6\n\nWhich is not true.", "id": "ik7pq2g", "owner_tier": 0.7, "score": -6.666666626150194e-10}], "link": "https://www.reddit.com/r/learnpython/comments/wntguq/why_are_only_mutable_variables_a_problem_in/", "question": {"content": "As far as I can gather, using a mutable variable as a default argument in a function causes issues because mutating that variable will mutate the default argument for that function for all subsequent calls.\n\n    def func(a=[]):\n        a.append(3)\n        return a\n    \n    func()\n    > [3]\n    func()\n    > [3, 3]\n\nI've read this is caused by python initialising those variables once when the code is loaded instead of every call to the function\n\nIf thats true, why is that only a problem for mutable variables, why do other variables get reset for every call?\n\n    def func(a=5):\n        a += 3\n        return a\n    \n    func()\n    > 8\n    func()\n    > 8", "id": "wntguq", "title": "Why are only mutable variables a problem in default arguments?", "traffic_rate": 153.12444444444444}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "What happens behind the scenes?\n\nLike does python remember the original list throughout the cycle of the application even though it's only defined as a default?\n\nThis breaks my mind to be honest... [This](https://stackoverflow.com/a/1145781/11010254) person explains it like this:\n\n>Actually, this is not a design flaw, and it is not because of internals or performance.\nIt comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.\n\n>As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \"member data\" and therefore their state may change from one call to the other - exactly as in any other object.\n\n>In any case, Effbot has a very nice explanation of the reasons for this behavior in [Default Parameter Values in Python](https://web.archive.org/web/20200221224620/http://effbot.org/zone/default-values.htm).\nI found it very clear, and I really suggest reading it for a better knowledge of how function objects work.\n\nOkay so I'm sure I've got a little misunderstanding on my end, but it looks like when python compiles the code the first time it defines everything in the def statements. So if you set something to a default value of None it doesn't redefine that value as None every time the code is ran, it just remembers that it's supposed to be None.\n\nRight. The default argument object is created once when the function definition is evaluated, then never again. If that object is mutable, and you mutate it, it stays the same between different calls because it's always the same object.", "id": "hgq5c8r", "owner_tier": 0.9, "score": 0.9999999980000001}, {"content": "*Technically*, it's actually safe to have a mutable default argument, **if** you never mutate or `return` the default object. This for example is perfectly safe:\n\n    def print_out(xs=[]):\n        for x in xs:\n            print(x)\n\nThe only danger here is there's the possibility that in a larger function, you forget that `xs` is potentially the default object, and mutate it when you change the behavior of the function down the road. You may want to avoid using a mutable default to eliminate the chances of accidentally introducing a bug, but simply having a mutable default argument is not necessarily dangerous.", "id": "hgqlirh", "owner_tier": 0.9, "score": -1.999999987845058e-09}], "link": "https://www.reddit.com/r/learnpython/comments/q8m2xn/python_mutable_defaults_are_the_source_of_all_evil/", "question": {"content": "Here is a tip that I learned today that unbroke my code: **Do not use mutable default arguments in Python**, unless you have a REALLY good reason to do so.\n\nhttps://florimond.dev/en/posts/2018/08/python-mutable-defaults-are-the-source-of-all-evil/", "id": "q8m2xn", "title": "Python Mutable Defaults Are The Source of All Evil", "traffic_rate": 153.12444444444444}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "Don't use class attributes for that, that's not what they are there for.  Use default arguments:\n\n    def __init__(self, name='Undefined', number=-1):\n        self.name = name\n        self.number = number\n\nIf any of the arguments are mutable, then you need to use the usual idiom:\n\n    def __init__(self, foo=None):\n        self.foo = [] if foo is None else foo\n\n\nI'm new to Python classes, so I'm not sure what you mean by the usual idiom if the arguments are mutable. It seems that, in the first example, the arguments are mutable as well?\n\n    me = MyClass(name='Joe', number=11)\n    me.name = 'Jack'\n\nCan you please explain when and why I'd use your second example? Thanks.\n\nYou can just do\n\n    self.foo = foo or [] \n\nYou should read up on mutable types in general because it causes issues throughout your Python code if you're not aware of it. Mutable is a specific term about data types, not about variable names. There, you're changing the name string by reassigning `me.name` to a different string. When you do something like\n    \n    L = [1, 2, 3]\n    L[0] = 5\n\nYou're going to the list and changing it in-place instead of creating an entirely different list [5, 2, 3] and binding it to L.\n\nDefault arguments are evaluated when its function is defined, not when it's called, so the default argument is always going to point to the same thing.\n\n    class MyClass(object):\n        def __init__(self, foo=[]):\n            self.foo = foo\n\n    a = MyClass()\n    b = MyClass()\n    # Both a.foo and b.foo are bound to the same list, foo\n    a.foo.append(2)\n    print(a.foo, b.foo)\n    # You've changed both since they're bound to the same thing\n\nYou need to be wary of this every time you use a mutable argument, such as lists, dictionaries, and custom-made objects.\n\nThe values for the default arguments are evaluated once, at the point where the `def` statement is evaluated, not each time the function is called.  That means that there's only object created for the default value, which is used every time the function is called.  For immutable types like strings and numbers it doesn't matter since the value cannot be modified, but with mutable types if you modify the object the change will be seen to all users, since they are all referring to the same object.  For example, if you wrote a function like:\n\n    def foo(bar=[]):\n        ...\n\nYou don't get a new empty list every time you call this function with no arguments.  It's the same list every time, it just happens to be initialized to the empty list.\n\n\nThat fails if possible valid values for `foo` could be falsey, such as the empty string, empty tuple, empty dict, the number zero, etc.  There's a reason that the idiom uses `is None` and not implicit testing.\n\n\n\nOhh I see. Thank you so much for that explanation, that makes much more sense now!\n\nWe are talking mutable here. If you pass a string or 0 when it wants a list, you're screwed anyway. ", "id": "cu3pibl", "owner_tier": 0.7, "score": 0.9999999989999999}, {"content": "do you need these vars on the class level, given that they are supposed to be relevant on a per instance basis?\n\n    class MyClass:\n        def __init__(self, name='Undefined', number=-1):\n            self.name = name\n            self.number = number\n        def __str__(self):\n            return '{0.__class__.__name__}(name={0.name}, number={0.number})'.format(self)\n\n    print(MyClass())\n    print(MyClass(name='Joe'))\n    print(MyClass(number=11))\n    print(MyClass(name='Joe', number=11))\n\nOk, I'm coming from Java so it looks kind of strange to me to see attributes being assigned that way. Normally I would have to declare the attributes and then write various constructors for assignment if I needed to assign them that way (or use accessors). Thank you for explaining that.\n\npython is dynamic, so there is no need to declare attributes in advance. You can just conjure them in `__init__()` and be done with it. You can think of python objects as souped up, syntactic-sugared dictionaries. Objects of a class don't even have to have the same attributes.\n\n    class Example:\n        def __init__(self, **kwargs):\n            for k, v in kwargs.items():\n                setattr(self, k, v)    \n        def __str__(self):\n            return '{0.__class__.__name__}({0.__dict__})'.format(self)\n\n    ex1 = Example(a=1, b=2)\n    ex2 = Example(c=3, d=4)\n    print ex1, ex1.a, ex1.b\n    print ex2, ex2.c, ex2.d\n\nout\n\n    $ python test.py\n    Example({'a': 1, 'b': 2}) 1 2\n    Example({'c': 3, 'd': 4}) 3 4\n\n\n\nI kinda started checking out java recently. After experiencing python it is so annoyingly verbose because of all that necessary boilerplate >_<\n\n\nPython follows a simpler and more consistent rule than Java in this regard (although there is also complex machinery behind the scenes that you can dig into when necessary).\n\nIn Python, everything is an object. Unlike Java, *\"everything\" includes functions* (and also there are no non-object primitives like Java's `int`, `short` etc.). In Java, inside the `class` body you define \"methods\", which are part of the class, and \"fields\", which are part of each instance of the class. \n\nIn Python, *everything assigned inside the class body is part of the class*. I say \"assigned\" rather than \"defined\" because you do it through assignments; in Python, the `def` statement [is an assignment](http://nedbatchelder.com/text/names.html). You define only \"attributes\", which are all part of the class, and which are all objects, and Python doesn't (yet) care what type they are. Typically, some of these will be functions, and some will be what you might think of as \"ordinary\" values (integers, strings etc.) But they are all handled the same way. Again, everything is an object, and *\"everything\" includes classes*, \n\nYou assign attributes to the instance in the same way - generally speaking, when the attribute doesn't already exist, it's added, and when it does, the value is replaced. It's analogous to assigning a value to a key in a dictionary. Conventionally, we set initial values for an instance's attributes in `__init__`, and normally don't create any new attributes beyond that - we *can*, but it can be confusing and error-prone.\n\n----\n\nThere's more to it than that, of course. There's a system whereby, if Python looks for an attribute on an object and it's not there, Python will also look for it in the corresponding class object, and then in bases of that class. However, *assigning* to an object's attribute will not affect those other objects, which is why it \"seems to work\" to use class attributes as \"defaults\"; when you *replace* the value, you actually create a separate attribute on the instance, while other instances will still indirectly look up the one from the class. But this only gets you in trouble when you *mutate* the value, because other instances will \"see\" the change you made - since they're all \"looking at\" the same underlying object.\n\nThere's also a system whereby, if Python doesn't find the attribute on an object and does find it on the class, *and* it finds a function, Python will instead give you back a method (again, everything is an object, and *\"everything\" includes methods*) - which allows method calls to work. Looking up the method to call is done in a separate step from actually calling it; and you can do things like storing that method in another variable, or using it as a callback.\n\nThere's also a system that lets you hook in to the attribute lookup and assignment processes, which e.g. allows objects to pretend to have additional \"virtual\" attributes that they don't actually store. This is pretty advanced stuff, though. (And in modern Python, you should first check if you can get the job done with properties.)\n\nDid I mention that everything is an object in Python? Just so you know, *\"everything\" includes modules*, too. That's how Python is able to use the same `foo.bar` syntax to mean \"the `bar` class in module `foo`\" or \"the `bar` function stored in class `foo`\" or \"the `bar` method of `foo` class instances\" (not quite the same!) or \"the `bar` attribute of the local variable `foo`\" - because *they all fundamentally mean the same thing*: \"the attribute named `bar` of the object named `foo`\". Or, more colloquially, \"the object that `foo` refers to by the name `bar`\". And while it's possible to insert various bits of magic into the lookup process, there is fundamentally only one process being used in all these cases.\n\nAnd before you ask, yes, there does exist a class that modules are instances of (though there's no name given to it via the built-in global names), and yes, it's an object. There is even a class that *classes* are instances of - which, being a class, is an instance *of itself*. It's called `type`.\n\nIt's difficult to change heads when you move from one language to another. [Python Is Not Java](http://dirtsimple.org/2004/12/python-is-not-java.html) and [Java is not Python, either...](http://dirtsimple.org/2004/12/java-is-not-python-either.html) might help.\n\nAre you trying to tell me that *everything* in Python is an object?\n\nSeriously though, this is an amazing explanation, thank you so much. I understand how it works much better now, although it's kind of jarring (no Java pun intended) to see classes handled this way.\n\n    class MyClass:\n        def __init__(self):\n            self.name = 'Undefined'\n            self.number = -1\n    \n        def add(self, a, b):\n            return a + b\n    \n    if __name__ == '__main__':\n        Bill = MyClass()\n        Bill.name = \"William\"\n        Bill.number = 8675309\n    \n        James = MyClass()\n        James.name = \"James\"\n        James.number = 3.14159\n        James.address = '21 Jump Street'  # James has an address, Bill must be homeless    \n    \n        Joe = MyClass()\n    \n        adder = Bill.add    # mind = blown\n    \n        print('Name:', Bill.name, 'Number:', Bill.number)\n        print('Name:', James.name, 'Number:', James.number, 'Address:', James.address)    \n        print('Name:', Joe.name, 'Number:', Joe.number)\n        print('adder(Bill.number, James.number:', adder(Bill.number, James.number))    \n\nThank you so much, I've bookmarked both articles, will read them very soon!\n\nToo bad, it's a good pun. ;) You should also try things you expect not to work, to understand how they fail, and also play around with the class attribute thing. Also, try the `adder = Bill.add` thing with a method that actually makes use of `self`. Try making a function that accepts a passed-in function and calls it - or does more than that. Try *returning* a function. Then read up on decorators. :)", "id": "cu3p623", "owner_tier": 0.7, "score": 0.5999999989999999}, {"content": "If you put something on the base it's to be able to use it in multiple class's usually meaning putting a mutable object like a list:\n\n    class C:\n        base = []\n        def __init__(self):\n            self.init = []\n\n    c0 = C()\n    c1 = C()\n    c0.base.append(1)\n    print(c1.base)\n    c0.init.append(1)\n    print(c1.init)\n\noutput:\n\n    [1]\n    []\n\nLike you see, both object own the same list. Compared to the ones with self. who are owned by the instance of the class in the __init__.\n\n\nOk, I think I understand. So creating class-level attributes is like creating a static attribute in Java, where all instances of the class share that one attribute, and if one instance changes it, it's changed for all the other instances as well. Good to know, thanks.\n\nthat applies only to mutable attributes. If you have x = 3 or x = 'some string' you only override locally for 1 object because ints and strings are immutable so it's not an in-place operation. You actually replace the reference to the int/str object, thus breaking the link to the \"hivemind\".  \nLists can be updated in-place and they are shared by all objects unless each object is given a fresh unique list object explicitly.\n\nYour explanation is a little unclear.\n\nAttributes can appear on the class, the instance, neither, or both. When the attribute is on both then the instance attribute overrides the class one. You can reassign the references no matter where they are. Mutability doesn't affect this at all.\n\n    class ImmutableChangedExample:\n        attrib = 'unchanged'\n\n    instance1 = ImmutableChangedExample()\n    instance2 = ImmutableChangedExample()\n    instance1.__class__.attrib = 'changed'\n    print(instance2.attrib) # prints 'changed' even though strings are immutable\n\n#\n\n    class MutableUnchangedExample:\n        attrib = ['unchanged']\n\n    instance1 = MutableUnchangedExample()\n    instance2 = MutableUnchangedExample()\n    instance1.attrib = ['changed']\n    print(instance2.attrib) # prints \"['unchanged']\" even though lists are mutable\n\n\ni know but i specifically i commented on the *one instance changing a \"static attribute\" shared by all instances* part. Instance working in its own context cannot do that unless it's let's say an append() operation on a shared list, that modifies the value but doesn't change the underlying reference.  \nThat's where the classic gotcha comes from. With lists etc you may or may not change the reference, with immutables you always change it, which means you always \"unlink\" which means the OP's assumption is strongly conditional.", "id": "cu3qbbz", "owner_tier": 0.5, "score": -1.000000082740371e-09}], "link": "https://www.reddit.com/r/learnpython/comments/3h2lrc/default_values_in_class_definition_and/", "question": {"content": "I'm wondering if this is the right way to do this. It seems... odd somehow to assign default values in the class definition, then default None in the constructor. I suppose I could give the same default values in both places, but again, this feels like unnecessarily repeating myself.\n\n    class MyClass:\n        name = 'Undefined'\n        number = -1\n    \n        def __init__(self, name=None, number=None):\n            if name is not None:\n                self.name = name\n            if number is not None:\n                self.number = number", "id": "3h2lrc", "title": "Default values in class definition and constructor? Is this the right way?", "traffic_rate": 153.12444444444444}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "This is sort of happens because of how functions are declared/defined.\n\nFunctions are first class objects in python, and the default argument is set during the function definition, not when its called.\n\nSo the empty list is getting assigned as the default argument on function definition.\n\nSo every call uses that same default argument.\n\nFirst of all, thanks for the technical explanation. It's still not exactly what I tried to find out though. I know *why* it behaves like this **in Python**. What I'm interested in is why it behaves *differently* in Python than in e.g. JavaScript, where functions are first-class-objects as well.\n\nTake this JS snippet for example:\n\n    function testFunction(arg1 = []) {\n      arg1.push(arg1.length+1); return arg1;\n    }\n    \n    let a = testFunction();\n    console.table(a);\n    \n    let b = testFunction();\n    console.table(b)\n\nThis works as **I** would expect it to work where both a and b contain just one single element with a value of 1, whereas the same snippet in Python wouldn't. Logging \"a\" would still result in the same output as JavaScript, but logging \"b\" would give me a list with two items, 1 and 2.\n\nMaybe you can elaborate some more on why this was decided on. I would like to understand on a technical level, what the python creators' reasoning was when designing the language that way.\n\nI haven't seen any post or explanation by the developers as to why this was the behavior they went with.\n\nMaybe someone else can chime in.\n\nJust as a side note, I lol'd at using Javascript as an example of a predictable language.. :)\n\nhttps://youtu.be/aXOChLn5ZdQ?t=74\n\nHaha got it - JS doesn't always lead by example, but in this particular case it behaves much like most C-Style languages and it's understood by many, so I decided to go with it here :D", "id": "j9j7lrg", "owner_tier": 0.7, "score": 0.9999999991666666}, {"content": "The default value is determined at function definition time, in the example there's a single list object.\n\nIt's been this way forever - there's little point debating whether it should or shouldn't be like that because it's not going to change, as such a change would be incompatible with existing code.\n\nThanks for the reply, but that's not really what I was asking. I specifically wanted to know _why_ this pattern was chosen and if the python creators think this is better for some reason.\n\n\"No one really knows\" would be an acceptable answer as well, but surely there is at least some unofficial theory or speculation?\n\n> it's not going to change, as such a change would be incompatible with existing code\n\nI mean, plenty of changes in Python were incompatible with existing code. Though I suppose the fact that Python 3 had many incompatible changes and this one wasn't included in them (even though people have doubtlessly been complaining about it at that time already), is a good indication that it's indeed not going to change.\n\nEither way I'd disagree with the notion that debating language design is pointless unless there's a chance that it could lead to the language changing.\n\nYou would have to ask [the exBDFL](https://lwn.net/Articles/759654/) for the *why*.  It does fit into the python philosophy of simple mechanisms in a simple language.  The BDFL chose the current mechanism and he has a track record of making language design decisions that may look odd but actually make sense.  The \"significant whitespace\" is the big example.\n\nIn this particular case the two choices are:\n\n1. define the default value at function/method call time\n2. define the default value at function definition time\n\nOption 2 is certainly simpler to implement.  In practice the need to use a sentinel value like `None` doesn't come up very often, and if python used option 1 we wouldn't be able to use code like this:\n\n    def fib(n, memo={0: 1, 1: 1}):\n        if n < 2:\n            return n\n        if n not in memo:\n            memo[n] = fib(n-1) + fib(n-2)\n        return memo[n]\n    \n    for i in range(10):\n        print(f\"fib({i})={fib(i)}\")\n\nOverall, I'm happy with the status quo.", "id": "j9j7u4h", "owner_tier": 0.5, "score": 0.9999999991666666}, {"content": "There are some good answers to this question in [this stack overflow post](https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument).", "id": "j9jq50e", "owner_tier": 0.1, "score": 0.08333333250000001}, {"content": "[This thread](https://softwareengineering.stackexchange.com/questions/157373/python-mutable-default-argument-why) (and the places it leads) are perhaps worth a peruse.\n\nI would point out that the `=` operator in Python performs name binding to the object referred to by the right hand side, which consistently uses the objects that are accessible from the current point in the code (because referring to an object in Python requires that the object exists). The act of calling a function (including for a class instantiation) passes all inputs by just their object reference, and assigns them (inside the function) to local names provided by the function\u2019s definition.\n\nIt may help to consider a function definition as \u201csyntactic sugar\u201d to instantiate a new callable object (which includes defining its calling behaviour) and assigning it a name that refers to it. From there it follows that the behaviour should be consistent for all name bindings:\n\n    default = 5\n    b = default\n    default = 3 # this does not change b\n    def test(param=default):\n        print(param)\n    default = 4 # this does not change param\u2019s default value in calls to the `test` function\n\nI\u2019m not sure how other languages handle this, but given the default value of a function\u2019s parameter in Python can be defined by an existing object reference (through a variable, or an index into a collection), or by instantiating a new object, does it not make sense to keep that object as an attribute of the function, rather than attempting to re-define it every time the function is called (which could be extremely expensive), or just hoping the name is still in scope (which could result in `NameError`s)?", "id": "j9jr37k", "owner_tier": 0.3, "score": 0.08333333250000001}, {"content": "I agree with you, but it becomes very complicated very quickly. For example you can use a function call to build the default value at runtime. \n\n    def test(x=builder()):\n\n\n\nThis function call can be very expensive, but under your scenario it would need to be called every single time the function is called. Or it could have side effects, changing its result and thus changing the default value. Or it could be very large, requiring much more memory. Or it could even be based on other files or even network resources that could change or disappear. Whether it is a *good* idea to do that is irrelevant, it is possible so the language needs to be able to handle it in a sane way. \n\nFurther, if the function has side effects, is it called every time the function is called, or only when the function doesn't have a value explicitly assigned? It isn't clear which would be the case. \n\nIt is also possible for the value to be very large, which would require it be regenerated every time.\n\nAnd what about if you use a third-party mutable class? Python would need internally to make a copy of it somehow or remember what the initialization was and run it again (which has the same problems as running a function again). And if it makes a copy, should it be a deep copy or a shallow one? If\n\nAnd it goes on. It works okay in simple examples. But there were just so many corner cases that making a system that was understandable and predictable without killing performance wasn't feasible.\n\nThere are ongoing efforts to set up some way to allow developers to do this on a case-by-case only when it makes sense, but no solution has been able to convince the core developers it is better enough than just using a sentinel value.", "id": "j9jypb9", "owner_tier": 0.9, "score": -8.333333282687742e-10}], "link": "https://www.reddit.com/r/learnpython/comments/118ucmz/why_do_python_functions_reuse_pointer_to_mutable/", "question": {"content": " \n\nFrom an experienced developer who's never used Python to all of you Python veterans out there - why does Python make me do this: [https://docs.quantifiedcode.com/python-anti-patterns/correctness/mutable\\_default\\_value\\_as\\_argument.html#use-a-sentinel-value-to-denote-an-empty-list-or-dictionary](https://docs.quantifiedcode.com/python-anti-patterns/correctness/mutable_default_value_as_argument.html#use-a-sentinel-value-to-denote-an-empty-list-or-dictionary)?\n\nIn my opinion, this is a) unnecessary boilerplate, b) confusing for any non-python developer, c) a waste of lines and d) unnecessary cognitive load.\n\nIs there any reason why python would think this solution is better than what other popular languages do? Are there other well-known languages that work in a similar way that I haven't used yet?\n\nI've used my fair share of languages (C, C++, Java, C#, JavaScript, PHP and probably a few others I missed right now), but never seen something like this.\n\nShould this question have been asked before, kindly refer me to that answer, I couldn't find anything, but I wasn't really sure what search terms to use in this case, so maybe there still is a thread I've missed.", "id": "118ucmz", "title": "Why do Python Functions Reuse Pointer to Mutable Default Values", "traffic_rate": 153.12444444444444}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "Try this:\n\n    def make(x, y=None):\n        if not y:\n            y = []\n        y.append(x)\n        print(y)\n\nThis bug was because you assigned empty list as a default argument in function definition. And this same list was used in every call to this function. (python wasn't creating new list each call, every time the same list was used)\n\ntldr: Don't use mutable objects as default arguments.\n\nThanks but it showed up in a question for an exam and I did not understand why for Christ's sake it would do that. Now I get why but I hate python just a little bit more =))))))", "id": "ince1oj", "owner_tier": 0.3, "score": 0.9999999994736841}, {"content": "You need to be careful using mutable objects (like lists) as default arguments.  Default arguments are evaluated *only once*, and that's when the function definition is evaluated.\n\nETA: A better way to do this is to default to `None` and then assign the mutable value inside the function, as /u/iiron3223 did in his reply.  (I might change `if not y:` to `if y is None:` for readability, but your mileage on that may vary; do what makes sense to you.)", "id": "incetkj", "owner_tier": 0.3, "score": 0.31578947315789474}, {"content": "[https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects](https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects)", "id": "incl5y3", "owner_tier": 0.5, "score": 0.10526315736842105}, {"content": "Thanks guys, I appreciate the answers. Now I get it...but...but why? =)) Why would they make default parameters static, why bound them to the definition instead of biding them to the execution? =))  \nI just seems like a the perfect breeding-ground for bugs without offering much in return\n\nThis is because in python functions are first class objects. This means they can be assigned to a variable, stored in lists and passed as arguments to other functions. For this to work function needs to be evaluated on its definition. So it is not a flaw in python design, but rather a feature, which has more pros than cons.\n\n>its a bit hard visualizing it mentally, go to this website and run your code [https://pythontutor.com/](https://pythontutor.com/) , it shows you a bit more step by step on what went where. Hopefully it helps. The reasoning is explained very well by Kyber, maybe when you see it line per line it'll be clearer\n\nThis is useful for caching and stuff like that the first example I would think of is memoisation.\n\n    def factorial(k, computed={}): \n       if k < 2: return 1 \n       if k not in computed: \n          computed[k] = k * factorial(k-1) \n       return computed[k]", "id": "incj7tf", "owner_tier": 0.1, "score": 0.47368420999999994}, {"content": "> I can't figure out why it works this way, why does the value of y not get lost after the function gets executed and gets popped off the execution stack.\n\nThe *value* of `y` does get lost. However, the default value `y` gets set to if a value isn't provided does not.\n\nIn each of your 5, 8, and 2 cases, the same list is assigned to `y` and then modified.", "id": "indp117", "owner_tier": 0.7, "score": -5.263157862750153e-10}, {"content": "Execute your code in [pythontutor](https://pythontutor.com/visualize.html#mode=edit) it's an excellent tool to learn how python execute your code", "id": "ingc6yt", "owner_tier": 0.1, "score": -5.263157862750153e-10}], "link": "https://www.reddit.com/r/learnpython/comments/x7heyh/needs_some_explaining/", "question": {"content": "    def make(x,y=[]):\n        y.append(x)\n        print(y)\n    \n    for i in [5,8,20,2]:\n        if i not in [10,20,30]:\n            make(i)\n        else:\n            make(i,[\"A\",\"B\",\"C\"])\n\nCan someone please explain me why the output of this code is:\n\n    [5]\n    [5, 8]\n    ['A', 'B', 'C', 20]\n    [5, 8, 2]\n    \n\nAnd not:\n\n    [5]\n    [5]\n    ['A', 'B', 'C', 20]\n    [8]\n    \n\nI can't figure out why it works this way, why does the value of y not get lost after the function gets executed and gets popped off the execution stack.", "id": "x7heyh", "title": "Needs some explaining", "traffic_rate": 153.12444444444444}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "This is my least favorite python footgun.\n\nHonestly it should be a syntax error, or be interpreted as a factory.\n\nI haven't done this in a decade since I remember the pain it caused so well, but I'd be shocked if all the standard linters/formatters didn't call it out.\n\nAll linters complain about it and PyCharm highlights it with a warning.\n\nFigured. Python style is so well defined as part of the language spec, I'd consider it a _huge_ mistake to not lint everything, always. Everyone on my team uses vscode or sublime to lint and autoformat on save, but if it was a larger team or we had outliers I'd probably want to enforce formatting via commit pipleline.\n\nLiterally the only lint rule we override is line length, we still use it, just change the value.", "id": "h6516ct", "owner_tier": 0.5, "score": 0.5792079207425742}, {"content": "I learned this the hard way...\n\nYeah, I discovered this while writing a recursive function to get the changed attributes between two instances of an object. Unfortunately for me, some of the attributes were objects with attributes that have the same names. It was hell trying to figure out why only some attributes seemed to be appearing and why some were incorrect values.\n\nCare to elaborate?\n\nI learned this as well when I tried to default an init param to an empty list.\n\nWell I wrote pretty much the function OP describes in his article within a telematics application.\n\nThe function itself was very simple, so I didn't expect any mistake in there.\n\nMy lists simply kept growing and I didn't understand why. I searched all my code where the old list elements would be re-added again.\n\nI tried debugging the code and couldn't find the issue.\n\nI've rewritten several chuncks of code but the issue was still there.\n\nOnly after several hours and writing a minimal example I realized that these mutable objects as default arguments are persistent between calls.\n\nI facepalmed myself to the moon, made a little fix in the function and called it a day.\n\nThe mutable object in the function argument gets initialized only once when the function is defined. So that variable always contains a reference to the same list for every call you make and not a new list like the signature might suggest.\n\nOP probably encountered issues because of this surprising behavior\n\nHere's an easy code snippet (untested, but based on my experience) that should repro the problem:\n\n    class Foo:\n        def __init__(self, items = []):\n            self.items = items\n\n    foo = Foo()\n    foo.items.append(\"bar\")\n    print(foo.items) # should see a list containing bar\n\n    foo2 = Foo()\n    print(foo.items) # you'd expect an empty list, but you'll see bar again\n\n\nTo avoid the problem, you can do something like this instead:\n\n    class Foo:\n        def __init__(self, items = None):\n            self.items = items or []\n\n    foo = Foo()\n    foo.items.append(\"bar\")\n    print(foo.items) # should see a list containing bar\n\n    foo2 = Foo()\n    print(foo2.items) # you should see an empty list this time\n\nI'm just assuming here. But I think its because maybe the interpreter handles default variables as part of the function definition and therefor saves specific memory and creates the variable on definition instead of creating it when the function its called. So, each time you called it without parameters you use the same list over and over (like in the example it keeps adding data) because the variable it's outside the fucntion's scope as it's part of the definition.\n\n&#x200B;\n\nThen again this is just eyeballing I don't know anything about the inner workings of the python interpreter but to be safe I just do arg= None and an if inside the function to create the list/mutable.\n\n&#x200B;\n\nedit: punctuation\n\nits basically like creating a global variable.  if you have experience with Python you know to create function level variables every time\n\n[Fixed formatting.](https://np.reddit.com/r/backtickbot/comments/opjmax/httpsnpredditcomrpythoncommentsopb7hmdo_not_use/)\n\nHello, pudds: code blocks using triple backticks (\\`\\`\\`) don't work on all versions of Reddit!\n\nSome users see [this](https://stalas.alm.lt/backformat/h65kzby.png) / [this](https://stalas.alm.lt/backformat/h65kzby.html) instead.\n\nTo fix this, **indent every line with 4 spaces** instead.\n\n[FAQ](https://www.reddit.com/r/backtickbot/wiki/index)\n\n^(You can opt out by replying with backtickopt6 to this comment.)\n\n> print(foo.items) # you'd expect an empty list, but you'll see bar again\n\nShouldn't this be print(foo2.items)?\n\nYep, pretty much. This was a design decision for the sake of optimization. Creating an immutable object potentially each time the function is called is inefficient. I guess that they wanted the behavior for mutable objects to be consistent with that.\n\nYup, exhibit A on why copy-pasting code is dangerous.", "id": "h64kikj", "owner_tier": 0.1, "score": 0.999999999950495}, {"content": "flake8-bugbear is your friend.\n\n> [flake8-bugbear](https://pypi.org/project/flake8-bugbear/16.4.0/)\n\nLink for the lazy", "id": "h650wkl", "owner_tier": 0.5, "score": 0.15841584153465346}, {"content": "Same for default date 'datetime.today()' on servers that stay online for years.\n\nLuckoly, `datetime.today` is callable, and `if callable(x):` is a thing.", "id": "h65b8jq", "owner_tier": 0.7, "score": 0.1435643563861386}, {"content": "That tip doesn't only apply to functions, but classes/dataclasses as well. There is a reason dataclasses 'field' method has a 'default_factory' parameter", "id": "h66avqx", "owner_tier": 0.3, "score": 0.11386138608910891}, {"content": "Wouldn't that feature work great for concurrent status storage, like atomic counters?\n\nDue to the GIL everything is atomic in python \ud83e\udd23", "id": "h66l2u6", "owner_tier": 0.5, "score": 0.07920792074257425}, {"content": "> Do not use mutable objects as default arguments in Python\n\nUnless you want to. Using mutable defaults is fine [if you know what you're doing](https://www.python.org/doc/essays/graphs/).\n\nUse a class.", "id": "h689bzt", "owner_tier": 0.7, "score": 0.08415841579207921}, {"content": "Pretty classic gotcha.", "id": "h67f7lx", "owner_tier": 0.7, "score": 0.0742574256930693}, {"content": "The real lesson should be don\u2019t use default arguments when your function requires a list to append some data to. This case should never happen so the example is moot.", "id": "h67oful", "owner_tier": 0.5, "score": 0.06930693064356436}, {"content": "PyCharm won't let me", "id": "h65zxz5", "owner_tier": 0.7, "score": 0.06930693064356436}, {"content": "I really hate when people make blanket \"don't\" statements. Almost everything has some reason to be done, you just have to know what and why.\n\nIn this case it very much is a blanket statement. Unless you want unreadable hacky code. If you truly want a global object, actually define one at the global scope and access it inside the function instead of relying on the kwarg default value being the same. Achieves the same and is orders of magnitude more readable. Remember explicit is better than implicit.\n\nThankfully, until you're senior enough to understand when a *static mutable object* is useful, you don't want to touch them yet. There's a lot of room for unexpected behavior in that combo.\n\nThe fact is, that even if you actually wanted a persistent object, that would still be a whacky way to do it...\n\n    def f(x=[]):\n        pass\n\nFunction's state changes over time, but isn't a generator.  Surprising behaviour, probably a bug.\n\n    x = []\n    def f():\n        global x\n        pass\n\nVery obviously intentional, but uses a global.  Kinda icky.\n\n    class Fer:\n    \n        def __init__(self):\n            self.x = []\n\n        def f(self, x=None):\n            if x is not None:\n                self.x = x\n            ...\n\n    f = Fer().f\n\nUglier, but reuseable, and no global modification.\n\nBlanket do/don't statements are a good idea when communicating to people who either aren't ready for or don't have the time for more nuanced points.\n\nDon't ban don't statements.\n\nIt can be used to keep information between different calls of the function without needing to write a bunch of infrastructure around it. If that's what you want, this is acceptable. \n\nFor just about everything there is a valid use for it and you just need to know about the possible catches.\n\nAll this does is teach people that nuance is not relevant. It doesn't help them learn a damn thing.\n\nI use that for caching. But this is a hack. If there is a breaking change in python on the subject I deserved to be punished.\n\nYeah that's a global object\n\nThat's what I was thinking. Using this nuance of Python could make code easier to manage.\n\nRather than defining a global object and then operating on it with a function, the object could be the default arg of the function. That way, it's clear that the object belongs to the function. That its purpose is explicitly to serve as a complement to the function.\n\nThat's... Not true?\n\nA beginner who is just learning about default arguments already has a lot that they're trying to remember. They'll pick up nuance later -- just like everyone does as they grow.\n\nThat doesn't interfere with any other scope. It could be very useful in very specific scenarios.\n\nIf you were to do this, you would unambiguously be commenitng it with this intention clearly stated.  On top of this, I think most linters would flag this, so you'd have a `# noqa` comment on there as well.\n\nFor me, as a matter of code review, I don't allow linter checks to be disabled without a comment explaining why.\n\nA few might. The rest will simply go \"I was told don't! So I don't.\"\n\nMaybe - but I feel like it's more likely to just confuse things. There are juniors on my team and i know this kind of thing can just ruin their week\n\nYou're right that the blanket \"don't\" statement isn't technically true, but if you know enough to know when to use this you probably know enough to ignore this kind of medium article\n\nThen use a different namespace. Don't hack it in the function signature.\n\nA cool way to do is to set the namespace on the function attr.\n\n    def f():\n      ...\n\n    f.cache = []\n\n\nIMO, I rather use a class but I get it, sometimes you don't want to rewrite everything as a class.\n\nDon't allow general noqa. It should always except a specific error. Also, `# noqa: E501` (line length) doesn't really need a comment.\n\nAnd if you don't know enough you've now just created a blanket prohibition in your head against doing something potentially useful in the future. This is a disservice to those who are expected to grow in knowledge and ability.\n\nI'm sorry you think something specifically left in there by the language designers is a hack. It's not.\n\nAgreed, sorry, I was just being brief with that statement.\n\nI hadn't considered that, but equally I feel like there's always a process of unlearning as we get better at stuff\n\nI still feel like the potential is for more harm than good for a junior reading this, unless the author explicitly recommends against it\n\nSaying \"potentially useful\" implies that there's no other way of doing it. The alternative maybe requires a few lines of infrastructure, but is orders of magnitude more readable and will save you and others a ton of headache in the future.\n    \n    Explicit is better than implicit.\n    Simple is better than complex.\n    Complex is better than complicated.\n\nNotice the order, it matters. Explicit is better than implicit. Yes simple is better than complex, but complex is better than complicated, and your solution is indeed complicated because it relies on hacky side-effect that is very hard to notice.\n\nThere are always better ways to do something like this. You don't give people who are learning a bunch of weird 'semi-rules' to store in their head on the off chance they'll encounter some corner case that would be conveniently resolved with this knowledge. \n\nOne of the fundamental precepts of python is to avoid doing things that behave in unexpected or unintuitive ways. This is absolutely one of those cases. Arguing against it \"just in case\" feels contrarian for the hell of it.\n\nNot every behavior is an explicit design choice. Not every bad practice behavior can be fixed either (e.g., backward compatiblility).\n\nArguing you simply must never do what the language maintainers have purposely left in is beyond contrarian.\n\nSo, they have to keep this bad hack in so they don't break anyone who's using this bad hack. That seems very illogical.", "id": "h650ncm", "owner_tier": 0.9, "score": 0.5495049504455445}, {"content": "Unless, this is the effect you desired. A stateful function.\n\nIn the rare instance that it *is* what you wanted, you can always ignore the *rule*.  If you understand *why* it's happening, you can make that decision yourself (and if you don't understand why it's happening, you should follow the article's advice).\n\nEven if you wanted this behavior, relying on a counterintuitive quirk would be a bad way to implement it.\n\nIf only there was some way to associate a function with some kind of state.\n\nNo I don\u2019t think there will ever be a case why you need this. I\u2019ve been wrapping my head around why anyone would possibly need this and I can\u2019t see any.\nYou can have global or local variables that are more explicit and readable. You can also use functools cache and lru_cache if caching is the effect you desired.\nOr you can also just use a oop approach.\nDoing this goes against the zen of python in many ways.\n\nIf only we could put the function into a class, or use functools. Or just put the function inside another function and use nonlocal\n\nI agree that it's not something anyone should be doing.  My point was that the advice is sound, and if anyone *really needs* to break the rule, they should *only* be doing so because they know exactly what and why they're doing what they're doing.\n\nYeah a class is what I was getting at.  `nonlocal` is as much a scourge as `global`.", "id": "h652jv7", "owner_tier": 0.3, "score": 0.08910891084158415}, {"content": "Is this not considered a bug? Why don\u2019t they change this in new versions?\n\nThe main reason I'm aware of is performance. It's faster to store a default argument in the function object than to re-evaluate that argument every time the function runs. If the function runs many times, this speeds things up a lot.\n\nThis is intentional choice and a well known behavior.  Like /u/jet_heller mentioned, you can use this technique to keep track of information between different calls of the function if you wanted.  I understand it's confusing at first, but there are easy ways around it.\n\nHow is that an argument when you can use a global?\n\nWhat do you mean? A global name still has to be evaluated. Were you trying to reply to someone else?\n\nYou have some immense misconceptions about how the Python interpreter works I think.  ANY name has to be \"evaluated\", whether it's a local, arg, global, whatever.  As a matter of fact, function arguments become locals within that function scope, so they have the exact same performance impact to use as something in globals.\n\nLet's start again.  Benjamin posits that the mutable default argument behaviour is bug-like.  You posit that there's a reason to keep it, and that that reason is for performance.  I point out that you can use a global instead of the function argument for things you'd like to mutate, the implication being \"to not have to use mutable function default arguments\" or \"in a world where there aren't mutable function default arguments\".  Do you disagree with that?\n\n> You have some immense misconceptions about how the Python interpreter works I think. ANY name has to be \"evaluated\", whether it's a local, arg, global, whatever. As a matter of fact, function arguments become locals within that function scope, so they have the exact same performance impact to use as something in globals.\n\nYes, of course I know that. The performance impact I'm talking about is not in the body of the function, but in establishing the default arguments themselves. Python stores the default arguments in the function's `__defaults__` attribute so they don't have to be evaluated again. [0] The only alternative to this that I can think of would be for Python to add code to the function that can evaluate the default argument expressions when the function gets called. Do you agree that evaluating an expression once is faster than evaluating it many times? Sure, you'd have to factor in the attribute and tuple lookups, but that's surely faster than allocating memory for a new object, or whatever else an expression might do, which could be anything.\n\nYour second paragraph appears to come from misunderstanding the point I was making. Hopefully, I've cleared that up.\n\n[0] https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy", "id": "h653utk", "owner_tier": 0.5, "score": 0.1435643563861386}, {"content": "This is the second time this article has been posted and the headline is garbage advice. \n\nMutable objects are very useful as default arguments for caching/memoization. \n\nPlease delete.\n\n> Mutable objects are very useful as default arguments for caching/memoization.\n\nThis is a terrible suggestion. Please don't do this. If someone reading the code didn't know about this implementation detail in Python, the behavior would be entirely counterintuitive.\n\n    >>> def f(x, lst=[]):\n    ...     lst.append(x)\n    ...     print(lst)\n    ...\n    >>> f('a')\n    ['a']\n    >>> f('b')\n    ['a', 'b']\n    >>> f('d', lst=['c'])\n    ['c', 'd']\n    >>> f('e')\n    ['a', 'b', 'e']\n\nYou might expect `f('e')` to produce `['c', 'd', 'e']` since we \"replaced\" `lst` in the previous call. That's not the case because `lst` in the function definition is allocated in heap memory, whereas `lst` in `f('c', lst=['c'])` is allocated on the stack.\n\nIf you need to do memoization, use the features provided in `functools`.\n\nCan you provide an example?\n\nIt's always better to just define a global object and use that for caching than imply on the implicit fact that kwarg default values are mutable.\n\nExplicit is better than implicit.\n\nOr better, use functools.cache\n\nIt remains good advice.  There are exceptions to every rule, including this one, but the advice remains solid.  If you *need* to break this \"rule\", then you *know* you need to and you know why and how.  For the vast majority of people, however, following this advice is the correct course of action.\n\n    def get_from_cache(name, cache={}):\n        if name in cache: \n            return cache[name]\n        cache[name] = expensive_calculation()\n        return cache[name]\n\nThough usually memoization is done with decorators because linters and IDEs will warn you about mutable defaults as they trip people up and are easy to miss at a glance.\n\nYou'd instead do something like \n\n    from functools import cache\n\n    @cache\n    def factorial(n):\n        return n * factorial(n-1) if n else 1\n    \n    >>> factorial(10)      # no previously cached result, makes 11 recursive calls\n    3628800\n    >>> factorial(5)       # just looks up cached value result\n    120\n    >>> factorial(12)      # makes two new recursive calls, the other 10 are cached\n    479001600\n\n[reference](https://docs.python.org/3/library/functools.html#functools.cache)\n\nSee the docs.\n\nWhat if I have functions that produce a function? Then I can\u2019t have global variables because I want these functions created dynamically.\n\nNot according to the docs, which says it is up to the programmer's discretion. \n\nAlso on enterprise programs default arguments can be considered cleaner than global objects.\n\nThis also works and doesn't use a mutable arg:\n\n    def get_from_cache(name):\n        if name in get_from_cache.cache: \n            return get_from_cache.cache[name]\n        get_from_cache.cache[name] = expensive_calculation()\n        return get_from_cache.cache[name]\n    \n    get_from_cache.cache = {}\n\nSo none then.\n\nSee https://www.reddit.com/r/Python/comments/opb7hm/do_not_use_mutable_objects_as_default_arguments/h657394/\n\nI'd need to see a specific, but I believe this is what [nonlocal](https://www.w3schools.com/python/ref_keyword_nonlocal.asp) does?\n\n    \n    def outer_func():\n      cache = {}\n      def inner_func(foo):\n        nonlocal cache\n        if foo not in cache:\n          cache[foo] = heavy_computation(foo)\n        return cache[foo]\n      return inner_func\n\nA lot of things are up to the programmers discretion. Unlike some other languages, Python doesn't really babysit the programmer, it let's you do a lot. Hell you can completely override the import mechanism or replace all the modules in sys.modules if you want. You can set `True = False` or replace `int.__add__`. Doesn't mean any of these are a good idea.\n\nTo be clear, I'm talking about code that will be seen by other people (though, yourself in 6 month also counts as someone else in most cases). You're free to do whatever you want in your own personal code, but if I ever saw this in a code review, I would shut it down real quick.\n\nI did the googling for you:\n\nHere:\n\nhttps://docs.python.org/3/faq/programming.html#id13\n\n\"Because of this feature, it is good programming practice to not use mutable objects as default values. Instead, use\u00a0None\u00a0as the default value and inside the function, check if the parameter is\u00a0None\u00a0and create a new list/dictionary/whatever if it is. For example, don\u2019t write:\n\ndef foo(mydict={}): ... \n\nbut:\n\ndef foo(mydict=None): if mydict is None: mydict = {} # create a new dict for local namespace \n\nThis feature can be useful. When you have a function that\u2019s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called \u201cmemoizing\u201d, and can be implemented like this:\n\nCallers can only provide two parameters and optionally pass _cache by keyword def expensive(arg1, arg2, *, _cache={}): if (arg1, arg2) in _cache: return _cache[(arg1, arg2)] # Calculate the value result = ... expensive computation ... _cache[(arg1, arg2)] = result # Store result in the cache return result \n\nYou could use a global variable containing a dictionary instead of the default value; it\u2019s a matter of taste.\"\n\nThat is true but python does have a style guide and in this instance the docs themselves state their recommendation.\n\n> You can set `True = False`\n\nSlight nitpick, but you cannot actually do that.\n\n    >>> True = False\n      File \"<stdin>\", line 1\n    SyntaxError: cannot assign to True \n    # (same goes for literals)\n\nThough I totally agree with everything you said. Replacing `__add__` for fun instead of having an `.add_to` function is potentially confusing to others. \n\nI think you can make exceptions for mini-languages, like how pathlib overrides the division operator for path concatenation. And of course dataclasses. But *generally speaking* it is a bad idea.\n\nAlso, the Google style guide is a great reference for beginners. I recommend it to people all the time, it has good examples of the \"do's and don'ts\".\n\nCalling it _cache at least makes it clear to the user. I still prefer the @cache decorator from functools\n\nLink?\n\nEDIT: The only code style I found is Google's, and they explicitly state to never do this:\nhttps://google.github.io/styleguide/pyguide.html#2124-decision\n\nMost companies I know of have similar internal style gudes.\n\nEDIT2: python-guide.org vaguely implies that it's fine to use, but that's not official Python either, it's some opinionated book.\n\n> Slight nitpick, but you cannot actually do that.\n\nHah, they indeed fixed that in Py3, definitely could in Py2.\n\n> pathlib overrides the division operator for path\n\nTo be clear, overriding operators isn't the issue, doing it on a base class is the problem. pathlib does it only on pathlib.Path objects, which is well within it's reign.\n\nMore precisely, you cannot do that *anymore*.\n\nThis was possible in 2.7.\n\nHere:\n\nhttps://docs.python.org/3/faq/programming.html#id13\n\n\"Because of this feature, it is good programming practice to not use mutable objects as default values. Instead, use\u00a0None\u00a0as the default value and inside the function, check if the parameter is\u00a0None\u00a0and create a new list/dictionary/whatever if it is. For example, don\u2019t write:\n\ndef foo(mydict={}): ... \n\nbut:\n\ndef foo(mydict=None): if mydict is None: mydict = {} # create a new dict for local namespace \n\nThis feature can be useful. When you have a function that\u2019s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called \u201cmemoizing\u201d, and can be implemented like this:\n\nCallers can only provide two parameters and optionally pass _cache by keyword def expensive(arg1, arg2, *, _cache={}): if (arg1, arg2) in _cache: return _cache[(arg1, arg2)] # Calculate the value result = ... expensive computation ... _cache[(arg1, arg2)] = result # Store result in the cache return result \n\nYou could use a global variable containing a dictionary instead of the default value; it\u2019s a matter of taste.\"\n\nInteresting, thanks for sharing.\n\nWorth noting that they actually explicitly use `_cache` for the variable name, with the _ in front, implying that users of the function won't actually pass a value and it's technically a \"private\" variable for the function. In that sense, and with good documentation, I could see it. But at the same time, self-documenting code is the best kind of code, so why write confusing code you need to add comments to explain, when doing it the other way is the same amount of effort but self-documenting.\n\nAlso, that's more of a FAQ than a style guide, and I'm assuming that entry is fairly old. Most style guides would still tell you to never use that.", "id": "h64zblj", "owner_tier": 0.5, "score": 0.21782178212871287}, {"content": "I don't see why anyone would do anything this way regardless.  Its basically a non issue you should be aware of... I think people, especially Python developers, care way too much about cutting a line or two out of their code and being \"Pythonic\" rather than making things more readable and adding a line or two... this problem is essentially avoided by just using new variables.  Default arguments = noob IMO\n\nHow is something built into the language a non issue? The reason people would do it this way is because they can and they didn't learn otherwise. You can make an argument for never using default arguments ever if you'd like, but no need to be condescending.\n\nits a non issue if you are coding to be readable and not trying to be overly pythonic, which is a thing IMO.  people try way too hard to shorten their function only to create bugs and make it harder to work with for others... sometimes shortening the code does neither of these things.  of course, there are lots of nuances to any programming language you'll have to learn.  I'm not being condescending at all, just giving my opinions", "id": "h65nqhy", "owner_tier": 0.9, "score": -4.950495459110747e-11}, {"content": "Huge pitfall. Took me way too long to figure it out the first time I tried it.", "id": "h673txc", "owner_tier": 0.5, "score": 0.0643564355940594}, {"content": "Thank you!!!", "id": "h67eang", "owner_tier": 0.1, "score": 0.0643564355940594}, {"content": "My solution to this is to make my default arguments `None`, always. Yes, numbers don't have the problem, so I could make a default argument a number -- or a tuple, or a frozenset, or .... But a policy of always using `None` means one less thing to think about and possibly get wrong.\n\nI really want to disagree with you but I can't find it in myself to do so.  Consistency is key, even if it's a bit verbose.", "id": "h67l342", "owner_tier": 0.7, "score": 0.0742574256930693}, {"content": "I know the implications of this but so far I think this shouldn't be a problem if you follow basic best practices anyways.\n\nBut I may be wrong here so I would like to ask:\n\nCan someone provide a function that is perfectly valid in regards to side effects, single responsibility and not reassigning arguments that would still have the same problem?\n\nLike literally every single example shown here breaks either or all of these guidelines and I would consider them bad no matter what.\n\nFor example:\n\n    def append_10(arr = []):\n    arr.append(10)\n    return arr\n\nThis function is obviously used to indicate how bad mutable default arguments are, but I think this function is bad even if you fix the default parameter.\n\nWhy? because the solution to the above problem is this:\n\n    def append_10(arr = None):\n    if arr is None:\n        arr = []\n    arr.append(10)\n    return arr\n\nBut this function:\n\n1. reassigns an argument\n2. does two things in the case no list is given (create as well as append)\n3. I think, isn't logically consistent\n\nTo these 3 points:\n\n1. reassigning arguments is bad in my eyes, they are arguments, not variables\n2. doesn't follow single-responsibility, if its responsibility is to append an element to a list, then it should take a list as a parameter and reject everything else. If someone wants to append 10 to an empty list, they should provide said empty list to the function.\n3. If I append 10, as the function name implies, to \"nothing\" then to me a list isn't what logically follows. If I have an empty list and append 10 then sure, a list with the element 10 follows. But if I don't even have a list then I simply can not append an item to it. Now this may be personal preference but I think it goes hand in hand with 2. and I think it is bad practice as it is ambiguous and doesn't follow single-responsibility.\n\nThe following version suggested by another person is even worse:\n\n    def append_10(arr = None):\n    arr = arr or []\n    arr.append(10)\n    return arr\n\nThis function returns a list, with the element 10 in it, for every single falsy value. It also obviously crashes for every truthy value except for those that have the method append which takes a single int as an argument. This again is logically inconsistent and behaviour, I think, one shouldn't expect from a function.\n\n* append\\_10(False) -> \\[10\\]\n* append\\_10(0) -> \\[10\\]\n* append\\_10(6<2) -> \\[10\\]\n* append\\_10(\"\") -> \\[10\\]\n* append\\_10({}) -> \\[10\\]\n* append\\_10(()) -> \\[10\\]\n* append\\_10(set()) -> \\[10\\]\n\n(I especially like the 3rd case, makes zero sense if spoken out loud, but works)\n\nOn top of this I also think the statement \"Do not use mutable objects as default arguments in Python\" itself is too general. It should be \"Do not use mutable objects as default arguments in functions which mutate said object\". Because I don't see how the problem would arise if you don't alter the argument in the first place.\n\nFor example if you had a list of terms you wanted to exclude and in case no terms are provided you use an empty list. This, I think, is valid but the general statement would tell you not to do it.\n\n    def add_10_but_exclude(arr, exclude = []):\n    for i,value in enumerate(arr):\n        if i not in exclude:\n            arr[i] = value + 10\n    return arr\n\n(yes I know \u00b4the function is bad, inefficient and doesn't follow any best practices either, but it's simple and gets the point across)\n\nThis function also uses a default parameter for exclude which is mutable. But as the state is never mutated to begin with, the above statement to \"not use it\" doesn't apply.\n\nSo, can anyone please provide a function that is \"logically consistent\", follows basic best practices and still requires a mutable default (that then has to be changed as mentioned in the article)?\n\n> reassigns an argument\n\nWho cares?  It's just a precondition.  The argument needs a default and Python is being a douche about how it has to be specified.\n\n    def f(x=0):\n        return x + 1\n\nYou don't have a problem with that because the language is doing something sensible.\n\nImagine a Python where default args could _only_ be `None` and had to be specified in the body.  That would then become:\n\n    def f(x=None):\n        if x is None: x = 0\n    \n        return x + 1\n\nNote how the language being a douche caused the code to have to do something weird.\n\n> does two things in the case no list is given (create as well as append)\n\nDoesn't matter.  The entire point of functions is to group one OR MORE operations into a reusable package.  Default arguments also create.\n\n    >>> def f(x=0):\n    ...  pass\n    ... \n    >>> f.__defaults__\n    (0,)\n    >>> \n\n> I think, isn't logically consistent\n\nSubjective.\n\nWhy so aggressive? I literally opened by stating I may be wrong here and that I would like to see better examples.\n\n>You don't have a problem with that because the language is doing something sensible.\n\nWell if I wanted to be pedantic then yes I would still have a problem with that. Because you've literally just provided the successor function with the unnecessary step of providing a 0 element in case no element is inserted. This also means a call to f() returns 1, which I again would regard as false. 1 is simply not the successor of None, it is the successor of 0 and those are not the same. \n\n  \nBut that was my entire point: The examples used are pointless because they are flawed even without what this discussion is about.\n\nWhich is exactly why I  - asked - for someone to provide a better example.\n\n>Doesn't matter. The entire point of functions is to group one OR MORE operations into a reusable package. Default arguments also create.\n\nCool, and the entire point of a program is to solve a problem. Yet we still try to solve them efficiently and follow best practices for various reasons.\n\nA function having multiple operations doesn't necessarily equal a function having multiple responsibilities.\n\n&#x200B;\n\n>Subjective.\n\nCare to elaborate when it is logical for a function called append\\_10 to return \\[10\\] when called with False?\n\nAt the very least this doesn't follow the principle of least astonishment.\n\nAlso what is the reason to not enforce append\\_10 to be called with a list in the first place? A user surely would expect a function requiring some argument to not work if said argument is not provided.\n\nTo me the so far presented examples just use hacky solutions in order to prevent false user input.\n\nAgain, I know these are just examples that try to get the point across. But I think these are bad examples and I would like to see a better one, that's all I was asking for.\n\n> Why so aggressive? \n\nThat's your reading of my message.  I'm not being aggressive, I'm engaging in discussion.\n\n> 1 is simply not the successor of None, it is the successor of 0 and those are not the same.\n\nYou're getting hung up on the details here.  The important thing is `None` denoting \"use default value\".  `None` is not being treated as a value in and of itself.  Because the language is not stupid when it comes to ints as they're immutable, I used those as an example.  I could quite easily have used a string.\n\nSimilarly I could quite easily have done something like this:\n\n    use_default = object()\n\n    def f(x=use_default):\n        if x is use_default:\n            x = some_default\n    \n        ...\n\nBecause Python is stupid with mutable values in `__defaults__` (and `__kwdefaults__`), you're forced to do the above.  In the case of immutable values, Python is doing that for you.  There's no world where that's not happening, it's just a case of whose responsibility it is to write it, the interpreter or the programmer.\n\nNow it just so happens that we already have an object in Python that's easily comparable and predefined, and has generally been used semantically as \"use the default argument if this is something that's meant to have a default argument but can't because mutable arguments are handled terribly\", and that's `None`, so the above becomes:\n\n    def f(x=None):\n        if x is None:\n            x = some_default\n    \n        ...\n\n> Which is exactly why I - asked - for someone to provide a better example.\n\nMy contention isn't the quality of the examples in the article, it's with the definition of quality of examples in your post.  None of the three points you declared are definitive of quality.  Quality occasionally exhibits your points, but it's not the other way around.  Reiterating that you want better examples _in reply to my comment_ is ignoring the points I'm making and is best served as a reply for someone who is arguing that the existing examples fit your definition of quality, rather than someone who is arguing that your definition of quality is suspicious.\n\n> A function having multiple operations doesn't necessarily equal a function having multiple responsibilities.\n\nThen where do you draw the line?  We use programming languages to solve real problems in the real world and NOBODY wants to pay you to maintain this trash:\n\n    def default(value, default):\n        return default if value is None else value\n    \n    def f(x=None):\n        x_with_a_different_name = default(x, some_default)\n    \n        ...\n\n> Care to elaborate when it is logical for a function called append_10 to return [10] when called with False?\n\nYour position has changed.  The appropriate naming of functions was not one of your three measures of quality.  I do not disagree that functions should be named appropriately.  Nobody disagrees with that.\n\n>You're getting hung up on the details here. The important thing is None denoting \"use default value\". None is not being treated as a value in and of itself. Because the language is not stupid when it comes to ints as they're immutable, I used those as an example. I could quite easily have used a string.\n\nI'm not talking about the \"None\" in the function though, maybe I should've phrased it differently and named it \"nothing\" instead of \"None\". I talk about the parameters the function is called with.\n\nIf you call f() you call a function without a parameter, you call it with \"nothing\".\n\nBut your \"successor function with default at 0\" puts out f()->1 which maps \"nothing\" to 1. f(3)->4 makes sense, f(0)->makes sense, f()->1 doesn't.\n\nThere simply is no need for any of the so far provided examples to use a default value in the first place, other than wanting to write f() instead of f(default).\n\nAll of the so far provided functions are of the same nature:\n\n    def func(some_mutable_argument=None):\n        if some_mutable_argument is None:\n            some_mutable_argument = a_new_instance_of_the_argument()\n        \n        # Do some shit with some_mutable_argument\n        ...\n\nBut why? Why not just use...:\n\n    def func(some_mutable_argument):\n    # Do some shit with some_mutable_argument\n    ...\n\n...and let the user of the function provide the object the function should mutate?\n\nLike isn't that literally the purpose of the function, to mutate the state of a provided object? From my point of view the (single) responsibility of the function is to do stuff with a provided object. The user is responsible to provide said object.\n\nThat is why I asked for a function that actually - requires - a mutable default argument, so I can get a better grasp of the use-case. Basically a real world example.\n\n>Your position has changed. The appropriate naming of functions was not one of your three measures of quality. I do not disagree that functions should be named appropriately. Nobody disagrees with that.\n\nOk so how would you name such a function \"appropriately\"?", "id": "h68dho7", "owner_tier": 0.5, "score": 0.0940594058910891}, {"content": "Can someone help me understand the code in  the bonus section at the bottom of the article?  \n\n    a = [10,20,30]\n    b = a\n    b[1] = 25\n    print(a)\n\nWhen I run it, b[1] = 20\n\n    >>> a = [10,20,30]\n    >>> b = a\n    >>> b[1] = 25\n    >>> print(a)\n    [10, 25, 30]\n    >>> print(b)\n    [10, 25, 30]\n    >>> \n\nCould be a layer 8 issue, or PEBCAK.\n\nHah, yes problem was definitely me.  For some reason I was reading it as the output of b[1] was 25 not that is was assigning that index as 25.  I need more coffee\n\nPlease don't substance abuse just to get better at programming.  :(", "id": "h68trr5", "owner_tier": 0.5, "score": 0.08415841579207921}, {"content": "I will never understand this sub.\nSure, it's a rather common anti-pattern, but more than a thousand upvotes for this post? That links to Medium?\n\nThere are people out there that do amazing stuff from scratch, approach entirely new domains of applications of Python, come up with clever ways to represent or interpret data...\n\nAnd here we are, burying this under an avalanche of upvotes.\n\nSeek originality, innovation, and creativity, or this place will become a boring graveyard\n\n[deleted]\n\nSure, it's an important concept, but so is the for-loop. One thing is to build skyscrapers, another is to milk upvotes.\n\nOf course, we're arguing about our respective opinions, and there are 1200+ upvotes saying that I'm clearly losing here", "id": "h6c4exb", "owner_tier": 0.3, "score": 0.0742574256930693}, {"content": "I actually hadn\u2019t thought of that, but it makes sense.", "id": "h7faz3y", "owner_tier": 0.3, "score": 0.0643564355940594}], "link": "https://www.reddit.com/r/Python/comments/opb7hm/do_not_use_mutable_objects_as_default_arguments/", "question": {"content": "", "id": "opb7hm", "title": "Do not use mutable objects as default arguments in Python", "traffic_rate": 207.9358484294499}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "I had to find this out the hard way :/\n\nP.s. I am a little rusty on python, but if you want a mutable default value (say a list) you can make the default `None` then inside the function you would reassign the variable if it's None.\n\nEveryone does, rite of passage\n\nIf it's something you find yourself doing often for some reason, it might be worth checking out things like [attrs' default factories](https://www.attrs.org/en/stable/examples.html#defaults), I find it easier to parse and refactor if necessary.\n\nUse tuples for a default iterable rather than None! Fewer optionals makes for better typing and automatic documentation.\n\nAnd we all have to learn it a second time.\n\nI didn't. I read it in [the docs](https://docs.python.org/3/tutorial/controlflow.html#default-argument-values). Everyone should read the docs.\n\nThanks for that :D\n\nBut I don't think I would add another import _just for that_, but what do I know, I don't even use python much nowadays (don't use it at all, sadly)\n\nCongratulations. I read the docs too\u2014constantly, really\u2014but still had to find this out the hard way. There's a lot to read!\n\n[deleted]\n\nWow, holding true to the stereotype that developers don't have any social skills...  NONE.\n\nwith that attitude, we all should really know absolutely everything that was ever written. and it seems it's not the case. you gotta understand, we're all humans, not machines.\n\nYou didn\u2019t have to originally write it to have to track it down\n\nLol quintessential r/iamverysmart material. Do you have the docs memorized? Yes? You've wasted your life, congratulations. No? Yeah total hypocrite.\n\nYou read the docs and didn't remember every single rule and caveat and gotcha? You're obviously not fit to program in Python. Maybe take up bowling? \ud83d\ude0f\n\nWhat I want is for people to read the docs, and not be surprised by things they could have learned by doing so.\n\nCoincidentally, what we want is for people like yourself to not worry about us. There's no moral dilemma here. Just people being human.\n\nSadly, I have to worry. I work with people who refuse to read the docs. There's one guy in particular, who if we're working on something and I get the docs up, is like \"ooh, you're reading the docs are you?\" like I've just got a magical tome from the highest shelf, full of arcane knowledge.\n\nIt's not like the docs I linked to are some obscure reference material. It's the official python tutorial, and a great place to start for beginners. If there's something basic that you don't know, that's in the tutorial, then whatever you read or watched to get you started is no good and now's a great time to read the tutorial.\n\nWhat if there\u2019s something basic you don\u2019t know you don\u2019t know? How would you know to go back to the beginners tutorial?\n\nHow often should one peruse elementary material to be sure one doesn\u2019t make a mistake at any point in any possible future?", "id": "j54rqz3", "owner_tier": 0.1, "score": 0.999999999970238}, {"content": "Yep. Always default mutables (like empty lists) to `None`, and don't rely on the output from functions there:\n\n    def blah(my_arg=None):\n        if my_arg is None:\n            my_arg = []\n\n    def other_blah(my_arg=None):\n        if my_arg is None:\n            my_arg = right_now()\n\nAdditionally, if you want to use None (or anything) as the default but need to know whether the caller explicitly passed None or whether the caller left it default you can do something like this: \n\n```\n_undefined = object()\n\ndef function(arg= _undefined):\n    if arg is _undefined:\n        arg = None\n```\n\n`my_arg = my_arg or []`\nOr, if you care about NoneType specifically;\n`my_arg = [] if my_arg is None else my_arg`\n\nYes! Empty string `''` works as a safe immutable default, too!\n\n```python\nfrom datetime import datetime\n\nclass Foo:\n    def __init__(self, timestamp: datetime = None) -> None:\n        self.timestamp = timestamp or datetime.now()\n```\n\nReally hoping the Sentinel PEP gets approved so we can have a more elegant solution to this. https://peps.python.org/pep-0661/\n\nAnd if you want None to be a valid value for your argument too, you can use a sentinel:\n\n    _sentinel = object()\n    def func(x=_sentinel):\n        x = [] if x is _sentinel else x\n\nI\u2019m sure it\u2019s not a massive difference for most projects. But I imagine with the special treatment None gets by python it would be marginally more efficient. But as far effectiveness then yes either would work.\n\nHis argument is a list so default '' doesn't make sense. The type is gonna be Optional[List].\n\nTrue, although if you need to support an empty list and None and I generally find code smell.\nNot sure if I'd prefer to use `**kwargs` instead at this point.\n\nYep. `\u2019\u2019` is a great and common default for `str` parameters, but of course not when other types are expected. It\u2019s common to see `notes: str = \u2018\u2019`, and there\u2019s seldom a need for the `Optional[str]` type.\n\nThe only time I\u2019ve really seen the pattern useful is when you want to emulate something similar to `dict.pop`, where for a missing key: `dict.pop(key)` raises an error and `dict.pop(key, default)` returns the default", "id": "j55je8d", "owner_tier": 0.9, "score": 0.29166666663690477}, {"content": "Mutable default are the root of all evil\n\nThe problem in the article is not related to mutability though.\n\nIs there even a sane use case?\n\nIt is, default args are bound at definition\n\nEven if there were, I\u2019d be hesitant to make use of it; \n\n- hard to know what\u2019s going on for anyone reading it\n- if this behavior ever is changed to something sensible, the function breaks\n\nI\u2019ve seen a kwarg named `cache` (dictionary) that kept state between executions.\n\nIt's not. Read the article. Author has a default argument of `datetime.date.today()`. Problem is not that `today` default variable mutates over executions, but it does share the same root problem, original dev was expecting the code to initialize the default to execute each time the function executed and it don't.\n\nAh I see where you\u2019re coming from. The original comment was about only mutability.\n\nAgreed, this example is particularly a behaviour of function declaration.\n\n[deleted]\n\nUmm, mutable defaults are definitely related lol, both are function gotchas for newbies\n\nNo idea why you want to make such a big deal out of this, but whatever\n\nShould mutable defaults even be accepted by Python.   At least according to my logical thinking a default value can not and should not be mutable.   It just doesn't make sense to me, the default values become part of the def for the function.\n\nThe way Python handles this doesn't seem to be rational.   Frankly I can even understand how time in this context can even be considered for a default value.   He is calling a routine that can not be relied upon to return the same value every time so it isn't a default value but rather a variable value.   Personally I think this is a big deal, it just doesn't make sense.\n\n[deleted]\n\nIt is rational within the design of the language.\n\nSee this SE answer\n https://softwareengineering.stackexchange.com/questions/157373/python-mutable-default-argument-why\n\nMaybe a simple warning that your \"def\" has a default being set by a function call would be good enough.   I have to wonder how common this practice is in the real world, it just seems to be an odd way to set a default value to me.   Mainly because there would likely be way to many cases where your default value might have randomness and that to me just blows the whole concept out of the water.   Now there may be cases where a default value set by a function call never varies throughout a programs execution so that might be a pass but then why not use a constant.\n\nMaybe I'm putting to much emphasis on the message that the world \"default\" brings to a definition.   For me is says this is the FIXED value that we have for this parameter at the time of creation, by evaluating this def.   If you want to set it to something else at the time you actually use the function that is find but otherwise the default value will always be this.", "id": "j54kgmd", "owner_tier": 0.7, "score": 0.7529761904464285}, {"content": "I learned this last week with a list \ud83d\ude05\n\n[`dangerous-default-value`](https://pylint.pycqa.org/en/latest/user_guide/messages/warning/dangerous-default-value.html)", "id": "j54zx9h", "owner_tier": 0.1, "score": 0.06845238092261904}, {"content": "BTW: flake8 can warn about these.\n\nhttps://pypi.org/project/flake8-bugbear/", "id": "j565f5w", "owner_tier": 0.3, "score": 0.02678571425595238}, {"content": "I\u2019ve never understood why it\u2019s built like this. Is this a limitation to stay consistent with some greater concept? From a usage perspective I can\u2019t for the life of me see how this is a feature not a bug\n\nbecause functions are created at definition, not execution, and binding of the default arguments can only be done at definition.\n\nIt\u2019s consistent with the way functions are objects and how all objects are treated.\n\nI would be fine with breaking that consistency personally.\n\nThat doesn't fully answer why the language was designed this way, which was the original question.\n\nEspecially since the original post made a point of how another language JavaScript made other decisions that enabled it's behavior to have default arguments recomputed at the invocation.\n\nInstead of binding datetime.date.today() when function is created you could have today_creator = datetime.date.today (or to make it easier to create from the parsed code, lambda : datetime.date.today() and similar for other cases) on function definition and then have something like today=today_creator() if today is None else today on each execution\n\nPython is my first language. I somehow always defined default args in definition instinctively, guess I was lucky to have never come across this nightmare\n\nI don\u2019t think it\u2019s accurate to say that it can only be done at definition\u2026 that\u2019s just how it\u2019s done now. It would\u2019ve been perfectly valid for Python to treat default parameter values as value factories that are used at call-time.\n\nI'm the opposite.   Python should be expanded to either warn or disallow such structures.   To do otherwise blows the whole idea of what \"default\" means in this context.\n\nbecause the parser needs to know what it has to bind to the argument when it executes the def line. It can't just say \"i'll evaluate it later\". The function is an object, and that object has arguments that need to be bound to something when the function definition is concluded. To do so, it must evaluate its argument defaults. The alternative would be that it has to put some form of \"here do it later\", but since it can't differentiate between what is mutable and what isn't, it would end up doing a \"here do it later\" for everything, basically converting every individual argument in an implicit lambda.\n\nBecause it's a different language, Python is not Javascript.\n\nIt's clearly documented that default argument value binding occurs at compilation and not during execution; sometimes it takes a couple of reads for one to understand what that means, other times a couple of runtime 2am debugging sessions, but that behavior is clearly documented.\n\nWhy? Because it was designed like that, planned to behave like that.\n\nAsk Guido if you're still curious.\n\nNo this would not be valid: \n\nhttps://docs.python.org/3/reference/compound_stmts.html#def\n\nThey stated this in bold letters for a reason:\n\n\"Default parameter values are evaluated from left to right when the function definition is executed. \"\n\nI dunno, I'm pretty happy with my IDE or linter issuing a warning: https://pylint.pycqa.org/en/latest/user_guide/messages/warning/dangerous-default-value.html\n\nThe last thing is what I am saying. It is a choice that can happen and in other languages that choice is made. The question is why are these implicit lambdas so bad in Python. That goes back in history to why the language was originally so against lambdas and that made this possibility worse. That is the detailed answer to the question. Just saying it is bound to this variable is a what the language is doing. Saying why it doesn't bind them all to a \"do it later\" because of the development of the language is what the original comment was after.\n\nQuestion: \"why was it designed like that?\"\n\nYour answer: \"because it's a different language\" and \"because it was designed like that\"\n\nDo you see why that doesn't work? Your first answer implies that every design decision for every language must be contrary to the corresponding design decision of every other language, which obviously is not true.\n\nYour answer other answer is like: \"Why does that person have a pencil on their head?\" \"because they have a pencil on their head\".\n\nThe point is, it's fair to assume that this decision was made consciously and based on some reasoning other than \"because we need to do it differently to how JavaScript does it\" or \"just because\". The question is: what was that reasoning?\n\nHere\u2019s some more bold letters for you:\n\n>\tI don\u2019t think it\u2019s accurate to say that it can only be done at definition\u2026 **that\u2019s just how it\u2019s done now**. It **would\u2019ve** been perfectly valid for Python to treat default parameter values as value factories that are used at call-time.\n\nI agree.  Python's behavior has always been crystal clear to me.  And having an IDE, or pylint, or whichever, remind me once in a while that I might be walking too close to a landmine is more than enough.\n\nIt is cool that such behavior is being addressed by a linter but I se this discussion as being slightly different.   I just have a huge problem with random \"default\" values, it just blows my mind.   It is getting late so I can't get into this anymore.\n\nit's a design choice likely dictated by performance. If you delay the evaluation, you will have to perform it every single time, for every single parameter default, for every function call, and due to the nature of python, there's no difference between an immutable argument and a mutable one. It would grind performance down for 99% of the cases for no reason at all.\n\nA general language philosophy (of python, and of design in general) is that you don't pay for what you don't need, and doing so would require you to pay the lambda execution tax for every function call, for every default parameter, for no reason at all especially when the current way already has a strategy to pay the tax when you do need to do so: set None as default, and then check inside the function.\n\nI never implied even subjectively that every design decision needs to reverse or invert any other decision for a different language, that seems like it came out of your own imagination.\n\nI did write that Python's design, both syntactic and semantic, are its own and if you prefer the way that JS behaves then you should be using JS for your coding instead.\n\nAnother reason why what you say that I said is nonsense is that Python appeared several years before JS, so it makes no sense that it would base it's design on JS's, either as a pattern or anti-pattern.\n\nAs for \"what was the reasoning\" behind the way rvalue bindings are done the way they're done for argument default values, go to the source: ask Guido.  I don't channel him, nor do I particularly care why he decided to do it that way, the only thing I care is that I find it clear and transparent, and meshes well with the way I reason through programming tasks, on the other hand I find JS to be nothing but headache inducing.\n\nMy citation is from the Python language reference, so no, it is not \"how it's done now\", it is how the language is specified. \n\nIf some implementation of Python would do it differently, the behavior of functions would suddenly change.\n\nIt is like saying that \"[] == False\" is just how its done now and it would be valid for Python to threat \"[] == True\" in the future.\n\nI don't care about nor know the answer either, I was just pointing out that your response saying 'because x and y' did not answer the question despite clearly being phrased as if it did.\n\nYou are misunderstanding my comment. I\u2019m not implying that this is a change that could be made in the future. Please reread the chain with that additional context.", "id": "j54nmun", "owner_tier": 0.1, "score": 0.35416666663690477}, {"content": "I had a semi-similar issue with [class variables](https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables) not too long ago.\n\nThe sorts of stuff I've been doing up until now, there's been no real need to write my own classes. Then I wrote a class for something recently, and ~~accidentally~~ *mistakenly* instantiated a dict as a class variable.\n\nFrustration and hijinks ensued, but I learnt something new at least.", "id": "j55lrcw", "owner_tier": 0.3, "score": 0.014880952351190477}, {"content": "Update: PEP 671 proposes adding in new syntax for \u201clate-bound function argument defaults\u201d - you\u2019d use `=>` instead of `=`, and it\u2019s currently tagged for Python 3.12 but IDK if it\u2019s likely to stay in or not:\n\nhttps://peps.python.org/pep-0671/\n\nMy original post:\n\nHave there been discussions or PEPs proposing changing this behavior?\n\nIf this behavior were to change, would it be major enough to warrant calling the language Python 4? \n\nGenerally it\u2019s a pretty huge change, but if I were to guess, I\u2019d say more bugs that haven\u2019t been noticed yet would be fixed by this change than code that depends on this behavior would break.\n\nHonestly, the biggest issue with making this change would be people would get used to writing code that relies on the new, logical behavior, and they\u2019d get burned whenever they\u2019re working with an older version of Python for whatever reason.\n\nMaybe `from __future__ import sane_default_arg_behavior` could be required for a few releases, before it switches to being the default behavior (with the future becoming a no-op.)\n\nMy recommendation is use a linter. There are linters that warn if you use mutable default value.\n\nThere was a pep I think for late binding defaults. For backwards compatibility it added new second syntax for late binding defaults and existing defaults would continue to have same behavior. I think changing that behavior is severe enough backwards compatibility change that is very unlikely to happen. Adding a second default type for early binding I did not perceive enough support for given size of that change (especially as it adds even more complexity to method signatures) that I think pep is on pause.\n\n>ode that relies on the new, logical behavior,\n\nWhat is being discussed here is not logical in any form.   A default value is exactly what the word says it is, to try to make that default value variable if foolish in my estimation.   If any thing Python needs to either warn or disallow such constructs as they make no sense at all.  If you make default values \"variable\" then you have a logical inconsistency as now your don't really know what that default value is at any one function call.   So all of a sudden your default values are not actually defaults.\n\nI'm not sure why people have problems with this.   We don't want to be changing the meaning of the word \"default\" here!   The real option is to enforce its meaning.   I'd go so far as to say if somebody wants to argue that variable defaults make sense that they are not looking at this issue logically and frankly have issues creating logical software.   Once aware a programmer should never try to do this in his code.\n\nWhy do you assume the new behavior is logical?\n\nYou realize that it\u2019s a fundamental change to the interpreter. In all other places, if it sees a function call with () and no \u201cdef\u201d, it calls the function, and replaces the call with the result.\n\nYou\u2019re asking the interpreter recognize that in a function declaration (code executed ONCE at function definition), it realize that we don\u2019t want to call the function then, we want it called each function call.\n\nThat\u2019s suuuuper magical for a non functional language. I realize JS does this, but JS is written by a dude who has a love affair with functional languages and has zero issue with \u201cmagic.\u201d\n\nDoing it the way you describe actually breaks convention with the rest of pythons style, even if you find it confusing to grasp initially.\n\nSame thing with mutable arguments. Why wouldn\u2019t python use the same list? The initializer is only called ONCE, at function definition.\n\nI don\u2019t mind people not liking it or finding it challenging at first, but I hate this take of \u201cI\u2019m confused by it becuase I come from a language with wholly different paradigms, so it\u2019s illogical in python\u201d when the issue is just a simple lack of understanding.\n\nThe current implementation is sane.  You define a default as a particular object, it should always be that object.  No if or buts about it.\n\nThere was a PEP recent to add new syntax for it. Changing the existing stuff would be a breaking change, and the Python 2 to 3 migration was a hard slog that came closer to killing Python than we'd like to admit (if it hadn't been for a few key members of the community stepping up, it could easily have gone the way of Perl 6). They won't want to go through that again without a damn good reason.\n\n> You\u2019re asking the interpreter recognize that in a function declaration (code executed ONCE at function definition), it realize that we don\u2019t want to call the function then, we want it called each function call.\n\nExactly like the function body.\n\nFor reference, this was added to JS in 2015, almost 20 years after Brendan Eich created it.\n\nThe function declaration is different than the function body. With a first order function, the definition is run once and then the definition (along with defaults) are saved into the first order object it is.\n\nYou can see said objects quite easily by running an inspect.getmembers on a declared function.\n\nNice, interesting fact I didn\u2019t know. I should\u2019ve stuck with my original example, which is Common Lisp. Thanks!\n\nYes, that's what currently happens. My (rather unclear \u2013 sorry) point was that it would not be illogical to have it the other way.\n\n    # Run now\n    t = f()\n    # Deferred\n    def g():\n        t = f(x)\n    # Evaluated now\n    def h(t=f(x)):\n        ...    \n\nIn Python, `f` is evaluated immediately in the last case, but the opposite behaviour seems equally consistent to me.\n\nIt\u2019s a huge diff for the interpreter. In your first and third examples, the function call is in code that is interpreted.\n\nIn the function body example, that code is not interpreted until it\u2019s run. Feel free to go test this with a plain syntax error in the body of a function. \n\nIt\u2019s also something python is very up front about in the docs:\n\n> Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call\n\nWe're talking about different things. You keep referring me to what Python *does*, whereas I'm talking about what it *might have done*. I know how Python works. My point is that it would be possible for Python to work the other way, without sacrificing logical consistency. (How difficult it would be to modify Python to work this way, I don't know, and is a separate, but related, point.)\n\nI am referring to your parenthesized clause.\n\nAnd yes, I am asserting that doing it in a different way would absolutely break logical consistency for python. \n\nA function call is executed, entered, and replaced with its return at the point it is interpreted.\n\nA function call in a rvalue in an arguments list will necessarily be interpreted at function definition (when executing the def command), as the argument list needs to be processed for validity. \n\nThey could make a special rule for rvalues, perhaps saving the rvalue of a default parameter as an anonymous function inside the first order functions dict, that\u2019s perfectly doable, but it does absolutely break consistency for a language that isn\u2019t functional.\n\nI wouldn\u2019t think it was terrible if they had done it, but I definitely would find it a bit odd - just like I do in Kotlin iirc where they do have the behavior you\u2019d prefer. \n\nIt seems like pointless complexity to me - especially when the whole idea of first order functions in python really was one of the interesting things to me - that a function definition itself is interpreted.\n\nThe reason I find executing a parameter defaults rvalue every time anachronous is simple - I see a function call in an interpreted statement and my mind immediately assumes it\u2019ll be resolved before the rest of the statement. \n\nThat pattern fits most non magic languages as well - and it is logically consistent with how python works in all other areas. The python documentation is quite clear about this as well.\n\nI also don\u2019t take issue with people wishing it was different or not liking it, but I do take issue with the rhetoric that it\u2019s \u201cdumb\u201d or \u201cillogical\u201d as it neglects the whole rvalue thing and how they work in every other part of the language. I\u2019d definitely argue the way it is is more logical, even if people find it unpleasant.\n\nI don't see why the \u2018special rule\u2019 here is any more special than the one that already exists for the body of a `def`. It seems like a completely natural extension to me.\n\nThe body of a def is not interpreted at the time of function definition.\n\nThe parameters are. They have to be in order to store the function.\n\nGiven it feels like a natura extension, I am sure there is a way to use decorators to effectively implement this yourself into every function definition. Slightly more cumbersome, but do-able on your own tbh. There may even be modules which can do this for you already.\n\n> They have to be in order to store the function.\n\nWhy can't we just store the unevaluated code?\n\nThat\u2019s a lot of processing to add on to a call if it\u2019s the entire list.\n\nAs I said in my long post above (did you read it?) they could not process and store unevaluated **only rvalues** and minimize the overhead, but that would still be slightly weird to me as then you\u2019re evaluating every part of the parameter list **but** the rvalues and you still have my initial complaint of breaking the visual of seeing a function call (`()`) that is **not** evaluated where it\u2019s written.\n\nIt\u2019s a very functional-language paradigm - which is why it\u2019s standard in CLisp and JS, but I find it weird when it\u2019s in non functional languages, like Ruby or Kotlin.\n\nOK, thanks for explaining.\n\nI think something important here is how python actually stores objects and saves them in memory. Objects end up just being pointers to values. And as you say a function call returns an object which points to a value upon interpretation. If that object is mutable, it \u201cerases\u201d the old value and replaces it with the new one. So the next time that default object gets used again, it is really just pointing to the new value.\n\nI feel like this part could help explain why it is such an unnecessary overhead for OOP to people. Of course it could be different, but then the base language has to do more. Current implementation allows for developer flexibility imo which is nice", "id": "j55nkgd", "owner_tier": 0.7, "score": 0.11904761901785714}, {"content": "So I'd offer a slightly different perspective here - the underlying problem isn't about default argument behavior, but a misunderstanding of Python syntax. When you write `datetime.date.today()` that `()` at the end isn't decorative, it is specifically telling the interpreter \"call this function now\". Python functions are first class objects, so if you want to save a function to call later, you just stick the function in a variable. \n\nSo if I was writing this kind of routine, the idiom I'd use would be something like `def myfn(blah blah ..., today=datetime.date.today, ...)`. Then in the function body you check if `today` is callable, and call it if so to get the value.\n\nThe problem here is that you are creating a def not actually calling a function and default values make no sense at all if people think they can be variables.   If you want a default value make is so such as today=2023-1-20\" or whatever makes sense.   If you try to call a function then you have no idea what the return value will be thus not logically a \"default\".\n\n    def foo():\n        datetime.date.today()\n\ndoesn't call `datetime.date.today` at function definition time, but\n\n    t = datetime.date.today()\n\ndoes. When one sees\n\n    def f(t=datetime.date.today()):\n        ...\n\nit's not unreasonable to assume that the evaluation of the default is deferred, like the first case, rather than the second. After all, it's part of a `def`. Yes, the brackets mean \u2018call this function now\u2019, but when \u2018now\u2019 is varies with context.\n\nIt gets called at definition time.", "id": "j55p52h", "owner_tier": 0.1, "score": 0.074404761875}, {"content": "Yup. The pattern to stick to here is to use only literals, and maybe module-scoped constant values, as argument defaults. In all other cases, use `None` and check-and-set the argument in the function.  For better or worse, Python lets you modify a parameter at runtime which makes for succinct cleanup of arguments:\n\n```python\ndef fn(a = None):\n    a = \"hello world\" if a is None else a\n```\n\nI want to use `a = a or \"hello world\"` but that is fraught with side-effects.\n\nNo. strings are immutables in python. It's perfectly safe to write\n\n    def fn(a=\"hello world\"):\n        foo(a)\n\n\u201cstick to literals\u201d is not good advice. List and dictionary literals would be problematic as default parameter values since those are mutable types. Ironically the example you\u2019ve given here could be simplified by just using the string literal as the default since strings are immutable. The key is to not use mutable values as defaults. It doesn\u2019t matter if those values are created via literals or otherwise.", "id": "j55x70k", "owner_tier": 0.7, "score": 0.02678571425595238}, {"content": "for the blog and readers sake, wouldn\u2019t it be helpful to discuss alternative behaviors snd fixes such as:\n\n* rename \u2018today\u2019 to \u2018day\u2019 as a param but don\u2019t set the default value and\n* specify the value when calling the function \n\nsince the docstrings weren\u2019t provided for all we know the original intent is such that the implementation of always defaulting to today is correct and users should specify an alternate day if looking for future days.\n\nFunctionally they are trying to make a default value a variable and this just cranks me in the wrong direction.", "id": "j55gqoq", "owner_tier": 0.5, "score": 0.023809523779761903}, {"content": "I love python. It's great and I've used it to do work I'm really happy with.\n\nBut I still hate the way it's always pass by reference. I've seen all the reasons why it's logical and good. I know how to deal with/use it correctly. I know there are some upsides.\n\nI don't care, I still hate that part of Python.\n\n(btw, I've learned that what python does isn't *exactly* what would properly be called \"pass-by-reference\". Fine, but that distinction isn't really relevant to my hatred for it.)\n\nEdit to clarify: The connection to OP here is that, because functions are created at the time they're defined, the behavior OP is talking about is a consequence of pass-by-reference.\n\nEdit 2: I love the downvotes for \"I like python a lot but *one single feature* isn't my favorite.\" quick guys, shun the ~~nonbeliever~~ slightly-less-than-absolute-zealot! Get him! None of us should ever have the slightest criticism! \ud83e\udd23\n\nWhat are you using that doesn't do things like this? C or C++?\n\nI can't think of a language I've used that isn't passing the \"reference-by-value\".\n\nI would say that the distinction between pass by reference and Python\u2019s behavior is actually important. The behavior only resembles pass by reference when using mutable values\u2026 strings, integers, tuples all behave like \u201cpass by value\u201d for this reason.\n\nNot in my mind.   It is because the \"def\" for the function creates those values when evaluated.   This is not when a function is executed.   Defaults are thus fixed values that are created in the absence of supplied values, from the original def.   It makes no sense at all that they would be variables as the definition has already been created.\n\nThe only one I can think of that passes-by-value is Pascal... and I haven't programmed in that in over 30 years.\n\nMost languages pass by value, and some (like C) let you achieve pass-by-reference by using pointers or something that achieves the same effect.\n\nMaybe it's just my particular experience, but no language I've used besides python passes everything by reference, such that any change to a mutable type is visible to the caller without explicitly returning the new value.\n\nI'm not sure what you mean by \"reference-by-value\". Did you just mix up terminology there, or is that something I'm unfamiliar with?\n\nThat's true, and also irrelevant to how much I dislike this aspect of Python. \n\nI also think it's kind of a pointless distinction. Sure, if I pass a tuple, it's passed by value... But if it were pass by reference I wouldn't be able to mutate it anyway, because it's immutable, so who cares?\n\n>It is because the \"def\" for the function creates those values when evaluated. This is not when a function is executed. Defaults are thus fixed values that are created in the absence of supplied values, from the original def.\n\nYeah that's exactly what I said.\n\n>It makes no sense at all that they would be variables as the definition has already been created.\n\nI'm not sure what you mean. The variable containing the default value is created at define time. Because it is passed to the function *by reference*, any mutation of it will be visible in later calls to the same function, *because the function is provided a reference to the variable, not simply a new variable with a copy of the original value*, which is the standard calling behavior in python.\n\nI think we must be using different terminology. Almost all languages are pass-by-value by default. C is pass-by-value.\n\nWell, if the elements of the tuple are mutable, they can be modified. The reason it seems like a pointless distinction is because neither term really describes what\u2019s happening here, they\u2019re just trying to describe the observed behavior in terms of concepts in other languages.\n\nThe mechanics of passed arguments is consistent regardless of type or mutability when you understand that arguments are just assigned to their corresponding parameters\u2026 due to the fact that Python doesn\u2019t really have \u201cvariables\u201d and only has \u201cnames\u201d that point to \u201cvalues,\u201d the apparent effects of that do seem to vary depending on type behavior.\n\n(But to the question of \u201cwho cares\u201d\u2026 passing a reference vs an immutable value is an important distribution because the memory footprints vary between the two methods. I don\u2019t often care about memory usage when I write Python though.)\n\nPossibly. I had to Google quickly to refresh myself on this topic... What I came up with is that most languages *do something more complicated: they pass primitive types by value and class types by reference.*\n\nYeah I get all that. I know it's entirely self-consistent. I know it's not *actually* pass-by-reference.\n\nThe thing is, I really don't care about what it's called. I'm not against pass-by-reference as a concept, and telling me this isn't pass-by-reference isn't going to make me like it. My dislike for it isn't *because* it's pass-by-reference. \n\nI don't care what it's called. I don't care if it's consistent. **I just don't like it**.\n\nMaybe, but seems weird to me. I don't write heavily OO code.\n\nRegardless, doing this with primitive types is certainly not typical.\n\nI don\u2019t really like it either, especially after working more with systems languages. I definitely prefer a C-like model with very straight forward mechanics.\n\nPassing everything by value is expensive (computationally). The compiler or interpreter has to make a copy of everything that gets passed. If you pass a reference instead, you're only passing a pointer which is \"cheaper\". \n\nThough if you are a Functional programmer, you'd be be quick to point out that passing-by-reference (despite being cheaper) can be \"side-effect-y\", if you're not careful.\n\nThe programming language, Rust, still does pass-by-reference, but it avoid side-effects by transferring ownership of the reference from the passer to the passee (the function that it was passed to). And if the passer is expecting it back, it is the responsibility of the function to return it.\n\nIt's a clever idea which we don't see implemented much in programming languages which I think we might see adopted more in the future.\n\nYeah exactly. I hate being surprised by it, and it just never feels natural to constantly work around it. What Amy I gonna do, copy.deepcopy every input argument *just in case*? I'd love python more if it simply didn't do that.\n\nIt's not just \"systems languages\" that don't have this behavior, either. I really can't think of any language I've ever used that does this. C, Java, Matlab^{shut up it counts}, a weird proprietary variation of Pascal, hell even bash... I feel like I'm forgetting many more languages I've used over the years.\n\n>Passing everything by value is expensive (computationally). The compiler or interpreter has to make a copy of everything that gets passed. If you pass a reference instead, you're only passing a pointer which is \"cheaper\".\n\nYeah absolutely. I understand the benefits of pass-by-reference, and I use and like it it where appropriate. My issue isn't with pass-by-reference *in general*, it's just with the way python does it for any mutable type, so the common pattern where a value is provided to a function and then modified but not intended to be returned will cause surprises. For example, you pass a list to a function and pop elements out of it in a loop that handles each element. Obviously there are ways to write that which play nice with python, I realize this isn't an unsolvable issue. It's just annoying and hasn't become natural to me despite writing python for many years. \n\n>The programming language, Rust, still does pass-by-reference, but it avoid side-effects by transferring ownership of the reference from the passer to the passee (the function that it was passed to). And if the passer is expecting it back, it is the responsibility of the function to return it.\n>\n>It's a clever idea which we don't see implemented much in programming languages which I think we might see adopted more in the future.\n\nI didn't know that, that's a very cool idea. Rust isn't really an option for me but I'd like to see that become more common.\n\n> value is provided to a function and then modified but not intended to be returned will cause surprises\n\nYup, that's exactly what I meant by \"side-effect-y\". You got it!\n\n> Rust isn't really an option for me\n\nYeah, same boat. I'm starting to dabble in Rust, but I haven't tried to write anything real yet.", "id": "j556c27", "owner_tier": 0.7, "score": 0.074404761875}, {"content": "The fixed code has a new issue though: `today` is now recomputed regardless of default value, so supplying a default value for today will only ever compute the actual current date and time.\n\n    def is_ongoing(self, today = None):\n        if today is None:\n            today = datetime.date.today()\n        return (today >= self.start_date) and (today <= self.end_date)\n\nWhich is what I needed. That method wasn't used anywhere else, there was no need for the default argument in the first place. Probably some overlook by the original authors of the code.\n\nRight but if the previous code failed because it wasn't well tested, will your new code be any more testable?", "id": "j56bh7k", "owner_tier": 0.7, "score": 0.029761904732142856}, {"content": "Crappy programmer is also bad at writing articles.", "id": "j56ym45", "owner_tier": 0.7, "score": -2.9761904581027647e-11}, {"content": "If you use a linter like pylint [it'll tell you about it every chance it and you won't have to relearn](https://pylint.readthedocs.io/en/latest/user_guide/messages/warning/dangerous-default-value.html#dangerous-default-value-w0102)", "id": "j56khf6", "owner_tier": 0.7, "score": 0.008928571398809523}, {"content": "They are not \"retained\". They exist under the same scope as the function.", "id": "j56kkta", "owner_tier": 0.7, "score": 0.008928571398809523}, {"content": "Your tools should warn you if you use a mutable default argument. If not, what are you using to write code?\n\nMany of the \"issue\" posts i see can be resovled through tooling. Though, of course, it is not _guaranteed_ to work due to the dynamic nature of Python, and I accept that the tools are not perfect.", "id": "j576amr", "owner_tier": 0.5, "score": 0.008928571398809523}, {"content": "Welcome to the Late Binding nightmare my friend. We all been there. \n\nTip for life. Don't assign data structures like {} or []. \n \nPass none and assign inside functions :)", "id": "j57ami9", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "Today I learned more about functions and methods!", "id": "j57uhmc", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "Could wrap it in a lambda", "id": "j588cpq", "owner_tier": 0.3, "score": 0.008928571398809523}, {"content": "Between \"function calls\" right, not between \"executions\"?", "id": "j588un3", "owner_tier": 0.3, "score": 0.008928571398809523}, {"content": "This blog's title doesn't really describe the behavior correctly.  I'd state it like, \"A Python function's default argument values are evaluated when the function is defined, not when it is invoked.\"", "id": "j58buwk", "owner_tier": 0.3, "score": 0.008928571398809523}, {"content": "Lesson learned: If you're not going to use an IDE, use a good linter. A good linter would warn about this.", "id": "j59edix", "owner_tier": 0.9, "score": 0.008928571398809523}, {"content": "Welcome to the club!  \nBTW, thank you for the time-machine package suggestion, looks pretty helpful.", "id": "j59pvh7", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "My takeaway from this is to not use default values for arguments? I'm new to python but have written code in other platforms and have never used a default value for a parameter in a function. Thoughts from experienced python coders?\n\nIf you want to do something like this, use a default that is not a valid value (usually, but not always None), and then check for that value within the function, and call/compute the value within that test. This also goes for \"collection\" objects like lists and dicts. \n\n\nIf you can't use None, you can create a new object, and use that for the default like this:\n\n```\nDEFAULT_VAL=object()\n\ndef func(param1=DEFAULT_OBJECT):\n    if param1 is DEFAULT_OBJECT:\n        param1 = calc_default()\n    ...\n```", "id": "j5abxu8", "owner_tier": 0.1, "score": 0.011904761875}, {"content": "For more of Python\u2019s fun stuff https://github.com/satwikkansal/wtfpython", "id": "j5aftk5", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "Some people said to me python not very important right now\nBecause it is not required for work shop", "id": "j5e3upt", "owner_tier": 0.1, "score": 0.008928571398809523}], "link": "https://www.reddit.com/r/Python/comments/10gt7tv/today_i_relearned_python_function_default/", "question": {"content": "", "id": "10gt7tv", "title": "Today I re-learned: Python function default arguments are retained between executions", "traffic_rate": 207.9358484294499}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "Also, a great way to speed up your code with memoization while making your linter and people reviewing your code super angry.\n\n    def fib(n: int, cache: dict[int, int] = {0: 0, 1: 1}) -> int:\n        if n not in cache:\n            cache[n] = fib(n-1) + fib(n-2)\n        return cache[n]\n\nyou can then save the cache and loaded it on later executions of the app\n\n```\nimport pickle \n\nfib(100)\ncache = inspect.signature(fib).parameters['cache'].default\n\nwith open('saved_cache.pkl', 'wb') as f:\n    pickle.dump(cache, f)\n\nwith open('saved_cache.pkl', 'rb') as f:\n    inspect.signature(fib).parameters['cache'].default = pickle.load(f)\n\nfib(101)\n\n```\n\nthis is cursed\n\nUsed this once because I needed memoization in a test mock. It didn't pass review. I honestly love my colleagues that they don't allow me to use these abominations.\n\nI don't see what's the problem\n\nOk fib(-1)\n\nLolz\n\nfib(-1)\n\nOr you know \n\n@cache from functools\n\nPoor man's `@functools.cache`\n\nAnd idiots say python is slow\n\nThis is absolutely disgusting, I love it\n\nGoddammit!\n\nNo, it is recursed\n\nGreat! I've got some PRs for you to review...\n\nThat don't works with `__slots__` :(\n\nIn the serene expanse where code flows like a gentle stream, a novice once sought the wisdom of the old master. \"Master,\" the novice inquired, \"I have crafted a function, sparing and pure, devoid of the standard library's embrace. Yet, they call it the 'poor man's functools.cache.' Have I erred in my simplicity?\"\n\nThe master, whose eyes reflected the calm of a thousand silent programs, smiled and said, \"In the village, a potter molds clay into a vessel. With the void inside, the vessel serves its purpose. Is it the clay that gives form, or the emptiness within?\"\n\nBaffled, the novice pondered. \"Master, what does a potter's craft teach us about my code?\"\n\nThe master replied, \"Your function, unadorned by the standard library's excess, is like the vessel, shaped not by what is added, but by what is omitted. True elegance lies not in accumulation but in the mindful subtraction. The potter's wheel turns, and with each removal, the utility emerges. So is your code, a testament to the enlightened path of simplicity and purpose.\"\n\n\"In its restraint,\" the master continued, \"your code becomes a mirror, reflecting the essence of what it seeks to accomplish. Like the ascetic who forsakes worldly excess for inner clarity, your function stands, not poor, but profoundly enlightened, embracing the Zen of less.\"\n\nThe novice bowed deeply, the fog of doubt clearing. In the vessel of simplicity, he discovered the profound depth of enlightenment, where the true essence of code\u2014and life\u2014resides.\n\nThe less disgusting way is to use function decorators or custom classes.\n\n\nhttps://cachetools.readthedocs.io/en/latest/\n\nthis is cursed\n\nThis made me laugh like an idiot. Thanks!\n\nGood one\n\nGood one\n\nLGTM\n\nalso at least something like json instead of pickle, first because I avoid pickle like the plague due to ACE issues, and second because having things in a somewhat human-readable-human-debuggable format is valuable for the inevitable case where something goes wrong.\n\nNo, it is recursed\n\nHappy Cake Day!\n\n> ACE issues\n\nYeah, this is a big problem with pickle for folks not in-the-know (ACE is arbitrary code execution, loading pickles executes python code and imports and can do very weird stuff). \n\nI tell folks the only true **proper** use of pickle is to serialize data to/from a concurrent process with the same execution environment (basically multiprocessing on the same host), or debugging (e.g. dump out some program state to pull it into a notebook to interrogate it).  Any time the program starts/stops or crosses an environment boundary, you're way better off with a proper de/serialization protocol.\n\nbreak\n\nr/recursion\n\nThis is cursed\n\nthis is cursed\n\nthanks\n\nError: keyword 'break' is invalid in the current context\n\nMy reply [is here](https://www.reddit.com/r/programminghorror/comments/1bu14pi/be_careful_with_default_args_in_python/kxqlprb/)\n\nthis is cursed\n\ncontinue\n\nMy reply is [here](https://www.reddit.com/r/programminghorror/comments/1bu14pi/be_careful_with_default_args_in_python/kxrax4j/)\n\nNo, it is recursed\n\npanic!()", "id": "kxpv052", "owner_tier": 0.5, "score": 0.9999999999968344}, {"content": "This is basically the first Python gotcha\n\n[deleted]\n\n[deleted]\n\nWhen using a proper IDE, you'll be warned about this pattern too. Unfortunately juniors tend to ignore those annoying squiggly lines because why pay attention to a warning if your code runs right? If it runs, that must mean that it has to be correct otherwise it wouldn't...\n\nYup. This is literally question on junior developer interview\n\nIt's also caught by every python linter.\n\nPython is relatively gotcha free, but this is one for sure.  I usually stub my toe once a year or so on this one.\n\nIt's safe with atomic types like `int`.\n\nI thought indentation is\n\nYeah, that's basically common sense 101... (obviously /s)\n\nI\u2018m 9985\n\nWhat coke and mentos thing?\n\nThat was my first one actually, probably day 1 of Python\n\nI love how this hinges on proper IDE. Meanwhile I've never seen this in any IDE I've used. Must be because I use lightweights. Edit: specifically warnings about mutable objects passed as arguments to a function or method.\n\n> proper ide\n\naka let the magic black box do the thinking for you\n\nFor real? Ive never tried python but is that in their docs or something?\n\nEdit: its is in most linters docs\n\nPut Mentos in coke and you'll see.\n\nGet a big 2L bottle and a pack of mentos\n\nMentos rough surface makes it easier for coke to form co2 bubbles significantly faster and make a nice fountain\n\nIt's really fun to drink Coke with mentos in your mouth\n\nPyCharm has this warning, as well as many linters do. \n\nYou should be using linters for serious programming regardless of the IDE (and enforce them in CI).\n\n>aka let the IDE take care of the generic and abstractable stuff, so you can focus on your business logic\n\nFTFY\n\nOtherwise, why care about compiler warnings at all? You are the programmer, you do the thinking, right?\n\nIt\u2019s described in the Python docs here:\nhttps://docs.python.org/3/reference/compound_stmts.html#function-definitions\n\nI'd expect any professional python programmer to know this.\n\nI was surprised to find out that this is not a chemical reaction in the same way that baking soda and vinegar is. It's entirely a physical reaction that, as you said, forces the soda to foam up because the surface of a mentos is rough. Something similar happens when my fiancee uses a particular reusable straw in sparkling water.\n\nSo it might work on Alka Seltzer tablets also?\n\nWell, that's my mistake for thinking an IDE was what was meant, not a linter.\n\nyeah but when youre a beginner you shouldnt rely on them, because they might say that its bad but they dont explain *why* its bad\n\nThanks!\n\nPossible\n\nIs it unreasonable to expect a \u2018proper IDE\u2019 to have a good linter? It\u2019s one of the things that sets an IDE apart from a text editor, after all. While a linter does not have to be part of an IDE, I would expect an IDE to always have a linter (at least in the modern day).\n\nWhen you're a beginner you should not get bogged down in intricacies and specifics. That is the most important time to focus on logic flow and ability and Theory. Once you start understanding the theory you can start applying advanced issues. This specific problem is python a python one learning how to code around that might make you a worse programmer in other languages. My opinion learning a tool come second\n\non the contrary, linters for java taught me a whole lot when I was still learning the language. all you have to do is search up why it's complaining about something and you understand what exactly you did wrong.\n\nNot unreasonable. I was just a little too literal, even for a room full of programmers.", "id": "kxpmt7q", "owner_tier": 0.5, "score": 0.796771130101298}, {"content": "> never use mutable default values in python\n\nPyCharm and every linter I know warns about this exact thing.\n\nShouldn't be an issue in the first place though\n\nWhat\u2019s next? Strict types? /s\n\nI'm trying to think of a \"it's a feature, not a bug\" use case.\n\nDrawing a blank.\n\nWake up babe new PEP just dropped\n\nFor the record, the usual workaround (if you need to construct a mutable object as default argument) is to do this:\n\n    def list_with_appended_value(val, existing_list=None):\n        if existing_list is None:\n            existing_list = []\n        existing_list.append(val)\n        return existing_list\n\nOr if \"None\" must also be a valid argument, where there's a will there's a way:\n\n    _DEFAULT = object()\n    def foo(val=_DEFAULT):\n        if val is _DEFAULT:\n            val = [123]\n        # do something weird...\n\nThere's also the approach to pop off kwargs but I'm not so much a fan of that as it can obscure the function signature somewhat\n\nWhat approach do you suggest they use?\n\nPlease, I need them\n\nWhat do you mean by \"strict\"?\n\nWhat do you mean by \"strict\"?\n\nWhat do you mean by \"strict\"?\n\nWhat do you mean by \"strict\"?\n\nIt's more so a fairly obvious optimisation that breaks down for mutable default arguments.\n\nIt's fairly unusual to have mutable arguments as default values anyways, linters and IDEs will warn about it, you can work around it with factory functions if needed, and ultimately the trade off of having them be singletons is worth it for the generic case because it works more often than not.\n\nThe implication for them _not_ being singletons is that you have to evaluate extra code on every function invocation, instead of just pushing some args onto stack and jumping into a function. Basically you turn each function call into X+1 function calls, where X is the number of default args in the signature.\n\nI think it's more of a necessity that comes out of syntax and language properties. Don't know why exactly, but that's my guess\n\nBehave like JS: treat the default argument as code and run it every time a default value is needed, instead of running it once when the function is created. Of course, at this point, changing the behavior would be more trouble than it's worth.\n\n\u201dWe made this cool, straightforward scripting language where you don\u2019t have to worry about types! It just works\u201d\n\n\u201dOh no, types actually have a point! Quick, let\u2019s add them as a library!\u201d\n\n- Devs of every fashionable language\n\n`from typing import Sequence, Mapping`\n\n\nUse them in type hints and your IDE will prevent you from mutating the list/dict.\n\nThat's called Kotlin\n\n    a = [\u201cb\u201d, 2, False, func]\n\nvs\n\n    const a: number[] = [1, 2, 3, 4]\n\nIt's this. It's because the default argument is an expression that is evaluated at function creation time.  A lot of parts of python are eagerly evaluated in places where more static languages  would have \"special cases and provisions\" with language syntax.\n\nNot in python. It's all evaluated as statements and expressions.  This goes for module definitions, class definitions, function definitions, decorators, etc.\n\nIt makes it very easy to do higher order programming, but that's the trade off. Practically, all you gotta do is remember:  \\*Python does not have declarations.\\* What looks like a declaration from another language is just syntactic sugar in Python.\n\nThat would result in a big performance penalty. It would also make runtime introspection difficult if not impossible.\n\n[deleted]\n\nMost of these languages start out as something simple to use/easy to learn and for some specific things (JS for browser API, python for scripting etc), then people want to use these languages for absolutely everything and we have these \"bloat\" issues\n\nYou could just do\n\n`a: list[int] = [1,2,3,4]` and you'd get lint warnings if you do actions that treat the content as non-ints.\n\nIt's almost as good as static typing as far as development experience goes.\n\nThe common case of strings, ints, bools etc could still be optimized the exact same way. What do you mean about runtime introspection?\n\nNo more performance penalty than passing the value normally, which evaluates the arguments every time anyway.\n\nScala <3\n\nDevelopment/IDE, yes. Runtime, not so much...\n\nYou could also use [beartype](https://github.com/beartype/beartype)\n\nThe default argument has no performance penalty.\n\nIn fairness, the Typescript example is still prone to errors in runtime since it doesn't actually check while it's executing, especially when mixing JS/TS or assuming a particular structure from a server response. You need real type safety like C++, where it will just crash if you ever have the wrong type\n\nI mean that `some_function([])` already evaluates the argument every time, so why would doing it for default arguments too be so much worse?\n\nIf types are worrying in c++, your code won't compile. There's no crash.\n\nThe performance difference is large, because you have to allocate a new object every time. The difference is\n\n    # how python does it\n    DEFAULT = [1, 2, 3]\n    def f(arg=DEFAULT):\n        return g(arg)\n\nand\n\n\n    # how js does it\n    def f(arg=None):\n        if arg is None:\n            arg = [1, 2, 3]\n        return g(arg)\n\n\nThe difference is that it g does not mutate its arguments, f is far more efficient since it's just reusing the same allocation. But, as this thread points out, if you return the default or mutate it, it's a big gotcha, so safety over efficiency should probably have prevailed here.\n\nFor mutable arguments it makes no difference, but for immutable arguments there's a performance penalty, and that's the more common case.\n\nLet me try to rephrase this. Let's say I've just designed a new scripting language, and I give it to you to test out. You write some sample code:\n\n    def append123(values):\n        values.append(1)\n        values.append(2)\n        values.append(3)\n        return values\n\n    def make123():\n        return append123([])\n\n    print(make123())\n    print(make123())\n\nYou reasonably assume that this will print\n\n    [1, 2, 3]\n    [1, 2, 3]\n\nbut are shocked to see that instead it prints\n\n    [1, 2, 3]\n    [1, 2, 3, 1, 2, 3]\n\nYou ask me what gives. I explain that function arguments are cached for performance, and you should have written some extra code if you wanted it to generate a new list every time. You beat me unconscious with a baseball bat.\n\nObviously, caching explicit arguments for performance is completely insane. If you wanted the argument cached, you would have cached it. I think that default arguments should behave the same way.\n\nOk, I see the point you're making now. In that case, you're right, it wouldn't be worse performance than just using positional arguments, but it's still slightly faster than evaluating the default argument each time. \n\nI don't think performance was the main reason for this decision, though. It's more that this follows naturally from how Python is interpreted - the function signature is evaluated once at runtime, as if it were a scripting command (which it basically is). Handling keyword arguments differently would require either completely changing how function definitions work under the hood, or else adding a bunch of special case code to be run for each keyword argument, which would have a much higher overhead than just evaluating the argument more than once.", "id": "kxplvoe", "owner_tier": 0.3, "score": 0.5045900601424502}, {"content": "Still, the point is to never mutate arguments. Ever. Why would we want to mutate an object when we do not know:\n- whether its state is relied upon somewhere else\n- whether it is being mutated somewhere else\n- who has created it and for what purpose. \n\nIn very high level languages, there are seldom good reasons to mutate arguments, and if you get to one of them probably you already know about this behavior.\n\nThat's the correct answer.\n\nThis python qwerk is only a problem if you are already doing something wrong.\n\nIn real high-level languages, you don't pass by reference. You use return values to get data back to the caller. Or at least annotated arguments which are pass by reference.\n\nHave a look at Ada, which illustrates just how long we have had good solutions to this problem. Or more modernly Elixir or Zinc.\n\nIsn't this only if you do functional programming? Say I want to (manually) sort a list; Isn't it much easier/less memory intensive to sort the list, than to copy it and return a new, sorted list?\n\nYeah like what is this person talking about. That is how I would expect it to work because why tf would you be trying to change a default argument? Like sure you can think of a reason to do so, but that seems like terrible practice even if it was allowed...\n\n... which is why a modern language that does not really care about performance in the first place should probably just make arguments immutable (or by value) by default.\n\nAgreed, it's usually not great practice to modify arguments, so this problem is super niche.\n\nI see you also have some qwerks sir (:\n\nquirk\n\nAda is annoying and I hate it. I will never again work in the stupid UK defense industry with it's stupid Ada legacy codebases.\n\nYou\u2019re totally correct, but the overhead of a single redundant copy usually isn\u2019t that big of a concern if you\u2019re using a high level language. The maintenance overhead of possibly introducing a bug by mutating the argument is usually going to be much bigger concern.\n\nThat would then be implemented as a method on the list, like python list.sort, it to the no mission guidelines, like python's sorted(list)", "id": "kxq6jor", "owner_tier": 0.1, "score": 0.10541310540993985}, {"content": "> JS/TS [...] as I'd expect\n\nAh yes, the programming languages which are famous for not being a bunch of weird behaviours and side effects glued together.\n\nHow did Python manage to implement something so basic worse than them?\n\nI still can't get over the fact that `this` does not mean \"this class\" in JS, leading to the stupid line [let self = this;](https://stackoverflow.com/questions/962033/what-underlies-this-javascript-idiom-var-self-this) being a common solution.\n\nI think it was just the easy path way back when it was being developed (I think this would have been python 1.x or even earlier), give python's bytecode and data model under the hood. Basically, create an object when the function is evaluated, and point to it. If you mutate that object, that's on you. No different than\n\n\n```\nfoo = []\ndef func(x, a=foo):\n\u00a0 a.append(x)\n```\n\n\n\nThe alternative is either a) you have to basically re-evaluate the whole function block or b) re-evaluate the function signature but make sure it's consistent with anything else in the scope. Both are really gnarly and can lead to other bugs, so it's basically pick your bugs.\n\n\nPersonally, I'd let Type objects (classes so to speak but I'm being precise) define a classmethod dunder like `__default_factory__` which the parser can look for when parsing args and use that for each function call. But then that also requires hacks if you want to actually do caching.\n\nRight.  JS has some weird stuff with string interpolation, but you can avoid it pretty easily.  But this ONE thing in python feels so much more painful because its EVERY FUNCTION.\n\nIn all fairness to python, mutating arguments is already bad practice so this shouldn\u2019t come up a whole lot.\n\nI\u2019m guessing they decided that not having to initialize the object on every function call was worth it when you shouldn\u2019t need a new object every time anyway.\n\nTo be fair, it is the only consistent way, that doesn't have undesirable side effects.\n\n\nFor consistency, the default arguments have to be evaluated either at definition time or at invocation time. The latter represents unnecessary repeated overhead for the common case of immutable values. The first case can be extended easily by using factory functions as arguments.\n\n\nIt also enables the pattern of\u00a0\n\n\n\u00a0 \u00a0 for x in range(10):\n\u00a0 \u00a0 \u00a0 \u00a0 def callback(x=x):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ...\n\n\nto explicitly distinguish between capturing the changing value of the loop variable vs capturing the value at a given iteration.\n\n\nBoth behaviors are somewhat unexpected and have bitten me in the past. But I can't think of a way to make it more.ovbious that won't have undesirable side effects such as higher function call overhead or complicating the scoping semantics.\n\n\nThough admittedly, I'd love for Python to have block scoping like JavaScript... Would make handling overgrown \"do x then do y etc\" functions easier to manage and refactor.\u00a0\n\nIn modern JS you would just use arrow functions to maintain the this context. JS this is very weird at first but once you start thinking about it in the correct ways (this refers to the object on which a function was called on, which is also how it works with other languages) it should be less confusing.\u00a0", "id": "kxq0v7d", "owner_tier": 0.7, "score": 0.09275087052548274}, {"content": "That's why you DON'T use mutables as default args and every Python linter will scream at you for doing it\n\nDoesn't make it any less horrific", "id": "kxqcb7r", "owner_tier": 0.3, "score": 0.015827793602405823}, {"content": "I have written python professionally and never encountered this, wow.\n\nEDIT: I'm realizing now it's because I don't mutate, lol\n\nMe too! I noticed only because I read the documentation\u2026", "id": "kxqdsdv", "owner_tier": 0.3, "score": 0.014245014241848685}, {"content": "Damn, that is pretty bad lol", "id": "kxpj09u", "owner_tier": 0.5, "score": 0.04590060145299145}, {"content": "The takeaway is correct, and this is really one of the _very few_ gotchas you have in Python: https://docs.python-guide.org/writing/gotchas/\n\nIt's because default arguments are evaluated during function definition, not function execution.\n\nBut why? Because evaluating default args during function _definition_ makes it much easier to grok what the context is during evaluating the default arg, (In this simple example with an empty list it doesn't much matter, but it could also be a function call or something else, and then the context can indeed change. See the discussion here: https://softwareengineering.stackexchange.com/questions/157373/python-mutable-default-argument-why)\n\nThat feels closer to after the fact rationalization of an obviously wrong design decision by fan boys than a legitimate argument. \n\nIt's definitely not more complex to implement or reason about considering the implementation could just have been the workaround everybody now does as syntactic sugar.\n\nas a developer with 25+ years of experience in a ton of languages including pascal, asm, c, lua, java, perl etc I never used python before but I always heard good things about it as a scripting language e.g. to make life easier instead of writing a bash script or something or as a beginner language\n\nqueue wanting to teach my kid their first programming lessons and thinking well python seems like a good choice...\n\nMe fighting with spaces, tabs, and indentations 99% of the time and trying to explain (even with an IDE) \"yeah you see the computer only understands this if you build perfect pyramids\" is BULLSHIT\n\nI will not touch python with a ten feet pole - I thought perl was hardcore but python is STUPID - why did they think begin/end or brackets was too good for them?\n\nHow many CPython patches have you upstreamed that deal with complex nuances like this?\n\nI\u2019ve found it one of the easiest ways to get people into programming, and while I agree with you, the no-bracket style tripped me up at first, it\u2019s also fastest zero-functional scripting I\u2019ve ever done. I wish I was introduced with Python instead of JavaScript\n\nThe indentations are annoying but they are there to help you...\n\nNone. Why would i be contributing to CPython? Also, isn't the quality and state of that code-base kind of a self-own? Python can't implement what other languages can because our main interpreter is just such a shitty fragile piece of shit code-base, it will be very hard to do something that even a basic syntax pre-processor could do. It would hard to make illegal, what every linter already makes illegal by default?\n\n**Options they had:**\n\n(a) implement it as an AST to AST transformation\n\n(b) not implement default arguments at all\n\n(c) not allow mutable values as default arguments\n\n**Right now, every company in the world uses a linter to enforce (b) or (c).**\n\nMaybe the people that build linters should work on a python interpreter since they are such fucking geniuses that were able to pull that off! And not just one of them. All of the linters support this! And the Ruby people, and the Javascript people .. every other language in the world pulled this off, but somehow it's the rocket science engineering of CPython, that we all just wouldn't understand the complexities of!\n\nSeriously, an AST level transformation of a default value in a function signature to an initialization statement is not that fucking complex. Shit, you can cover 99% of the use cases with a freaking regular expression! \n\nI can't imagine that's the true reason, because i can't imagine the CPython developers to be that incompetent. I'm fairly sure it's the pathetic \"python fanboys\" that are too incompetent to understand it, and the actual engineers would likely just admit it was a design mistake. Obviously they aren't in this thread, nor are they in the on stack overflow answering these questions. \n\nPython isn't perfect; this is objectively a mistake and you are just gaslighting.\n\nIt is hard to explain to a beginner if I already struggle with the logical reasons for it.\n\nMeanwhile, I found lua to be far better beginner language and with games like Roblox etc its easier to rope kids into having fun in programming.\n\nSir, the therapist is this way...\n\n  \njk, but seriously, seek help.\n\nA) requires special casing lists and would lead to confusion when someone tried to use any other mutable type\n\nB) would make the language much less expressive\n\nC) would require complicating the language by adding some way for classes to identify themselves as immutable, which besides this the language does just fine without \n\nSo although I agree it is bad, I understand why the devs concluded it was the least bad of the options available.\n\no_O\n\nI mean I\u2019m far less experienced than you are in developing so maybe you\u2019re suffering from being a little too advanced to remember what it was like to be still learning, but  I\u2019ve never really had an issue with it myself. \n\nLua is great too! Especially for people who don\u2019t really want to be a developer but do want to make games\n\nHow would A require special casing anything?\n\nToday:\n\nWhen parsing a function, create a list of default arguments.\n\nWhen calling a function, for each argument, if it is not provided, replace it with the corresponding default argument.\n\nBetter:\n\nWhen parsing a function, create a list of lambdas that generate the default arguments\n\nWhen calling a function, for each argument, if it is not provided, replace it with the result of calling the corresponding default argument lambda.\n\nmy beginning languages were BASIC and Turbo Pascal, functional programming languages easily understood.\n\nThey tell you when a block starts for a function for ifs/else or for loops - like any other language basically I have developed in - yet here is python\n\nTake it the other way around - when you learn python first - will it not be weird that everything else will require you now to not think about your tabs/spaces/alignment but have either brackets or BEGIN and END to mark a block?", "id": "kxpn669", "owner_tier": 0.9, "score": 0.0487496043019943}, {"content": "I\u2019m curious about how someone thought this should be the right behavior when designing the language\n\nOver my long career, I\u2019ve learned to avoid saying \u201cthat\u2019s stupid\u201d but instead ask why it was done that way. \n\nTypically the reasons are interesting - it may have solved a problem that you aren\u2019t aware of, or it could actually just be stupid. \n\nI\u2019d also love to know why it was designed this way.\n\nThey thought it was the least bad of a bunch of bad options\n\nLmao i've been scrolling this thread trying to find someone saying \"Actually it's useful for-\".\n\nThis is the right energy. It\u2019s so easy to fall into the trap of assuming everyone must be an idiot for not seeing this simple issue you see, when you are the idiot that doesn\u2019t understand the complexity of the situation. \n\nSometimes people are idiots though, its just better not to default to that.\n\nYeah I avoid saying too but it\u2019s hard not to think it", "id": "kxpst0k", "owner_tier": 0.7, "score": 0.04621715732510288}, {"content": "Yeah I learned this when pycharm warned me about it, it's so stupid.", "id": "kxpj6t5", "owner_tier": 0.5, "score": 0.02279202278885723}, {"content": "Thanks, I hate it", "id": "kxpysvt", "owner_tier": 0.7, "score": 0.01772712883507439}, {"content": "using js as an example when criticizing another language for so-called insanity certainly is... a choice.\n\nWell, I mean when even js got it \"right\" that says something.\n\nFor once JS got it right\n\n\"Hey js... Sort these integers please.\"\n\" *As you wish*\"", "id": "kxpou65", "owner_tier": 0.7, "score": 0.038936372266540044}, {"content": "thank you for bringing this to light lmao i could\u2019ve screwed so much up in the future without knowing this", "id": "kxpw6zu", "owner_tier": 0.1, "score": 0.012029123137068692}, {"content": "I think I tripped over this. Once. In two decades of Python use.\n\nI'll accept the risk.\n\nIt's not a risk if you know about it.", "id": "kxqhlsp", "owner_tier": 0.7, "score": 0.012662234881291548}, {"content": "There is a PEP you should know and follow, or at least use a modern IDE that will let you know when you're doing things wrong.\n\nI\u2019m using VS code with Pylance \u2026 zero mention of this and it seems pretty stringent.\n\nThen again, I\u2019m also using typing module pretty religiously, so maybe I\u2019ve just naturally not run into the issue.\n\n>I\u2019m using VS code\n\nThey said modern IDE.\n\nI also use VSCode with Pylance but have used PyCharm in the past and this type of stuff along with a bunch of other PEP related things (like having a blank line at the end of the file) are picked up by PyCharm but not mentioned in VSCode\n\nhttps://marketplace.visualstudio.com/items?itemName=ms-python.pylint", "id": "kxprn33", "owner_tier": 0.7, "score": 0.021842355172522948}, {"content": "Ah, so THAT'S why PyCharm warns me against making the default argument mutable.", "id": "kxpshlm", "owner_tier": 0.5, "score": 0.013295346625514404}, {"content": "Everyone learns this the hard way.", "id": "kxptuz2", "owner_tier": 0.7, "score": 0.011396011392845837}, {"content": "Uh, in most languages it's a best practice to treat function/method arguments as though they were immutable.", "id": "kxrtd0o", "owner_tier": 0.9, "score": 0.011712567264957265}, {"content": "Python team should patch it to work like JavaScript, release it without the slightest mention in the patch notes, and then any code that breaks as a result deserves it", "id": "kxsmj9f", "owner_tier": 0.9, "score": 0.01234567900918012}, {"content": "yep... learned that the hard way, too, many years back...", "id": "kxpsnlu", "owner_tier": 0.5, "score": 0.011079455520734409}, {"content": "I used this for logging. Current time as default argument.\n\nThe timestamps were ... less than useful.", "id": "kxq9xnf", "owner_tier": 0.5, "score": 0.011079455520734409}, {"content": "Yeah I learnt the hard and long way to never use mutable default args. I\u2019ve always been able to find an alternative. \nAlso curious if this is a side effect of how Python is built or was intended by the creators?\n\nedit typos\n\nSort of both. Making this work any other way would have required doing a bunch of other things differently, and they decided the cost of those would be higher than doing it this way. So they understood the problem at the time, but they thought other approaches had worse problems.", "id": "kxqvvfp", "owner_tier": 0.1, "score": 0.012029123137068692}, {"content": "Don\u2019t mutate arguments, you get unexpected results", "id": "kxrbaxt", "owner_tier": 0.1, "score": 0.011079455520734409}, {"content": "Why would you modify an input mutable param that's also optional?\n\nEither it modifies a param by contract, in which case making it optional makes no sense...\nOr it's just an input not to be modified, in which case you don't touch it, _obviously_, otherwise you're playing with data that isn't yours and isn't supposed to be changed...", "id": "kxpteth", "owner_tier": 0.5, "score": 0.012978790753402976}, {"content": "It's definitely a gotcha, but Python is a scripting language at heart. It's just evaluating any expressions in a function signature once, instead of for every call. Hardly insane.", "id": "kxpndci", "owner_tier": 0.7, "score": 0.013928458369737258}, {"content": "Memoization is an intentional caching optimization.", "id": "kxpwvqt", "owner_tier": 0.5, "score": 0.010762899648622981}, {"content": "PyLint would warn you about errors like this.", "id": "kxqmfwd", "owner_tier": 0.1, "score": 0.010762899648622981}, {"content": "So much for functional programming :(", "id": "kxrx4li", "owner_tier": 0.7, "score": 0.010762899648622981}, {"content": "Yep, I got burned by this too. Python has *several*  horrific behaviors involving things that are static but don't look static.\n\nThis is just one of pythons data types. Lists are mutable, so not static. If you want immutable default arg, use a tuple, or None and declare it on instance initiation.\n\nBy static I mean they're re-used across different instances. In every other language I know of, default values for fields and parameters are not re-used each time.\n\nAh, ok I see what you mean", "id": "kxqrmas", "owner_tier": 0.7, "score": 0.01234567900918012}, {"content": "My first python gotcha is that class variables are global, you have to instantiate the variable in the constructor for it to be class", "id": "kxr4gon", "owner_tier": 0.3, "score": 0.010762899648622981}, {"content": "Pytyon is an abomination for anything that is not a script that's exdcuted once to produce a graph that's used in a paper", "id": "kxraoie", "owner_tier": 0.3, "score": 0.010762899648622981}, {"content": "In what universe would this be preferable? If I wanted that I'd write it in myself, why is this the default??", "id": "kxrn7zt", "owner_tier": 0.7, "score": 0.010762899648622981}, {"content": "Oh Jesus... Oh **Jesus**... I've got a lot of code to go back and check...", "id": "kxs5374", "owner_tier": 0.5, "score": 0.010762899648622981}, {"content": "The more i get to know python, the more i hate it", "id": "kxr160b", "owner_tier": 0.3, "score": 0.011079455520734409}, {"content": "This is a fun one. Usually just screws with people and they\u2019re really confused, but it\u2019s also a way to get static variable behavior from C into python. Now you probably shouldn\u2019t do that because it\u2019s confusing and error-prone, but it\u2019s still neat", "id": "kxq0im9", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "```\ndef get_user(userid, cache={}):\n    if userid in cache:\n        return cache[userid]\n    user = db_conn.getuser(userid)\n    cache[userid] = user\n    return user\n```\n\n... Actually no. I still prefer `functools.lru_cache()`, or straight up `cachetools`.", "id": "kxqaebv", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "That shit got me stuck for so long at work once... Just couldn't understand what the fuck was going on", "id": "kxrbqih", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "I'd forgotten about it and starting a huge python project soon thanks for the reminder \ud83e\udd23", "id": "kxrtl8f", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "Is this some sort of shared mutability joke I'm too rustacean to understand?", "id": "kxry466", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "What is that mini macOS IDE called?", "id": "kxs1cc9", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "Tbh if the list had a name it would make sense \"the default list to use is this one\" so I guess one could argue that adopting the same behavior for an unnamed one makes sense to still not something I would have personally chosen", "id": "kxs2f84", "owner_tier": 0.9, "score": 0.010446343776511553}, {"content": "\"By accident\" haha.", "id": "kxs5jg1", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "Yes, default values are initialized once, at the time the function is defined.", "id": "kxsaq3w", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Got burnt on this last week", "id": "kxsi7iw", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "We solved this using type hints. Your IDE will prevent you from mutating it if you type it with the related readonly interface: `Sequence` for list and `Mapping` for dict", "id": "kxt4ipq", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "I think most IDEs even warn, that this may lead to the very behaviour you described.\nAvoid mutable args\n\nMicrosoft's VSCode Python thing (Pylance) doesn't. I think I'm running Ruff as a linter as well ; Ruff definitely has a [rule](https://docs.astral.sh/ruff/rules/mutable-argument-default/) for this, but it's not in the default ruleset - you have to extend it to include this rule or the bugbear rules in general.\n\n    ruff --extend-select B <rest of args>\n\nPyCharm (Community) does highlight this, but you could miss it easily if you don't look in the lint problems because it only highlights the `[]` and it just looks like fancy brace highlighting.\n\nI got bitten by this one within living memory (while doing Advent of Code this year).", "id": "kxtd2cg", "owner_tier": 0.1, "score": 0.010762899648622981}, {"content": "You should make that a tuple. If you want the mutable, you'll get the mutable.", "id": "kxtjb6o", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "The way to do this properly is \\`def f(a, b, \\*optional\\_arg)\\`, right?", "id": "kxtpqr6", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "Oh yeah, specifically with list and dictionaries, this is particularly because list and dictionaries in python are pass-by-reference by default, togerher with the default arguments being effectively pass-by-reference it gets \"shared\"\n\nIts not shared btw, if you set an empty string or a string (or any objects), that PoC shouldnt work", "id": "kxtpxm3", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "I can never not think of pirates when I see \"arg\"", "id": "kxtqg5t", "owner_tier": 0.9, "score": 0.010446343776511553}, {"content": "Because the function definition is a object and the default arguments are part of the function definition. When you are mutating the arguments you are really mutating an attribute of the function object.", "id": "kxtrvd0", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "This is a question every graduate gets asked in interview.", "id": "kxtxbk1", "owner_tier": 0.9, "score": 0.010446343776511553}, {"content": "Whut", "id": "kxudmn3", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "That's one of the best known gotchas in Python", "id": "kxurjhx", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "Well, how tables have turned!", "id": "kxwl5kp", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "There was a proposal for having \\`def surprise(my\\_list => \\[\\]): ...\\` for default args that get recalculated (and can therefore rely on other args too). But it seems to have died? I actually thought it had made it into 3.12 but it seems it hasn't :(", "id": "kxwpjzo", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "This is not news. It's pretty common knowledge in Python circles. Even your ide warns you to not use mutable default arguments.", "id": "kxxpxrp", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "Don't do this:\n\n    def f(x = []):\n        ...\n\nDo this instead:\n\n    def f(x = None):\n        if x is None:\n            x = []\n        ...", "id": "kxzv2el", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "This has been around since Python 1.6, early 2000s.", "id": "ky07nb4", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "It's 2024, do people really still not know of this nowadays...?", "id": "ky0alia", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "dude in a python example in my book in highschool theres an example which uses a variable that isnt passed to a function?? I have no clue if it compiles, I hope it doesnt, heres what I remember it looking like\n```\ndef square():\n    return x**2\n\nx = 5\nprint(square())\n```\n\nWhat is this insanity???", "id": "ky2kacx", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "Thats why i optional_args = None and then do:\n```\nif not isinstance(optional_args, list):\n    optional_args = []\n```\n\n    optional_args = optional_args or []\n\nThat assumes optional_args is always a list", "id": "ky4zv2n", "owner_tier": 0.3, "score": 0.011079455520734409}, {"content": "I can't imagine debugging this as someone who barely scraped by on a project in college where I had to debug something where I kept accidentally changing pointers instead of the values they point to", "id": "ky8ioqy", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Who designed that nonsense, sat back, and said \u201cah yes, functioning as intended\u201d? What a grand misstep in an otherwise great language", "id": "kxqdbev", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "A truly insane choice.", "id": "kxqubof", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Tuples are immutable (but not their contents) :)\n```\ndef surprise(my_tuple = ()):  \n    print(my_tuple)  \n    my_tuple.append('x')  # AttributeError\n```", "id": "kxq6uhz", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "I remember one day trying to understand what was happening until I learned this. Terrible.", "id": "kxq8um9", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "Is there an lolpython sub like the php one?\n\nOnly 1 way to find out: \nr/lolpython", "id": "kxqafb9", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Programmer: I'm looking to define a function parameter that has a default value\n\nPython:  Best I can do is a lexically-scoped variable, sorry.", "id": "kxqauer", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Eugh I hate how loosely defined and floaty everything feels in python\n\nYou\u2019re welcome to use a more strict language. Python suits my needs just fine. I also use stricter languages like Java and Rust.\n\nYou\u2019re welcome to use a more strict language. Python suits my needs just fine. I also use stricter languages like Java and Rust.", "id": "kxqcnp6", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "That\u2019s fucked", "id": "kxs689x", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "lol", "id": "kxppl8j", "owner_tier": 0.5, "score": 0.010129787904400127}, {"content": "Everyone who uses python knows it", "id": "kxqpy8h", "owner_tier": 0.1, "score": 0.0098132320322887}, {"content": "Tell me you don\u2019t read the docs without telling me you don\u2019t read the docs\n\nit's still insane", "id": "kxspct6", "owner_tier": 0.5, "score": 0.010129787904400127}, {"content": "Man alive that's awful...", "id": "kxqcueg", "owner_tier": 0.9, "score": 0.010129787904400127}, {"content": "Probably considered a feature not a defect by the snek boiz", "id": "kxqi9t7", "owner_tier": 0.9, "score": 0.010129787904400127}, {"content": "That's why I can't take scripting languages seriously. Who thought that this is a good idea?", "id": "kxpjcce", "owner_tier": 0.5, "score": -3.1655589830337796e-12}, {"content": "There is nothing new about this - basically the first thing you learn when getting into python\n\nYes. It is documented well, in the articles that describe how function arguments are interpreted: the default array is generated at script reading time, not at function invocation time.\n\nYes. It is documented well, in the articles that describe how function arguments are interpreted: the default array is generated at script reading time, not at function invocation time.\n\nno it's not lol that's insane\n\nYeah, it's pretty common knowledge to be fair\n\ncommon knowledge sure. but \"first thing you learn\" even as a matter of speech is really stretching it\n\nYeah, that's not what I said. Ofc it's not the _first_ things, but if you do an intro course or read a book, as soon as they cover functions, it's mentioned.", "id": "kxr3xr3", "owner_tier": 0.5, "score": 0.01234567900918012}, {"content": "No wait really? _yo wtf_", "id": "kxprb03", "owner_tier": 0.7, "score": 0.00823045267173156}, {"content": "That's a pre-junior question on an interview\n\ndoesn't make it any less bad", "id": "kxrdbnj", "owner_tier": 0.5, "score": 0.009496676160177272}], "link": "https://www.reddit.com/r/programminghorror/comments/1bu14pi/be_careful_with_default_args_in_python/", "question": {"content": "Came across this image. I couldn\u2019t believe it and had to test for myself. It\u2019s real (2nd pic has example)", "id": "1bu14pi", "title": "Be careful with default args in Python", "traffic_rate": 76.37194851309366}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "By default, anything defined during the class's definition is a _class attribute_. It is not tied to an instance, at all:\n\n    class Apple:\n         size = 3\n\n    print(Apple.size)\n\nYou can access class attributes through an instance, however:\n\n    a = Apple()\n    print(a.size) # 3\n\nThat's _not_ because `a` has an instance attribute that is a pointer to the same value as the class attribute, but because attribute lookups, if they don't find an instance attribute of that name, next look to see if there's an attribute on the instance's class of that name. You can verify this by checking `a`'s and `Apple`'s `__dict__`, which stores their direct attributes in dictionary form:\n\n    print(a.__dict__)     # {}\n    print(Apple.__dict__) # {..., \"size\": 3, ...}\n\nThus, if you change the class attribute, all instances will see that change.\n\nTo define an instance attribute, you must do an attribute assignment on the instance after it has been created. The most common place to do so is the `__init__` method, though you can do it anywhere:\n\n    a.color = \"red\"\n    print(a.color) # red\n\nNote that if you do an attribute assignment on the instance for a name that already exists as a class attribute, you create a new instance attribute, rather than reassigning the class attribute:\n\n    a.size = 1\n    print(a.size)     # 1\n    print(Apple.size) # 3\n\nNote also that there's a popular decorator `dataclasses.dataclass` which, when applied to class, uses its class atttributes to auto-generate logic including an `__init__` method that creates instance attributes with the same name, default value, and type.\n\nThank you so much, that explains perfectly what I was looking for. As I mentioned in response to another reply, I didn't know about class attributes and instance attributes. However, based on this idea of creating a new instance attribute when doing an attribute assignment after the instance has been created, shouldn't the following hold true:  \n\n\n    Class Test:\n        var lst1 = []\n    \n    test_obj = Test()\n    test_obj2 = Test()\n    \n    test_obj.lst1.append[1]\n    print(test_obj2.lst1) # should print [1]\n    \n    test_obj2.lst1 = []\n    test_obj.lst1.append[3]\n    print(test_obj.lst1) # should print [1]\n    print(test_obj2.lst1) # should print [3]\n\nOr, does the mutability of lists effect this idea of an instance attribute with the same name as a class attribute and `print(test_obj2.lst1)` will actually give us `[1 3]`?\n\nNo, mutability does not affect this. But your code would actually print (after fixing a few typoes and removing `var`):\n\n    [1]\n    [1, 3]\n    []\n\nIf you appended `3` to `test_obj2.lst1` (instead of to `test_obj.lst1`), you'd get the outputs you indicated, so maybe that was a typo, too?\n\nThanks for noticing and yes, I meant to append 3 to test_obj2.lst1.", "id": "jgbqpow", "owner_tier": 0.3, "score": 0.7499999975}, {"content": "Its not really just a class thing. If you use mutable collection as default value in a function, init or not, it will not create a new empty collection object at each call but point to the same one.\nIt is useful for cache/memoization etc.", "id": "jgbryvi", "owner_tier": 0.5, "score": -2.4999999848063226e-09}, {"content": "It would help if you showed an example in code of what you're talking about, because I *suspect* what you mean is different from what others have been hearing and addressing so far. I *think* you're talking about the init function *parameters* rather than attributes per se:\n\n    class Foo:\n        def __init__(self, param1, param2, ...):\n\nAnd, I think in particular you're talking about giving them default values, and why you shouldn't have such a default value be a list:\n\n    class Foo:\n        def __init__(self, param1=['bar'], param2, ...):\n            self.param1 = param1\n            ...\n\nbut instead should default it to None (if it must have a default), and do the assignment inside the init:\n\n    class Foo:\n        def __init__(self, param1=None, param2, ...):\n            if param1 == None:\n                self.param1 = ['bar']\n            else:\n                self.param1 = param1\n            ...\n\nAm I understanding you correctly? If so, it's because the default values are only evaluated once, as the class definition is first being read by the interpreter. The result when you have a mutable object (like a list) as a parameter default value is that you're not getting a fresh new copy of the list each time you create a new instance object of the class. You're instead getting that very same list object, including whatever changes were previously made to the contents of the list with previously created instances.\n\nHere's one article I just searched up explaining it better: https://leimao.github.io/blog/Python-Default-Argument-Mutable-Object/\n\nSorry for not including a code example. I wasn't thinking specifically in the context of default values, more so because I didn't know Python could do that (I know that behaviour from Java and Kotlin). I replied to another comment with a code example, which I'll paste here:\n\n    Class Test:\n        var1 = 8\n        var_lst1 = [\"string\"]\n    \n    test_obj = Test()\n    test_obj2 = Test()\n    \n    test_obj.var1 = 10\n    test_obj.var_lst1.append(\"string2\")\n    \n    print(test_obj2.var1) # will get 8\n    print(len(test_obj2.var_lst1)) # will get 2\n\n&#x200B;\n\nHowever if the list was created in the constructor instead, we get:\n\n    Class Test:\n        var1 = 8\n        def __init__(self):\n            var_lst1 = [\"string\"]\n    \n    test_obj = Test()\n    test_obj2 = Test()\n    \n    test_obj.var1 = 10\n    test_obj.var_lst1.append(\"string2\")\n    \n    print(test_obj2.var1) # will get 8\n    print(len(test_obj2.var_lst1)) # will get 1\n\n&#x200B;\n\nThe example I just gave isn't really that different from yours. I guess it's the fact that a mutable object will change just the one variable value (that is, the contents of the same list) while that's not the case for an immutable object (like in both my examples with Test.var1).\n\nOn the surface, both are variables that are being modified. But under the surface, what's going to give the behaviour above?\n\nOkay, so, with \"test\\_obj.var1 = 10\", in both scenarios you're replacing the original value (the integer object whose value is 8) with a new value (the integer object whose value is 10). Or to put it even more technically, you're re-assigning the name \"test\\_obj.var1\" to now be a reference to the integer object whose value is 10. The name \"test\\_obj2.var1\" hasn't been changed; it still refers to the integer object with value 8. Although \"var1\" was originally created at the class level for both instances, you've dynamically added the \"var1\" variable at the instance level for test\\_obj with the new assignment through the \"test\\_obj\" name. With test\\_obj2, it's still referring to the class level \"var1\", even though you're getting to it through the instance name. I *think* if you did print(test\\_obj.\\_\\_class\\_\\_.var1), it would give you the class's 8 rather than the instance's 10, showing that the value is still there but just with the new \"var1\" name in the instance having the closer scope. (That could probably be written with better organization, but I hope it makes sense. (And I hope it's actually correct! \ud83d\ude01))\n\nWith var\\_lst1, in the first scenario it's created at the class level, so in both instances the name is referring to the *very same* original list object, [\"string\"], *not* a separate object in each which happens to have the same value. So when you modify the value with append, you're still pointing to the same object, just with a modified value. (Like a bottle is the same bottle even if you pour out the contents and put something else in it, or mix something else in.) The second scenario is different because now var\\_lst1 is created at the instance level, so each instance has its own separate copy of the list, which just happen to be equal to each other. That is, there are two separate list objects, and the name var\\_lst1 in the first instance refers to the first list, and the name var\\_lst1 in the second instance refers to the second list. So modifying the content of one has no effect on the other.\n\nAgain I hope I got that right as I type it out on my phone without testing anything, and I welcome correction from those who know better.\n\nThank you so much! That makes a lot of sense now. So, it's not a copy type situation in memory for immutable attributes, but a new attribute taking up a new location in memory and just happens to have the same variable name? Or, to put it another way, when I create an instance attribute of the same name as a class attribute, Python knows to go to the place in memory where the instance attribute is stored when the attribute is called using dot notation, and if there's no specific instance variable, then Python knows to use the class variable instead?\n\nDo you know how this all works with inheritance? Let's say I have the attribute Fruit.price and I create an instance of Apple, which is a child of Fruit, with the name apl_obi. Now, let's say my Fruit.price had a default value of 5 and in the Apple class definition, I set Apple.price to 3. If I set apl_obj.price to 1, then any calls to the attribute price would fetch the instance attribute. If I did not set apl_obj.price explicitly, would calls to apl_obj.price return 3 or 5?", "id": "jgc3pqq", "owner_tier": 0.7, "score": 0.9999999975}], "link": "https://www.reddit.com/r/learnpython/comments/12mqjpy/intricacies_of_python_classes/", "question": {"content": "Hi all,\n\nI'm taking the course Crash Course on Python as part of the Coursera Google IT Automation with Python program. I already know a good amount of beginner Python, but it's the first course in the series. Anyway, I'm doing the option week all about classes and the like. While I'm familiar with classes from other languages I've worked with in the past - Java mostly - I have done much with Python.\n\nThere are a few different examples they use to explain concepts, but the most notable one is using a class called Apple, in which there are 2 attributes - flavour and colour. During one video, they create another class for the demonstration and use a list attribute but define it only within the constructor. With the Apple class examples, the attributes were usually defined within the class itself with default values. They then go on to explain why the list attribute wasn't defined within the class by saying the following:\n\nWith the Apple class, if we change one Apple object (they use the term instance instead but I'm used to object) to have a colour different than the default value, it will change for only *that* object. However, if the Apple class had a list attribute that was defined in the class, and one of the object's changed that list, all of the objects would have the same change. Is this because of memory and how simple data types are dealt with when creating class instances? Specifically, I'm assuming that when the class definition is parsed, space in memory is created for it including all its attributes, default values, methods, etc. Then, when an object of that class is created, a copy of all that class data is created at a new location in memory. Thus, when changing one attribute for an object, Python only looks at the memory allocated for that object.\n\nHowever, with lists, I'm assuming pointers are involved. So, if a class definition contains a list attribute, what's really created in memory is a pointer with the attribute name to some other section in memory allocated for the list. So, when an object of that class is created, the class data that's copied includes a copy of the pointer with the same attribute name. In other words, when the list is updated through a specific object, the \"master memory location\" for that list is accessed and modified which is why other objects of the same class will also reflect the modified list attribute. Whereas, if a list is defined in the class constructor, then memory is allocated for the list attribute only when memory is created for a class object, rather than when reading the class definition?\n\nThank you.", "id": "12mqjpy", "title": "Intricacies of Python classes", "traffic_rate": 153.1714814814815}, "saved_time": 1721101398, "source": "reddit", "tags": []}, {"answers": [{"content": "\r\n    The DEFAULT constraint is used to insert a default value into a column.\n\r\nThe default value will be added to all new records, if no other value is specified.\n\r\nif u use this constraint across all columns means u can't able to insert the null values.\n\r\nOther than this there will not be any disadvantages happen\r\n", "id": "2_986803_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/898010/Is-there-any-disadvantage-of-apply-default-constra", "question": {"content": "\r\n\t\t\t    Hello, \n\r\nI have a confusion, Is there any disadvantage of apply default constraints over every fields of DB table . \n\r\nI want to apply default constraints at every fields of table, So whenever , I save any data into DB table, than it should be save with some default value rather than null,\r\n\t\t    ", "id": "898010", "title": "Is there any disadvantage of apply default constraints over every fields of DB table", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["SQL"]}, {"answers": [{"content": "\r\n    Variables are initialised with a default value upon creation. For numeric types like boolean, integer, and floating point this is the value zero and for object types like string it is null. If you do not set a variable by assignments in your code they will contain their default value.\n\r\nSee also Default Values at Primitive Data Types (The Java\u2122 Tutorials >                    Learning the Java Language > Language Basics)[^].\r\n", "id": "2_1238906_1", "owner_tier": 0.5, "score": 5.0}], "link": "https://www.codeproject.com/Questions/1238903/Why-the-output-is-showing-the-null-values", "question": {"content": "\n\n\r\nimport java.io.*;\r\npublic class Employee {\r\n\r\n   public String name;\r\n\r\n   private double salary;\r\n\r\n   public Employee (String empName) {\r\n      name = empName;\r\n   }\r\n   public Employee (double empSal) {\r\n      salary = empSal;\r\n   }\r\n\r\n   public void printEmp() {\r\n      System.out.println(\"name  : \" + name );\r\n      System.out.println(\"salary :\" + salary);\r\n   }\r\n\r\n   public static void main(String args[]) {\r\n     Employee empOne = new Employee(\"Ransika\");\r\n     Employee emptwo = new Employee(1000);\r\n      empOne.printEmp();\r\n      emptwo.printEmp();\r\n   }\r\n}\n\nWhat I have tried:\n\r\noutput :\n\n\r\n$javac Employee.java\r\n$java -Xmx128M -Xms16M Employee\r\nname  : Ransika\r\nsalary :0.0\r\nname  : null\r\nsalary :1000.0\n", "id": "1238903", "title": "Why the output is showing the null values?", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["Java"]}, {"answers": [{"content": "\r\n    You can set the properties in the call to new:\nC#\n\r\nnew GetBaseCustomerResponse { Property1 = value1, Property2 = value2 ...};\r\nWithout more information on what you are trying to do or sample code, it is hard to offer much more advice.\r\n", "id": "2_1276184_1", "owner_tier": 0.1, "score": 0}], "link": "https://www.codeproject.com/Questions/1268161/How-to-restrict-the-default-values-initialization", "question": {"content": "\r\n\t\t\t    In my application while creating derived class object baseclass constructor called and dervied class constructor also called at the time varibles are intalized and then operations are performed on the method.finally return the response.in that response i had get varibles are get with values based on operation performed and default values initialization don't want return the default value initialization. i need varibles are initialized with values based operation performed.\nC#\n\r\n[HttpPost]\r\n[Route(\"api/Account/Login\")]\r\n public async Task<GetBaseCustomerResponse> Login([FromBody]LoginRequest request)\r\n  {\r\n  GetBaseCustomerResponse _response = new GetBaseCustomerResponse();\r\n\r\n\r\n   -----operations are performed--------\r\n\r\n\r\n\r\n   return _response \r\n}\n\nC#\n\r\npublic class GetBaseCustomerResponse : GetResponseTemplate<BaseCustomerModel>\r\n{\r\n      \r\n}\n\nC#\n\r\npublic class BaseCustomerModel\r\n{\r\npublic int Customerid{get;set;}\r\n\r\npublic string cusname{get;set;}\r\n\r\npublic string cusaddress{get;set;}\r\n\r\npublic string email{get;set;}\r\n\r\npublic string Dateofbirth{get;set;}\r\n\r\n}\n\r\nplease help me.\r\nThank u\n\nWhat I have tried:\n\r\nIn my application while creating derived class object baseclass constructor called and dervied class constructor also called at the time varibles are intalized and then operations are performed on the method.finally return the response.in that response i had get varibles are get with values based on operation performed and default values initialization don't want return the default value initialization. i need varibles are initialized with values based operation performed\r\n\t\t    ", "id": "1268161", "title": "How to restrict the default values initialization while creating object of the class", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C#"]}, {"answers": [{"content": "\r\n    The first question is why are you using \"Type\"?  That is not a good name to use as it is a class name that is used by .NET and is going to lead to confusion in the code.\n\r\nI think your Type should become MarketType, and could also be the name of your Enum.\nC#\n\r\npublic enum MarketType\r\n{\r\n    Single,\r\n    Combined\r\n}\r\n\r\nand in your entity model:\nC#\n\r\npublic class Market\r\n{\r\n    public int ID { get; set; }\r\n    public string Name { get; set; }\r\n    public string IsoCode { get; set; }\r\n    public MarketType MarketType { get; set; }\r\n}\r\n\n", "id": "2_759429_1", "owner_tier": 0.7, "score": 0}], "link": "https://www.codeproject.com/Questions/759410/Entity-Framework-Default-Values-are-allowed-only-f", "question": {"content": "\r\n\t\t\t    Hi Guys,\n\r\nI hope you are all well and that someone here might be able to shed some light on my issue.\n\r\nI have a database table with the following setup:\n\n\n\r\nID [Bigint]<br />\r\nName [nvarchar(250)]<br />\r\nISOCode [nvarchar(5)]<br />\r\nMarketType [tinyint]\n\r\nUsing EntityFramework 6 Database first, I have added this table to my edmx file and it generates a class called \"Market\".\n\r\nOff of this, I have created two classes, 'SingleMarket' and 'CombinedMarket' (Some of you may be thinking da-ja-vu here but this is different to my last question relating to the same objects).\r\nI have converted the Type property on my Market to be an Enum which has two options:\n\n\n\r\nSingle = 1,<br />\r\nCombined = 2\n\r\nThese determine whether an object is a Single or Combined market, as I'm sure you gathered by now.\r\nMy issue is that right now my edmx fails so build with the error\n\"Default Values are allowed only for non-spatial primitive types\"\n\r\nNow I know that this error is caused by my \"MarketType\" property on the market base class, but I want the MarketType to default to 1 (Single). I also want to keep the \"MarketType\" property on my entity.\n\r\nIf I delete the MarketType property then it all compiles, but then I can't say \"What type is this Market\", or if I can I don't know how to. \n\r\nI also have this error:\r\n\"\n\r\nProblem in mapping fragments starting at lines 290, 298, 304:Column Market.MarketType has no default value and is not nullable. A column value is required to store entity data.<br />\r\nAn Entity with Key (PK) will not round-trip when:<br />\r\n  ( PK is in 'Markets' EntitySet AND Entity is type [MRPData.Market])\"\n\r\nSo, in simple, how can I keep my \"MarketType\" property on the base class and have it set with a default value of 1 (single) ?\n\r\nAny questions/clarification needed please ask.\n\r\nThanks in advance.\n\r\n[Edit]Type property renamed to MarketType as per Dave's advice.[/Edit]\r\n\t\t    ", "id": "759410", "title": "Entity Framework 6 - Default Values are allowed only for non-spatial primitive types.", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C#", "enum", "EF6.0"]}, {"answers": [{"content": "\r\n    There is no equivalent in C#.\n\r\nIn C, C++ and C# you must declare your variables before attempting to assign them.\n\r\nYou should however be aware of variable scope - Variable and Method Scope in Microsoft .NET[^] - there are no differences between scope in VB.NET and C# (AFAIK).\n\r\n[EDIT] - Option Explicit in VB isn't what provides the default values - those are defined by the framework - Default Values Table (C# Reference)[^]\n\r\nIf you want to prevent default values being used then get into the habit of always explicitly assigning a value to the variable. There are tools available that will prompt you if you have not done this (I don't know of any free ones though)\n\r\n[EDIT #2]\r\nI downloaded an express version of Visual Studio so I could check this without the tools or settings I normally use...\r\nConsider this code snippet ..\nC#\n\r\nint c;\r\n\r\nprivate void button1_Click(object sender, EventArgs e)\r\n{\r\n    int a;\r\n    int b = 10;\r\n\r\n    Console.WriteLine((a + b).ToString());\r\n    Console.WriteLine((c + b).ToString());\r\n\r\n}\r\nThis gave me one error and one warning ...\n \n\r\nError Use of unassigned local variable 'a'\r\nWarning 'WindowsFormsApplication1.Form1.c' is never assigned to, and will always have its default value 0\r\nSo for local variables you will be told off by VS for not initialising but for 'global' or class level variables you will only be warned by default.\n\r\nYou can force VS to convert those warnings to errors by going into YourProject, Properties, Build\r\n", "id": "2_1076632_3", "owner_tier": 0.5, "score": 1.2}, {"content": "\r\n    In C#: in the Project Properties facility, in the 'Build options panel you can set the \"warning level\" that will govern what types of error events (messages) will be raised: [^]:\n\nWarning level\tMeaning\r\n0\tTurns off emission of all warning messages.\r\n1\tDisplays severe warning messages.\r\n2\tDisplays level 1 warnings plus certain, less-severe warnings, such as warnings about hiding class members.\r\n3\tDisplays level 2 warnings plus certain, less-severe warnings, such as warnings about expressions that always evaluate to true or false.\r\n4\tDisplays all level 3 warnings plus informational warnings. This is the default warning level at the command line.\n\r\nWork in Debug mode.\r\n", "id": "2_1076646_1", "owner_tier": 0.5, "score": 5.0}, {"content": "\r\n    Option Explicit in VB.NET only forces you to declare variables before you try to use them. That's it. Nothing else. It has nothing to do with initializing variables. All variables in .NET are initialized to an appropriate value by default.\n\n\r\nPublic Function TestSub(x As Integer, y As Integer)\r\n    ' The following line will cause a compiler error if Option Explicit is turned on.\r\n    ' i was never defined before being used.\r\n    i = x + y\r\n    return i\r\nEnd Function\r\n\n\r\nC# forces this by default. There is no turning it off.\n\n\r\npublic int TestSub(int x, int y)\r\n{\r\n    i = x + y;\r\n    return i;\r\n}\r\n\r\nwill throw an error because i wasn't declared at all.\n\r\nOption Explicit does NOT force you to initialize a variable. There is no option in VB.NET or C# that does this.\n\r\nIf the default value of a variable causes your code to give unexpected results, the problem is with you, not some option. You didn't take the steps required to validate your input before you tried to use those values. Input, in this context, is any values being used by an algorithm, including declared variables, not just the stuff a user types in.\r\n", "id": "2_1076647_1", "owner_tier": 0.7, "score": 2.5}], "link": "https://www.codeproject.com/Questions/1076625/Can-I-prevent-NET-from-allowing-use-of-default-val", "question": {"content": "\r\n\t\t\t    Hi Everyone,\n\r\nIs there an equivalent to the vbs switch \"Option Explicit\" in .NET (specifically C#)?  I've been burned a couple times now by variables that I failed to explicitly initialize.  I'd rather break than have code I think is working which produces bad output!!\r\n\t\t    ", "id": "1076625", "title": "Can I prevent .NET from allowing use of default values for variables", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C#", ".NET"]}, {"answers": [{"content": "\r\n    You cannot define a default value for an array as a parameter, because this way the default value has to be a compile-time constant.\r\nYou can however test for a null value, and assign the default value accordingly:\nC#\n\r\nvoid MyMethod(string[] datakeyNames = null)\r\n{\r\n   datakeyNames = datakeyNames ?? new string[] { \"Id\", \"DateModified\" };\r\n   // ...\r\n}\n", "id": "2_5161217_2", "owner_tier": 0.5, "score": 1.5}, {"content": "\r\n    You can't do it with default parameters (for an array), but you can do it with an overload:\n\nC#\n\r\npublic bool MyMethod()\r\n{\r\n    string[] value = new string[] { \"Id\", \"DataModified\" };\r\n    return MyMethod(value);\r\n}\r\n\r\npublic bool MyMethod(string[] value)\r\n{\r\n    // do something with the string array\r\n    return false;\r\n}\n\r\nThis way, you can call either overload and be okay. If you combine the two answers, you could do something like this:\n\nC#\n\r\nprotected string[] DefaultValues()\r\n{\r\n    return new string[] { \"Id\", \"DataModified\" };\r\n}\r\n\r\npublic bool MyMethod()\r\n{\r\n    return MyMethod(this.DefaultValues());\r\n}\r\n\r\npublic bool MyMethod(string[] value = null)\r\n{\r\n    value = value ?? this.DefaultValues();\r\n    // do something with the string array\r\n    return false;\r\n}\n\r\nThat way, you cover all of your bases, and still only have to change the default values in one location.\r\n", "id": "2_5161218_4", "owner_tier": 0.7, "score": 1.5}, {"content": "\r\n    This is an alternative pattern I sometimes use for handling a mix of optional and default parameters:\n\r\nprivate string[] defaultData = new []{\"Id\", \"DataModified\"};\r\n\r\n// requires C# >= 4.00\r\n// requires Linq\r\npublic bool myMethod(bool ensureDefaultDataIsUsed = true, params string[] data)\r\n{\r\n    if (ensureDefaultDataIsUsed)\r\n    {\r\n        data = data.Concat(defaultData).Distinct().ToArray();\r\n    }\r\n\r\n    return true;\r\n}Consider these usage examples:\n\r\n// no parameters: 'defaultData is used\r\nbool m0 = myMethod();\r\n\r\n// single parameter: 'defaultData combines with parameter\r\nbool m1 = myMethod(data: \"hello\");\r\n\r\n// multiple parameters: 'defaultData combines with parameters\r\nbool m2 = myMethod(true, \"hello\", \"goodbye\");\r\n\r\n// multiple parameters: 'defaultData is not used\r\nbool m3 = myMethod(false, \"hello\", \"goodbye\");\r\n\r\n// will not compile\r\nbool m4 = myMethod(\"hello\");What I like about this:\n\r\n1 keeping default parameters in a variable makes it easy to change what the defaults are\n\r\n2 all the options are in one method\n\r\n3 control over whether defaults are used, ignored, or combined with user supplied data\n\r\nWhat some might consider the downside: example #m4 illustrates that using an explicitly named parameter for 'ensureDefaultDataIsUsed is required to avoid a clash between a positional and an optional value.\r\n", "id": "2_5161260_1", "owner_tier": 0.5, "score": 1.0}], "link": "https://www.codeproject.com/Questions/5161216/Make-method-with-string-with-optional-default-valu", "question": {"content": "\r\n\t\t\t    Hi Folks,\n\r\nHow to have a method that has a string[] array value with default optional values.\n\r\nIn gridviews most database have the fields ID and DateModified setup for GridView.DataKeyNames.\r\nI have 1 application that have ID and date_modified als columns for GridView.DataKeyNames\n\r\nIn my method I want to do \r\nvoid MyMethod(string[] datakeyNames = new string[] { \"Id\", \"DateModified\"})\n\r\nHow can I set-up default values for a string array in a method?\n\nWhat I have tried:\n\r\nAll I get from C# compiler is the message:\r\n\tDefault parameter value for 'datakeyNames' must be a compile-time constant\r\n\t\t    ", "id": "5161216", "title": "Make method with string[] with optional default values", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C#", "Gridview", "ASP.NET4"]}, {"answers": [{"content": "\r\n    Another possibility for you would be to use the singleton pattern by having a static object.\r\nPlease see this code for your class:\nC#\n\r\nclass Settings\r\n{\r\n   private Settings()\r\n   {\r\n   }\r\n   static Settings m_instance = null;\r\n   public static Settings Core\r\n   {\r\n      get\r\n      {\r\n            if (m_instance == null)\r\n               m_instance = new Settings();\r\n            return m_instance;\r\n      }\r\n   }\r\n   public decimal Density = 21;\r\n   public string SelectedPrinterName = \"ZDesigner GX430t\";\r\n}\r\nYou can then use the class from wherever you want using the follwing code:\nC#\n\r\npublic Form1()\r\n{\r\n   InitializeComponent();\r\n   Settings.Core.Density = 5;\r\n}\n", "id": "2_469366_1", "owner_tier": 0.3, "score": 3.0}, {"content": "\r\n    You are sharing the same class (Type) but not the same instance of that class (Object).\r\nYou should explore the usage of the keyword static if you want to have such \"global\" object or even better have a llok at the singleton pattern. You'll find plenty of articles in code project about it.\r\n", "id": "2_469368_1", "owner_tier": 0.3, "score": 0}, {"content": "\r\n    This is the popular question about form collaboration. The most robust solution is implementation of an appropriate interface in form class and passing the interface reference instead of reference to a \"whole instance\" of a Form. Please see my past solution for more detail: How to copy all the items between listboxes in two forms[^].\n\r\nPlease also see other solutions in this discussion. If the application is simple enough, the solution could be as simple as declaring of some internal property in one form and passing a reference to the instance of one form to the instance of another form. For more complex projects, such violation of strictly encapsulated style and loose coupling could add up the the accidental complexity of the code and invite mistakes, so the well-encapsulated solution would be preferable.\n\r\nPlease see also:\nhttp://en.wikipedia.org/wiki/Accidental_complexity[^],\nhttp://en.wikipedia.org/wiki/Loose_coupling[^].\n\n\u2014SA\n", "id": "2_469451_1", "owner_tier": 0.7, "score": 0}], "link": "https://www.codeproject.com/Questions/469358/Passing-data-between-forms-why-so-complicated", "question": {"content": "\r\n\t\t\t    Hey,\n\r\nUPDATE: Solution 1 accepted!\n\r\nI've been programming in C# for a few weeks (nearly fulltime) and learning every day. I am currently trying to organize the data in my project. This question is a followup question from my previous question Passing data between forms. I have for example some settings which I want to adjust. These settings are used in the main form but set in a different form.\n\r\nI'd like to have a central point in my project where I can store all my settings (variables). It is important that I can acces and update the data from all froms in my project. \n\r\nI create for example a class with all the declarations with a default value. like this:\n\nC#\n\r\nnamespace SerialProgrammer\r\n{\r\n    class Settings\r\n    {\r\n        public decimal Density = 21;\r\n        public string SelectedPrinterName = \"ZDesigner GX430t\";\r\n    }\r\n}\n\n\r\nSo I want to adjust this value in form2; like this: \n\nC#\n\r\nSettings settings = new Settings();\r\nprivate void BTN_Set_Click(object sender, EventArgs e)\r\n{\r\n\r\n    settings.Density = nudDensity.Value;\r\n    this.Close();\r\n\r\n}\n\r\nAnd on my main form I want to use the settings, like this: \n\nC#\n\r\nSettings settings = new Settings();\r\nprivate void printLabel(string snum, string type, int number)\r\n{\r\n    if (IsPrinterOnline(settings.SelectedPrinterName))\r\n    {\r\n        if (settings.SelectedPrinterName.Contains(Dymo_PrinterName))\r\n        {\r\n            dymoPrintLabel(snum, type, number);\r\n        }\r\n        else if (settings.SelectedPrinterName.Contains(Zebra_PrinterName))\r\n        {\r\n            ZebraPrintLabel(snum, type, number);\r\n        }\r\n\r\n    }\r\n}\n\r\nWhat I experienced is that even though it looks like (at least for me) that both forms share the class Settings, they both use a different class Settings with different values. How can I change my code that I have one set of settings which are easily accessable from both forms?\r\n\t\t    ", "id": "469358", "title": "Passing data between forms why so complicated?!~SOLVED", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C#", "C#4.0"]}, {"answers": [{"content": "\r\n    This worked for me (in VS):\n\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\n   public:\r\n     CSmartArray();\r\n\r\n   private:\r\n      const T& m_preset_value;\r\n};\r\n\r\ntemplate <class T> CSmartArray<T>::CSmartArray() : m_preset_value(0)\r\n{\r\n   \r\n}\n\r\nNot sure if it's quite what you want though. (Note I had to make it a const reference. You might just want to use a pointer here instead, it will probably be easier.)\r\n", "id": "2_636702_1", "owner_tier": 0.3, "score": 2.5}, {"content": "\r\n    If we take a look at the generated code then a reference is exactly the same as a pointer. On language level syntactically references have more strict rules: a reference has to be initialized exactly once where you declare/define it. If the reference is the member variable of a class then you have to initialize it from the initializer list of every constructor of the class. A reference can not be changed later to point to something else. After declaration and initialization the identifier of the reference variable works as if it was the identifier of the object to which the reference points. For this reason initializing a reference to zero has no point. If you want to change the reference after initialization to point to something else then you want to use a pointer instead of a reference.\r\n", "id": "2_636705_1", "owner_tier": 0.3, "score": 1.5}, {"content": "\r\n    It does not make much sense to have a reference member to an \"unknown\" type. If this is really what you want to do (assuming that a default constructor exists), you would also have to implement the destructor and ensure that the object is not copyable...\n\r\nIf not, then you have to ensure that the type is a POD type (rules are a bit different with C++ 11 but since I don't know all details).\n\r\nThus, you would have something like this (for simplicity all functions are defined inline):\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\npublic:\r\n  CSmartArray() : m_preset_value(*new T())\r\n  {\r\n  }\r\n\r\n  ~CSmartArray()\r\n  {\r\n    delete &m_preset_value;\r\n  }\r\n\r\nprivate:\r\n  CSmartArray(const CSmartArray &); // No copy\r\n  CSmartArray& operator=(const CSmartArray &); // No copy\r\n\r\n  T& m_preset_value;\r\n};\n\r\nIf an instance is used, then it simplify to this (this is what I would recommand to do):\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\npublic:\r\n  CSmartArray() : m_preset_value() // Empty () will force default value in that case since a long time.\r\n  {\r\n  }\r\n\r\nprivate:\r\n  T m_preset_value;\r\n};\n\r\nBy the way, this is not very flexible as it is not possible to create object not using the default constructor.\r\n", "id": "2_636776_2", "owner_tier": 0.3, "score": 5.0}, {"content": "\r\n    What you are trying to achieve does not make sense, because the template parameter is any arbitrary type, and an arbitrary file does not have a concept of \"null\", but it does not even have to support a concept of some \"default initial value\". Nothing can be assumed for this type.\n\r\nThere are some work-around approaches. Let's think.\n\r\nIt may seem that you can internally use the pointer to T as your private member m_preset_value. Then you could assign this member to the 0 pointer, regardless of the actual type of T. However, it would not solve problem, only delay it, as you don't know the constructor for T if it is required, so how one would instantiate it?\n\r\nThe simplest real resolution could be something like this:\nC++\n\r\ntemplate <class T> class SmartArray {\r\nprotected:\r\n\tT m_preset_value;\r\n\tvirtual void Initialize() = 0;\r\npublic:\r\n\tvoid SomeMethod() { m_preset_value = Initialize(); } // could be anything, for example, constructor\r\n};\n\r\nThis way, with each instantiation of the template you should also create a derived class and the virtual method should be overridden:\nC++\n\r\nclass BooleanSmartArray : public SmartArray<bool> {\r\nprotected:\r\n    virtual void Initialize() { m_preset_value = 0; }\r\n};\n\r\nThis may seem to be not very convenient. As an alternative, you would need to use something like generic constraints of CLI (.NET, in particular). This way, you could create some interface class with operations like Initialize and more. Then, instead of arbitrary unconstrained type T, you could indicate that the template parameter is contrained to be derived from this interface class.\n\r\nYou can see these suggestions by Bjarne Stroustrup:\nhttp://www.stroustrup.com/bs_faq2.html#constraints[^].\n\r\nAnother approach is implemented in boost: http://www.boost.org/doc/libs/1_36_0/libs/concept_check/concept_check.htm[^].\n\r\nSee also:\nhttp://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29[^],\nhttp://www.boost.org/[^].\n\r\nAnd if you can use C++11, you can think about the use of template std::initializer_list:\nhttp://en.wikipedia.org/wiki/C%2B%2B11#Initializer_lists[^]\n\n\u2014SA\n", "id": "2_636718_2", "owner_tier": 0.7, "score": 1.2666666666666666}], "link": "https://www.codeproject.com/Questions/636695/Cplusplus-templates-plus-variable-default-values", "question": {"content": "\r\n\t\t\t    I'm having trouble wrapping my head around this and Mr. Google doesn't seem to know much about it either or I'm just not querying correctly, probably he latter but I've got a template;\n\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\n   public:\r\n     CSmartArray(...);\r\n\r\n      blah...blah...blah\r\n\r\n   private:\r\n      T& m_preset_value;  //<=== The value to set\r\n};\r\n\r\ntemplate <class T> T& CSmartArray<T>CSmartArray(...)\r\n{\r\n   //How do I set the following value to some default value such as zero?\r\n   m_preset_value = 0;     //Nope\r\n   m_preset_value = (T)0;  //Nope\r\n   m_preset_value = (T&)0; //Nope\r\n}\n\r\nQuestion is how do I set the m_preset_value to some default value such as zero?\n\r\nIt's probably very simple but am not seeing it but how do I set any value to m_preset_value?\n\r\nUrgent send code plz......  :)\n\r\nThanks Y'all\n\r\nBTW Templates using GCC is a PITA!\r\n\t\t    ", "id": "636695", "title": "C++ templates + variable default values", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C++"]}, {"answers": [{"content": "\r\n    Oh boy - this is going to be difficult to explain without pictures, so you would be better off looking in a book. But:\n\r\nIn your click handler, you create an instance of Class1, and assign it to a variable called oClass1. What is actually in oClass1? Is it an int - the total data stored by Class1? Or is it something else?\r\nWhat is actually stored in oClass1 is not the actual Class1 instance - it is a reference to the class instance. I.e. the instance you created is on the heap and oClass1 is (probably) on the stack. Why? So that you could have a second variable if you needed it:\n\n\r\nprotected void Button2_Click(object sender, EventArgs e)\r\n{\r\n    Class1 oClass1 = new Class1();\r\n    Class1 oClass2 = oClass1;\r\n    oClass1.MyProperty1 = 10;\r\n    MethodCall(oClass1);\r\n    TextBox2.Text = oClass1.MyProperty1.ToString();\r\n}\r\nAnd then both oClass1 and oClass2 would refer to the same instance of a Class1.\r\nWith me so far? Good.\r\nYou then hand the content of oClass1 to your method. What gets handed through? Answer: the reference to the instance. Not oClass1, but the content of oClass1.\r\nSo when you modify MyProperty in MethodCall you are modifying the object that oClass1 refers to.\n\r\nThis is a lot easier to explain with pictures!\n\r\nTry this and you might see what I mean:\n\n\r\nclass Class1 { public int i;}\r\nprivate void ShowTheDifference()\r\n    {\r\n    Class1 cs = new Class1();\r\n    cs.i = 100;\r\n    Method(cs);\r\n    MessageBox.Show(cs.i.ToString());\r\n    Method2(cs);\r\n    MessageBox.Show(cs.i.ToString());\r\n    }\r\nvoid Method(Class1 cs) { cs = new Class1(); cs.i = 999; }\r\nvoid Method2(Class1 cs) { cs.i = 999; }\r\n\n", "id": "2_101579_1", "owner_tier": 0.9, "score": 1.5}, {"content": "\r\n    Anything other than ValueTypes are passed by reference. ValueTypes includes structures. \r\nInt32 is a structure, so it is passed by value.\n\r\nYour custom object TextBox or any object (which is not ValueType)is always passed by Reference.\r\n", "id": "2_101781_1", "owner_tier": 0.5, "score": 1.7}, {"content": "\r\n    No! Both, value and reference types are passed by value unless you require them to be passed by reference (the ref or out keywords). Since Class1 is a reference type its value is a reference pointing to some object stored on the heap. Thus, changing the value of a property of a reference to oclass in MethodCall  changes the value of oclass.MyProperty on the heap.\n\n\n\r\npublic void MethodCall(Class1 oclass)    {        oclass.MyProperty1 = 100;    }\n\r\nIf you want to pass by reference use ref:\n\n\n\r\npublic void MethodCallByRef(ref Class1 oclass) {\r\nint tOldValue = oclass.MyProperty1;\r\noclass = new Class1();\r\noclass.Property1 = tOldValue;\r\n}\n\r\nthen you have:\n\n\n\r\n...\r\n\r\nClass1 o1 = new Class1();\r\nClass1 o2 = o1;\r\n\r\nMethodCall(o2);\r\n\r\nConsole.Write(Object.Equals(o1.Property1, o2.Property1));// prints true\r\nConsole.Write(Object.ReferenceEquals(o1, o2)); // prints true\r\n\r\nMethodCallByRef(ref o2); // explicit call by reference!\r\n\r\nConsole.Write(Object.Equals(o1.Property1, o2.Property1)); // prints true!\r\nConsole.Write(Object.ReferenceEquals(o1, o2)); // prints false!\r\n...\n", "id": "2_101800_2", "owner_tier": 0.1, "score": 0.5275}, {"content": "\r\n    All register types are default by value, like int, int32 and also reference pointers (not directly visible in c# but they are there). These variables live on the stack and are there only alive in the stackframe of that method call. An object lives on the heap and only the reference lives on the stack. So when changing an object property it is done to the referenced object and therefore can be seen by everyone with a reference to that object. It is an optimization because it means that the object doesn't have to be copied every time it is passed. If it must stay the same you could clone it using that method accordingly.\n\r\nThis is however language specific because c/cpp for example will create copies of structs/objects if you do not explicitly specify differently.\n\r\nHopefully this gave you some idea.\n\r\nGood luck!\r\n", "id": "2_101576_1", "owner_tier": 0.3, "score": 0}, {"content": "\r\n    The answers above are correct, but I find them confusing. I'm a beginner and rather simpleminded, to boot. In simpler terms, objects are passed to methods by reference, while simple types like int and int32 are passed by value. The difference is easy to understand. \n\r\nWhen you pass a simple type to a method, the method gets a copy of the original variable. If the method changes that value, when the method returns the original variable is unchanged, and the copy used in the method is destroyed.\n\r\nWhen you pass an object, the method gets the address of the original variable, and when the method makes a change, the original gets changed. Passing variables by reference sort of opens a pipeline to the original variable, and gives your method access to it. \n\r\nIf you want to preserve the changed value of a simple type, give your method a return type that matches the type used as a parameter, then use a return statement to pass the result out of the method:\n\n\n\r\npublic int32 MyMethod(int32 MyParam)\r\n{\r\n    int32 MyValue = 5 * MyParam;  //MyParam is a local copy of the input parameter\r\n    return MyValue;\r\n}\r\n\r\nint32 MyChangedValue = MyMethod(MyParam);\n\n\r\nI hope a simpleton's explanation is helpful... :)\r\n", "id": "2_101733_1", "owner_tier": 0.5, "score": 0.9}, {"content": "\r\n    A more pictoral reference is explained in the following link. I hope that helps for new comers like me. \n\nhttp://www.javaranch.com/campfire/StoryPassBy.jsp[^]\r\n", "id": "2_699351_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/101574/In-C-objects-are-passed-by-value-or-by-reference-C", "question": {"content": "\n\n\r\npublic class Class1\r\n    {\r\n        private int Prop1;\r\n\r\n        public int MyProperty1\r\n        {\r\n            get { return Prop1; }\r\n            set { Prop1 = value; }\r\n        }\r\n    }\r\n\r\n    protected void Button2_Click(object sender, EventArgs e)\r\n    {\r\n        Class1 oClass1 = new Class1();\r\n        oClass1.MyProperty1 = 10;\r\n        MethodCall(oClass1);\r\n        TextBox2.Text = oClass1.MyProperty1.ToString();\r\n    }\r\n\r\n    public void MethodCall(Class1 oclass)\r\n    {\r\n        oclass.MyProperty1 = 100;\r\n    }\n\r\nAbove code gives TextBox.Text as 100.\r\nThese values are changed in a function which gets class1 object as parameter but not by reference. But still change in value in method is reflected in calling method.\r\nThis doesn't happen with int or Int32.\n\r\nCan anybody please explain me the reason ?\r\nThanks in advance.\n\r\n[edit]Code block added to preserve formatting - OriginalGriff[/edit]\r\n\t\t    ", "id": "101574", "title": "In C# objects are passed by value or by reference ? Confused !!!", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C#", "ASP", ".NET"]}, {"answers": [{"content": "\r\n    The CLR automatically zeros the memory it allocates for variables. This will set all types to their default value - 0 for numbers, false for booleans, null for reference types, etc. \n\r\nFor classes and structs, this will set all fields to their default values.\n\r\nThe C# compiler will generate a CS0165 error if you try to read a local variable without setting it to a value first. But that's only because this is usually an indication of an error with your code. The variable will technically have been initialized to its default value by the CLR.\n\r\nThe compiler will not generate a similar error for an uninitialized field - especially since structs have no good way to initialize their fields to anything other than the default. They can't have parameterless constructors, and they can't have field initializers. IIRC, this is to speed up allocation of arrays of structs - the CLR can just zero out the whole memory, rather than having to run code on each item in the array.\r\n", "id": "2_5305008_1", "owner_tier": 0.7, "score": 5.0}, {"content": "\r\n    I don`t exactly understand your question ... but basicly you as the developer are responsible for initializing a variable - that could be done when you declare it :C#\n\r\nprivate string str1 = \"default-Value\";\r\nprivate int num1 = 123;\n", "id": "2_5304989_1", "owner_tier": 0.3, "score": 0}], "link": "https://www.codeproject.com/Questions/5304983/What-is-responsible-for-initializing-fields-of-a-c", "question": {"content": "\r\n\t\t\t    In C#, instance fields in a struct type (can't be initialized at declaration) are either always initialized by the the default parameter-less constructor with the respective default value or by any parameterized constructor explicitly defined by the programmer.\n\n\n\r\npublic struct MyStruct\r\n{\r\n    private string str1;\r\n\r\n    private int num1;\r\n\r\n    //parametized constructors in a struct always obligated to initialize instance fields\r\n    public MyStruct(string strParameter, int numParameter)\r\n    {\r\n        str1 = stringParameter;\r\n\r\n        num1 = numParameter;\r\n    }\r\n}\r\n\n\r\nWith instance fields in a class type however, fields are either intialized with a default value by the parameter-less constructor, but parameterized constructor are not obligated to initalize the fields as with struct types:\n\n\n\r\npublic class MyClass\r\n{\r\n    private string str1;\r\n\r\n    private int num1;\r\n\r\n    //parametized constructors in a class not obligated to initialize instance fields\r\n    public MyClass(string strParameter, int numParameter)\r\n    {\r\n        //nothing in the body\r\n    }\r\n}\r\n\n\r\nIf a paramterized constructor of a class is not obligated to initialize the instance fields, then what initializes them with their default value, when the parameterized constructor is called?\n\nWhat I have tried:\n\r\nWas unable to resolve this problem after investegation.\r\n\t\t    ", "id": "5304983", "title": "What is responsible for initializing fields of a class, if they were not initialized at its declaration nor by any parameterized constructor?", "traffic_rate": 0}, "saved_time": 1721101398, "source": "codeproject", "tags": ["C#", "constructor"]}, {"answers": [{"content": "I developed a Python package (https://github.com/LLyaudet/python-none-objects, https://pypi.org/project/python-none-objects/).\nIt supplies the following \"None\" objects to have simpler code:", "id": 78399549, "owner_tier": 0.3, "score": -5.46448087431694e-11}, {"content": "PyCharm warns that the default argument is mutable, which may seem obtuse, but what it means is that objects you create using the default are all sharing the same reference to that one default argument. Here's a bit of code that demonstrates the problem: If I then go on to create a few instances of the foo class without supplying a new list of stuff for each, then each instance will share a reference to that same default list! You can see I've added items to the stuff list for a but when I print the two instances the second time, b also has two items in it's stuff as well, ... in fact it's the same two items! The best way to get around this, but still supply defaults is to change your code just a bit and supply None as the default, then use or to coalesce that with a new list inside the constructor: Now if we repeat the construction of a and b and add stuff to a exactly as before, we get a different result: This is because the instance a and the instance b no longer share a reference to the same (default) list, but use new lists constructed when the instance was initialized.  While python hides most of the ugliness of pointers and references they are still there under-the-hood and sometimes we still need to be aware of them.  Incidentally, if you supply values (primitive types) as defaults, they don't have this issue because the value itself is placed in the instance, not a reference (e.g. stuff=1 rather than stuff=[]).", "id": 76484610, "owner_tier": 0.5, "score": 0.005464480819672131}, {"content": "This is a warning from the interpreter that because your default argument is mutable, you might end up changing the default if you modify it in-place, which could lead to unexpected results in some cases. The default argument is really just a reference to the object you indicate, so much like when you alias a list to two different identifiers, e.g., if the object is changed through any reference, whether during that call to the function, a separate call, or even outside the function, it will affect future calls the function. If you're not expecting the behavior of the function to change at runtime, this could be a cause for bugs. Every time the function is called, it's the same name being bound to the same object. (in fact, I'm not sure if it even goes through the whole name binding process each time? I think it just gets another reference.) You can see the effect of this by declaring the following and calling it a few times: Wait, what? yes, because the object referenced by the argument doesn't change between calls, changing one of its elements changes the default. If you use an immutable type, you don't have to worry about this because it shouldn't be possible, under standard circumstances, to change an immutable's data. I don't know if this holds for user-defined classes, but that is why this is usually just addressed with \"None\" (that, and you only need it as a placeholder, nothing more. Why spend the extra RAM on something more complicated?) In your case, you were saved by an implicit copy, as another answer pointed out, but it's never a good idea to rely on implicit behavior, especially unexpected implicit behavior, since it could change. That's why we say \"explicit is better than implicit\". Besides which, implicit behavior tends to hide what's going on, which could lead you or another programmer to removing the duct tape. You can avoid this bug magnet completely and satisfy the warning by, as others have suggested, using an immutable type such as None, checking for it at the start of the function, and if found, immediately replacing it before your function gets going: Since immutable types force you to replace them (Technically, you are binding a new object to the same name. In the above, the reference to None is overwritten when attachment is rebound to the new empty dictionary) instead of updating them, you know attachment will always start as None unless specified in the call parameters, thus avoiding the risk of unexpected changes to the default. (As an aside, when in doubt whether an object is the same as another object, compare them with is or check id(object). The former can check whether two references refer to the same object, and the latter can be useful for debugging by printing a unique identifier\u2014typically the memory location\u2014for the object.)", "id": 63329315, "owner_tier": 0.3, "score": 0.07650273218579234}, {"content": "If you don't alter the \"mutable default argument\" or pass it anywhere where it could be altered just ignore the message, because there is nothing to be \"fixed\". In your case you only unpack (which does an implicit copy) the \"mutable default argument\" - so you're safe. If you want to \"remove that warning message\" you could use None as default and set it to {} when it's None: Just to explain the \"what it means\": Some types in Python are immutable (int, str, ...) others are mutable (like dict, set, list, ...). If you want to change immutable objects another object is created - but if you change mutable objects the object remains the same but it's contents are changed. The tricky part is that class variables and default arguments are created when the function is loaded (and only once), that means that any changes to a \"mutable default argument\" or \"mutable class variable\" are permanent: PyCharm probably shows this Warning because it's easy to get it wrong by accident (see for example Why do mutable default arguments remember mutations between function calls? and all linked questions). However, if you did it on purpose (Good uses for mutable function argument default values?) the Warning could be annoying.", "id": 41686973, "owner_tier": 0.9, "score": 0.9999999999453552}, {"content": "To rephrase the warning: every call to this function, if it uses the default, will use the same object.  So long as you never change that object, the fact that it is mutable won't matter.  But if you do change it, then subsequent calls will start with the modified value, which is probably not what you want. One solution to avoid this issue would be to have the default be a immutable type like None, and set the parameter to {} if that default is used:", "id": 41686974, "owner_tier": 0.9, "score": 0.01639344256830601}, {"content": "Lists are mutable and as declaring default with def at declaration at compile time will assign a mutable list to the variable at some address \u00a0 To correct this:  \u00a0", "id": 59855340, "owner_tier": 0.3, "score": -5.46448087431694e-11}, {"content": "You can replace mutable default arguments with None. Then check inside the function and assign the default: This works because None evaluates to False so we then assign an empty dictionary. In general you may want to explicitly check for None as other values could also evaluate to False, e.g. 0, '', set(), [], etc, are all False-y. If your default isn't 0 and is 5 for example, then you wouldn't want to stomp on 0 being passed as a valid parameter:", "id": 41686977, "owner_tier": 0.7, "score": 0.08743169393442622}], "link": "https://stackoverflow.com/questions/41686829/why-does-pycharm-warn-about-mutable-default-arguments-how-can-i-work-around-the", "question": {"content": "I am using PyCharm (Python 3) to write a Python function which accepts a dictionary as an argument with attachment={}. In the IDE, attachment={} is colored yellow. Moving the mouse over it shows a warning. Default arguments value is mutable This inspection detects when a mutable value as list or dictionary is\ndetected in a default value for an argument. Default argument values are evaluated only once at function definition\ntime, which means that modifying the default value of the argument\nwill affect all subsequent calls of the function. What does this mean and how can I resolve it?", "id": 41686829, "title": "Why does PyCharm warn about mutable default arguments? How can I work around them?", "traffic_rate": 30}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "pycharm", "warnings"]}, {"answers": [{"content": "Why does c1 behave like a class variable? Because you specified default value for them and they're now a class attribute. In the Mutable Default Values section, it's mentioned: Python stores default member variable values in class attributes. But look at this: c1 doesn't have default value so it's not in class's namespace. Indeed by doing so(defining default value), Python stores that c1 and c2 inside both instance's namespace (n1.__dict__) and class's namespace (Y.__dict__). Those are the same objects, only the reference is passed: So now, If you want them to be different you have several options: In the second option, because I didn't specify default parameter(you can't mix both), nothing is going to be stored in the class's namespace. field(default=SOMETHING) is another way of saying = SOMETHING.", "id": 73599520, "owner_tier": 0.5, "score": 0.9999999975}], "link": "https://stackoverflow.com/questions/73598938/why-is-dataclass-field-shared-across-instances", "question": {"content": "First time using dataclass, also not really good at Python. The following behaviour conflicts with my understanding so far: This prints Why does c1 behave like a class variable? What can I do to keep n2.c1 != n1.c1, do I need to write an init function? I can get sensible results with this addition to Y: prints:", "id": 73598938, "title": "Why is dataclass field shared across instances", "traffic_rate": 1243}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "python-dataclasses"]}, {"answers": [], "link": "https://stackoverflow.com/questions/6838255/python-class-function-default-variables-are-class-objects", "question": {"content": "I was writing some code this afternoon, and stumbled across a bug in my code. I noticed that the default values for one of my newly created objects was carrying over from another object! For example: So I know it can be solved by doing this: What I would like to know is... Why? Why are Python classes structured so that the default values are saved across instances of the class?", "id": 6838255, "title": "Python class function default variables are class objects?", "traffic_rate": 1}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python"]}, {"answers": [{"content": "The class defined in your lecture is dumb (not very dumb, just pointless and misleading, as you've clearly been misled by it). There is zero reason to define class attributes that happen to share the same value as the default arguments to the initializer. The only thing doing that accomplishes is: In all other ways, there is no relationship between the class level attributes and the defaults defined for the __init__ initializer method; the moment __init__ assigns to self.slices and self.temperature, it shadows the class level attributes so they cannot be directly accessed from that instance of the class (without deleting the instance attributes or bypassing the instance to look at the values on the class itself). So no, you can't do: because the arguments named slices and temperature have nothing to do with the class attributes. By removing their defaults, the user of your class is forced to provide their own values, and there is no default that will be provided (they could, I suppose, do Pizza(Pizza.slices, Pizza.temperature), but that's an insane way to handle defaults). To your updated question, even without the class variables, works just fine. Outside of any methods of the class, slices and temperature won't exist, but any other methods you define on Pizza will be able to access that instance's slice and temperature attributes by looking them up on self, just like __init__ did when it assigned to them (with self.slices or self.temperature), and anyone who creates an instance of Pizza, say, with mypizza = Pizza(12, 140), can do mypizza.slices to see the attribute for the instance they hold. A note on the class attributes: In normal cases, they're stupid and nonsensical. There is an exception for dataclasses though, where you define them at class level for the express purpose of helping the dataclasses module dynamically generate your code, removing the need to write a __init__ with separate defaults entirely. For example: is a perfectly reasonable way to write the baseline class, and it uses those annotations and defaulted assignments to generate as __init__ for you (along with reasonable default implementations of __repr__ and __eq__, and other special methods if you pass specific arguments to the @dataclass decorator, saving you a ton of boilerplate required for minimal expected class functionality). It does leave the class attributes in place, which is arguably a bad idea, but at least you're getting something useful out of the deal, it's not just repeating the same defaults in two essentially unrelated places, one of which is completely useless.", "id": 71947785, "owner_tier": 0.9, "score": 0.0}, {"content": "If you use: Then slices and temperature are parameters that must be specified. What you can do is create a variable, and then use that as the default for the function parameter. Just keep in mind that if you redefine that variable, it does not affect the default value for the function.", "id": 71934595, "owner_tier": 0.9, "score": 0.0}], "link": "https://stackoverflow.com/questions/71934568/python-are-these-default-values-being-passed-to-the-init-function-necessary", "question": {"content": "Here is a screenshot from a lecture that I am going through at school:  My question is, if the class data fields are already being defined: Do those values (16 and 75.0) also need to be passed to the __init__ method or can you just pass the variables names, because they are already assigned to those values? Not sure why/if you would need to pass the default values when they are the exact same as what the variables are already set to? so instead of: Could you just do: Updated new question\nIf you removed the initial class-level variables at the top, and are only defining them in the constructor class, are they only scoped to the constructor class? Or are they available throughout the entire class, even though you didn't define them at the very top (class-level)?? Example: Or, because you are defining them as \"self.slices\", they are by default passed to all of the other methods when you pass (self) into the other methods?", "id": 71934568, "title": "Python: Are these default values being passed to the __init__ function necessary?", "traffic_rate": 353}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "python-3.x"]}, {"answers": [{"content": "With dataclasses, a feature added in Python 3.7, there is now yet another (quite convenient) way to achieve setting default values on class instances. The decorator dataclass will automatically generate a few methods on your class, such as the constructor. As the documentation linked above notes, \"[t]he member variables to use in these generated methods are defined using PEP 526 type annotations\". Considering OP's example, we could implement it like this: When constructing an object of this class's type we could optionally overwrite the value.", "id": 62758003, "owner_tier": 0.3, "score": 0.010989010934065934}, {"content": "The two snippets do different things, so it's not a matter of taste but a matter of what's the right behaviour in your context. Python documentation explains the difference, but here are some examples: This binds num to the Foo instances. Change to this field is not propagated to other instances. Thus: This binds num to the Bar class. Changes are propagated! If I do not require a class variable, but only need to set a default value for my instance variables, are both methods equally good? Or one of them more 'pythonic' than the other? The code in exhibit B is plain wrong for this: why would you want to bind a class attribute (default value on instance creation) to the single instance? The code in exhibit A is okay. If you want to give defaults for instance variables in your constructor I would however do this: ...or even: ...or even: (preferrable, but if and only if you are dealing with immutable types!) This way you can do:", "id": 2681286, "owner_tier": 0.5, "score": 0.3956043955494506}, {"content": "Extending bp's answer, I wanted to show you what he meant by immutable types. First, this is okay: However, this only works for immutable (unchangable) types. If the default value was mutable (meaning it can be replaced), this would happen instead: Note that both a and b have a shared attribute. This is often unwanted. This is the Pythonic way of defining default values for instance variables, when the type is mutable: The reason my first snippet of code works is because, with immutable types, Python creates a new instance of it whenever you want one. If you needed to add 1 to 1, Python makes a new 2 for you, because the old 1 cannot be changed. The reason is mostly for hashing, I believe.", "id": 2681507, "owner_tier": 0.5, "score": 0.999999999945055}, {"content": "You can also declare class variables as None which will prevent propagation. This is useful when you need a well defined class and want to prevent AttributeErrors.\nFor example: Also if you need defaults: Of course still follow the info in the other answers about using mutable vs immutable types as the default in __init__.", "id": 30515149, "owner_tier": 0.5, "score": -5.494505461112797e-11}, {"content": "Using class members to give default values works very well just so long as you are careful only to do it with immutable values. If you try to do it with a list or a dict that would be pretty deadly. It also works where the instance attribute is a reference to a class just so long as the default value is None. I've seen this technique used very successfully in repoze which is a framework that runs on top of Zope. The advantage here is not just that when your class is persisted to the database only the non-default attributes need to be saved, but also when you need to add a new field into the schema all the existing objects see the new field with its default value without any need to actually change the stored data. I find it also works well in more general coding, but it's a style thing. Use whatever you are happiest with.", "id": 2681363, "owner_tier": 0.9, "score": 0.027472527417582417}, {"content": "Using class members for default values of instance variables is not a good idea, and it's the first time I've seen this idea mentioned at all. It works in your example, but it may fail in a lot of cases. E.g., if the value is mutable, mutating it on an unmodified instance will alter the default:", "id": 2681303, "owner_tier": 0.9, "score": -5.494505461112797e-11}], "link": "https://stackoverflow.com/questions/2681243/how-should-i-declare-default-values-for-instance-variables-in-python", "question": {"content": "Should I give my class members default values like this: or like this? In this question I discovered that in both cases, is a well-defined operation. I understand that the first method will give me a class variable while the second one will not. However, if I do not require a class variable, but only need to set a default value for my instance variables, are both methods equally good? Or one of them more 'pythonic' than the other? One thing I've noticed is that in the Django tutorial, they use the second method to declare Models. Personally I think the second method is more elegant, but I'd like to know what the 'standard' way is.", "id": 2681243, "title": "How should I declare default values for instance variables in Python?", "traffic_rate": 61}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "class", "oop"]}, {"answers": [{"content": "According to what's given here A Python variable is a symbolic name that is a reference or pointer to an object. Once an object is assigned to a variable, you can refer to the object by that name. But the data itself is still contained within the object. Here, A's reference is passed to B. So they point to the same data, but are just called by different names. So whatever operation you perform on B, you also perform on A. Hence, later when you assign A to C, the same data is referenced by C. If you don't want that to happen, use deepcopy:", "id": 61756644, "owner_tier": 0.1, "score": 0.0}], "link": "https://stackoverflow.com/questions/61756422/creating-new-object-keeps-data-even-with-default-value", "question": {"content": "I am struggling to understand why instance C keeps data of instance B, even though I initialized the instance variable var with the default empty list. Why is the default argument \"var = []\" ignored?. The print retuns Even stranger is this: prints How can the statement self.var = var append to the  list from the front?", "id": 61756422, "title": "Creating new object keeps data even with default value", "traffic_rate": 318}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python-3.x", "default-value", "instance-variables", "class-variables"]}, {"answers": [{"content": "Python passes parameters to functions by value; So for objects, the value passed is a reference to the object, not a new copy of the object. That, along with the following part of the official docs is what helped me understand it better (emphasis mine): Default parameter values are evaluated [...] when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. [...] A way around this is to use None as the default, and explicitly test for it in the body of the function [...] Putting it all together: If you define the default for a parameter to be a mutable object (such as []) then the \"pre-computed\" value is the reference to that object, so each call to the function will always reference the same object, which can then be mutated across multiple invocations of the function. However, since None is an immutable built-in type, the \"pre-computed\" value for a default of None is simply that. So the parameter will be None each time you call the function. Hopefully that helps! I do think that the tutorial could have had better wording, because I was also confused by that at first.", "id": 33573262, "owner_tier": 0.5, "score": 0.9999999997674418}, {"content": "I think this is happening because a list is a mutable object while the value None is immutable. For the first function, variable L is outside the function environment (in the function definition), and it refers to an empty list. Then you make changes to this list in the function environment, but since a list is mutable, the variable L that is outside the function environment refers to this now mutated list, and the change propagates each time you call the function. For the second function, variable L is also outside the function environment (in the function definition), but this time it refers to None, which is immutable. Now, every change you make in the function environment will not affect what L refers to outside the function environment. The variable L inside the function environment refers to something different as you change it. First, it refers to an empty list, and then a list that gets a value appended to it. You then return this list. The next time you call the function, you call it with the variable L that is outside the function environment, which has not changed and still refers to None. Hope this makes sense.", "id": 24053766, "owner_tier": 0.1, "score": -2.3255813812151838e-10}, {"content": "What happens is as follows: When a python function is called, it is evaluated in the environment in which it was defined and not the environment in which it was called although the second part is secondary ( no pun intended) for the purpose of answering your question. The default arguments are evaluated only once at the time of function definition. This creates a closure. Think of closure as function code + environment in which the function was been defined.  So in this case when the function was defined, L was assigned to [] and now every subsequent call to the function will use this value of L.  The tutorial also mentions: The default values are evaluated at the point of function definition in the defining scope (and the defining scope is part of the closure along with function code) http://docs.python.org/2/tutorial/controlflow.html#default-argument-values", "id": 20862647, "owner_tier": 0.7, "score": -2.3255813812151838e-10}], "link": "https://stackoverflow.com/questions/13087344/python-function-default-parameter-is-evaluated-only-once", "question": {"content": "I am a python beginner, reading 'python tutorial', it says if we have a function: This will print Because the default value is evaluated only once and list is a mutable object. I can understand it. And it says continue, if we don't want the default to be shared between subsquent calls, we can: and this will output: But why? How to explain this. We know default value is evaluated only once, and when we call f(2), L is not None and that if(in line 2) can not be true, so L.append(a) == [1, 2]. Could I guess the default value is evaluated again for some reason , but what is 'some reason', just because the python interpreter see if L is None: L = []", "id": 13087344, "title": "python function default parameter is evaluated only once?", "traffic_rate": 10}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "function", "parameters"]}, {"answers": [{"content": "This is a known Python gotcha. You have to avoid using a mutable object on the call of a function/method. The objects that provide the default values are not created at the time that the function/method is called. They are created at the time that the statement that defines the function is executed. (See the discussion at Default arguments in Python: two easy blunders: \"Expressions in default arguments are calculated when the function is defined, not when it\u2019s called.\") This behavior is not a wart in the Python language. It really is a feature, not a bug. There are times when you really do want to use mutable default arguments. One thing they can do (for example) is retain a list of results from previous invocations, something that might be very handy. But for most programmers \u2014 especially beginning Pythonistas \u2014 this behavior is a gotcha. So for most cases we adopt the following rules. So... we plan always to follow rule #1. Now, the question is how to do it... how to code functionF in order to get the behavior that we want. Fortunately, the solution is straightforward. The mutable objects used as defaults are replaced by None, and then the arguments are tested for None. So how can one do it correctly? One solution is avoid using mutable default values for arguments. But this is hardly satisfactory, as from time to time a new list is a useful default. There are some complex solutions like defining a decorator for functions that deep-copies all arguments. This is an overkill, and the problem can be solved easily as follows:", "id": 1534515, "owner_tier": 0.9, "score": -1.111111111111111e-09}, {"content": "Please read this answer for a discussion of how to setup a class from __init__().  You have encountered a well-known quirk of Python: you are trying to set up a mutable, and your mutable is being evaluated once when __init__() is compiled.  The standard workaround is:", "id": 1534461, "owner_tier": 0.9, "score": 0.22222222111111112}, {"content": "From http://docs.python.org/3.1/tutorial/controlflow.html: The default value is evaluated only\n  once. This makes a difference when the\n  default is a mutable object such as a\n  list, dictionary, or instances of most\n  classes.", "id": 1534448, "owner_tier": 0.5, "score": 0.11111111}, {"content": "Your problem is that the default value is evaluated at function definition time. This means that the same list object is shared between instances. See the answer to this question for more discussion.", "id": 1534444, "owner_tier": 0.9, "score": 0.6666666655555555}, {"content": "You should change to and all will be better. This is a detail in the way default arguments are handled if they're mutable. There's some more information in the discussion section of this page.", "id": 1534443, "owner_tier": 0.9, "score": 0.9999999988888888}], "link": "https://stackoverflow.com/questions/1534407/python-object-initialization-bug-or-am-i-misunderstanding-how-objects-work", "question": {"content": "This will print the reference to the object assigned to one._resources for both one and two objects. I would think that two would be an empty array as it is clearly setting it as such if it's not defined when creating the object. Uncommenting myobj.__init__(self, resources) does the same thing.  Using super(ext, self).__init__(resources) also does the same thing. The only way I can get it to work is if I use the following: I shouldn't have to manually set the default value when creating the object to make this work. Or maybe I do. Any thoughts? I tried this using Python 2.5 and 2.6.", "id": 1534407, "title": "Python object initialization bug. Or am I misunderstanding how objects work?", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "mutable", "arguments"]}, {"answers": [{"content": "Taken from the the documentation: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. [...] If you don\u2019t want the default to be shared between subsequent calls, you can write the function like this instead:", "id": 24981298, "owner_tier": 0.5, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/24981239/why-is-a-default-value-set-for-a-python-3-function-overwritten-when-the-function", "question": {"content": "Can someone explain me why, when I call this function multiple times, L is never set to empty by default? But instead the result of any following call is L appended to all results of preceding calls? The function separates the data into blocks of 7 days, starting with the last date ([::-1]),\ncalculates the mean of each 7 days and appends the result as a value to\na list. Ignores incomplete blocks The default value for data is a list of dates in ordinal format.", "id": 24981239, "title": "Why is a default value set for a Python 3 function overwritten when the function gets called multiple times?", "traffic_rate": 900}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "list", "append", "default"]}, {"answers": [{"content": "You fell into a common newbie trap for Python.  Using a list as a default variable as you did with def __init__(self, list = [0,0,0,0,0,0,0,0,0,0]) means that all instances of that class share the same list instance as the value for that argument.  See also \"Least Astonishment\" and the Mutable Default Argument By the way, a common idiom if you want to use a container object such as a list as a default argument, is to instead use None and check for that.  For example: Or whatever.  Not quite as clearly self-documenting as default arguments but it works. As a side note, don't use list as a variable name, as it shadows the (somewhat commonly used) list builtin.", "id": 13389510, "owner_tier": 0.7, "score": 0.9999999985714286}], "link": "https://stackoverflow.com/questions/13389325/why-do-two-class-instances-appear-to-be-sharing-the-same-data", "question": {"content": "I was doing some work in Python when I ran into an unexpected problem.  I have a class, and two variables x and y.  x and y are meant to be separate copies of the class each with their own data.  So I set x equal to the class and give it some values, then do the same with y.  Once I try to use that data though, I realize that I overwrote my values for x.  It seems that I have not created two separate copies of the class to work with but instead two references to the same class.  So here is the general example in code: The end result is that 3 is printed instead of 2.  I want to create a separate \"version\" of the class to hold different data for each variable.  Not sure as to how though.  Using Python 3.3.  Here is the code for the class:", "id": 13389325, "title": "Why do two class instances appear to be sharing the same data?", "traffic_rate": 1195}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "stackoverflow", "tags": ["python", "class"]}, {"answers": [{"content": "This is such a common question that it's in the official Python language FAQ: https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects\n\nTL;DR: when a function argument has a default value, the default value is a *property of the function itself* and therefore every time you call the function, you're getting a reference to the same object. (You're technically correct that in your function, `y` is a local variable. But in Python, variables *point to* objects, and the object that `y` points to is shared.)\n\nAlso [here](https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument).\n\nThank you so much.", "id": "jdnsv60", "owner_tier": 0.7, "score": 0.9999999989999999}, {"content": "Dont use list (unless you do this on purpose) as default value to function parameter, Python will use the same list instance for every function call.", "id": "jdnt216", "owner_tier": 0.5, "score": -9.99999993922529e-10}, {"content": "python evaluates default param values once, when the function is defined, and reuses them on subsequent calls. mutable values, like lists and divts, will be changing unless you make a copy inside the function, and operate on that", "id": "jdnt97l", "owner_tier": 0.5, "score": -9.99999993922529e-10}], "link": "https://www.reddit.com/r/learnprogramming/comments/121xc5q/python_weird_behavior_for_functions_default_values/", "question": {"content": "I was trying to implement the Fibonacci series recursively using python when I came across this weird behavior that I don't understand.\n\nI will not use the Fibonacci function as my example , I will use simpler example.\n\nconsider this function\n\n    def test(y=[0]):\n      for i in range(10): \n         y.append(0)\n       return y\n\n&#x200B;\n\nthis function has a default value for y which is an array that has only one item 0\n\nif I print out this function twice I expected to get the exact same result\n\n    print(test())\n    print(test())\n\nsince I am running the same function twice, in both cases I did't include a value for y. So I was expecting the output to be array with eleven zeros in both cases but this is what I get instead\n\n    [0,0,0,0,0,0,0,0,0,0,0]\n    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\nas if arr was a global variable and all the zeros from the first function were already appended to it before running the function for the next time.\n\nBut this is not the case, arr is local to the function. so can someone explain to me this weird behavior or tell me what to search for because I don't even have a clue for what to search for.", "id": "121xc5q", "title": "Python Weird behavior for functions default values", "traffic_rate": 759.40625}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "It's not that mutable arguments are reset with each call, it's that changing them at any point reassigns the variable to a *new instance*.\n\nE.g. in your second example, a is 5 by default. When you add 3 to it, it doesn't change the 5 in memory to 8, it creates a new spot in memory to hold that 8 and points the variable to that. (That's probably a bit of a simplification, but it gives you the idea).\n\nWith mutable arguments, rather than creating a new spot in memory, you might modify the original. Note that if you have the discipline to never modify that in place, it will never be a problem, but it's bad practice because it forces you to be more careful.\n\nI think I get what you are saying but it still doesnt add up for me\r  \n\r  \nI accept that the point in memory does not change, but haven't you still updated the variable by pointing it at the new spot in memory\r  \n\r  \nso heres the steps I'm imagining\r  \n\r  \n1. function is loaded\r  \n2. a is created\r  \n3. a is pointed at 5 in memory\r  \n4. function is run\r  \n5. a is pointed at 8 in memory\r  \n6. function is run\r  \n7. a is now pointed at 11 in memory  \n\n\nbut this isnt the case so I'm guessing that there must be 2 `a` variables in different scopes or something\n\n> but this isnt the case so I'm guessing that there must be 2 `a` variables in different scopes or something\n\nEssentially yes. Consider this differently though. The default argument is always initialized with the same *object*.\n\nWhen Python encounters \n\n    def func(a=[]):\n        a.append(3)\n        return a\n\nWhat happens? Like, you're defining something, `func`, but what does python actually do here? It compiles it to byte code. It creates the default argument object(`[]`). Now, whenever you enter the function, and use the default argument, it is pointing to that same object. Because a list is mutable, that object can change. So, if the function (or elsewhere) modifies the list, future calls will see that same object in the modified state. All calls look at the same object, so naturally, if that object gets modified, all calls see those modifications.\n\nWhat if it's immutable? Well, all calls look at the same object. What happens with the below lines of code?\n\n    a = 3\n    a += 1\n\n`a` gets assigned the object of `3`. Then, since `3` is immutable, 3 doesn't get touched. 3 is never modified. 3 existed before time, and will exist when the end of all things comes to pass. When everything you know and love has faded into dust and is long forgotten, `3` will remain. Unchanging. Unflinching. Uncaring. Prime. `a` gets assigned to a completely different object, `4`. `3` still exists. And `3` does not forget, and it does not forgive.\n\nLook at the below code:\n\n    a = 1\n    b = a\n    b += 1\n\n    print(f\"a: {a}\")\n\n    c = [1]\n    d = c\n    d += [1]\n\n    print(f\"c: {c}\")\n\n\nOutput:\n\n    a: 1\n    c: [1, 1]\n\nWith the non-mutable example, b can't mutate `1`, so it gets a new object. Anything that was pointing to the old object, still is, which hasn't changed. With the mutable example, `d` can mutate, so it does, and all references see that mutation.\n\n> I'm guessing that there must be 2 a variables in different scopes or something\n\nYes, exactly! That seems to be the missing link. `a` is a thing for you and me; what Python sees is a location in memory. Each call to the function uses the same location in memory for the default argument (in the same way that it uses the same location in memory for the function's instructions, rather than re-creating the function every time), but it uses a different chunk of memory for each call.\n\nA function is a set of instructions, really no different from a very long list of values, just like variable values. We generally don't want to make a new copy of those instructions each time, given that the *instructions* will never change. Default arguments are part of the function's definition, and thus are not re-created with each function call.\n\nBut each function call has to create a new instance of the function's local variables, including parameters (some languages provide a way around this).\n\nSo, in your example, `func` is created once - including its instructions and the `[]` default parameter - but local variables - meaning `a` - are created with each call. So the steps really look more like this:\n\n1. function is created\n   * instructions are created\n   * default parameters (`5`) are created\n1. function is called\n   1. `a` is created\n   1. `a` is pointed at the default parameter - `5` - in memory\n   1. `a` is changed to `8`\n      * The default parameter is not touched\n1. function is called\n   1. `a` is created\n   1. `a` is pointed at the default parameter - `5` - in memory\n   1. `a` is changed to `8`\n      * The default parameter is not touched\n1. Rinse & repeat\n\nPython *could* create a new instance of the default variables each time, but it was designed to not do that. Python also could create a new instance of each function each time it's called, but it was designed to not do that. These are arbitrary (but very common) language design choices.\n\nIt makes way more sense to think about it that way.  That the default behaviour is to try to mutate the object in memory and only if that is impossible, then the name is assigned to a new object instead\n\nAlso I love your writing style\n\nIts all coming together now, I think I get it\n\nfunc is an instance of the function class, that has a `default arguments` attribute, which points to an object in memory\n\nWhen func is invoked, it creates a local variable that also points to that object in memory.\n\nWhen you try to update an object, python will try to mutate it in memory, and if it cant it will create/point to a new object instead, which explains the behaviour in the examples\n\nI had a look at the func object and you can even mess with the defaults arguments manually\n\n    def func(a=5):\n    return a\n    \n    func.__defaults__ = (10,)\n    func()\n    >10", "id": "ik7593i", "owner_tier": 0.7, "score": 0.9999999993333333}, {"content": "Because there is a big difference between reassigning a variable using `=` and calling a mutative method like `append` on the object.\n\n`=` changes what object the variable is pointing to. It doesn't modify the object in any way, so no one else looking at that object will notice anything. This would be like multiple people pointing at an object. A new person pointing at the object has no affect on the object itself. `a += 1` makes `a` point to the object that resulted from `a + 1`, but this didn't change the old object that other code may be referring to.\n\n`append` actually modifies the object though. This would be like if multiple people were pointing at an object, and then someone came and destroyed the object. They would all see the change because they were all looking at the same object that was mutated. If multiple pieces of code are looking at the same object, you must be careful what you do to that object\n\n***\n\nAnd this isn't really about mutable vs immutable objects (other than that `+=` is mutative on lists). What really matters is what you're doing to the object. In theory, it's fine to have a mutable default argument *as long as you never mutate it or leak a reference to it* (like by returning it). If you have a list as a default argument and all you did was iterate it with a `for` loop, it's fine (at the moment). This is a potential source of a bug in the future though, so it's usually best to avoid mutable defaults altogether.\n\nThanks, I think I understand it now.  \n\n\n>\\+= is mutative on lists\n\nThats really surprising as it means a += b is not equivalent to a = a + b for mutable objects.  \n\n\nI just tested it  \n\n\n`def func(a=[]):`  \n`a = a + [3]`  \n`return a`\n\n`func()`  \n`> [3]`  \n`func()`  \n`> [3]`  \n\n\n`def func(a=[]):`  \n`a += [3]`  \n`return a`\n\n`func()`  \n`> [3]`  \n`func()`  \n`> [3, 3]`  \n\n\nthats super counterintuitive if you didnt know that,  feels like it would be a really annoying interview question\n\nYes, it's essentially just `.extend`. They use the same code behind the scenes. And ya, I agree, it can be confusing.\n\nIn all cases x = x + y is a generic combo of unoptimized calculation of a new value x+y, and then reassigning x. That's two separate steps that can't be optimized in any way.   \nBut in case of += and mutables it's possible to have a more optimized version that performs the action in place, without let's say duplicating a potentially huge object. It's worthwhile to have it as an option, because sometimes the generic, naive way is very expensive compared to the lightning fast in place op.\n\nLong story short if the mutable type might support in-place operations with optimization potential, expect augmented assignments like += to be exactly that, unless proven otherwise.", "id": "ik76h76", "owner_tier": 0.9, "score": 0.466666666}, {"content": "> I've read this is caused by python initializing those variables once when the code is loaded instead of every call to the function\n\n> If that's true, why is that only a problem for mutable variables? Why do other variables get reset for every call?\n\nBecause you can't do anything to change the value of an immutable variable, so there are no side effects to using the same variable across multiple calls.\n\nThe \"problem\" with mutable defaults isn't really a Python problem--it's a conceptual one in the programmer's mind. Python treats all defaults exactly the same way, but programmers tend to \"think\" about them incorrectly.\n\n    a = []\n    a.append(b)\n\nisn't changing the value of `a`, it's changing the object that `a` refers to--`a` stays \"constant\". However, most new programmers consider this type of \"change\" equivalent to:\n\n    a = 5\n    a = 6\n\nWhich is not true.", "id": "ik7pq2g", "owner_tier": 0.7, "score": -6.666666626150194e-10}], "link": "https://www.reddit.com/r/learnpython/comments/wntguq/why_are_only_mutable_variables_a_problem_in/", "question": {"content": "As far as I can gather, using a mutable variable as a default argument in a function causes issues because mutating that variable will mutate the default argument for that function for all subsequent calls.\n\n    def func(a=[]):\n        a.append(3)\n        return a\n    \n    func()\n    > [3]\n    func()\n    > [3, 3]\n\nI've read this is caused by python initialising those variables once when the code is loaded instead of every call to the function\n\nIf thats true, why is that only a problem for mutable variables, why do other variables get reset for every call?\n\n    def func(a=5):\n        a += 3\n        return a\n    \n    func()\n    > 8\n    func()\n    > 8", "id": "wntguq", "title": "Why are only mutable variables a problem in default arguments?", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "What happens behind the scenes?\n\nLike does python remember the original list throughout the cycle of the application even though it's only defined as a default?\n\nThis breaks my mind to be honest... [This](https://stackoverflow.com/a/1145781/11010254) person explains it like this:\n\n>Actually, this is not a design flaw, and it is not because of internals or performance.\nIt comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.\n\n>As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \"member data\" and therefore their state may change from one call to the other - exactly as in any other object.\n\n>In any case, Effbot has a very nice explanation of the reasons for this behavior in [Default Parameter Values in Python](https://web.archive.org/web/20200221224620/http://effbot.org/zone/default-values.htm).\nI found it very clear, and I really suggest reading it for a better knowledge of how function objects work.\n\nOkay so I'm sure I've got a little misunderstanding on my end, but it looks like when python compiles the code the first time it defines everything in the def statements. So if you set something to a default value of None it doesn't redefine that value as None every time the code is ran, it just remembers that it's supposed to be None.\n\nRight. The default argument object is created once when the function definition is evaluated, then never again. If that object is mutable, and you mutate it, it stays the same between different calls because it's always the same object.", "id": "hgq5c8r", "owner_tier": 0.9, "score": 0.9999999980000001}, {"content": "*Technically*, it's actually safe to have a mutable default argument, **if** you never mutate or `return` the default object. This for example is perfectly safe:\n\n    def print_out(xs=[]):\n        for x in xs:\n            print(x)\n\nThe only danger here is there's the possibility that in a larger function, you forget that `xs` is potentially the default object, and mutate it when you change the behavior of the function down the road. You may want to avoid using a mutable default to eliminate the chances of accidentally introducing a bug, but simply having a mutable default argument is not necessarily dangerous.", "id": "hgqlirh", "owner_tier": 0.9, "score": -1.999999987845058e-09}], "link": "https://www.reddit.com/r/learnpython/comments/q8m2xn/python_mutable_defaults_are_the_source_of_all_evil/", "question": {"content": "Here is a tip that I learned today that unbroke my code: **Do not use mutable default arguments in Python**, unless you have a REALLY good reason to do so.\n\nhttps://florimond.dev/en/posts/2018/08/python-mutable-defaults-are-the-source-of-all-evil/", "id": "q8m2xn", "title": "Python Mutable Defaults Are The Source of All Evil", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "Don't use class attributes for that, that's not what they are there for.  Use default arguments:\n\n    def __init__(self, name='Undefined', number=-1):\n        self.name = name\n        self.number = number\n\nIf any of the arguments are mutable, then you need to use the usual idiom:\n\n    def __init__(self, foo=None):\n        self.foo = [] if foo is None else foo\n\n\nI'm new to Python classes, so I'm not sure what you mean by the usual idiom if the arguments are mutable. It seems that, in the first example, the arguments are mutable as well?\n\n    me = MyClass(name='Joe', number=11)\n    me.name = 'Jack'\n\nCan you please explain when and why I'd use your second example? Thanks.\n\nYou can just do\n\n    self.foo = foo or [] \n\nYou should read up on mutable types in general because it causes issues throughout your Python code if you're not aware of it. Mutable is a specific term about data types, not about variable names. There, you're changing the name string by reassigning `me.name` to a different string. When you do something like\n    \n    L = [1, 2, 3]\n    L[0] = 5\n\nYou're going to the list and changing it in-place instead of creating an entirely different list [5, 2, 3] and binding it to L.\n\nDefault arguments are evaluated when its function is defined, not when it's called, so the default argument is always going to point to the same thing.\n\n    class MyClass(object):\n        def __init__(self, foo=[]):\n            self.foo = foo\n\n    a = MyClass()\n    b = MyClass()\n    # Both a.foo and b.foo are bound to the same list, foo\n    a.foo.append(2)\n    print(a.foo, b.foo)\n    # You've changed both since they're bound to the same thing\n\nYou need to be wary of this every time you use a mutable argument, such as lists, dictionaries, and custom-made objects.\n\nThe values for the default arguments are evaluated once, at the point where the `def` statement is evaluated, not each time the function is called.  That means that there's only object created for the default value, which is used every time the function is called.  For immutable types like strings and numbers it doesn't matter since the value cannot be modified, but with mutable types if you modify the object the change will be seen to all users, since they are all referring to the same object.  For example, if you wrote a function like:\n\n    def foo(bar=[]):\n        ...\n\nYou don't get a new empty list every time you call this function with no arguments.  It's the same list every time, it just happens to be initialized to the empty list.\n\n\nThat fails if possible valid values for `foo` could be falsey, such as the empty string, empty tuple, empty dict, the number zero, etc.  There's a reason that the idiom uses `is None` and not implicit testing.\n\n\n\nOhh I see. Thank you so much for that explanation, that makes much more sense now!\n\nWe are talking mutable here. If you pass a string or 0 when it wants a list, you're screwed anyway. ", "id": "cu3pibl", "owner_tier": 0.7, "score": 0.9999999989999999}, {"content": "do you need these vars on the class level, given that they are supposed to be relevant on a per instance basis?\n\n    class MyClass:\n        def __init__(self, name='Undefined', number=-1):\n            self.name = name\n            self.number = number\n        def __str__(self):\n            return '{0.__class__.__name__}(name={0.name}, number={0.number})'.format(self)\n\n    print(MyClass())\n    print(MyClass(name='Joe'))\n    print(MyClass(number=11))\n    print(MyClass(name='Joe', number=11))\n\nOk, I'm coming from Java so it looks kind of strange to me to see attributes being assigned that way. Normally I would have to declare the attributes and then write various constructors for assignment if I needed to assign them that way (or use accessors). Thank you for explaining that.\n\npython is dynamic, so there is no need to declare attributes in advance. You can just conjure them in `__init__()` and be done with it. You can think of python objects as souped up, syntactic-sugared dictionaries. Objects of a class don't even have to have the same attributes.\n\n    class Example:\n        def __init__(self, **kwargs):\n            for k, v in kwargs.items():\n                setattr(self, k, v)    \n        def __str__(self):\n            return '{0.__class__.__name__}({0.__dict__})'.format(self)\n\n    ex1 = Example(a=1, b=2)\n    ex2 = Example(c=3, d=4)\n    print ex1, ex1.a, ex1.b\n    print ex2, ex2.c, ex2.d\n\nout\n\n    $ python test.py\n    Example({'a': 1, 'b': 2}) 1 2\n    Example({'c': 3, 'd': 4}) 3 4\n\n\n\nI kinda started checking out java recently. After experiencing python it is so annoyingly verbose because of all that necessary boilerplate >_<\n\n\nPython follows a simpler and more consistent rule than Java in this regard (although there is also complex machinery behind the scenes that you can dig into when necessary).\n\nIn Python, everything is an object. Unlike Java, *\"everything\" includes functions* (and also there are no non-object primitives like Java's `int`, `short` etc.). In Java, inside the `class` body you define \"methods\", which are part of the class, and \"fields\", which are part of each instance of the class. \n\nIn Python, *everything assigned inside the class body is part of the class*. I say \"assigned\" rather than \"defined\" because you do it through assignments; in Python, the `def` statement [is an assignment](http://nedbatchelder.com/text/names.html). You define only \"attributes\", which are all part of the class, and which are all objects, and Python doesn't (yet) care what type they are. Typically, some of these will be functions, and some will be what you might think of as \"ordinary\" values (integers, strings etc.) But they are all handled the same way. Again, everything is an object, and *\"everything\" includes classes*, \n\nYou assign attributes to the instance in the same way - generally speaking, when the attribute doesn't already exist, it's added, and when it does, the value is replaced. It's analogous to assigning a value to a key in a dictionary. Conventionally, we set initial values for an instance's attributes in `__init__`, and normally don't create any new attributes beyond that - we *can*, but it can be confusing and error-prone.\n\n----\n\nThere's more to it than that, of course. There's a system whereby, if Python looks for an attribute on an object and it's not there, Python will also look for it in the corresponding class object, and then in bases of that class. However, *assigning* to an object's attribute will not affect those other objects, which is why it \"seems to work\" to use class attributes as \"defaults\"; when you *replace* the value, you actually create a separate attribute on the instance, while other instances will still indirectly look up the one from the class. But this only gets you in trouble when you *mutate* the value, because other instances will \"see\" the change you made - since they're all \"looking at\" the same underlying object.\n\nThere's also a system whereby, if Python doesn't find the attribute on an object and does find it on the class, *and* it finds a function, Python will instead give you back a method (again, everything is an object, and *\"everything\" includes methods*) - which allows method calls to work. Looking up the method to call is done in a separate step from actually calling it; and you can do things like storing that method in another variable, or using it as a callback.\n\nThere's also a system that lets you hook in to the attribute lookup and assignment processes, which e.g. allows objects to pretend to have additional \"virtual\" attributes that they don't actually store. This is pretty advanced stuff, though. (And in modern Python, you should first check if you can get the job done with properties.)\n\nDid I mention that everything is an object in Python? Just so you know, *\"everything\" includes modules*, too. That's how Python is able to use the same `foo.bar` syntax to mean \"the `bar` class in module `foo`\" or \"the `bar` function stored in class `foo`\" or \"the `bar` method of `foo` class instances\" (not quite the same!) or \"the `bar` attribute of the local variable `foo`\" - because *they all fundamentally mean the same thing*: \"the attribute named `bar` of the object named `foo`\". Or, more colloquially, \"the object that `foo` refers to by the name `bar`\". And while it's possible to insert various bits of magic into the lookup process, there is fundamentally only one process being used in all these cases.\n\nAnd before you ask, yes, there does exist a class that modules are instances of (though there's no name given to it via the built-in global names), and yes, it's an object. There is even a class that *classes* are instances of - which, being a class, is an instance *of itself*. It's called `type`.\n\nIt's difficult to change heads when you move from one language to another. [Python Is Not Java](http://dirtsimple.org/2004/12/python-is-not-java.html) and [Java is not Python, either...](http://dirtsimple.org/2004/12/java-is-not-python-either.html) might help.\n\nAre you trying to tell me that *everything* in Python is an object?\n\nSeriously though, this is an amazing explanation, thank you so much. I understand how it works much better now, although it's kind of jarring (no Java pun intended) to see classes handled this way.\n\n    class MyClass:\n        def __init__(self):\n            self.name = 'Undefined'\n            self.number = -1\n    \n        def add(self, a, b):\n            return a + b\n    \n    if __name__ == '__main__':\n        Bill = MyClass()\n        Bill.name = \"William\"\n        Bill.number = 8675309\n    \n        James = MyClass()\n        James.name = \"James\"\n        James.number = 3.14159\n        James.address = '21 Jump Street'  # James has an address, Bill must be homeless    \n    \n        Joe = MyClass()\n    \n        adder = Bill.add    # mind = blown\n    \n        print('Name:', Bill.name, 'Number:', Bill.number)\n        print('Name:', James.name, 'Number:', James.number, 'Address:', James.address)    \n        print('Name:', Joe.name, 'Number:', Joe.number)\n        print('adder(Bill.number, James.number:', adder(Bill.number, James.number))    \n\nThank you so much, I've bookmarked both articles, will read them very soon!\n\nToo bad, it's a good pun. ;) You should also try things you expect not to work, to understand how they fail, and also play around with the class attribute thing. Also, try the `adder = Bill.add` thing with a method that actually makes use of `self`. Try making a function that accepts a passed-in function and calls it - or does more than that. Try *returning* a function. Then read up on decorators. :)", "id": "cu3p623", "owner_tier": 0.7, "score": 0.5999999989999999}, {"content": "If you put something on the base it's to be able to use it in multiple class's usually meaning putting a mutable object like a list:\n\n    class C:\n        base = []\n        def __init__(self):\n            self.init = []\n\n    c0 = C()\n    c1 = C()\n    c0.base.append(1)\n    print(c1.base)\n    c0.init.append(1)\n    print(c1.init)\n\noutput:\n\n    [1]\n    []\n\nLike you see, both object own the same list. Compared to the ones with self. who are owned by the instance of the class in the __init__.\n\n\nOk, I think I understand. So creating class-level attributes is like creating a static attribute in Java, where all instances of the class share that one attribute, and if one instance changes it, it's changed for all the other instances as well. Good to know, thanks.\n\nthat applies only to mutable attributes. If you have x = 3 or x = 'some string' you only override locally for 1 object because ints and strings are immutable so it's not an in-place operation. You actually replace the reference to the int/str object, thus breaking the link to the \"hivemind\".  \nLists can be updated in-place and they are shared by all objects unless each object is given a fresh unique list object explicitly.\n\nYour explanation is a little unclear.\n\nAttributes can appear on the class, the instance, neither, or both. When the attribute is on both then the instance attribute overrides the class one. You can reassign the references no matter where they are. Mutability doesn't affect this at all.\n\n    class ImmutableChangedExample:\n        attrib = 'unchanged'\n\n    instance1 = ImmutableChangedExample()\n    instance2 = ImmutableChangedExample()\n    instance1.__class__.attrib = 'changed'\n    print(instance2.attrib) # prints 'changed' even though strings are immutable\n\n#\n\n    class MutableUnchangedExample:\n        attrib = ['unchanged']\n\n    instance1 = MutableUnchangedExample()\n    instance2 = MutableUnchangedExample()\n    instance1.attrib = ['changed']\n    print(instance2.attrib) # prints \"['unchanged']\" even though lists are mutable\n\n\ni know but i specifically i commented on the *one instance changing a \"static attribute\" shared by all instances* part. Instance working in its own context cannot do that unless it's let's say an append() operation on a shared list, that modifies the value but doesn't change the underlying reference.  \nThat's where the classic gotcha comes from. With lists etc you may or may not change the reference, with immutables you always change it, which means you always \"unlink\" which means the OP's assumption is strongly conditional.", "id": "cu3qbbz", "owner_tier": 0.5, "score": -1.000000082740371e-09}], "link": "https://www.reddit.com/r/learnpython/comments/3h2lrc/default_values_in_class_definition_and/", "question": {"content": "I'm wondering if this is the right way to do this. It seems... odd somehow to assign default values in the class definition, then default None in the constructor. I suppose I could give the same default values in both places, but again, this feels like unnecessarily repeating myself.\n\n    class MyClass:\n        name = 'Undefined'\n        number = -1\n    \n        def __init__(self, name=None, number=None):\n            if name is not None:\n                self.name = name\n            if number is not None:\n                self.number = number", "id": "3h2lrc", "title": "Default values in class definition and constructor? Is this the right way?", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "This is sort of happens because of how functions are declared/defined.\n\nFunctions are first class objects in python, and the default argument is set during the function definition, not when its called.\n\nSo the empty list is getting assigned as the default argument on function definition.\n\nSo every call uses that same default argument.\n\nFirst of all, thanks for the technical explanation. It's still not exactly what I tried to find out though. I know *why* it behaves like this **in Python**. What I'm interested in is why it behaves *differently* in Python than in e.g. JavaScript, where functions are first-class-objects as well.\n\nTake this JS snippet for example:\n\n    function testFunction(arg1 = []) {\n      arg1.push(arg1.length+1); return arg1;\n    }\n    \n    let a = testFunction();\n    console.table(a);\n    \n    let b = testFunction();\n    console.table(b)\n\nThis works as **I** would expect it to work where both a and b contain just one single element with a value of 1, whereas the same snippet in Python wouldn't. Logging \"a\" would still result in the same output as JavaScript, but logging \"b\" would give me a list with two items, 1 and 2.\n\nMaybe you can elaborate some more on why this was decided on. I would like to understand on a technical level, what the python creators' reasoning was when designing the language that way.\n\nI haven't seen any post or explanation by the developers as to why this was the behavior they went with.\n\nMaybe someone else can chime in.\n\nJust as a side note, I lol'd at using Javascript as an example of a predictable language.. :)\n\nhttps://youtu.be/aXOChLn5ZdQ?t=74\n\nHaha got it - JS doesn't always lead by example, but in this particular case it behaves much like most C-Style languages and it's understood by many, so I decided to go with it here :D", "id": "j9j7lrg", "owner_tier": 0.7, "score": 0.9999999991666666}, {"content": "The default value is determined at function definition time, in the example there's a single list object.\n\nIt's been this way forever - there's little point debating whether it should or shouldn't be like that because it's not going to change, as such a change would be incompatible with existing code.\n\nThanks for the reply, but that's not really what I was asking. I specifically wanted to know _why_ this pattern was chosen and if the python creators think this is better for some reason.\n\n\"No one really knows\" would be an acceptable answer as well, but surely there is at least some unofficial theory or speculation?\n\n> it's not going to change, as such a change would be incompatible with existing code\n\nI mean, plenty of changes in Python were incompatible with existing code. Though I suppose the fact that Python 3 had many incompatible changes and this one wasn't included in them (even though people have doubtlessly been complaining about it at that time already), is a good indication that it's indeed not going to change.\n\nEither way I'd disagree with the notion that debating language design is pointless unless there's a chance that it could lead to the language changing.\n\nYou would have to ask [the exBDFL](https://lwn.net/Articles/759654/) for the *why*.  It does fit into the python philosophy of simple mechanisms in a simple language.  The BDFL chose the current mechanism and he has a track record of making language design decisions that may look odd but actually make sense.  The \"significant whitespace\" is the big example.\n\nIn this particular case the two choices are:\n\n1. define the default value at function/method call time\n2. define the default value at function definition time\n\nOption 2 is certainly simpler to implement.  In practice the need to use a sentinel value like `None` doesn't come up very often, and if python used option 1 we wouldn't be able to use code like this:\n\n    def fib(n, memo={0: 1, 1: 1}):\n        if n < 2:\n            return n\n        if n not in memo:\n            memo[n] = fib(n-1) + fib(n-2)\n        return memo[n]\n    \n    for i in range(10):\n        print(f\"fib({i})={fib(i)}\")\n\nOverall, I'm happy with the status quo.", "id": "j9j7u4h", "owner_tier": 0.5, "score": 0.9999999991666666}, {"content": "There are some good answers to this question in [this stack overflow post](https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument).", "id": "j9jq50e", "owner_tier": 0.1, "score": 0.08333333250000001}, {"content": "[This thread](https://softwareengineering.stackexchange.com/questions/157373/python-mutable-default-argument-why) (and the places it leads) are perhaps worth a peruse.\n\nI would point out that the `=` operator in Python performs name binding to the object referred to by the right hand side, which consistently uses the objects that are accessible from the current point in the code (because referring to an object in Python requires that the object exists). The act of calling a function (including for a class instantiation) passes all inputs by just their object reference, and assigns them (inside the function) to local names provided by the function\u2019s definition.\n\nIt may help to consider a function definition as \u201csyntactic sugar\u201d to instantiate a new callable object (which includes defining its calling behaviour) and assigning it a name that refers to it. From there it follows that the behaviour should be consistent for all name bindings:\n\n    default = 5\n    b = default\n    default = 3 # this does not change b\n    def test(param=default):\n        print(param)\n    default = 4 # this does not change param\u2019s default value in calls to the `test` function\n\nI\u2019m not sure how other languages handle this, but given the default value of a function\u2019s parameter in Python can be defined by an existing object reference (through a variable, or an index into a collection), or by instantiating a new object, does it not make sense to keep that object as an attribute of the function, rather than attempting to re-define it every time the function is called (which could be extremely expensive), or just hoping the name is still in scope (which could result in `NameError`s)?", "id": "j9jr37k", "owner_tier": 0.3, "score": 0.08333333250000001}, {"content": "I agree with you, but it becomes very complicated very quickly. For example you can use a function call to build the default value at runtime. \n\n    def test(x=builder()):\n\n\n\nThis function call can be very expensive, but under your scenario it would need to be called every single time the function is called. Or it could have side effects, changing its result and thus changing the default value. Or it could be very large, requiring much more memory. Or it could even be based on other files or even network resources that could change or disappear. Whether it is a *good* idea to do that is irrelevant, it is possible so the language needs to be able to handle it in a sane way. \n\nFurther, if the function has side effects, is it called every time the function is called, or only when the function doesn't have a value explicitly assigned? It isn't clear which would be the case. \n\nIt is also possible for the value to be very large, which would require it be regenerated every time.\n\nAnd what about if you use a third-party mutable class? Python would need internally to make a copy of it somehow or remember what the initialization was and run it again (which has the same problems as running a function again). And if it makes a copy, should it be a deep copy or a shallow one? If\n\nAnd it goes on. It works okay in simple examples. But there were just so many corner cases that making a system that was understandable and predictable without killing performance wasn't feasible.\n\nThere are ongoing efforts to set up some way to allow developers to do this on a case-by-case only when it makes sense, but no solution has been able to convince the core developers it is better enough than just using a sentinel value.", "id": "j9jypb9", "owner_tier": 0.9, "score": -8.333333282687742e-10}], "link": "https://www.reddit.com/r/learnpython/comments/118ucmz/why_do_python_functions_reuse_pointer_to_mutable/", "question": {"content": " \n\nFrom an experienced developer who's never used Python to all of you Python veterans out there - why does Python make me do this: [https://docs.quantifiedcode.com/python-anti-patterns/correctness/mutable\\_default\\_value\\_as\\_argument.html#use-a-sentinel-value-to-denote-an-empty-list-or-dictionary](https://docs.quantifiedcode.com/python-anti-patterns/correctness/mutable_default_value_as_argument.html#use-a-sentinel-value-to-denote-an-empty-list-or-dictionary)?\n\nIn my opinion, this is a) unnecessary boilerplate, b) confusing for any non-python developer, c) a waste of lines and d) unnecessary cognitive load.\n\nIs there any reason why python would think this solution is better than what other popular languages do? Are there other well-known languages that work in a similar way that I haven't used yet?\n\nI've used my fair share of languages (C, C++, Java, C#, JavaScript, PHP and probably a few others I missed right now), but never seen something like this.\n\nShould this question have been asked before, kindly refer me to that answer, I couldn't find anything, but I wasn't really sure what search terms to use in this case, so maybe there still is a thread I've missed.", "id": "118ucmz", "title": "Why do Python Functions Reuse Pointer to Mutable Default Values", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "Try this:\n\n    def make(x, y=None):\n        if not y:\n            y = []\n        y.append(x)\n        print(y)\n\nThis bug was because you assigned empty list as a default argument in function definition. And this same list was used in every call to this function. (python wasn't creating new list each call, every time the same list was used)\n\ntldr: Don't use mutable objects as default arguments.\n\nThanks but it showed up in a question for an exam and I did not understand why for Christ's sake it would do that. Now I get why but I hate python just a little bit more =))))))", "id": "ince1oj", "owner_tier": 0.3, "score": 0.9999999994736841}, {"content": "You need to be careful using mutable objects (like lists) as default arguments.  Default arguments are evaluated *only once*, and that's when the function definition is evaluated.\n\nETA: A better way to do this is to default to `None` and then assign the mutable value inside the function, as /u/iiron3223 did in his reply.  (I might change `if not y:` to `if y is None:` for readability, but your mileage on that may vary; do what makes sense to you.)", "id": "incetkj", "owner_tier": 0.3, "score": 0.31578947315789474}, {"content": "[https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects](https://docs.python.org/3/faq/programming.html#why-are-default-values-shared-between-objects)", "id": "incl5y3", "owner_tier": 0.5, "score": 0.10526315736842105}, {"content": "Thanks guys, I appreciate the answers. Now I get it...but...but why? =)) Why would they make default parameters static, why bound them to the definition instead of biding them to the execution? =))  \nI just seems like a the perfect breeding-ground for bugs without offering much in return\n\nThis is because in python functions are first class objects. This means they can be assigned to a variable, stored in lists and passed as arguments to other functions. For this to work function needs to be evaluated on its definition. So it is not a flaw in python design, but rather a feature, which has more pros than cons.\n\n>its a bit hard visualizing it mentally, go to this website and run your code [https://pythontutor.com/](https://pythontutor.com/) , it shows you a bit more step by step on what went where. Hopefully it helps. The reasoning is explained very well by Kyber, maybe when you see it line per line it'll be clearer\n\nThis is useful for caching and stuff like that the first example I would think of is memoisation.\n\n    def factorial(k, computed={}): \n       if k < 2: return 1 \n       if k not in computed: \n          computed[k] = k * factorial(k-1) \n       return computed[k]", "id": "incj7tf", "owner_tier": 0.1, "score": 0.47368420999999994}, {"content": "> I can't figure out why it works this way, why does the value of y not get lost after the function gets executed and gets popped off the execution stack.\n\nThe *value* of `y` does get lost. However, the default value `y` gets set to if a value isn't provided does not.\n\nIn each of your 5, 8, and 2 cases, the same list is assigned to `y` and then modified.", "id": "indp117", "owner_tier": 0.7, "score": -5.263157862750153e-10}, {"content": "Execute your code in [pythontutor](https://pythontutor.com/visualize.html#mode=edit) it's an excellent tool to learn how python execute your code", "id": "ingc6yt", "owner_tier": 0.1, "score": -5.263157862750153e-10}], "link": "https://www.reddit.com/r/learnpython/comments/x7heyh/needs_some_explaining/", "question": {"content": "    def make(x,y=[]):\n        y.append(x)\n        print(y)\n    \n    for i in [5,8,20,2]:\n        if i not in [10,20,30]:\n            make(i)\n        else:\n            make(i,[\"A\",\"B\",\"C\"])\n\nCan someone please explain me why the output of this code is:\n\n    [5]\n    [5, 8]\n    ['A', 'B', 'C', 20]\n    [5, 8, 2]\n    \n\nAnd not:\n\n    [5]\n    [5]\n    ['A', 'B', 'C', 20]\n    [8]\n    \n\nI can't figure out why it works this way, why does the value of y not get lost after the function gets executed and gets popped off the execution stack.", "id": "x7heyh", "title": "Needs some explaining", "traffic_rate": 153.12444444444444}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "This is my least favorite python footgun.\n\nHonestly it should be a syntax error, or be interpreted as a factory.\n\nI haven't done this in a decade since I remember the pain it caused so well, but I'd be shocked if all the standard linters/formatters didn't call it out.\n\nAll linters complain about it and PyCharm highlights it with a warning.\n\nFigured. Python style is so well defined as part of the language spec, I'd consider it a _huge_ mistake to not lint everything, always. Everyone on my team uses vscode or sublime to lint and autoformat on save, but if it was a larger team or we had outliers I'd probably want to enforce formatting via commit pipleline.\n\nLiterally the only lint rule we override is line length, we still use it, just change the value.", "id": "h6516ct", "owner_tier": 0.5, "score": 0.5792079207425742}, {"content": "I learned this the hard way...\n\nYeah, I discovered this while writing a recursive function to get the changed attributes between two instances of an object. Unfortunately for me, some of the attributes were objects with attributes that have the same names. It was hell trying to figure out why only some attributes seemed to be appearing and why some were incorrect values.\n\nCare to elaborate?\n\nI learned this as well when I tried to default an init param to an empty list.\n\nWell I wrote pretty much the function OP describes in his article within a telematics application.\n\nThe function itself was very simple, so I didn't expect any mistake in there.\n\nMy lists simply kept growing and I didn't understand why. I searched all my code where the old list elements would be re-added again.\n\nI tried debugging the code and couldn't find the issue.\n\nI've rewritten several chuncks of code but the issue was still there.\n\nOnly after several hours and writing a minimal example I realized that these mutable objects as default arguments are persistent between calls.\n\nI facepalmed myself to the moon, made a little fix in the function and called it a day.\n\nThe mutable object in the function argument gets initialized only once when the function is defined. So that variable always contains a reference to the same list for every call you make and not a new list like the signature might suggest.\n\nOP probably encountered issues because of this surprising behavior\n\nHere's an easy code snippet (untested, but based on my experience) that should repro the problem:\n\n    class Foo:\n        def __init__(self, items = []):\n            self.items = items\n\n    foo = Foo()\n    foo.items.append(\"bar\")\n    print(foo.items) # should see a list containing bar\n\n    foo2 = Foo()\n    print(foo.items) # you'd expect an empty list, but you'll see bar again\n\n\nTo avoid the problem, you can do something like this instead:\n\n    class Foo:\n        def __init__(self, items = None):\n            self.items = items or []\n\n    foo = Foo()\n    foo.items.append(\"bar\")\n    print(foo.items) # should see a list containing bar\n\n    foo2 = Foo()\n    print(foo2.items) # you should see an empty list this time\n\nI'm just assuming here. But I think its because maybe the interpreter handles default variables as part of the function definition and therefor saves specific memory and creates the variable on definition instead of creating it when the function its called. So, each time you called it without parameters you use the same list over and over (like in the example it keeps adding data) because the variable it's outside the fucntion's scope as it's part of the definition.\n\n&#x200B;\n\nThen again this is just eyeballing I don't know anything about the inner workings of the python interpreter but to be safe I just do arg= None and an if inside the function to create the list/mutable.\n\n&#x200B;\n\nedit: punctuation\n\nits basically like creating a global variable.  if you have experience with Python you know to create function level variables every time\n\n[Fixed formatting.](https://np.reddit.com/r/backtickbot/comments/opjmax/httpsnpredditcomrpythoncommentsopb7hmdo_not_use/)\n\nHello, pudds: code blocks using triple backticks (\\`\\`\\`) don't work on all versions of Reddit!\n\nSome users see [this](https://stalas.alm.lt/backformat/h65kzby.png) / [this](https://stalas.alm.lt/backformat/h65kzby.html) instead.\n\nTo fix this, **indent every line with 4 spaces** instead.\n\n[FAQ](https://www.reddit.com/r/backtickbot/wiki/index)\n\n^(You can opt out by replying with backtickopt6 to this comment.)\n\n> print(foo.items) # you'd expect an empty list, but you'll see bar again\n\nShouldn't this be print(foo2.items)?\n\nYep, pretty much. This was a design decision for the sake of optimization. Creating an immutable object potentially each time the function is called is inefficient. I guess that they wanted the behavior for mutable objects to be consistent with that.\n\nYup, exhibit A on why copy-pasting code is dangerous.", "id": "h64kikj", "owner_tier": 0.1, "score": 0.999999999950495}, {"content": "flake8-bugbear is your friend.\n\n> [flake8-bugbear](https://pypi.org/project/flake8-bugbear/16.4.0/)\n\nLink for the lazy", "id": "h650wkl", "owner_tier": 0.5, "score": 0.15841584153465346}, {"content": "Same for default date 'datetime.today()' on servers that stay online for years.\n\nLuckoly, `datetime.today` is callable, and `if callable(x):` is a thing.", "id": "h65b8jq", "owner_tier": 0.7, "score": 0.1435643563861386}, {"content": "That tip doesn't only apply to functions, but classes/dataclasses as well. There is a reason dataclasses 'field' method has a 'default_factory' parameter", "id": "h66avqx", "owner_tier": 0.3, "score": 0.11386138608910891}, {"content": "Wouldn't that feature work great for concurrent status storage, like atomic counters?\n\nDue to the GIL everything is atomic in python \ud83e\udd23", "id": "h66l2u6", "owner_tier": 0.5, "score": 0.07920792074257425}, {"content": "> Do not use mutable objects as default arguments in Python\n\nUnless you want to. Using mutable defaults is fine [if you know what you're doing](https://www.python.org/doc/essays/graphs/).\n\nUse a class.", "id": "h689bzt", "owner_tier": 0.7, "score": 0.08415841579207921}, {"content": "Pretty classic gotcha.", "id": "h67f7lx", "owner_tier": 0.7, "score": 0.0742574256930693}, {"content": "The real lesson should be don\u2019t use default arguments when your function requires a list to append some data to. This case should never happen so the example is moot.", "id": "h67oful", "owner_tier": 0.5, "score": 0.06930693064356436}, {"content": "PyCharm won't let me", "id": "h65zxz5", "owner_tier": 0.7, "score": 0.06930693064356436}, {"content": "I really hate when people make blanket \"don't\" statements. Almost everything has some reason to be done, you just have to know what and why.\n\nIn this case it very much is a blanket statement. Unless you want unreadable hacky code. If you truly want a global object, actually define one at the global scope and access it inside the function instead of relying on the kwarg default value being the same. Achieves the same and is orders of magnitude more readable. Remember explicit is better than implicit.\n\nThankfully, until you're senior enough to understand when a *static mutable object* is useful, you don't want to touch them yet. There's a lot of room for unexpected behavior in that combo.\n\nThe fact is, that even if you actually wanted a persistent object, that would still be a whacky way to do it...\n\n    def f(x=[]):\n        pass\n\nFunction's state changes over time, but isn't a generator.  Surprising behaviour, probably a bug.\n\n    x = []\n    def f():\n        global x\n        pass\n\nVery obviously intentional, but uses a global.  Kinda icky.\n\n    class Fer:\n    \n        def __init__(self):\n            self.x = []\n\n        def f(self, x=None):\n            if x is not None:\n                self.x = x\n            ...\n\n    f = Fer().f\n\nUglier, but reuseable, and no global modification.\n\nBlanket do/don't statements are a good idea when communicating to people who either aren't ready for or don't have the time for more nuanced points.\n\nDon't ban don't statements.\n\nIt can be used to keep information between different calls of the function without needing to write a bunch of infrastructure around it. If that's what you want, this is acceptable. \n\nFor just about everything there is a valid use for it and you just need to know about the possible catches.\n\nAll this does is teach people that nuance is not relevant. It doesn't help them learn a damn thing.\n\nI use that for caching. But this is a hack. If there is a breaking change in python on the subject I deserved to be punished.\n\nYeah that's a global object\n\nThat's what I was thinking. Using this nuance of Python could make code easier to manage.\n\nRather than defining a global object and then operating on it with a function, the object could be the default arg of the function. That way, it's clear that the object belongs to the function. That its purpose is explicitly to serve as a complement to the function.\n\nThat's... Not true?\n\nA beginner who is just learning about default arguments already has a lot that they're trying to remember. They'll pick up nuance later -- just like everyone does as they grow.\n\nThat doesn't interfere with any other scope. It could be very useful in very specific scenarios.\n\nIf you were to do this, you would unambiguously be commenitng it with this intention clearly stated.  On top of this, I think most linters would flag this, so you'd have a `# noqa` comment on there as well.\n\nFor me, as a matter of code review, I don't allow linter checks to be disabled without a comment explaining why.\n\nA few might. The rest will simply go \"I was told don't! So I don't.\"\n\nMaybe - but I feel like it's more likely to just confuse things. There are juniors on my team and i know this kind of thing can just ruin their week\n\nYou're right that the blanket \"don't\" statement isn't technically true, but if you know enough to know when to use this you probably know enough to ignore this kind of medium article\n\nThen use a different namespace. Don't hack it in the function signature.\n\nA cool way to do is to set the namespace on the function attr.\n\n    def f():\n      ...\n\n    f.cache = []\n\n\nIMO, I rather use a class but I get it, sometimes you don't want to rewrite everything as a class.\n\nDon't allow general noqa. It should always except a specific error. Also, `# noqa: E501` (line length) doesn't really need a comment.\n\nAnd if you don't know enough you've now just created a blanket prohibition in your head against doing something potentially useful in the future. This is a disservice to those who are expected to grow in knowledge and ability.\n\nI'm sorry you think something specifically left in there by the language designers is a hack. It's not.\n\nAgreed, sorry, I was just being brief with that statement.\n\nI hadn't considered that, but equally I feel like there's always a process of unlearning as we get better at stuff\n\nI still feel like the potential is for more harm than good for a junior reading this, unless the author explicitly recommends against it\n\nSaying \"potentially useful\" implies that there's no other way of doing it. The alternative maybe requires a few lines of infrastructure, but is orders of magnitude more readable and will save you and others a ton of headache in the future.\n    \n    Explicit is better than implicit.\n    Simple is better than complex.\n    Complex is better than complicated.\n\nNotice the order, it matters. Explicit is better than implicit. Yes simple is better than complex, but complex is better than complicated, and your solution is indeed complicated because it relies on hacky side-effect that is very hard to notice.\n\nThere are always better ways to do something like this. You don't give people who are learning a bunch of weird 'semi-rules' to store in their head on the off chance they'll encounter some corner case that would be conveniently resolved with this knowledge. \n\nOne of the fundamental precepts of python is to avoid doing things that behave in unexpected or unintuitive ways. This is absolutely one of those cases. Arguing against it \"just in case\" feels contrarian for the hell of it.\n\nNot every behavior is an explicit design choice. Not every bad practice behavior can be fixed either (e.g., backward compatiblility).\n\nArguing you simply must never do what the language maintainers have purposely left in is beyond contrarian.\n\nSo, they have to keep this bad hack in so they don't break anyone who's using this bad hack. That seems very illogical.", "id": "h650ncm", "owner_tier": 0.9, "score": 0.5495049504455445}, {"content": "Unless, this is the effect you desired. A stateful function.\n\nIn the rare instance that it *is* what you wanted, you can always ignore the *rule*.  If you understand *why* it's happening, you can make that decision yourself (and if you don't understand why it's happening, you should follow the article's advice).\n\nEven if you wanted this behavior, relying on a counterintuitive quirk would be a bad way to implement it.\n\nIf only there was some way to associate a function with some kind of state.\n\nNo I don\u2019t think there will ever be a case why you need this. I\u2019ve been wrapping my head around why anyone would possibly need this and I can\u2019t see any.\nYou can have global or local variables that are more explicit and readable. You can also use functools cache and lru_cache if caching is the effect you desired.\nOr you can also just use a oop approach.\nDoing this goes against the zen of python in many ways.\n\nIf only we could put the function into a class, or use functools. Or just put the function inside another function and use nonlocal\n\nI agree that it's not something anyone should be doing.  My point was that the advice is sound, and if anyone *really needs* to break the rule, they should *only* be doing so because they know exactly what and why they're doing what they're doing.\n\nYeah a class is what I was getting at.  `nonlocal` is as much a scourge as `global`.", "id": "h652jv7", "owner_tier": 0.3, "score": 0.08910891084158415}, {"content": "Is this not considered a bug? Why don\u2019t they change this in new versions?\n\nThe main reason I'm aware of is performance. It's faster to store a default argument in the function object than to re-evaluate that argument every time the function runs. If the function runs many times, this speeds things up a lot.\n\nThis is intentional choice and a well known behavior.  Like /u/jet_heller mentioned, you can use this technique to keep track of information between different calls of the function if you wanted.  I understand it's confusing at first, but there are easy ways around it.\n\nHow is that an argument when you can use a global?\n\nWhat do you mean? A global name still has to be evaluated. Were you trying to reply to someone else?\n\nYou have some immense misconceptions about how the Python interpreter works I think.  ANY name has to be \"evaluated\", whether it's a local, arg, global, whatever.  As a matter of fact, function arguments become locals within that function scope, so they have the exact same performance impact to use as something in globals.\n\nLet's start again.  Benjamin posits that the mutable default argument behaviour is bug-like.  You posit that there's a reason to keep it, and that that reason is for performance.  I point out that you can use a global instead of the function argument for things you'd like to mutate, the implication being \"to not have to use mutable function default arguments\" or \"in a world where there aren't mutable function default arguments\".  Do you disagree with that?\n\n> You have some immense misconceptions about how the Python interpreter works I think. ANY name has to be \"evaluated\", whether it's a local, arg, global, whatever. As a matter of fact, function arguments become locals within that function scope, so they have the exact same performance impact to use as something in globals.\n\nYes, of course I know that. The performance impact I'm talking about is not in the body of the function, but in establishing the default arguments themselves. Python stores the default arguments in the function's `__defaults__` attribute so they don't have to be evaluated again. [0] The only alternative to this that I can think of would be for Python to add code to the function that can evaluate the default argument expressions when the function gets called. Do you agree that evaluating an expression once is faster than evaluating it many times? Sure, you'd have to factor in the attribute and tuple lookups, but that's surely faster than allocating memory for a new object, or whatever else an expression might do, which could be anything.\n\nYour second paragraph appears to come from misunderstanding the point I was making. Hopefully, I've cleared that up.\n\n[0] https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy", "id": "h653utk", "owner_tier": 0.5, "score": 0.1435643563861386}, {"content": "This is the second time this article has been posted and the headline is garbage advice. \n\nMutable objects are very useful as default arguments for caching/memoization. \n\nPlease delete.\n\n> Mutable objects are very useful as default arguments for caching/memoization.\n\nThis is a terrible suggestion. Please don't do this. If someone reading the code didn't know about this implementation detail in Python, the behavior would be entirely counterintuitive.\n\n    >>> def f(x, lst=[]):\n    ...     lst.append(x)\n    ...     print(lst)\n    ...\n    >>> f('a')\n    ['a']\n    >>> f('b')\n    ['a', 'b']\n    >>> f('d', lst=['c'])\n    ['c', 'd']\n    >>> f('e')\n    ['a', 'b', 'e']\n\nYou might expect `f('e')` to produce `['c', 'd', 'e']` since we \"replaced\" `lst` in the previous call. That's not the case because `lst` in the function definition is allocated in heap memory, whereas `lst` in `f('c', lst=['c'])` is allocated on the stack.\n\nIf you need to do memoization, use the features provided in `functools`.\n\nCan you provide an example?\n\nIt's always better to just define a global object and use that for caching than imply on the implicit fact that kwarg default values are mutable.\n\nExplicit is better than implicit.\n\nOr better, use functools.cache\n\nIt remains good advice.  There are exceptions to every rule, including this one, but the advice remains solid.  If you *need* to break this \"rule\", then you *know* you need to and you know why and how.  For the vast majority of people, however, following this advice is the correct course of action.\n\n    def get_from_cache(name, cache={}):\n        if name in cache: \n            return cache[name]\n        cache[name] = expensive_calculation()\n        return cache[name]\n\nThough usually memoization is done with decorators because linters and IDEs will warn you about mutable defaults as they trip people up and are easy to miss at a glance.\n\nYou'd instead do something like \n\n    from functools import cache\n\n    @cache\n    def factorial(n):\n        return n * factorial(n-1) if n else 1\n    \n    >>> factorial(10)      # no previously cached result, makes 11 recursive calls\n    3628800\n    >>> factorial(5)       # just looks up cached value result\n    120\n    >>> factorial(12)      # makes two new recursive calls, the other 10 are cached\n    479001600\n\n[reference](https://docs.python.org/3/library/functools.html#functools.cache)\n\nSee the docs.\n\nWhat if I have functions that produce a function? Then I can\u2019t have global variables because I want these functions created dynamically.\n\nNot according to the docs, which says it is up to the programmer's discretion. \n\nAlso on enterprise programs default arguments can be considered cleaner than global objects.\n\nThis also works and doesn't use a mutable arg:\n\n    def get_from_cache(name):\n        if name in get_from_cache.cache: \n            return get_from_cache.cache[name]\n        get_from_cache.cache[name] = expensive_calculation()\n        return get_from_cache.cache[name]\n    \n    get_from_cache.cache = {}\n\nSo none then.\n\nSee https://www.reddit.com/r/Python/comments/opb7hm/do_not_use_mutable_objects_as_default_arguments/h657394/\n\nI'd need to see a specific, but I believe this is what [nonlocal](https://www.w3schools.com/python/ref_keyword_nonlocal.asp) does?\n\n    \n    def outer_func():\n      cache = {}\n      def inner_func(foo):\n        nonlocal cache\n        if foo not in cache:\n          cache[foo] = heavy_computation(foo)\n        return cache[foo]\n      return inner_func\n\nA lot of things are up to the programmers discretion. Unlike some other languages, Python doesn't really babysit the programmer, it let's you do a lot. Hell you can completely override the import mechanism or replace all the modules in sys.modules if you want. You can set `True = False` or replace `int.__add__`. Doesn't mean any of these are a good idea.\n\nTo be clear, I'm talking about code that will be seen by other people (though, yourself in 6 month also counts as someone else in most cases). You're free to do whatever you want in your own personal code, but if I ever saw this in a code review, I would shut it down real quick.\n\nI did the googling for you:\n\nHere:\n\nhttps://docs.python.org/3/faq/programming.html#id13\n\n\"Because of this feature, it is good programming practice to not use mutable objects as default values. Instead, use\u00a0None\u00a0as the default value and inside the function, check if the parameter is\u00a0None\u00a0and create a new list/dictionary/whatever if it is. For example, don\u2019t write:\n\ndef foo(mydict={}): ... \n\nbut:\n\ndef foo(mydict=None): if mydict is None: mydict = {} # create a new dict for local namespace \n\nThis feature can be useful. When you have a function that\u2019s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called \u201cmemoizing\u201d, and can be implemented like this:\n\nCallers can only provide two parameters and optionally pass _cache by keyword def expensive(arg1, arg2, *, _cache={}): if (arg1, arg2) in _cache: return _cache[(arg1, arg2)] # Calculate the value result = ... expensive computation ... _cache[(arg1, arg2)] = result # Store result in the cache return result \n\nYou could use a global variable containing a dictionary instead of the default value; it\u2019s a matter of taste.\"\n\nThat is true but python does have a style guide and in this instance the docs themselves state their recommendation.\n\n> You can set `True = False`\n\nSlight nitpick, but you cannot actually do that.\n\n    >>> True = False\n      File \"<stdin>\", line 1\n    SyntaxError: cannot assign to True \n    # (same goes for literals)\n\nThough I totally agree with everything you said. Replacing `__add__` for fun instead of having an `.add_to` function is potentially confusing to others. \n\nI think you can make exceptions for mini-languages, like how pathlib overrides the division operator for path concatenation. And of course dataclasses. But *generally speaking* it is a bad idea.\n\nAlso, the Google style guide is a great reference for beginners. I recommend it to people all the time, it has good examples of the \"do's and don'ts\".\n\nCalling it _cache at least makes it clear to the user. I still prefer the @cache decorator from functools\n\nLink?\n\nEDIT: The only code style I found is Google's, and they explicitly state to never do this:\nhttps://google.github.io/styleguide/pyguide.html#2124-decision\n\nMost companies I know of have similar internal style gudes.\n\nEDIT2: python-guide.org vaguely implies that it's fine to use, but that's not official Python either, it's some opinionated book.\n\n> Slight nitpick, but you cannot actually do that.\n\nHah, they indeed fixed that in Py3, definitely could in Py2.\n\n> pathlib overrides the division operator for path\n\nTo be clear, overriding operators isn't the issue, doing it on a base class is the problem. pathlib does it only on pathlib.Path objects, which is well within it's reign.\n\nMore precisely, you cannot do that *anymore*.\n\nThis was possible in 2.7.\n\nHere:\n\nhttps://docs.python.org/3/faq/programming.html#id13\n\n\"Because of this feature, it is good programming practice to not use mutable objects as default values. Instead, use\u00a0None\u00a0as the default value and inside the function, check if the parameter is\u00a0None\u00a0and create a new list/dictionary/whatever if it is. For example, don\u2019t write:\n\ndef foo(mydict={}): ... \n\nbut:\n\ndef foo(mydict=None): if mydict is None: mydict = {} # create a new dict for local namespace \n\nThis feature can be useful. When you have a function that\u2019s time-consuming to compute, a common technique is to cache the parameters and the resulting value of each call to the function, and return the cached value if the same value is requested again. This is called \u201cmemoizing\u201d, and can be implemented like this:\n\nCallers can only provide two parameters and optionally pass _cache by keyword def expensive(arg1, arg2, *, _cache={}): if (arg1, arg2) in _cache: return _cache[(arg1, arg2)] # Calculate the value result = ... expensive computation ... _cache[(arg1, arg2)] = result # Store result in the cache return result \n\nYou could use a global variable containing a dictionary instead of the default value; it\u2019s a matter of taste.\"\n\nInteresting, thanks for sharing.\n\nWorth noting that they actually explicitly use `_cache` for the variable name, with the _ in front, implying that users of the function won't actually pass a value and it's technically a \"private\" variable for the function. In that sense, and with good documentation, I could see it. But at the same time, self-documenting code is the best kind of code, so why write confusing code you need to add comments to explain, when doing it the other way is the same amount of effort but self-documenting.\n\nAlso, that's more of a FAQ than a style guide, and I'm assuming that entry is fairly old. Most style guides would still tell you to never use that.", "id": "h64zblj", "owner_tier": 0.5, "score": 0.21782178212871287}, {"content": "I don't see why anyone would do anything this way regardless.  Its basically a non issue you should be aware of... I think people, especially Python developers, care way too much about cutting a line or two out of their code and being \"Pythonic\" rather than making things more readable and adding a line or two... this problem is essentially avoided by just using new variables.  Default arguments = noob IMO\n\nHow is something built into the language a non issue? The reason people would do it this way is because they can and they didn't learn otherwise. You can make an argument for never using default arguments ever if you'd like, but no need to be condescending.\n\nits a non issue if you are coding to be readable and not trying to be overly pythonic, which is a thing IMO.  people try way too hard to shorten their function only to create bugs and make it harder to work with for others... sometimes shortening the code does neither of these things.  of course, there are lots of nuances to any programming language you'll have to learn.  I'm not being condescending at all, just giving my opinions", "id": "h65nqhy", "owner_tier": 0.9, "score": -4.950495459110747e-11}, {"content": "Huge pitfall. Took me way too long to figure it out the first time I tried it.", "id": "h673txc", "owner_tier": 0.5, "score": 0.0643564355940594}, {"content": "Thank you!!!", "id": "h67eang", "owner_tier": 0.1, "score": 0.0643564355940594}, {"content": "My solution to this is to make my default arguments `None`, always. Yes, numbers don't have the problem, so I could make a default argument a number -- or a tuple, or a frozenset, or .... But a policy of always using `None` means one less thing to think about and possibly get wrong.\n\nI really want to disagree with you but I can't find it in myself to do so.  Consistency is key, even if it's a bit verbose.", "id": "h67l342", "owner_tier": 0.7, "score": 0.0742574256930693}, {"content": "I know the implications of this but so far I think this shouldn't be a problem if you follow basic best practices anyways.\n\nBut I may be wrong here so I would like to ask:\n\nCan someone provide a function that is perfectly valid in regards to side effects, single responsibility and not reassigning arguments that would still have the same problem?\n\nLike literally every single example shown here breaks either or all of these guidelines and I would consider them bad no matter what.\n\nFor example:\n\n    def append_10(arr = []):\n    arr.append(10)\n    return arr\n\nThis function is obviously used to indicate how bad mutable default arguments are, but I think this function is bad even if you fix the default parameter.\n\nWhy? because the solution to the above problem is this:\n\n    def append_10(arr = None):\n    if arr is None:\n        arr = []\n    arr.append(10)\n    return arr\n\nBut this function:\n\n1. reassigns an argument\n2. does two things in the case no list is given (create as well as append)\n3. I think, isn't logically consistent\n\nTo these 3 points:\n\n1. reassigning arguments is bad in my eyes, they are arguments, not variables\n2. doesn't follow single-responsibility, if its responsibility is to append an element to a list, then it should take a list as a parameter and reject everything else. If someone wants to append 10 to an empty list, they should provide said empty list to the function.\n3. If I append 10, as the function name implies, to \"nothing\" then to me a list isn't what logically follows. If I have an empty list and append 10 then sure, a list with the element 10 follows. But if I don't even have a list then I simply can not append an item to it. Now this may be personal preference but I think it goes hand in hand with 2. and I think it is bad practice as it is ambiguous and doesn't follow single-responsibility.\n\nThe following version suggested by another person is even worse:\n\n    def append_10(arr = None):\n    arr = arr or []\n    arr.append(10)\n    return arr\n\nThis function returns a list, with the element 10 in it, for every single falsy value. It also obviously crashes for every truthy value except for those that have the method append which takes a single int as an argument. This again is logically inconsistent and behaviour, I think, one shouldn't expect from a function.\n\n* append\\_10(False) -> \\[10\\]\n* append\\_10(0) -> \\[10\\]\n* append\\_10(6<2) -> \\[10\\]\n* append\\_10(\"\") -> \\[10\\]\n* append\\_10({}) -> \\[10\\]\n* append\\_10(()) -> \\[10\\]\n* append\\_10(set()) -> \\[10\\]\n\n(I especially like the 3rd case, makes zero sense if spoken out loud, but works)\n\nOn top of this I also think the statement \"Do not use mutable objects as default arguments in Python\" itself is too general. It should be \"Do not use mutable objects as default arguments in functions which mutate said object\". Because I don't see how the problem would arise if you don't alter the argument in the first place.\n\nFor example if you had a list of terms you wanted to exclude and in case no terms are provided you use an empty list. This, I think, is valid but the general statement would tell you not to do it.\n\n    def add_10_but_exclude(arr, exclude = []):\n    for i,value in enumerate(arr):\n        if i not in exclude:\n            arr[i] = value + 10\n    return arr\n\n(yes I know \u00b4the function is bad, inefficient and doesn't follow any best practices either, but it's simple and gets the point across)\n\nThis function also uses a default parameter for exclude which is mutable. But as the state is never mutated to begin with, the above statement to \"not use it\" doesn't apply.\n\nSo, can anyone please provide a function that is \"logically consistent\", follows basic best practices and still requires a mutable default (that then has to be changed as mentioned in the article)?\n\n> reassigns an argument\n\nWho cares?  It's just a precondition.  The argument needs a default and Python is being a douche about how it has to be specified.\n\n    def f(x=0):\n        return x + 1\n\nYou don't have a problem with that because the language is doing something sensible.\n\nImagine a Python where default args could _only_ be `None` and had to be specified in the body.  That would then become:\n\n    def f(x=None):\n        if x is None: x = 0\n    \n        return x + 1\n\nNote how the language being a douche caused the code to have to do something weird.\n\n> does two things in the case no list is given (create as well as append)\n\nDoesn't matter.  The entire point of functions is to group one OR MORE operations into a reusable package.  Default arguments also create.\n\n    >>> def f(x=0):\n    ...  pass\n    ... \n    >>> f.__defaults__\n    (0,)\n    >>> \n\n> I think, isn't logically consistent\n\nSubjective.\n\nWhy so aggressive? I literally opened by stating I may be wrong here and that I would like to see better examples.\n\n>You don't have a problem with that because the language is doing something sensible.\n\nWell if I wanted to be pedantic then yes I would still have a problem with that. Because you've literally just provided the successor function with the unnecessary step of providing a 0 element in case no element is inserted. This also means a call to f() returns 1, which I again would regard as false. 1 is simply not the successor of None, it is the successor of 0 and those are not the same. \n\n  \nBut that was my entire point: The examples used are pointless because they are flawed even without what this discussion is about.\n\nWhich is exactly why I  - asked - for someone to provide a better example.\n\n>Doesn't matter. The entire point of functions is to group one OR MORE operations into a reusable package. Default arguments also create.\n\nCool, and the entire point of a program is to solve a problem. Yet we still try to solve them efficiently and follow best practices for various reasons.\n\nA function having multiple operations doesn't necessarily equal a function having multiple responsibilities.\n\n&#x200B;\n\n>Subjective.\n\nCare to elaborate when it is logical for a function called append\\_10 to return \\[10\\] when called with False?\n\nAt the very least this doesn't follow the principle of least astonishment.\n\nAlso what is the reason to not enforce append\\_10 to be called with a list in the first place? A user surely would expect a function requiring some argument to not work if said argument is not provided.\n\nTo me the so far presented examples just use hacky solutions in order to prevent false user input.\n\nAgain, I know these are just examples that try to get the point across. But I think these are bad examples and I would like to see a better one, that's all I was asking for.\n\n> Why so aggressive? \n\nThat's your reading of my message.  I'm not being aggressive, I'm engaging in discussion.\n\n> 1 is simply not the successor of None, it is the successor of 0 and those are not the same.\n\nYou're getting hung up on the details here.  The important thing is `None` denoting \"use default value\".  `None` is not being treated as a value in and of itself.  Because the language is not stupid when it comes to ints as they're immutable, I used those as an example.  I could quite easily have used a string.\n\nSimilarly I could quite easily have done something like this:\n\n    use_default = object()\n\n    def f(x=use_default):\n        if x is use_default:\n            x = some_default\n    \n        ...\n\nBecause Python is stupid with mutable values in `__defaults__` (and `__kwdefaults__`), you're forced to do the above.  In the case of immutable values, Python is doing that for you.  There's no world where that's not happening, it's just a case of whose responsibility it is to write it, the interpreter or the programmer.\n\nNow it just so happens that we already have an object in Python that's easily comparable and predefined, and has generally been used semantically as \"use the default argument if this is something that's meant to have a default argument but can't because mutable arguments are handled terribly\", and that's `None`, so the above becomes:\n\n    def f(x=None):\n        if x is None:\n            x = some_default\n    \n        ...\n\n> Which is exactly why I - asked - for someone to provide a better example.\n\nMy contention isn't the quality of the examples in the article, it's with the definition of quality of examples in your post.  None of the three points you declared are definitive of quality.  Quality occasionally exhibits your points, but it's not the other way around.  Reiterating that you want better examples _in reply to my comment_ is ignoring the points I'm making and is best served as a reply for someone who is arguing that the existing examples fit your definition of quality, rather than someone who is arguing that your definition of quality is suspicious.\n\n> A function having multiple operations doesn't necessarily equal a function having multiple responsibilities.\n\nThen where do you draw the line?  We use programming languages to solve real problems in the real world and NOBODY wants to pay you to maintain this trash:\n\n    def default(value, default):\n        return default if value is None else value\n    \n    def f(x=None):\n        x_with_a_different_name = default(x, some_default)\n    \n        ...\n\n> Care to elaborate when it is logical for a function called append_10 to return [10] when called with False?\n\nYour position has changed.  The appropriate naming of functions was not one of your three measures of quality.  I do not disagree that functions should be named appropriately.  Nobody disagrees with that.\n\n>You're getting hung up on the details here. The important thing is None denoting \"use default value\". None is not being treated as a value in and of itself. Because the language is not stupid when it comes to ints as they're immutable, I used those as an example. I could quite easily have used a string.\n\nI'm not talking about the \"None\" in the function though, maybe I should've phrased it differently and named it \"nothing\" instead of \"None\". I talk about the parameters the function is called with.\n\nIf you call f() you call a function without a parameter, you call it with \"nothing\".\n\nBut your \"successor function with default at 0\" puts out f()->1 which maps \"nothing\" to 1. f(3)->4 makes sense, f(0)->makes sense, f()->1 doesn't.\n\nThere simply is no need for any of the so far provided examples to use a default value in the first place, other than wanting to write f() instead of f(default).\n\nAll of the so far provided functions are of the same nature:\n\n    def func(some_mutable_argument=None):\n        if some_mutable_argument is None:\n            some_mutable_argument = a_new_instance_of_the_argument()\n        \n        # Do some shit with some_mutable_argument\n        ...\n\nBut why? Why not just use...:\n\n    def func(some_mutable_argument):\n    # Do some shit with some_mutable_argument\n    ...\n\n...and let the user of the function provide the object the function should mutate?\n\nLike isn't that literally the purpose of the function, to mutate the state of a provided object? From my point of view the (single) responsibility of the function is to do stuff with a provided object. The user is responsible to provide said object.\n\nThat is why I asked for a function that actually - requires - a mutable default argument, so I can get a better grasp of the use-case. Basically a real world example.\n\n>Your position has changed. The appropriate naming of functions was not one of your three measures of quality. I do not disagree that functions should be named appropriately. Nobody disagrees with that.\n\nOk so how would you name such a function \"appropriately\"?", "id": "h68dho7", "owner_tier": 0.5, "score": 0.0940594058910891}, {"content": "Can someone help me understand the code in  the bonus section at the bottom of the article?  \n\n    a = [10,20,30]\n    b = a\n    b[1] = 25\n    print(a)\n\nWhen I run it, b[1] = 20\n\n    >>> a = [10,20,30]\n    >>> b = a\n    >>> b[1] = 25\n    >>> print(a)\n    [10, 25, 30]\n    >>> print(b)\n    [10, 25, 30]\n    >>> \n\nCould be a layer 8 issue, or PEBCAK.\n\nHah, yes problem was definitely me.  For some reason I was reading it as the output of b[1] was 25 not that is was assigning that index as 25.  I need more coffee\n\nPlease don't substance abuse just to get better at programming.  :(", "id": "h68trr5", "owner_tier": 0.5, "score": 0.08415841579207921}, {"content": "I will never understand this sub.\nSure, it's a rather common anti-pattern, but more than a thousand upvotes for this post? That links to Medium?\n\nThere are people out there that do amazing stuff from scratch, approach entirely new domains of applications of Python, come up with clever ways to represent or interpret data...\n\nAnd here we are, burying this under an avalanche of upvotes.\n\nSeek originality, innovation, and creativity, or this place will become a boring graveyard\n\n[deleted]\n\nSure, it's an important concept, but so is the for-loop. One thing is to build skyscrapers, another is to milk upvotes.\n\nOf course, we're arguing about our respective opinions, and there are 1200+ upvotes saying that I'm clearly losing here", "id": "h6c4exb", "owner_tier": 0.3, "score": 0.0742574256930693}, {"content": "I actually hadn\u2019t thought of that, but it makes sense.", "id": "h7faz3y", "owner_tier": 0.3, "score": 0.0643564355940594}], "link": "https://www.reddit.com/r/Python/comments/opb7hm/do_not_use_mutable_objects_as_default_arguments/", "question": {"content": "", "id": "opb7hm", "title": "Do not use mutable objects as default arguments in Python", "traffic_rate": 207.9358484294499}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "I had to find this out the hard way :/\n\nP.s. I am a little rusty on python, but if you want a mutable default value (say a list) you can make the default `None` then inside the function you would reassign the variable if it's None.\n\nEveryone does, rite of passage\n\nIf it's something you find yourself doing often for some reason, it might be worth checking out things like [attrs' default factories](https://www.attrs.org/en/stable/examples.html#defaults), I find it easier to parse and refactor if necessary.\n\nUse tuples for a default iterable rather than None! Fewer optionals makes for better typing and automatic documentation.\n\nAnd we all have to learn it a second time.\n\nI didn't. I read it in [the docs](https://docs.python.org/3/tutorial/controlflow.html#default-argument-values). Everyone should read the docs.\n\nThanks for that :D\n\nBut I don't think I would add another import _just for that_, but what do I know, I don't even use python much nowadays (don't use it at all, sadly)\n\nCongratulations. I read the docs too\u2014constantly, really\u2014but still had to find this out the hard way. There's a lot to read!\n\n[deleted]\n\nWow, holding true to the stereotype that developers don't have any social skills...  NONE.\n\nwith that attitude, we all should really know absolutely everything that was ever written. and it seems it's not the case. you gotta understand, we're all humans, not machines.\n\nYou didn\u2019t have to originally write it to have to track it down\n\nLol quintessential r/iamverysmart material. Do you have the docs memorized? Yes? You've wasted your life, congratulations. No? Yeah total hypocrite.\n\nYou read the docs and didn't remember every single rule and caveat and gotcha? You're obviously not fit to program in Python. Maybe take up bowling? \ud83d\ude0f\n\nWhat I want is for people to read the docs, and not be surprised by things they could have learned by doing so.\n\nCoincidentally, what we want is for people like yourself to not worry about us. There's no moral dilemma here. Just people being human.\n\nSadly, I have to worry. I work with people who refuse to read the docs. There's one guy in particular, who if we're working on something and I get the docs up, is like \"ooh, you're reading the docs are you?\" like I've just got a magical tome from the highest shelf, full of arcane knowledge.\n\nIt's not like the docs I linked to are some obscure reference material. It's the official python tutorial, and a great place to start for beginners. If there's something basic that you don't know, that's in the tutorial, then whatever you read or watched to get you started is no good and now's a great time to read the tutorial.\n\nWhat if there\u2019s something basic you don\u2019t know you don\u2019t know? How would you know to go back to the beginners tutorial?\n\nHow often should one peruse elementary material to be sure one doesn\u2019t make a mistake at any point in any possible future?", "id": "j54rqz3", "owner_tier": 0.1, "score": 0.999999999970238}, {"content": "Yep. Always default mutables (like empty lists) to `None`, and don't rely on the output from functions there:\n\n    def blah(my_arg=None):\n        if my_arg is None:\n            my_arg = []\n\n    def other_blah(my_arg=None):\n        if my_arg is None:\n            my_arg = right_now()\n\nAdditionally, if you want to use None (or anything) as the default but need to know whether the caller explicitly passed None or whether the caller left it default you can do something like this: \n\n```\n_undefined = object()\n\ndef function(arg= _undefined):\n    if arg is _undefined:\n        arg = None\n```\n\n`my_arg = my_arg or []`\nOr, if you care about NoneType specifically;\n`my_arg = [] if my_arg is None else my_arg`\n\nYes! Empty string `''` works as a safe immutable default, too!\n\n```python\nfrom datetime import datetime\n\nclass Foo:\n    def __init__(self, timestamp: datetime = None) -> None:\n        self.timestamp = timestamp or datetime.now()\n```\n\nReally hoping the Sentinel PEP gets approved so we can have a more elegant solution to this. https://peps.python.org/pep-0661/\n\nAnd if you want None to be a valid value for your argument too, you can use a sentinel:\n\n    _sentinel = object()\n    def func(x=_sentinel):\n        x = [] if x is _sentinel else x\n\nI\u2019m sure it\u2019s not a massive difference for most projects. But I imagine with the special treatment None gets by python it would be marginally more efficient. But as far effectiveness then yes either would work.\n\nHis argument is a list so default '' doesn't make sense. The type is gonna be Optional[List].\n\nTrue, although if you need to support an empty list and None and I generally find code smell.\nNot sure if I'd prefer to use `**kwargs` instead at this point.\n\nYep. `\u2019\u2019` is a great and common default for `str` parameters, but of course not when other types are expected. It\u2019s common to see `notes: str = \u2018\u2019`, and there\u2019s seldom a need for the `Optional[str]` type.\n\nThe only time I\u2019ve really seen the pattern useful is when you want to emulate something similar to `dict.pop`, where for a missing key: `dict.pop(key)` raises an error and `dict.pop(key, default)` returns the default", "id": "j55je8d", "owner_tier": 0.9, "score": 0.29166666663690477}, {"content": "Mutable default are the root of all evil\n\nThe problem in the article is not related to mutability though.\n\nIs there even a sane use case?\n\nIt is, default args are bound at definition\n\nEven if there were, I\u2019d be hesitant to make use of it; \n\n- hard to know what\u2019s going on for anyone reading it\n- if this behavior ever is changed to something sensible, the function breaks\n\nI\u2019ve seen a kwarg named `cache` (dictionary) that kept state between executions.\n\nIt's not. Read the article. Author has a default argument of `datetime.date.today()`. Problem is not that `today` default variable mutates over executions, but it does share the same root problem, original dev was expecting the code to initialize the default to execute each time the function executed and it don't.\n\nAh I see where you\u2019re coming from. The original comment was about only mutability.\n\nAgreed, this example is particularly a behaviour of function declaration.\n\n[deleted]\n\nUmm, mutable defaults are definitely related lol, both are function gotchas for newbies\n\nNo idea why you want to make such a big deal out of this, but whatever\n\nShould mutable defaults even be accepted by Python.   At least according to my logical thinking a default value can not and should not be mutable.   It just doesn't make sense to me, the default values become part of the def for the function.\n\nThe way Python handles this doesn't seem to be rational.   Frankly I can even understand how time in this context can even be considered for a default value.   He is calling a routine that can not be relied upon to return the same value every time so it isn't a default value but rather a variable value.   Personally I think this is a big deal, it just doesn't make sense.\n\n[deleted]\n\nIt is rational within the design of the language.\n\nSee this SE answer\n https://softwareengineering.stackexchange.com/questions/157373/python-mutable-default-argument-why\n\nMaybe a simple warning that your \"def\" has a default being set by a function call would be good enough.   I have to wonder how common this practice is in the real world, it just seems to be an odd way to set a default value to me.   Mainly because there would likely be way to many cases where your default value might have randomness and that to me just blows the whole concept out of the water.   Now there may be cases where a default value set by a function call never varies throughout a programs execution so that might be a pass but then why not use a constant.\n\nMaybe I'm putting to much emphasis on the message that the world \"default\" brings to a definition.   For me is says this is the FIXED value that we have for this parameter at the time of creation, by evaluating this def.   If you want to set it to something else at the time you actually use the function that is find but otherwise the default value will always be this.", "id": "j54kgmd", "owner_tier": 0.7, "score": 0.7529761904464285}, {"content": "I learned this last week with a list \ud83d\ude05\n\n[`dangerous-default-value`](https://pylint.pycqa.org/en/latest/user_guide/messages/warning/dangerous-default-value.html)", "id": "j54zx9h", "owner_tier": 0.1, "score": 0.06845238092261904}, {"content": "BTW: flake8 can warn about these.\n\nhttps://pypi.org/project/flake8-bugbear/", "id": "j565f5w", "owner_tier": 0.3, "score": 0.02678571425595238}, {"content": "I\u2019ve never understood why it\u2019s built like this. Is this a limitation to stay consistent with some greater concept? From a usage perspective I can\u2019t for the life of me see how this is a feature not a bug\n\nbecause functions are created at definition, not execution, and binding of the default arguments can only be done at definition.\n\nIt\u2019s consistent with the way functions are objects and how all objects are treated.\n\nI would be fine with breaking that consistency personally.\n\nThat doesn't fully answer why the language was designed this way, which was the original question.\n\nEspecially since the original post made a point of how another language JavaScript made other decisions that enabled it's behavior to have default arguments recomputed at the invocation.\n\nInstead of binding datetime.date.today() when function is created you could have today_creator = datetime.date.today (or to make it easier to create from the parsed code, lambda : datetime.date.today() and similar for other cases) on function definition and then have something like today=today_creator() if today is None else today on each execution\n\nPython is my first language. I somehow always defined default args in definition instinctively, guess I was lucky to have never come across this nightmare\n\nI don\u2019t think it\u2019s accurate to say that it can only be done at definition\u2026 that\u2019s just how it\u2019s done now. It would\u2019ve been perfectly valid for Python to treat default parameter values as value factories that are used at call-time.\n\nI'm the opposite.   Python should be expanded to either warn or disallow such structures.   To do otherwise blows the whole idea of what \"default\" means in this context.\n\nbecause the parser needs to know what it has to bind to the argument when it executes the def line. It can't just say \"i'll evaluate it later\". The function is an object, and that object has arguments that need to be bound to something when the function definition is concluded. To do so, it must evaluate its argument defaults. The alternative would be that it has to put some form of \"here do it later\", but since it can't differentiate between what is mutable and what isn't, it would end up doing a \"here do it later\" for everything, basically converting every individual argument in an implicit lambda.\n\nBecause it's a different language, Python is not Javascript.\n\nIt's clearly documented that default argument value binding occurs at compilation and not during execution; sometimes it takes a couple of reads for one to understand what that means, other times a couple of runtime 2am debugging sessions, but that behavior is clearly documented.\n\nWhy? Because it was designed like that, planned to behave like that.\n\nAsk Guido if you're still curious.\n\nNo this would not be valid: \n\nhttps://docs.python.org/3/reference/compound_stmts.html#def\n\nThey stated this in bold letters for a reason:\n\n\"Default parameter values are evaluated from left to right when the function definition is executed. \"\n\nI dunno, I'm pretty happy with my IDE or linter issuing a warning: https://pylint.pycqa.org/en/latest/user_guide/messages/warning/dangerous-default-value.html\n\nThe last thing is what I am saying. It is a choice that can happen and in other languages that choice is made. The question is why are these implicit lambdas so bad in Python. That goes back in history to why the language was originally so against lambdas and that made this possibility worse. That is the detailed answer to the question. Just saying it is bound to this variable is a what the language is doing. Saying why it doesn't bind them all to a \"do it later\" because of the development of the language is what the original comment was after.\n\nQuestion: \"why was it designed like that?\"\n\nYour answer: \"because it's a different language\" and \"because it was designed like that\"\n\nDo you see why that doesn't work? Your first answer implies that every design decision for every language must be contrary to the corresponding design decision of every other language, which obviously is not true.\n\nYour answer other answer is like: \"Why does that person have a pencil on their head?\" \"because they have a pencil on their head\".\n\nThe point is, it's fair to assume that this decision was made consciously and based on some reasoning other than \"because we need to do it differently to how JavaScript does it\" or \"just because\". The question is: what was that reasoning?\n\nHere\u2019s some more bold letters for you:\n\n>\tI don\u2019t think it\u2019s accurate to say that it can only be done at definition\u2026 **that\u2019s just how it\u2019s done now**. It **would\u2019ve** been perfectly valid for Python to treat default parameter values as value factories that are used at call-time.\n\nI agree.  Python's behavior has always been crystal clear to me.  And having an IDE, or pylint, or whichever, remind me once in a while that I might be walking too close to a landmine is more than enough.\n\nIt is cool that such behavior is being addressed by a linter but I se this discussion as being slightly different.   I just have a huge problem with random \"default\" values, it just blows my mind.   It is getting late so I can't get into this anymore.\n\nit's a design choice likely dictated by performance. If you delay the evaluation, you will have to perform it every single time, for every single parameter default, for every function call, and due to the nature of python, there's no difference between an immutable argument and a mutable one. It would grind performance down for 99% of the cases for no reason at all.\n\nA general language philosophy (of python, and of design in general) is that you don't pay for what you don't need, and doing so would require you to pay the lambda execution tax for every function call, for every default parameter, for no reason at all especially when the current way already has a strategy to pay the tax when you do need to do so: set None as default, and then check inside the function.\n\nI never implied even subjectively that every design decision needs to reverse or invert any other decision for a different language, that seems like it came out of your own imagination.\n\nI did write that Python's design, both syntactic and semantic, are its own and if you prefer the way that JS behaves then you should be using JS for your coding instead.\n\nAnother reason why what you say that I said is nonsense is that Python appeared several years before JS, so it makes no sense that it would base it's design on JS's, either as a pattern or anti-pattern.\n\nAs for \"what was the reasoning\" behind the way rvalue bindings are done the way they're done for argument default values, go to the source: ask Guido.  I don't channel him, nor do I particularly care why he decided to do it that way, the only thing I care is that I find it clear and transparent, and meshes well with the way I reason through programming tasks, on the other hand I find JS to be nothing but headache inducing.\n\nMy citation is from the Python language reference, so no, it is not \"how it's done now\", it is how the language is specified. \n\nIf some implementation of Python would do it differently, the behavior of functions would suddenly change.\n\nIt is like saying that \"[] == False\" is just how its done now and it would be valid for Python to threat \"[] == True\" in the future.\n\nI don't care about nor know the answer either, I was just pointing out that your response saying 'because x and y' did not answer the question despite clearly being phrased as if it did.\n\nYou are misunderstanding my comment. I\u2019m not implying that this is a change that could be made in the future. Please reread the chain with that additional context.", "id": "j54nmun", "owner_tier": 0.1, "score": 0.35416666663690477}, {"content": "I had a semi-similar issue with [class variables](https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables) not too long ago.\n\nThe sorts of stuff I've been doing up until now, there's been no real need to write my own classes. Then I wrote a class for something recently, and ~~accidentally~~ *mistakenly* instantiated a dict as a class variable.\n\nFrustration and hijinks ensued, but I learnt something new at least.", "id": "j55lrcw", "owner_tier": 0.3, "score": 0.014880952351190477}, {"content": "Update: PEP 671 proposes adding in new syntax for \u201clate-bound function argument defaults\u201d - you\u2019d use `=>` instead of `=`, and it\u2019s currently tagged for Python 3.12 but IDK if it\u2019s likely to stay in or not:\n\nhttps://peps.python.org/pep-0671/\n\nMy original post:\n\nHave there been discussions or PEPs proposing changing this behavior?\n\nIf this behavior were to change, would it be major enough to warrant calling the language Python 4? \n\nGenerally it\u2019s a pretty huge change, but if I were to guess, I\u2019d say more bugs that haven\u2019t been noticed yet would be fixed by this change than code that depends on this behavior would break.\n\nHonestly, the biggest issue with making this change would be people would get used to writing code that relies on the new, logical behavior, and they\u2019d get burned whenever they\u2019re working with an older version of Python for whatever reason.\n\nMaybe `from __future__ import sane_default_arg_behavior` could be required for a few releases, before it switches to being the default behavior (with the future becoming a no-op.)\n\nMy recommendation is use a linter. There are linters that warn if you use mutable default value.\n\nThere was a pep I think for late binding defaults. For backwards compatibility it added new second syntax for late binding defaults and existing defaults would continue to have same behavior. I think changing that behavior is severe enough backwards compatibility change that is very unlikely to happen. Adding a second default type for early binding I did not perceive enough support for given size of that change (especially as it adds even more complexity to method signatures) that I think pep is on pause.\n\n>ode that relies on the new, logical behavior,\n\nWhat is being discussed here is not logical in any form.   A default value is exactly what the word says it is, to try to make that default value variable if foolish in my estimation.   If any thing Python needs to either warn or disallow such constructs as they make no sense at all.  If you make default values \"variable\" then you have a logical inconsistency as now your don't really know what that default value is at any one function call.   So all of a sudden your default values are not actually defaults.\n\nI'm not sure why people have problems with this.   We don't want to be changing the meaning of the word \"default\" here!   The real option is to enforce its meaning.   I'd go so far as to say if somebody wants to argue that variable defaults make sense that they are not looking at this issue logically and frankly have issues creating logical software.   Once aware a programmer should never try to do this in his code.\n\nWhy do you assume the new behavior is logical?\n\nYou realize that it\u2019s a fundamental change to the interpreter. In all other places, if it sees a function call with () and no \u201cdef\u201d, it calls the function, and replaces the call with the result.\n\nYou\u2019re asking the interpreter recognize that in a function declaration (code executed ONCE at function definition), it realize that we don\u2019t want to call the function then, we want it called each function call.\n\nThat\u2019s suuuuper magical for a non functional language. I realize JS does this, but JS is written by a dude who has a love affair with functional languages and has zero issue with \u201cmagic.\u201d\n\nDoing it the way you describe actually breaks convention with the rest of pythons style, even if you find it confusing to grasp initially.\n\nSame thing with mutable arguments. Why wouldn\u2019t python use the same list? The initializer is only called ONCE, at function definition.\n\nI don\u2019t mind people not liking it or finding it challenging at first, but I hate this take of \u201cI\u2019m confused by it becuase I come from a language with wholly different paradigms, so it\u2019s illogical in python\u201d when the issue is just a simple lack of understanding.\n\nThe current implementation is sane.  You define a default as a particular object, it should always be that object.  No if or buts about it.\n\nThere was a PEP recent to add new syntax for it. Changing the existing stuff would be a breaking change, and the Python 2 to 3 migration was a hard slog that came closer to killing Python than we'd like to admit (if it hadn't been for a few key members of the community stepping up, it could easily have gone the way of Perl 6). They won't want to go through that again without a damn good reason.\n\n> You\u2019re asking the interpreter recognize that in a function declaration (code executed ONCE at function definition), it realize that we don\u2019t want to call the function then, we want it called each function call.\n\nExactly like the function body.\n\nFor reference, this was added to JS in 2015, almost 20 years after Brendan Eich created it.\n\nThe function declaration is different than the function body. With a first order function, the definition is run once and then the definition (along with defaults) are saved into the first order object it is.\n\nYou can see said objects quite easily by running an inspect.getmembers on a declared function.\n\nNice, interesting fact I didn\u2019t know. I should\u2019ve stuck with my original example, which is Common Lisp. Thanks!\n\nYes, that's what currently happens. My (rather unclear \u2013 sorry) point was that it would not be illogical to have it the other way.\n\n    # Run now\n    t = f()\n    # Deferred\n    def g():\n        t = f(x)\n    # Evaluated now\n    def h(t=f(x)):\n        ...    \n\nIn Python, `f` is evaluated immediately in the last case, but the opposite behaviour seems equally consistent to me.\n\nIt\u2019s a huge diff for the interpreter. In your first and third examples, the function call is in code that is interpreted.\n\nIn the function body example, that code is not interpreted until it\u2019s run. Feel free to go test this with a plain syntax error in the body of a function. \n\nIt\u2019s also something python is very up front about in the docs:\n\n> Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call\n\nWe're talking about different things. You keep referring me to what Python *does*, whereas I'm talking about what it *might have done*. I know how Python works. My point is that it would be possible for Python to work the other way, without sacrificing logical consistency. (How difficult it would be to modify Python to work this way, I don't know, and is a separate, but related, point.)\n\nI am referring to your parenthesized clause.\n\nAnd yes, I am asserting that doing it in a different way would absolutely break logical consistency for python. \n\nA function call is executed, entered, and replaced with its return at the point it is interpreted.\n\nA function call in a rvalue in an arguments list will necessarily be interpreted at function definition (when executing the def command), as the argument list needs to be processed for validity. \n\nThey could make a special rule for rvalues, perhaps saving the rvalue of a default parameter as an anonymous function inside the first order functions dict, that\u2019s perfectly doable, but it does absolutely break consistency for a language that isn\u2019t functional.\n\nI wouldn\u2019t think it was terrible if they had done it, but I definitely would find it a bit odd - just like I do in Kotlin iirc where they do have the behavior you\u2019d prefer. \n\nIt seems like pointless complexity to me - especially when the whole idea of first order functions in python really was one of the interesting things to me - that a function definition itself is interpreted.\n\nThe reason I find executing a parameter defaults rvalue every time anachronous is simple - I see a function call in an interpreted statement and my mind immediately assumes it\u2019ll be resolved before the rest of the statement. \n\nThat pattern fits most non magic languages as well - and it is logically consistent with how python works in all other areas. The python documentation is quite clear about this as well.\n\nI also don\u2019t take issue with people wishing it was different or not liking it, but I do take issue with the rhetoric that it\u2019s \u201cdumb\u201d or \u201cillogical\u201d as it neglects the whole rvalue thing and how they work in every other part of the language. I\u2019d definitely argue the way it is is more logical, even if people find it unpleasant.\n\nI don't see why the \u2018special rule\u2019 here is any more special than the one that already exists for the body of a `def`. It seems like a completely natural extension to me.\n\nThe body of a def is not interpreted at the time of function definition.\n\nThe parameters are. They have to be in order to store the function.\n\nGiven it feels like a natura extension, I am sure there is a way to use decorators to effectively implement this yourself into every function definition. Slightly more cumbersome, but do-able on your own tbh. There may even be modules which can do this for you already.\n\n> They have to be in order to store the function.\n\nWhy can't we just store the unevaluated code?\n\nThat\u2019s a lot of processing to add on to a call if it\u2019s the entire list.\n\nAs I said in my long post above (did you read it?) they could not process and store unevaluated **only rvalues** and minimize the overhead, but that would still be slightly weird to me as then you\u2019re evaluating every part of the parameter list **but** the rvalues and you still have my initial complaint of breaking the visual of seeing a function call (`()`) that is **not** evaluated where it\u2019s written.\n\nIt\u2019s a very functional-language paradigm - which is why it\u2019s standard in CLisp and JS, but I find it weird when it\u2019s in non functional languages, like Ruby or Kotlin.\n\nOK, thanks for explaining.\n\nI think something important here is how python actually stores objects and saves them in memory. Objects end up just being pointers to values. And as you say a function call returns an object which points to a value upon interpretation. If that object is mutable, it \u201cerases\u201d the old value and replaces it with the new one. So the next time that default object gets used again, it is really just pointing to the new value.\n\nI feel like this part could help explain why it is such an unnecessary overhead for OOP to people. Of course it could be different, but then the base language has to do more. Current implementation allows for developer flexibility imo which is nice", "id": "j55nkgd", "owner_tier": 0.7, "score": 0.11904761901785714}, {"content": "So I'd offer a slightly different perspective here - the underlying problem isn't about default argument behavior, but a misunderstanding of Python syntax. When you write `datetime.date.today()` that `()` at the end isn't decorative, it is specifically telling the interpreter \"call this function now\". Python functions are first class objects, so if you want to save a function to call later, you just stick the function in a variable. \n\nSo if I was writing this kind of routine, the idiom I'd use would be something like `def myfn(blah blah ..., today=datetime.date.today, ...)`. Then in the function body you check if `today` is callable, and call it if so to get the value.\n\nThe problem here is that you are creating a def not actually calling a function and default values make no sense at all if people think they can be variables.   If you want a default value make is so such as today=2023-1-20\" or whatever makes sense.   If you try to call a function then you have no idea what the return value will be thus not logically a \"default\".\n\n    def foo():\n        datetime.date.today()\n\ndoesn't call `datetime.date.today` at function definition time, but\n\n    t = datetime.date.today()\n\ndoes. When one sees\n\n    def f(t=datetime.date.today()):\n        ...\n\nit's not unreasonable to assume that the evaluation of the default is deferred, like the first case, rather than the second. After all, it's part of a `def`. Yes, the brackets mean \u2018call this function now\u2019, but when \u2018now\u2019 is varies with context.\n\nIt gets called at definition time.", "id": "j55p52h", "owner_tier": 0.1, "score": 0.074404761875}, {"content": "Yup. The pattern to stick to here is to use only literals, and maybe module-scoped constant values, as argument defaults. In all other cases, use `None` and check-and-set the argument in the function.  For better or worse, Python lets you modify a parameter at runtime which makes for succinct cleanup of arguments:\n\n```python\ndef fn(a = None):\n    a = \"hello world\" if a is None else a\n```\n\nI want to use `a = a or \"hello world\"` but that is fraught with side-effects.\n\nNo. strings are immutables in python. It's perfectly safe to write\n\n    def fn(a=\"hello world\"):\n        foo(a)\n\n\u201cstick to literals\u201d is not good advice. List and dictionary literals would be problematic as default parameter values since those are mutable types. Ironically the example you\u2019ve given here could be simplified by just using the string literal as the default since strings are immutable. The key is to not use mutable values as defaults. It doesn\u2019t matter if those values are created via literals or otherwise.", "id": "j55x70k", "owner_tier": 0.7, "score": 0.02678571425595238}, {"content": "for the blog and readers sake, wouldn\u2019t it be helpful to discuss alternative behaviors snd fixes such as:\n\n* rename \u2018today\u2019 to \u2018day\u2019 as a param but don\u2019t set the default value and\n* specify the value when calling the function \n\nsince the docstrings weren\u2019t provided for all we know the original intent is such that the implementation of always defaulting to today is correct and users should specify an alternate day if looking for future days.\n\nFunctionally they are trying to make a default value a variable and this just cranks me in the wrong direction.", "id": "j55gqoq", "owner_tier": 0.5, "score": 0.023809523779761903}, {"content": "I love python. It's great and I've used it to do work I'm really happy with.\n\nBut I still hate the way it's always pass by reference. I've seen all the reasons why it's logical and good. I know how to deal with/use it correctly. I know there are some upsides.\n\nI don't care, I still hate that part of Python.\n\n(btw, I've learned that what python does isn't *exactly* what would properly be called \"pass-by-reference\". Fine, but that distinction isn't really relevant to my hatred for it.)\n\nEdit to clarify: The connection to OP here is that, because functions are created at the time they're defined, the behavior OP is talking about is a consequence of pass-by-reference.\n\nEdit 2: I love the downvotes for \"I like python a lot but *one single feature* isn't my favorite.\" quick guys, shun the ~~nonbeliever~~ slightly-less-than-absolute-zealot! Get him! None of us should ever have the slightest criticism! \ud83e\udd23\n\nWhat are you using that doesn't do things like this? C or C++?\n\nI can't think of a language I've used that isn't passing the \"reference-by-value\".\n\nI would say that the distinction between pass by reference and Python\u2019s behavior is actually important. The behavior only resembles pass by reference when using mutable values\u2026 strings, integers, tuples all behave like \u201cpass by value\u201d for this reason.\n\nNot in my mind.   It is because the \"def\" for the function creates those values when evaluated.   This is not when a function is executed.   Defaults are thus fixed values that are created in the absence of supplied values, from the original def.   It makes no sense at all that they would be variables as the definition has already been created.\n\nThe only one I can think of that passes-by-value is Pascal... and I haven't programmed in that in over 30 years.\n\nMost languages pass by value, and some (like C) let you achieve pass-by-reference by using pointers or something that achieves the same effect.\n\nMaybe it's just my particular experience, but no language I've used besides python passes everything by reference, such that any change to a mutable type is visible to the caller without explicitly returning the new value.\n\nI'm not sure what you mean by \"reference-by-value\". Did you just mix up terminology there, or is that something I'm unfamiliar with?\n\nThat's true, and also irrelevant to how much I dislike this aspect of Python. \n\nI also think it's kind of a pointless distinction. Sure, if I pass a tuple, it's passed by value... But if it were pass by reference I wouldn't be able to mutate it anyway, because it's immutable, so who cares?\n\n>It is because the \"def\" for the function creates those values when evaluated. This is not when a function is executed. Defaults are thus fixed values that are created in the absence of supplied values, from the original def.\n\nYeah that's exactly what I said.\n\n>It makes no sense at all that they would be variables as the definition has already been created.\n\nI'm not sure what you mean. The variable containing the default value is created at define time. Because it is passed to the function *by reference*, any mutation of it will be visible in later calls to the same function, *because the function is provided a reference to the variable, not simply a new variable with a copy of the original value*, which is the standard calling behavior in python.\n\nI think we must be using different terminology. Almost all languages are pass-by-value by default. C is pass-by-value.\n\nWell, if the elements of the tuple are mutable, they can be modified. The reason it seems like a pointless distinction is because neither term really describes what\u2019s happening here, they\u2019re just trying to describe the observed behavior in terms of concepts in other languages.\n\nThe mechanics of passed arguments is consistent regardless of type or mutability when you understand that arguments are just assigned to their corresponding parameters\u2026 due to the fact that Python doesn\u2019t really have \u201cvariables\u201d and only has \u201cnames\u201d that point to \u201cvalues,\u201d the apparent effects of that do seem to vary depending on type behavior.\n\n(But to the question of \u201cwho cares\u201d\u2026 passing a reference vs an immutable value is an important distribution because the memory footprints vary between the two methods. I don\u2019t often care about memory usage when I write Python though.)\n\nPossibly. I had to Google quickly to refresh myself on this topic... What I came up with is that most languages *do something more complicated: they pass primitive types by value and class types by reference.*\n\nYeah I get all that. I know it's entirely self-consistent. I know it's not *actually* pass-by-reference.\n\nThe thing is, I really don't care about what it's called. I'm not against pass-by-reference as a concept, and telling me this isn't pass-by-reference isn't going to make me like it. My dislike for it isn't *because* it's pass-by-reference. \n\nI don't care what it's called. I don't care if it's consistent. **I just don't like it**.\n\nMaybe, but seems weird to me. I don't write heavily OO code.\n\nRegardless, doing this with primitive types is certainly not typical.\n\nI don\u2019t really like it either, especially after working more with systems languages. I definitely prefer a C-like model with very straight forward mechanics.\n\nPassing everything by value is expensive (computationally). The compiler or interpreter has to make a copy of everything that gets passed. If you pass a reference instead, you're only passing a pointer which is \"cheaper\". \n\nThough if you are a Functional programmer, you'd be be quick to point out that passing-by-reference (despite being cheaper) can be \"side-effect-y\", if you're not careful.\n\nThe programming language, Rust, still does pass-by-reference, but it avoid side-effects by transferring ownership of the reference from the passer to the passee (the function that it was passed to). And if the passer is expecting it back, it is the responsibility of the function to return it.\n\nIt's a clever idea which we don't see implemented much in programming languages which I think we might see adopted more in the future.\n\nYeah exactly. I hate being surprised by it, and it just never feels natural to constantly work around it. What Amy I gonna do, copy.deepcopy every input argument *just in case*? I'd love python more if it simply didn't do that.\n\nIt's not just \"systems languages\" that don't have this behavior, either. I really can't think of any language I've ever used that does this. C, Java, Matlab^{shut up it counts}, a weird proprietary variation of Pascal, hell even bash... I feel like I'm forgetting many more languages I've used over the years.\n\n>Passing everything by value is expensive (computationally). The compiler or interpreter has to make a copy of everything that gets passed. If you pass a reference instead, you're only passing a pointer which is \"cheaper\".\n\nYeah absolutely. I understand the benefits of pass-by-reference, and I use and like it it where appropriate. My issue isn't with pass-by-reference *in general*, it's just with the way python does it for any mutable type, so the common pattern where a value is provided to a function and then modified but not intended to be returned will cause surprises. For example, you pass a list to a function and pop elements out of it in a loop that handles each element. Obviously there are ways to write that which play nice with python, I realize this isn't an unsolvable issue. It's just annoying and hasn't become natural to me despite writing python for many years. \n\n>The programming language, Rust, still does pass-by-reference, but it avoid side-effects by transferring ownership of the reference from the passer to the passee (the function that it was passed to). And if the passer is expecting it back, it is the responsibility of the function to return it.\n>\n>It's a clever idea which we don't see implemented much in programming languages which I think we might see adopted more in the future.\n\nI didn't know that, that's a very cool idea. Rust isn't really an option for me but I'd like to see that become more common.\n\n> value is provided to a function and then modified but not intended to be returned will cause surprises\n\nYup, that's exactly what I meant by \"side-effect-y\". You got it!\n\n> Rust isn't really an option for me\n\nYeah, same boat. I'm starting to dabble in Rust, but I haven't tried to write anything real yet.", "id": "j556c27", "owner_tier": 0.7, "score": 0.074404761875}, {"content": "The fixed code has a new issue though: `today` is now recomputed regardless of default value, so supplying a default value for today will only ever compute the actual current date and time.\n\n    def is_ongoing(self, today = None):\n        if today is None:\n            today = datetime.date.today()\n        return (today >= self.start_date) and (today <= self.end_date)\n\nWhich is what I needed. That method wasn't used anywhere else, there was no need for the default argument in the first place. Probably some overlook by the original authors of the code.\n\nRight but if the previous code failed because it wasn't well tested, will your new code be any more testable?", "id": "j56bh7k", "owner_tier": 0.7, "score": 0.029761904732142856}, {"content": "Crappy programmer is also bad at writing articles.", "id": "j56ym45", "owner_tier": 0.7, "score": -2.9761904581027647e-11}, {"content": "If you use a linter like pylint [it'll tell you about it every chance it and you won't have to relearn](https://pylint.readthedocs.io/en/latest/user_guide/messages/warning/dangerous-default-value.html#dangerous-default-value-w0102)", "id": "j56khf6", "owner_tier": 0.7, "score": 0.008928571398809523}, {"content": "They are not \"retained\". They exist under the same scope as the function.", "id": "j56kkta", "owner_tier": 0.7, "score": 0.008928571398809523}, {"content": "Your tools should warn you if you use a mutable default argument. If not, what are you using to write code?\n\nMany of the \"issue\" posts i see can be resovled through tooling. Though, of course, it is not _guaranteed_ to work due to the dynamic nature of Python, and I accept that the tools are not perfect.", "id": "j576amr", "owner_tier": 0.5, "score": 0.008928571398809523}, {"content": "Welcome to the Late Binding nightmare my friend. We all been there. \n\nTip for life. Don't assign data structures like {} or []. \n \nPass none and assign inside functions :)", "id": "j57ami9", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "Today I learned more about functions and methods!", "id": "j57uhmc", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "Could wrap it in a lambda", "id": "j588cpq", "owner_tier": 0.3, "score": 0.008928571398809523}, {"content": "Between \"function calls\" right, not between \"executions\"?", "id": "j588un3", "owner_tier": 0.3, "score": 0.008928571398809523}, {"content": "This blog's title doesn't really describe the behavior correctly.  I'd state it like, \"A Python function's default argument values are evaluated when the function is defined, not when it is invoked.\"", "id": "j58buwk", "owner_tier": 0.3, "score": 0.008928571398809523}, {"content": "Lesson learned: If you're not going to use an IDE, use a good linter. A good linter would warn about this.", "id": "j59edix", "owner_tier": 0.9, "score": 0.008928571398809523}, {"content": "Welcome to the club!  \nBTW, thank you for the time-machine package suggestion, looks pretty helpful.", "id": "j59pvh7", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "My takeaway from this is to not use default values for arguments? I'm new to python but have written code in other platforms and have never used a default value for a parameter in a function. Thoughts from experienced python coders?\n\nIf you want to do something like this, use a default that is not a valid value (usually, but not always None), and then check for that value within the function, and call/compute the value within that test. This also goes for \"collection\" objects like lists and dicts. \n\n\nIf you can't use None, you can create a new object, and use that for the default like this:\n\n```\nDEFAULT_VAL=object()\n\ndef func(param1=DEFAULT_OBJECT):\n    if param1 is DEFAULT_OBJECT:\n        param1 = calc_default()\n    ...\n```", "id": "j5abxu8", "owner_tier": 0.1, "score": 0.011904761875}, {"content": "For more of Python\u2019s fun stuff https://github.com/satwikkansal/wtfpython", "id": "j5aftk5", "owner_tier": 0.1, "score": 0.008928571398809523}, {"content": "Some people said to me python not very important right now\nBecause it is not required for work shop", "id": "j5e3upt", "owner_tier": 0.1, "score": 0.008928571398809523}], "link": "https://www.reddit.com/r/Python/comments/10gt7tv/today_i_relearned_python_function_default/", "question": {"content": "", "id": "10gt7tv", "title": "Today I re-learned: Python function default arguments are retained between executions", "traffic_rate": 207.9358484294499}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "Also, a great way to speed up your code with memoization while making your linter and people reviewing your code super angry.\n\n    def fib(n: int, cache: dict[int, int] = {0: 0, 1: 1}) -> int:\n        if n not in cache:\n            cache[n] = fib(n-1) + fib(n-2)\n        return cache[n]\n\nyou can then save the cache and loaded it on later executions of the app\n\n```\nimport pickle \n\nfib(100)\ncache = inspect.signature(fib).parameters['cache'].default\n\nwith open('saved_cache.pkl', 'wb') as f:\n    pickle.dump(cache, f)\n\nwith open('saved_cache.pkl', 'rb') as f:\n    inspect.signature(fib).parameters['cache'].default = pickle.load(f)\n\nfib(101)\n\n```\n\nthis is cursed\n\nUsed this once because I needed memoization in a test mock. It didn't pass review. I honestly love my colleagues that they don't allow me to use these abominations.\n\nI don't see what's the problem\n\nOk fib(-1)\n\nLolz\n\nfib(-1)\n\nOr you know \n\n@cache from functools\n\nPoor man's `@functools.cache`\n\nAnd idiots say python is slow\n\nThis is absolutely disgusting, I love it\n\nGoddammit!\n\nNo, it is recursed\n\nGreat! I've got some PRs for you to review...\n\nThat don't works with `__slots__` :(\n\nIn the serene expanse where code flows like a gentle stream, a novice once sought the wisdom of the old master. \"Master,\" the novice inquired, \"I have crafted a function, sparing and pure, devoid of the standard library's embrace. Yet, they call it the 'poor man's functools.cache.' Have I erred in my simplicity?\"\n\nThe master, whose eyes reflected the calm of a thousand silent programs, smiled and said, \"In the village, a potter molds clay into a vessel. With the void inside, the vessel serves its purpose. Is it the clay that gives form, or the emptiness within?\"\n\nBaffled, the novice pondered. \"Master, what does a potter's craft teach us about my code?\"\n\nThe master replied, \"Your function, unadorned by the standard library's excess, is like the vessel, shaped not by what is added, but by what is omitted. True elegance lies not in accumulation but in the mindful subtraction. The potter's wheel turns, and with each removal, the utility emerges. So is your code, a testament to the enlightened path of simplicity and purpose.\"\n\n\"In its restraint,\" the master continued, \"your code becomes a mirror, reflecting the essence of what it seeks to accomplish. Like the ascetic who forsakes worldly excess for inner clarity, your function stands, not poor, but profoundly enlightened, embracing the Zen of less.\"\n\nThe novice bowed deeply, the fog of doubt clearing. In the vessel of simplicity, he discovered the profound depth of enlightenment, where the true essence of code\u2014and life\u2014resides.\n\nThe less disgusting way is to use function decorators or custom classes.\n\n\nhttps://cachetools.readthedocs.io/en/latest/\n\nthis is cursed\n\nThis made me laugh like an idiot. Thanks!\n\nGood one\n\nGood one\n\nLGTM\n\nalso at least something like json instead of pickle, first because I avoid pickle like the plague due to ACE issues, and second because having things in a somewhat human-readable-human-debuggable format is valuable for the inevitable case where something goes wrong.\n\nNo, it is recursed\n\nHappy Cake Day!\n\n> ACE issues\n\nYeah, this is a big problem with pickle for folks not in-the-know (ACE is arbitrary code execution, loading pickles executes python code and imports and can do very weird stuff). \n\nI tell folks the only true **proper** use of pickle is to serialize data to/from a concurrent process with the same execution environment (basically multiprocessing on the same host), or debugging (e.g. dump out some program state to pull it into a notebook to interrogate it).  Any time the program starts/stops or crosses an environment boundary, you're way better off with a proper de/serialization protocol.\n\nbreak\n\nr/recursion\n\nThis is cursed\n\nthis is cursed\n\nthanks\n\nError: keyword 'break' is invalid in the current context\n\nMy reply [is here](https://www.reddit.com/r/programminghorror/comments/1bu14pi/be_careful_with_default_args_in_python/kxqlprb/)\n\nthis is cursed\n\ncontinue\n\nMy reply is [here](https://www.reddit.com/r/programminghorror/comments/1bu14pi/be_careful_with_default_args_in_python/kxrax4j/)\n\nNo, it is recursed\n\npanic!()", "id": "kxpv052", "owner_tier": 0.5, "score": 0.9999999999968344}, {"content": "This is basically the first Python gotcha\n\n[deleted]\n\n[deleted]\n\nWhen using a proper IDE, you'll be warned about this pattern too. Unfortunately juniors tend to ignore those annoying squiggly lines because why pay attention to a warning if your code runs right? If it runs, that must mean that it has to be correct otherwise it wouldn't...\n\nYup. This is literally question on junior developer interview\n\nIt's also caught by every python linter.\n\nPython is relatively gotcha free, but this is one for sure.  I usually stub my toe once a year or so on this one.\n\nIt's safe with atomic types like `int`.\n\nI thought indentation is\n\nYeah, that's basically common sense 101... (obviously /s)\n\nI\u2018m 9985\n\nWhat coke and mentos thing?\n\nThat was my first one actually, probably day 1 of Python\n\nI love how this hinges on proper IDE. Meanwhile I've never seen this in any IDE I've used. Must be because I use lightweights. Edit: specifically warnings about mutable objects passed as arguments to a function or method.\n\n> proper ide\n\naka let the magic black box do the thinking for you\n\nFor real? Ive never tried python but is that in their docs or something?\n\nEdit: its is in most linters docs\n\nPut Mentos in coke and you'll see.\n\nGet a big 2L bottle and a pack of mentos\n\nMentos rough surface makes it easier for coke to form co2 bubbles significantly faster and make a nice fountain\n\nIt's really fun to drink Coke with mentos in your mouth\n\nPyCharm has this warning, as well as many linters do. \n\nYou should be using linters for serious programming regardless of the IDE (and enforce them in CI).\n\n>aka let the IDE take care of the generic and abstractable stuff, so you can focus on your business logic\n\nFTFY\n\nOtherwise, why care about compiler warnings at all? You are the programmer, you do the thinking, right?\n\nIt\u2019s described in the Python docs here:\nhttps://docs.python.org/3/reference/compound_stmts.html#function-definitions\n\nI'd expect any professional python programmer to know this.\n\nI was surprised to find out that this is not a chemical reaction in the same way that baking soda and vinegar is. It's entirely a physical reaction that, as you said, forces the soda to foam up because the surface of a mentos is rough. Something similar happens when my fiancee uses a particular reusable straw in sparkling water.\n\nSo it might work on Alka Seltzer tablets also?\n\nWell, that's my mistake for thinking an IDE was what was meant, not a linter.\n\nyeah but when youre a beginner you shouldnt rely on them, because they might say that its bad but they dont explain *why* its bad\n\nThanks!\n\nPossible\n\nIs it unreasonable to expect a \u2018proper IDE\u2019 to have a good linter? It\u2019s one of the things that sets an IDE apart from a text editor, after all. While a linter does not have to be part of an IDE, I would expect an IDE to always have a linter (at least in the modern day).\n\nWhen you're a beginner you should not get bogged down in intricacies and specifics. That is the most important time to focus on logic flow and ability and Theory. Once you start understanding the theory you can start applying advanced issues. This specific problem is python a python one learning how to code around that might make you a worse programmer in other languages. My opinion learning a tool come second\n\non the contrary, linters for java taught me a whole lot when I was still learning the language. all you have to do is search up why it's complaining about something and you understand what exactly you did wrong.\n\nNot unreasonable. I was just a little too literal, even for a room full of programmers.", "id": "kxpmt7q", "owner_tier": 0.5, "score": 0.796771130101298}, {"content": "> never use mutable default values in python\n\nPyCharm and every linter I know warns about this exact thing.\n\nShouldn't be an issue in the first place though\n\nWhat\u2019s next? Strict types? /s\n\nI'm trying to think of a \"it's a feature, not a bug\" use case.\n\nDrawing a blank.\n\nWake up babe new PEP just dropped\n\nFor the record, the usual workaround (if you need to construct a mutable object as default argument) is to do this:\n\n    def list_with_appended_value(val, existing_list=None):\n        if existing_list is None:\n            existing_list = []\n        existing_list.append(val)\n        return existing_list\n\nOr if \"None\" must also be a valid argument, where there's a will there's a way:\n\n    _DEFAULT = object()\n    def foo(val=_DEFAULT):\n        if val is _DEFAULT:\n            val = [123]\n        # do something weird...\n\nThere's also the approach to pop off kwargs but I'm not so much a fan of that as it can obscure the function signature somewhat\n\nWhat approach do you suggest they use?\n\nPlease, I need them\n\nWhat do you mean by \"strict\"?\n\nWhat do you mean by \"strict\"?\n\nWhat do you mean by \"strict\"?\n\nWhat do you mean by \"strict\"?\n\nIt's more so a fairly obvious optimisation that breaks down for mutable default arguments.\n\nIt's fairly unusual to have mutable arguments as default values anyways, linters and IDEs will warn about it, you can work around it with factory functions if needed, and ultimately the trade off of having them be singletons is worth it for the generic case because it works more often than not.\n\nThe implication for them _not_ being singletons is that you have to evaluate extra code on every function invocation, instead of just pushing some args onto stack and jumping into a function. Basically you turn each function call into X+1 function calls, where X is the number of default args in the signature.\n\nI think it's more of a necessity that comes out of syntax and language properties. Don't know why exactly, but that's my guess\n\nBehave like JS: treat the default argument as code and run it every time a default value is needed, instead of running it once when the function is created. Of course, at this point, changing the behavior would be more trouble than it's worth.\n\n\u201dWe made this cool, straightforward scripting language where you don\u2019t have to worry about types! It just works\u201d\n\n\u201dOh no, types actually have a point! Quick, let\u2019s add them as a library!\u201d\n\n- Devs of every fashionable language\n\n`from typing import Sequence, Mapping`\n\n\nUse them in type hints and your IDE will prevent you from mutating the list/dict.\n\nThat's called Kotlin\n\n    a = [\u201cb\u201d, 2, False, func]\n\nvs\n\n    const a: number[] = [1, 2, 3, 4]\n\nIt's this. It's because the default argument is an expression that is evaluated at function creation time.  A lot of parts of python are eagerly evaluated in places where more static languages  would have \"special cases and provisions\" with language syntax.\n\nNot in python. It's all evaluated as statements and expressions.  This goes for module definitions, class definitions, function definitions, decorators, etc.\n\nIt makes it very easy to do higher order programming, but that's the trade off. Practically, all you gotta do is remember:  \\*Python does not have declarations.\\* What looks like a declaration from another language is just syntactic sugar in Python.\n\nThat would result in a big performance penalty. It would also make runtime introspection difficult if not impossible.\n\n[deleted]\n\nMost of these languages start out as something simple to use/easy to learn and for some specific things (JS for browser API, python for scripting etc), then people want to use these languages for absolutely everything and we have these \"bloat\" issues\n\nYou could just do\n\n`a: list[int] = [1,2,3,4]` and you'd get lint warnings if you do actions that treat the content as non-ints.\n\nIt's almost as good as static typing as far as development experience goes.\n\nThe common case of strings, ints, bools etc could still be optimized the exact same way. What do you mean about runtime introspection?\n\nNo more performance penalty than passing the value normally, which evaluates the arguments every time anyway.\n\nScala <3\n\nDevelopment/IDE, yes. Runtime, not so much...\n\nYou could also use [beartype](https://github.com/beartype/beartype)\n\nThe default argument has no performance penalty.\n\nIn fairness, the Typescript example is still prone to errors in runtime since it doesn't actually check while it's executing, especially when mixing JS/TS or assuming a particular structure from a server response. You need real type safety like C++, where it will just crash if you ever have the wrong type\n\nI mean that `some_function([])` already evaluates the argument every time, so why would doing it for default arguments too be so much worse?\n\nIf types are worrying in c++, your code won't compile. There's no crash.\n\nThe performance difference is large, because you have to allocate a new object every time. The difference is\n\n    # how python does it\n    DEFAULT = [1, 2, 3]\n    def f(arg=DEFAULT):\n        return g(arg)\n\nand\n\n\n    # how js does it\n    def f(arg=None):\n        if arg is None:\n            arg = [1, 2, 3]\n        return g(arg)\n\n\nThe difference is that it g does not mutate its arguments, f is far more efficient since it's just reusing the same allocation. But, as this thread points out, if you return the default or mutate it, it's a big gotcha, so safety over efficiency should probably have prevailed here.\n\nFor mutable arguments it makes no difference, but for immutable arguments there's a performance penalty, and that's the more common case.\n\nLet me try to rephrase this. Let's say I've just designed a new scripting language, and I give it to you to test out. You write some sample code:\n\n    def append123(values):\n        values.append(1)\n        values.append(2)\n        values.append(3)\n        return values\n\n    def make123():\n        return append123([])\n\n    print(make123())\n    print(make123())\n\nYou reasonably assume that this will print\n\n    [1, 2, 3]\n    [1, 2, 3]\n\nbut are shocked to see that instead it prints\n\n    [1, 2, 3]\n    [1, 2, 3, 1, 2, 3]\n\nYou ask me what gives. I explain that function arguments are cached for performance, and you should have written some extra code if you wanted it to generate a new list every time. You beat me unconscious with a baseball bat.\n\nObviously, caching explicit arguments for performance is completely insane. If you wanted the argument cached, you would have cached it. I think that default arguments should behave the same way.\n\nOk, I see the point you're making now. In that case, you're right, it wouldn't be worse performance than just using positional arguments, but it's still slightly faster than evaluating the default argument each time. \n\nI don't think performance was the main reason for this decision, though. It's more that this follows naturally from how Python is interpreted - the function signature is evaluated once at runtime, as if it were a scripting command (which it basically is). Handling keyword arguments differently would require either completely changing how function definitions work under the hood, or else adding a bunch of special case code to be run for each keyword argument, which would have a much higher overhead than just evaluating the argument more than once.", "id": "kxplvoe", "owner_tier": 0.3, "score": 0.5045900601424502}, {"content": "Still, the point is to never mutate arguments. Ever. Why would we want to mutate an object when we do not know:\n- whether its state is relied upon somewhere else\n- whether it is being mutated somewhere else\n- who has created it and for what purpose. \n\nIn very high level languages, there are seldom good reasons to mutate arguments, and if you get to one of them probably you already know about this behavior.\n\nThat's the correct answer.\n\nThis python qwerk is only a problem if you are already doing something wrong.\n\nIn real high-level languages, you don't pass by reference. You use return values to get data back to the caller. Or at least annotated arguments which are pass by reference.\n\nHave a look at Ada, which illustrates just how long we have had good solutions to this problem. Or more modernly Elixir or Zinc.\n\nIsn't this only if you do functional programming? Say I want to (manually) sort a list; Isn't it much easier/less memory intensive to sort the list, than to copy it and return a new, sorted list?\n\nYeah like what is this person talking about. That is how I would expect it to work because why tf would you be trying to change a default argument? Like sure you can think of a reason to do so, but that seems like terrible practice even if it was allowed...\n\n... which is why a modern language that does not really care about performance in the first place should probably just make arguments immutable (or by value) by default.\n\nAgreed, it's usually not great practice to modify arguments, so this problem is super niche.\n\nI see you also have some qwerks sir (:\n\nquirk\n\nAda is annoying and I hate it. I will never again work in the stupid UK defense industry with it's stupid Ada legacy codebases.\n\nYou\u2019re totally correct, but the overhead of a single redundant copy usually isn\u2019t that big of a concern if you\u2019re using a high level language. The maintenance overhead of possibly introducing a bug by mutating the argument is usually going to be much bigger concern.\n\nThat would then be implemented as a method on the list, like python list.sort, it to the no mission guidelines, like python's sorted(list)", "id": "kxq6jor", "owner_tier": 0.1, "score": 0.10541310540993985}, {"content": "> JS/TS [...] as I'd expect\n\nAh yes, the programming languages which are famous for not being a bunch of weird behaviours and side effects glued together.\n\nHow did Python manage to implement something so basic worse than them?\n\nI still can't get over the fact that `this` does not mean \"this class\" in JS, leading to the stupid line [let self = this;](https://stackoverflow.com/questions/962033/what-underlies-this-javascript-idiom-var-self-this) being a common solution.\n\nI think it was just the easy path way back when it was being developed (I think this would have been python 1.x or even earlier), give python's bytecode and data model under the hood. Basically, create an object when the function is evaluated, and point to it. If you mutate that object, that's on you. No different than\n\n\n```\nfoo = []\ndef func(x, a=foo):\n\u00a0 a.append(x)\n```\n\n\n\nThe alternative is either a) you have to basically re-evaluate the whole function block or b) re-evaluate the function signature but make sure it's consistent with anything else in the scope. Both are really gnarly and can lead to other bugs, so it's basically pick your bugs.\n\n\nPersonally, I'd let Type objects (classes so to speak but I'm being precise) define a classmethod dunder like `__default_factory__` which the parser can look for when parsing args and use that for each function call. But then that also requires hacks if you want to actually do caching.\n\nRight.  JS has some weird stuff with string interpolation, but you can avoid it pretty easily.  But this ONE thing in python feels so much more painful because its EVERY FUNCTION.\n\nIn all fairness to python, mutating arguments is already bad practice so this shouldn\u2019t come up a whole lot.\n\nI\u2019m guessing they decided that not having to initialize the object on every function call was worth it when you shouldn\u2019t need a new object every time anyway.\n\nTo be fair, it is the only consistent way, that doesn't have undesirable side effects.\n\n\nFor consistency, the default arguments have to be evaluated either at definition time or at invocation time. The latter represents unnecessary repeated overhead for the common case of immutable values. The first case can be extended easily by using factory functions as arguments.\n\n\nIt also enables the pattern of\u00a0\n\n\n\u00a0 \u00a0 for x in range(10):\n\u00a0 \u00a0 \u00a0 \u00a0 def callback(x=x):\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ...\n\n\nto explicitly distinguish between capturing the changing value of the loop variable vs capturing the value at a given iteration.\n\n\nBoth behaviors are somewhat unexpected and have bitten me in the past. But I can't think of a way to make it more.ovbious that won't have undesirable side effects such as higher function call overhead or complicating the scoping semantics.\n\n\nThough admittedly, I'd love for Python to have block scoping like JavaScript... Would make handling overgrown \"do x then do y etc\" functions easier to manage and refactor.\u00a0\n\nIn modern JS you would just use arrow functions to maintain the this context. JS this is very weird at first but once you start thinking about it in the correct ways (this refers to the object on which a function was called on, which is also how it works with other languages) it should be less confusing.\u00a0", "id": "kxq0v7d", "owner_tier": 0.7, "score": 0.09275087052548274}, {"content": "That's why you DON'T use mutables as default args and every Python linter will scream at you for doing it\n\nDoesn't make it any less horrific", "id": "kxqcb7r", "owner_tier": 0.3, "score": 0.015827793602405823}, {"content": "I have written python professionally and never encountered this, wow.\n\nEDIT: I'm realizing now it's because I don't mutate, lol\n\nMe too! I noticed only because I read the documentation\u2026", "id": "kxqdsdv", "owner_tier": 0.3, "score": 0.014245014241848685}, {"content": "Damn, that is pretty bad lol", "id": "kxpj09u", "owner_tier": 0.5, "score": 0.04590060145299145}, {"content": "The takeaway is correct, and this is really one of the _very few_ gotchas you have in Python: https://docs.python-guide.org/writing/gotchas/\n\nIt's because default arguments are evaluated during function definition, not function execution.\n\nBut why? Because evaluating default args during function _definition_ makes it much easier to grok what the context is during evaluating the default arg, (In this simple example with an empty list it doesn't much matter, but it could also be a function call or something else, and then the context can indeed change. See the discussion here: https://softwareengineering.stackexchange.com/questions/157373/python-mutable-default-argument-why)\n\nThat feels closer to after the fact rationalization of an obviously wrong design decision by fan boys than a legitimate argument. \n\nIt's definitely not more complex to implement or reason about considering the implementation could just have been the workaround everybody now does as syntactic sugar.\n\nas a developer with 25+ years of experience in a ton of languages including pascal, asm, c, lua, java, perl etc I never used python before but I always heard good things about it as a scripting language e.g. to make life easier instead of writing a bash script or something or as a beginner language\n\nqueue wanting to teach my kid their first programming lessons and thinking well python seems like a good choice...\n\nMe fighting with spaces, tabs, and indentations 99% of the time and trying to explain (even with an IDE) \"yeah you see the computer only understands this if you build perfect pyramids\" is BULLSHIT\n\nI will not touch python with a ten feet pole - I thought perl was hardcore but python is STUPID - why did they think begin/end or brackets was too good for them?\n\nHow many CPython patches have you upstreamed that deal with complex nuances like this?\n\nI\u2019ve found it one of the easiest ways to get people into programming, and while I agree with you, the no-bracket style tripped me up at first, it\u2019s also fastest zero-functional scripting I\u2019ve ever done. I wish I was introduced with Python instead of JavaScript\n\nThe indentations are annoying but they are there to help you...\n\nNone. Why would i be contributing to CPython? Also, isn't the quality and state of that code-base kind of a self-own? Python can't implement what other languages can because our main interpreter is just such a shitty fragile piece of shit code-base, it will be very hard to do something that even a basic syntax pre-processor could do. It would hard to make illegal, what every linter already makes illegal by default?\n\n**Options they had:**\n\n(a) implement it as an AST to AST transformation\n\n(b) not implement default arguments at all\n\n(c) not allow mutable values as default arguments\n\n**Right now, every company in the world uses a linter to enforce (b) or (c).**\n\nMaybe the people that build linters should work on a python interpreter since they are such fucking geniuses that were able to pull that off! And not just one of them. All of the linters support this! And the Ruby people, and the Javascript people .. every other language in the world pulled this off, but somehow it's the rocket science engineering of CPython, that we all just wouldn't understand the complexities of!\n\nSeriously, an AST level transformation of a default value in a function signature to an initialization statement is not that fucking complex. Shit, you can cover 99% of the use cases with a freaking regular expression! \n\nI can't imagine that's the true reason, because i can't imagine the CPython developers to be that incompetent. I'm fairly sure it's the pathetic \"python fanboys\" that are too incompetent to understand it, and the actual engineers would likely just admit it was a design mistake. Obviously they aren't in this thread, nor are they in the on stack overflow answering these questions. \n\nPython isn't perfect; this is objectively a mistake and you are just gaslighting.\n\nIt is hard to explain to a beginner if I already struggle with the logical reasons for it.\n\nMeanwhile, I found lua to be far better beginner language and with games like Roblox etc its easier to rope kids into having fun in programming.\n\nSir, the therapist is this way...\n\n  \njk, but seriously, seek help.\n\nA) requires special casing lists and would lead to confusion when someone tried to use any other mutable type\n\nB) would make the language much less expressive\n\nC) would require complicating the language by adding some way for classes to identify themselves as immutable, which besides this the language does just fine without \n\nSo although I agree it is bad, I understand why the devs concluded it was the least bad of the options available.\n\no_O\n\nI mean I\u2019m far less experienced than you are in developing so maybe you\u2019re suffering from being a little too advanced to remember what it was like to be still learning, but  I\u2019ve never really had an issue with it myself. \n\nLua is great too! Especially for people who don\u2019t really want to be a developer but do want to make games\n\nHow would A require special casing anything?\n\nToday:\n\nWhen parsing a function, create a list of default arguments.\n\nWhen calling a function, for each argument, if it is not provided, replace it with the corresponding default argument.\n\nBetter:\n\nWhen parsing a function, create a list of lambdas that generate the default arguments\n\nWhen calling a function, for each argument, if it is not provided, replace it with the result of calling the corresponding default argument lambda.\n\nmy beginning languages were BASIC and Turbo Pascal, functional programming languages easily understood.\n\nThey tell you when a block starts for a function for ifs/else or for loops - like any other language basically I have developed in - yet here is python\n\nTake it the other way around - when you learn python first - will it not be weird that everything else will require you now to not think about your tabs/spaces/alignment but have either brackets or BEGIN and END to mark a block?", "id": "kxpn669", "owner_tier": 0.9, "score": 0.0487496043019943}, {"content": "I\u2019m curious about how someone thought this should be the right behavior when designing the language\n\nOver my long career, I\u2019ve learned to avoid saying \u201cthat\u2019s stupid\u201d but instead ask why it was done that way. \n\nTypically the reasons are interesting - it may have solved a problem that you aren\u2019t aware of, or it could actually just be stupid. \n\nI\u2019d also love to know why it was designed this way.\n\nThey thought it was the least bad of a bunch of bad options\n\nLmao i've been scrolling this thread trying to find someone saying \"Actually it's useful for-\".\n\nThis is the right energy. It\u2019s so easy to fall into the trap of assuming everyone must be an idiot for not seeing this simple issue you see, when you are the idiot that doesn\u2019t understand the complexity of the situation. \n\nSometimes people are idiots though, its just better not to default to that.\n\nYeah I avoid saying too but it\u2019s hard not to think it", "id": "kxpst0k", "owner_tier": 0.7, "score": 0.04621715732510288}, {"content": "Yeah I learned this when pycharm warned me about it, it's so stupid.", "id": "kxpj6t5", "owner_tier": 0.5, "score": 0.02279202278885723}, {"content": "Thanks, I hate it", "id": "kxpysvt", "owner_tier": 0.7, "score": 0.01772712883507439}, {"content": "using js as an example when criticizing another language for so-called insanity certainly is... a choice.\n\nWell, I mean when even js got it \"right\" that says something.\n\nFor once JS got it right\n\n\"Hey js... Sort these integers please.\"\n\" *As you wish*\"", "id": "kxpou65", "owner_tier": 0.7, "score": 0.038936372266540044}, {"content": "thank you for bringing this to light lmao i could\u2019ve screwed so much up in the future without knowing this", "id": "kxpw6zu", "owner_tier": 0.1, "score": 0.012029123137068692}, {"content": "I think I tripped over this. Once. In two decades of Python use.\n\nI'll accept the risk.\n\nIt's not a risk if you know about it.", "id": "kxqhlsp", "owner_tier": 0.7, "score": 0.012662234881291548}, {"content": "There is a PEP you should know and follow, or at least use a modern IDE that will let you know when you're doing things wrong.\n\nI\u2019m using VS code with Pylance \u2026 zero mention of this and it seems pretty stringent.\n\nThen again, I\u2019m also using typing module pretty religiously, so maybe I\u2019ve just naturally not run into the issue.\n\n>I\u2019m using VS code\n\nThey said modern IDE.\n\nI also use VSCode with Pylance but have used PyCharm in the past and this type of stuff along with a bunch of other PEP related things (like having a blank line at the end of the file) are picked up by PyCharm but not mentioned in VSCode\n\nhttps://marketplace.visualstudio.com/items?itemName=ms-python.pylint", "id": "kxprn33", "owner_tier": 0.7, "score": 0.021842355172522948}, {"content": "Ah, so THAT'S why PyCharm warns me against making the default argument mutable.", "id": "kxpshlm", "owner_tier": 0.5, "score": 0.013295346625514404}, {"content": "Everyone learns this the hard way.", "id": "kxptuz2", "owner_tier": 0.7, "score": 0.011396011392845837}, {"content": "Uh, in most languages it's a best practice to treat function/method arguments as though they were immutable.", "id": "kxrtd0o", "owner_tier": 0.9, "score": 0.011712567264957265}, {"content": "Python team should patch it to work like JavaScript, release it without the slightest mention in the patch notes, and then any code that breaks as a result deserves it", "id": "kxsmj9f", "owner_tier": 0.9, "score": 0.01234567900918012}, {"content": "yep... learned that the hard way, too, many years back...", "id": "kxpsnlu", "owner_tier": 0.5, "score": 0.011079455520734409}, {"content": "I used this for logging. Current time as default argument.\n\nThe timestamps were ... less than useful.", "id": "kxq9xnf", "owner_tier": 0.5, "score": 0.011079455520734409}, {"content": "Yeah I learnt the hard and long way to never use mutable default args. I\u2019ve always been able to find an alternative. \nAlso curious if this is a side effect of how Python is built or was intended by the creators?\n\nedit typos\n\nSort of both. Making this work any other way would have required doing a bunch of other things differently, and they decided the cost of those would be higher than doing it this way. So they understood the problem at the time, but they thought other approaches had worse problems.", "id": "kxqvvfp", "owner_tier": 0.1, "score": 0.012029123137068692}, {"content": "Don\u2019t mutate arguments, you get unexpected results", "id": "kxrbaxt", "owner_tier": 0.1, "score": 0.011079455520734409}, {"content": "Why would you modify an input mutable param that's also optional?\n\nEither it modifies a param by contract, in which case making it optional makes no sense...\nOr it's just an input not to be modified, in which case you don't touch it, _obviously_, otherwise you're playing with data that isn't yours and isn't supposed to be changed...", "id": "kxpteth", "owner_tier": 0.5, "score": 0.012978790753402976}, {"content": "It's definitely a gotcha, but Python is a scripting language at heart. It's just evaluating any expressions in a function signature once, instead of for every call. Hardly insane.", "id": "kxpndci", "owner_tier": 0.7, "score": 0.013928458369737258}, {"content": "Memoization is an intentional caching optimization.", "id": "kxpwvqt", "owner_tier": 0.5, "score": 0.010762899648622981}, {"content": "PyLint would warn you about errors like this.", "id": "kxqmfwd", "owner_tier": 0.1, "score": 0.010762899648622981}, {"content": "So much for functional programming :(", "id": "kxrx4li", "owner_tier": 0.7, "score": 0.010762899648622981}, {"content": "Yep, I got burned by this too. Python has *several*  horrific behaviors involving things that are static but don't look static.\n\nThis is just one of pythons data types. Lists are mutable, so not static. If you want immutable default arg, use a tuple, or None and declare it on instance initiation.\n\nBy static I mean they're re-used across different instances. In every other language I know of, default values for fields and parameters are not re-used each time.\n\nAh, ok I see what you mean", "id": "kxqrmas", "owner_tier": 0.7, "score": 0.01234567900918012}, {"content": "My first python gotcha is that class variables are global, you have to instantiate the variable in the constructor for it to be class", "id": "kxr4gon", "owner_tier": 0.3, "score": 0.010762899648622981}, {"content": "Pytyon is an abomination for anything that is not a script that's exdcuted once to produce a graph that's used in a paper", "id": "kxraoie", "owner_tier": 0.3, "score": 0.010762899648622981}, {"content": "In what universe would this be preferable? If I wanted that I'd write it in myself, why is this the default??", "id": "kxrn7zt", "owner_tier": 0.7, "score": 0.010762899648622981}, {"content": "Oh Jesus... Oh **Jesus**... I've got a lot of code to go back and check...", "id": "kxs5374", "owner_tier": 0.5, "score": 0.010762899648622981}, {"content": "The more i get to know python, the more i hate it", "id": "kxr160b", "owner_tier": 0.3, "score": 0.011079455520734409}, {"content": "This is a fun one. Usually just screws with people and they\u2019re really confused, but it\u2019s also a way to get static variable behavior from C into python. Now you probably shouldn\u2019t do that because it\u2019s confusing and error-prone, but it\u2019s still neat", "id": "kxq0im9", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "```\ndef get_user(userid, cache={}):\n    if userid in cache:\n        return cache[userid]\n    user = db_conn.getuser(userid)\n    cache[userid] = user\n    return user\n```\n\n... Actually no. I still prefer `functools.lru_cache()`, or straight up `cachetools`.", "id": "kxqaebv", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "That shit got me stuck for so long at work once... Just couldn't understand what the fuck was going on", "id": "kxrbqih", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "I'd forgotten about it and starting a huge python project soon thanks for the reminder \ud83e\udd23", "id": "kxrtl8f", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "Is this some sort of shared mutability joke I'm too rustacean to understand?", "id": "kxry466", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "What is that mini macOS IDE called?", "id": "kxs1cc9", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "Tbh if the list had a name it would make sense \"the default list to use is this one\" so I guess one could argue that adopting the same behavior for an unnamed one makes sense to still not something I would have personally chosen", "id": "kxs2f84", "owner_tier": 0.9, "score": 0.010446343776511553}, {"content": "\"By accident\" haha.", "id": "kxs5jg1", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "Yes, default values are initialized once, at the time the function is defined.", "id": "kxsaq3w", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Got burnt on this last week", "id": "kxsi7iw", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "We solved this using type hints. Your IDE will prevent you from mutating it if you type it with the related readonly interface: `Sequence` for list and `Mapping` for dict", "id": "kxt4ipq", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "I think most IDEs even warn, that this may lead to the very behaviour you described.\nAvoid mutable args\n\nMicrosoft's VSCode Python thing (Pylance) doesn't. I think I'm running Ruff as a linter as well ; Ruff definitely has a [rule](https://docs.astral.sh/ruff/rules/mutable-argument-default/) for this, but it's not in the default ruleset - you have to extend it to include this rule or the bugbear rules in general.\n\n    ruff --extend-select B <rest of args>\n\nPyCharm (Community) does highlight this, but you could miss it easily if you don't look in the lint problems because it only highlights the `[]` and it just looks like fancy brace highlighting.\n\nI got bitten by this one within living memory (while doing Advent of Code this year).", "id": "kxtd2cg", "owner_tier": 0.1, "score": 0.010762899648622981}, {"content": "You should make that a tuple. If you want the mutable, you'll get the mutable.", "id": "kxtjb6o", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "The way to do this properly is \\`def f(a, b, \\*optional\\_arg)\\`, right?", "id": "kxtpqr6", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "Oh yeah, specifically with list and dictionaries, this is particularly because list and dictionaries in python are pass-by-reference by default, togerher with the default arguments being effectively pass-by-reference it gets \"shared\"\n\nIts not shared btw, if you set an empty string or a string (or any objects), that PoC shouldnt work", "id": "kxtpxm3", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "I can never not think of pirates when I see \"arg\"", "id": "kxtqg5t", "owner_tier": 0.9, "score": 0.010446343776511553}, {"content": "Because the function definition is a object and the default arguments are part of the function definition. When you are mutating the arguments you are really mutating an attribute of the function object.", "id": "kxtrvd0", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "This is a question every graduate gets asked in interview.", "id": "kxtxbk1", "owner_tier": 0.9, "score": 0.010446343776511553}, {"content": "Whut", "id": "kxudmn3", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "That's one of the best known gotchas in Python", "id": "kxurjhx", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "Well, how tables have turned!", "id": "kxwl5kp", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "There was a proposal for having \\`def surprise(my\\_list => \\[\\]): ...\\` for default args that get recalculated (and can therefore rely on other args too). But it seems to have died? I actually thought it had made it into 3.12 but it seems it hasn't :(", "id": "kxwpjzo", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "This is not news. It's pretty common knowledge in Python circles. Even your ide warns you to not use mutable default arguments.", "id": "kxxpxrp", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "Don't do this:\n\n    def f(x = []):\n        ...\n\nDo this instead:\n\n    def f(x = None):\n        if x is None:\n            x = []\n        ...", "id": "kxzv2el", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "This has been around since Python 1.6, early 2000s.", "id": "ky07nb4", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "It's 2024, do people really still not know of this nowadays...?", "id": "ky0alia", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "dude in a python example in my book in highschool theres an example which uses a variable that isnt passed to a function?? I have no clue if it compiles, I hope it doesnt, heres what I remember it looking like\n```\ndef square():\n    return x**2\n\nx = 5\nprint(square())\n```\n\nWhat is this insanity???", "id": "ky2kacx", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "Thats why i optional_args = None and then do:\n```\nif not isinstance(optional_args, list):\n    optional_args = []\n```\n\n    optional_args = optional_args or []\n\nThat assumes optional_args is always a list", "id": "ky4zv2n", "owner_tier": 0.3, "score": 0.011079455520734409}, {"content": "I can't imagine debugging this as someone who barely scraped by on a project in college where I had to debug something where I kept accidentally changing pointers instead of the values they point to", "id": "ky8ioqy", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Who designed that nonsense, sat back, and said \u201cah yes, functioning as intended\u201d? What a grand misstep in an otherwise great language", "id": "kxqdbev", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "A truly insane choice.", "id": "kxqubof", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Tuples are immutable (but not their contents) :)\n```\ndef surprise(my_tuple = ()):  \n    print(my_tuple)  \n    my_tuple.append('x')  # AttributeError\n```", "id": "kxq6uhz", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "I remember one day trying to understand what was happening until I learned this. Terrible.", "id": "kxq8um9", "owner_tier": 0.1, "score": 0.010446343776511553}, {"content": "Is there an lolpython sub like the php one?\n\nOnly 1 way to find out: \nr/lolpython", "id": "kxqafb9", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Programmer: I'm looking to define a function parameter that has a default value\n\nPython:  Best I can do is a lexically-scoped variable, sorry.", "id": "kxqauer", "owner_tier": 0.7, "score": 0.010446343776511553}, {"content": "Eugh I hate how loosely defined and floaty everything feels in python\n\nYou\u2019re welcome to use a more strict language. Python suits my needs just fine. I also use stricter languages like Java and Rust.\n\nYou\u2019re welcome to use a more strict language. Python suits my needs just fine. I also use stricter languages like Java and Rust.", "id": "kxqcnp6", "owner_tier": 0.3, "score": 0.010446343776511553}, {"content": "That\u2019s fucked", "id": "kxs689x", "owner_tier": 0.5, "score": 0.010446343776511553}, {"content": "lol", "id": "kxppl8j", "owner_tier": 0.5, "score": 0.010129787904400127}, {"content": "Everyone who uses python knows it", "id": "kxqpy8h", "owner_tier": 0.1, "score": 0.0098132320322887}, {"content": "Tell me you don\u2019t read the docs without telling me you don\u2019t read the docs\n\nit's still insane", "id": "kxspct6", "owner_tier": 0.5, "score": 0.010129787904400127}, {"content": "Man alive that's awful...", "id": "kxqcueg", "owner_tier": 0.9, "score": 0.010129787904400127}, {"content": "Probably considered a feature not a defect by the snek boiz", "id": "kxqi9t7", "owner_tier": 0.9, "score": 0.010129787904400127}, {"content": "That's why I can't take scripting languages seriously. Who thought that this is a good idea?", "id": "kxpjcce", "owner_tier": 0.5, "score": -3.1655589830337796e-12}, {"content": "There is nothing new about this - basically the first thing you learn when getting into python\n\nYes. It is documented well, in the articles that describe how function arguments are interpreted: the default array is generated at script reading time, not at function invocation time.\n\nYes. It is documented well, in the articles that describe how function arguments are interpreted: the default array is generated at script reading time, not at function invocation time.\n\nno it's not lol that's insane\n\nYeah, it's pretty common knowledge to be fair\n\ncommon knowledge sure. but \"first thing you learn\" even as a matter of speech is really stretching it\n\nYeah, that's not what I said. Ofc it's not the _first_ things, but if you do an intro course or read a book, as soon as they cover functions, it's mentioned.", "id": "kxr3xr3", "owner_tier": 0.5, "score": 0.01234567900918012}, {"content": "No wait really? _yo wtf_", "id": "kxprb03", "owner_tier": 0.7, "score": 0.00823045267173156}, {"content": "That's a pre-junior question on an interview\n\ndoesn't make it any less bad", "id": "kxrdbnj", "owner_tier": 0.5, "score": 0.009496676160177272}], "link": "https://www.reddit.com/r/programminghorror/comments/1bu14pi/be_careful_with_default_args_in_python/", "question": {"content": "Came across this image. I couldn\u2019t believe it and had to test for myself. It\u2019s real (2nd pic has example)", "id": "1bu14pi", "title": "Be careful with default args in Python", "traffic_rate": 76.37194851309366}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "By default, anything defined during the class's definition is a _class attribute_. It is not tied to an instance, at all:\n\n    class Apple:\n         size = 3\n\n    print(Apple.size)\n\nYou can access class attributes through an instance, however:\n\n    a = Apple()\n    print(a.size) # 3\n\nThat's _not_ because `a` has an instance attribute that is a pointer to the same value as the class attribute, but because attribute lookups, if they don't find an instance attribute of that name, next look to see if there's an attribute on the instance's class of that name. You can verify this by checking `a`'s and `Apple`'s `__dict__`, which stores their direct attributes in dictionary form:\n\n    print(a.__dict__)     # {}\n    print(Apple.__dict__) # {..., \"size\": 3, ...}\n\nThus, if you change the class attribute, all instances will see that change.\n\nTo define an instance attribute, you must do an attribute assignment on the instance after it has been created. The most common place to do so is the `__init__` method, though you can do it anywhere:\n\n    a.color = \"red\"\n    print(a.color) # red\n\nNote that if you do an attribute assignment on the instance for a name that already exists as a class attribute, you create a new instance attribute, rather than reassigning the class attribute:\n\n    a.size = 1\n    print(a.size)     # 1\n    print(Apple.size) # 3\n\nNote also that there's a popular decorator `dataclasses.dataclass` which, when applied to class, uses its class atttributes to auto-generate logic including an `__init__` method that creates instance attributes with the same name, default value, and type.\n\nThank you so much, that explains perfectly what I was looking for. As I mentioned in response to another reply, I didn't know about class attributes and instance attributes. However, based on this idea of creating a new instance attribute when doing an attribute assignment after the instance has been created, shouldn't the following hold true:  \n\n\n    Class Test:\n        var lst1 = []\n    \n    test_obj = Test()\n    test_obj2 = Test()\n    \n    test_obj.lst1.append[1]\n    print(test_obj2.lst1) # should print [1]\n    \n    test_obj2.lst1 = []\n    test_obj.lst1.append[3]\n    print(test_obj.lst1) # should print [1]\n    print(test_obj2.lst1) # should print [3]\n\nOr, does the mutability of lists effect this idea of an instance attribute with the same name as a class attribute and `print(test_obj2.lst1)` will actually give us `[1 3]`?\n\nNo, mutability does not affect this. But your code would actually print (after fixing a few typoes and removing `var`):\n\n    [1]\n    [1, 3]\n    []\n\nIf you appended `3` to `test_obj2.lst1` (instead of to `test_obj.lst1`), you'd get the outputs you indicated, so maybe that was a typo, too?\n\nThanks for noticing and yes, I meant to append 3 to test_obj2.lst1.", "id": "jgbqpow", "owner_tier": 0.3, "score": 0.7499999975}, {"content": "Its not really just a class thing. If you use mutable collection as default value in a function, init or not, it will not create a new empty collection object at each call but point to the same one.\nIt is useful for cache/memoization etc.", "id": "jgbryvi", "owner_tier": 0.5, "score": -2.4999999848063226e-09}, {"content": "It would help if you showed an example in code of what you're talking about, because I *suspect* what you mean is different from what others have been hearing and addressing so far. I *think* you're talking about the init function *parameters* rather than attributes per se:\n\n    class Foo:\n        def __init__(self, param1, param2, ...):\n\nAnd, I think in particular you're talking about giving them default values, and why you shouldn't have such a default value be a list:\n\n    class Foo:\n        def __init__(self, param1=['bar'], param2, ...):\n            self.param1 = param1\n            ...\n\nbut instead should default it to None (if it must have a default), and do the assignment inside the init:\n\n    class Foo:\n        def __init__(self, param1=None, param2, ...):\n            if param1 == None:\n                self.param1 = ['bar']\n            else:\n                self.param1 = param1\n            ...\n\nAm I understanding you correctly? If so, it's because the default values are only evaluated once, as the class definition is first being read by the interpreter. The result when you have a mutable object (like a list) as a parameter default value is that you're not getting a fresh new copy of the list each time you create a new instance object of the class. You're instead getting that very same list object, including whatever changes were previously made to the contents of the list with previously created instances.\n\nHere's one article I just searched up explaining it better: https://leimao.github.io/blog/Python-Default-Argument-Mutable-Object/\n\nSorry for not including a code example. I wasn't thinking specifically in the context of default values, more so because I didn't know Python could do that (I know that behaviour from Java and Kotlin). I replied to another comment with a code example, which I'll paste here:\n\n    Class Test:\n        var1 = 8\n        var_lst1 = [\"string\"]\n    \n    test_obj = Test()\n    test_obj2 = Test()\n    \n    test_obj.var1 = 10\n    test_obj.var_lst1.append(\"string2\")\n    \n    print(test_obj2.var1) # will get 8\n    print(len(test_obj2.var_lst1)) # will get 2\n\n&#x200B;\n\nHowever if the list was created in the constructor instead, we get:\n\n    Class Test:\n        var1 = 8\n        def __init__(self):\n            var_lst1 = [\"string\"]\n    \n    test_obj = Test()\n    test_obj2 = Test()\n    \n    test_obj.var1 = 10\n    test_obj.var_lst1.append(\"string2\")\n    \n    print(test_obj2.var1) # will get 8\n    print(len(test_obj2.var_lst1)) # will get 1\n\n&#x200B;\n\nThe example I just gave isn't really that different from yours. I guess it's the fact that a mutable object will change just the one variable value (that is, the contents of the same list) while that's not the case for an immutable object (like in both my examples with Test.var1).\n\nOn the surface, both are variables that are being modified. But under the surface, what's going to give the behaviour above?\n\nOkay, so, with \"test\\_obj.var1 = 10\", in both scenarios you're replacing the original value (the integer object whose value is 8) with a new value (the integer object whose value is 10). Or to put it even more technically, you're re-assigning the name \"test\\_obj.var1\" to now be a reference to the integer object whose value is 10. The name \"test\\_obj2.var1\" hasn't been changed; it still refers to the integer object with value 8. Although \"var1\" was originally created at the class level for both instances, you've dynamically added the \"var1\" variable at the instance level for test\\_obj with the new assignment through the \"test\\_obj\" name. With test\\_obj2, it's still referring to the class level \"var1\", even though you're getting to it through the instance name. I *think* if you did print(test\\_obj.\\_\\_class\\_\\_.var1), it would give you the class's 8 rather than the instance's 10, showing that the value is still there but just with the new \"var1\" name in the instance having the closer scope. (That could probably be written with better organization, but I hope it makes sense. (And I hope it's actually correct! \ud83d\ude01))\n\nWith var\\_lst1, in the first scenario it's created at the class level, so in both instances the name is referring to the *very same* original list object, [\"string\"], *not* a separate object in each which happens to have the same value. So when you modify the value with append, you're still pointing to the same object, just with a modified value. (Like a bottle is the same bottle even if you pour out the contents and put something else in it, or mix something else in.) The second scenario is different because now var\\_lst1 is created at the instance level, so each instance has its own separate copy of the list, which just happen to be equal to each other. That is, there are two separate list objects, and the name var\\_lst1 in the first instance refers to the first list, and the name var\\_lst1 in the second instance refers to the second list. So modifying the content of one has no effect on the other.\n\nAgain I hope I got that right as I type it out on my phone without testing anything, and I welcome correction from those who know better.\n\nThank you so much! That makes a lot of sense now. So, it's not a copy type situation in memory for immutable attributes, but a new attribute taking up a new location in memory and just happens to have the same variable name? Or, to put it another way, when I create an instance attribute of the same name as a class attribute, Python knows to go to the place in memory where the instance attribute is stored when the attribute is called using dot notation, and if there's no specific instance variable, then Python knows to use the class variable instead?\n\nDo you know how this all works with inheritance? Let's say I have the attribute Fruit.price and I create an instance of Apple, which is a child of Fruit, with the name apl_obi. Now, let's say my Fruit.price had a default value of 5 and in the Apple class definition, I set Apple.price to 3. If I set apl_obj.price to 1, then any calls to the attribute price would fetch the instance attribute. If I did not set apl_obj.price explicitly, would calls to apl_obj.price return 3 or 5?", "id": "jgc3pqq", "owner_tier": 0.7, "score": 0.9999999975}], "link": "https://www.reddit.com/r/learnpython/comments/12mqjpy/intricacies_of_python_classes/", "question": {"content": "Hi all,\n\nI'm taking the course Crash Course on Python as part of the Coursera Google IT Automation with Python program. I already know a good amount of beginner Python, but it's the first course in the series. Anyway, I'm doing the option week all about classes and the like. While I'm familiar with classes from other languages I've worked with in the past - Java mostly - I have done much with Python.\n\nThere are a few different examples they use to explain concepts, but the most notable one is using a class called Apple, in which there are 2 attributes - flavour and colour. During one video, they create another class for the demonstration and use a list attribute but define it only within the constructor. With the Apple class examples, the attributes were usually defined within the class itself with default values. They then go on to explain why the list attribute wasn't defined within the class by saying the following:\n\nWith the Apple class, if we change one Apple object (they use the term instance instead but I'm used to object) to have a colour different than the default value, it will change for only *that* object. However, if the Apple class had a list attribute that was defined in the class, and one of the object's changed that list, all of the objects would have the same change. Is this because of memory and how simple data types are dealt with when creating class instances? Specifically, I'm assuming that when the class definition is parsed, space in memory is created for it including all its attributes, default values, methods, etc. Then, when an object of that class is created, a copy of all that class data is created at a new location in memory. Thus, when changing one attribute for an object, Python only looks at the memory allocated for that object.\n\nHowever, with lists, I'm assuming pointers are involved. So, if a class definition contains a list attribute, what's really created in memory is a pointer with the attribute name to some other section in memory allocated for the list. So, when an object of that class is created, the class data that's copied includes a copy of the pointer with the same attribute name. In other words, when the list is updated through a specific object, the \"master memory location\" for that list is accessed and modified which is why other objects of the same class will also reflect the modified list attribute. Whereas, if a list is defined in the class constructor, then memory is allocated for the list attribute only when memory is created for a class object, rather than when reading the class definition?\n\nThank you.", "id": "12mqjpy", "title": "Intricacies of Python classes", "traffic_rate": 153.1714814814815}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "reddit"}, {"answers": [{"content": "\r\n    The DEFAULT constraint is used to insert a default value into a column.\n\r\nThe default value will be added to all new records, if no other value is specified.\n\r\nif u use this constraint across all columns means u can't able to insert the null values.\n\r\nOther than this there will not be any disadvantages happen\r\n", "id": "2_986803_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/898010/Is-there-any-disadvantage-of-apply-default-constra", "question": {"content": "\r\n\t\t\t    Hello, \n\r\nI have a confusion, Is there any disadvantage of apply default constraints over every fields of DB table . \n\r\nI want to apply default constraints at every fields of table, So whenever , I save any data into DB table, than it should be save with some default value rather than null,\r\n\t\t    ", "id": "898010", "title": "Is there any disadvantage of apply default constraints over every fields of DB table", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["SQL"]}, {"answers": [{"content": "\r\n    Variables are initialised with a default value upon creation. For numeric types like boolean, integer, and floating point this is the value zero and for object types like string it is null. If you do not set a variable by assignments in your code they will contain their default value.\n\r\nSee also Default Values at Primitive Data Types (The Java\u2122 Tutorials >                    Learning the Java Language > Language Basics)[^].\r\n", "id": "2_1238906_1", "owner_tier": 0.5, "score": 5.0}], "link": "https://www.codeproject.com/Questions/1238903/Why-the-output-is-showing-the-null-values", "question": {"content": "\n\n\r\nimport java.io.*;\r\npublic class Employee {\r\n\r\n   public String name;\r\n\r\n   private double salary;\r\n\r\n   public Employee (String empName) {\r\n      name = empName;\r\n   }\r\n   public Employee (double empSal) {\r\n      salary = empSal;\r\n   }\r\n\r\n   public void printEmp() {\r\n      System.out.println(\"name  : \" + name );\r\n      System.out.println(\"salary :\" + salary);\r\n   }\r\n\r\n   public static void main(String args[]) {\r\n     Employee empOne = new Employee(\"Ransika\");\r\n     Employee emptwo = new Employee(1000);\r\n      empOne.printEmp();\r\n      emptwo.printEmp();\r\n   }\r\n}\n\nWhat I have tried:\n\r\noutput :\n\n\r\n$javac Employee.java\r\n$java -Xmx128M -Xms16M Employee\r\nname  : Ransika\r\nsalary :0.0\r\nname  : null\r\nsalary :1000.0\n", "id": "1238903", "title": "Why the output is showing the null values?", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["Java"]}, {"answers": [{"content": "\r\n    You can set the properties in the call to new:\nC#\n\r\nnew GetBaseCustomerResponse { Property1 = value1, Property2 = value2 ...};\r\nWithout more information on what you are trying to do or sample code, it is hard to offer much more advice.\r\n", "id": "2_1276184_1", "owner_tier": 0.1, "score": 0}], "link": "https://www.codeproject.com/Questions/1268161/How-to-restrict-the-default-values-initialization", "question": {"content": "\r\n\t\t\t    In my application while creating derived class object baseclass constructor called and dervied class constructor also called at the time varibles are intalized and then operations are performed on the method.finally return the response.in that response i had get varibles are get with values based on operation performed and default values initialization don't want return the default value initialization. i need varibles are initialized with values based operation performed.\nC#\n\r\n[HttpPost]\r\n[Route(\"api/Account/Login\")]\r\n public async Task<GetBaseCustomerResponse> Login([FromBody]LoginRequest request)\r\n  {\r\n  GetBaseCustomerResponse _response = new GetBaseCustomerResponse();\r\n\r\n\r\n   -----operations are performed--------\r\n\r\n\r\n\r\n   return _response \r\n}\n\nC#\n\r\npublic class GetBaseCustomerResponse : GetResponseTemplate<BaseCustomerModel>\r\n{\r\n      \r\n}\n\nC#\n\r\npublic class BaseCustomerModel\r\n{\r\npublic int Customerid{get;set;}\r\n\r\npublic string cusname{get;set;}\r\n\r\npublic string cusaddress{get;set;}\r\n\r\npublic string email{get;set;}\r\n\r\npublic string Dateofbirth{get;set;}\r\n\r\n}\n\r\nplease help me.\r\nThank u\n\nWhat I have tried:\n\r\nIn my application while creating derived class object baseclass constructor called and dervied class constructor also called at the time varibles are intalized and then operations are performed on the method.finally return the response.in that response i had get varibles are get with values based on operation performed and default values initialization don't want return the default value initialization. i need varibles are initialized with values based operation performed\r\n\t\t    ", "id": "1268161", "title": "How to restrict the default values initialization while creating object of the class", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C#"]}, {"answers": [{"content": "\r\n    The first question is why are you using \"Type\"?  That is not a good name to use as it is a class name that is used by .NET and is going to lead to confusion in the code.\n\r\nI think your Type should become MarketType, and could also be the name of your Enum.\nC#\n\r\npublic enum MarketType\r\n{\r\n    Single,\r\n    Combined\r\n}\r\n\r\nand in your entity model:\nC#\n\r\npublic class Market\r\n{\r\n    public int ID { get; set; }\r\n    public string Name { get; set; }\r\n    public string IsoCode { get; set; }\r\n    public MarketType MarketType { get; set; }\r\n}\r\n\n", "id": "2_759429_1", "owner_tier": 0.7, "score": 0}], "link": "https://www.codeproject.com/Questions/759410/Entity-Framework-Default-Values-are-allowed-only-f", "question": {"content": "\r\n\t\t\t    Hi Guys,\n\r\nI hope you are all well and that someone here might be able to shed some light on my issue.\n\r\nI have a database table with the following setup:\n\n\n\r\nID [Bigint]<br />\r\nName [nvarchar(250)]<br />\r\nISOCode [nvarchar(5)]<br />\r\nMarketType [tinyint]\n\r\nUsing EntityFramework 6 Database first, I have added this table to my edmx file and it generates a class called \"Market\".\n\r\nOff of this, I have created two classes, 'SingleMarket' and 'CombinedMarket' (Some of you may be thinking da-ja-vu here but this is different to my last question relating to the same objects).\r\nI have converted the Type property on my Market to be an Enum which has two options:\n\n\n\r\nSingle = 1,<br />\r\nCombined = 2\n\r\nThese determine whether an object is a Single or Combined market, as I'm sure you gathered by now.\r\nMy issue is that right now my edmx fails so build with the error\n\"Default Values are allowed only for non-spatial primitive types\"\n\r\nNow I know that this error is caused by my \"MarketType\" property on the market base class, but I want the MarketType to default to 1 (Single). I also want to keep the \"MarketType\" property on my entity.\n\r\nIf I delete the MarketType property then it all compiles, but then I can't say \"What type is this Market\", or if I can I don't know how to. \n\r\nI also have this error:\r\n\"\n\r\nProblem in mapping fragments starting at lines 290, 298, 304:Column Market.MarketType has no default value and is not nullable. A column value is required to store entity data.<br />\r\nAn Entity with Key (PK) will not round-trip when:<br />\r\n  ( PK is in 'Markets' EntitySet AND Entity is type [MRPData.Market])\"\n\r\nSo, in simple, how can I keep my \"MarketType\" property on the base class and have it set with a default value of 1 (single) ?\n\r\nAny questions/clarification needed please ask.\n\r\nThanks in advance.\n\r\n[Edit]Type property renamed to MarketType as per Dave's advice.[/Edit]\r\n\t\t    ", "id": "759410", "title": "Entity Framework 6 - Default Values are allowed only for non-spatial primitive types.", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C#", "enum", "EF6.0"]}, {"answers": [{"content": "\r\n    There is no equivalent in C#.\n\r\nIn C, C++ and C# you must declare your variables before attempting to assign them.\n\r\nYou should however be aware of variable scope - Variable and Method Scope in Microsoft .NET[^] - there are no differences between scope in VB.NET and C# (AFAIK).\n\r\n[EDIT] - Option Explicit in VB isn't what provides the default values - those are defined by the framework - Default Values Table (C# Reference)[^]\n\r\nIf you want to prevent default values being used then get into the habit of always explicitly assigning a value to the variable. There are tools available that will prompt you if you have not done this (I don't know of any free ones though)\n\r\n[EDIT #2]\r\nI downloaded an express version of Visual Studio so I could check this without the tools or settings I normally use...\r\nConsider this code snippet ..\nC#\n\r\nint c;\r\n\r\nprivate void button1_Click(object sender, EventArgs e)\r\n{\r\n    int a;\r\n    int b = 10;\r\n\r\n    Console.WriteLine((a + b).ToString());\r\n    Console.WriteLine((c + b).ToString());\r\n\r\n}\r\nThis gave me one error and one warning ...\n \n\r\nError Use of unassigned local variable 'a'\r\nWarning 'WindowsFormsApplication1.Form1.c' is never assigned to, and will always have its default value 0\r\nSo for local variables you will be told off by VS for not initialising but for 'global' or class level variables you will only be warned by default.\n\r\nYou can force VS to convert those warnings to errors by going into YourProject, Properties, Build\r\n", "id": "2_1076632_3", "owner_tier": 0.5, "score": 1.2}, {"content": "\r\n    In C#: in the Project Properties facility, in the 'Build options panel you can set the \"warning level\" that will govern what types of error events (messages) will be raised: [^]:\n\nWarning level\tMeaning\r\n0\tTurns off emission of all warning messages.\r\n1\tDisplays severe warning messages.\r\n2\tDisplays level 1 warnings plus certain, less-severe warnings, such as warnings about hiding class members.\r\n3\tDisplays level 2 warnings plus certain, less-severe warnings, such as warnings about expressions that always evaluate to true or false.\r\n4\tDisplays all level 3 warnings plus informational warnings. This is the default warning level at the command line.\n\r\nWork in Debug mode.\r\n", "id": "2_1076646_1", "owner_tier": 0.5, "score": 5.0}, {"content": "\r\n    Option Explicit in VB.NET only forces you to declare variables before you try to use them. That's it. Nothing else. It has nothing to do with initializing variables. All variables in .NET are initialized to an appropriate value by default.\n\n\r\nPublic Function TestSub(x As Integer, y As Integer)\r\n    ' The following line will cause a compiler error if Option Explicit is turned on.\r\n    ' i was never defined before being used.\r\n    i = x + y\r\n    return i\r\nEnd Function\r\n\n\r\nC# forces this by default. There is no turning it off.\n\n\r\npublic int TestSub(int x, int y)\r\n{\r\n    i = x + y;\r\n    return i;\r\n}\r\n\r\nwill throw an error because i wasn't declared at all.\n\r\nOption Explicit does NOT force you to initialize a variable. There is no option in VB.NET or C# that does this.\n\r\nIf the default value of a variable causes your code to give unexpected results, the problem is with you, not some option. You didn't take the steps required to validate your input before you tried to use those values. Input, in this context, is any values being used by an algorithm, including declared variables, not just the stuff a user types in.\r\n", "id": "2_1076647_1", "owner_tier": 0.7, "score": 2.5}], "link": "https://www.codeproject.com/Questions/1076625/Can-I-prevent-NET-from-allowing-use-of-default-val", "question": {"content": "\r\n\t\t\t    Hi Everyone,\n\r\nIs there an equivalent to the vbs switch \"Option Explicit\" in .NET (specifically C#)?  I've been burned a couple times now by variables that I failed to explicitly initialize.  I'd rather break than have code I think is working which produces bad output!!\r\n\t\t    ", "id": "1076625", "title": "Can I prevent .NET from allowing use of default values for variables", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C#", ".NET"]}, {"answers": [{"content": "\r\n    You cannot define a default value for an array as a parameter, because this way the default value has to be a compile-time constant.\r\nYou can however test for a null value, and assign the default value accordingly:\nC#\n\r\nvoid MyMethod(string[] datakeyNames = null)\r\n{\r\n   datakeyNames = datakeyNames ?? new string[] { \"Id\", \"DateModified\" };\r\n   // ...\r\n}\n", "id": "2_5161217_2", "owner_tier": 0.5, "score": 1.5}, {"content": "\r\n    You can't do it with default parameters (for an array), but you can do it with an overload:\n\nC#\n\r\npublic bool MyMethod()\r\n{\r\n    string[] value = new string[] { \"Id\", \"DataModified\" };\r\n    return MyMethod(value);\r\n}\r\n\r\npublic bool MyMethod(string[] value)\r\n{\r\n    // do something with the string array\r\n    return false;\r\n}\n\r\nThis way, you can call either overload and be okay. If you combine the two answers, you could do something like this:\n\nC#\n\r\nprotected string[] DefaultValues()\r\n{\r\n    return new string[] { \"Id\", \"DataModified\" };\r\n}\r\n\r\npublic bool MyMethod()\r\n{\r\n    return MyMethod(this.DefaultValues());\r\n}\r\n\r\npublic bool MyMethod(string[] value = null)\r\n{\r\n    value = value ?? this.DefaultValues();\r\n    // do something with the string array\r\n    return false;\r\n}\n\r\nThat way, you cover all of your bases, and still only have to change the default values in one location.\r\n", "id": "2_5161218_4", "owner_tier": 0.7, "score": 1.5}, {"content": "\r\n    This is an alternative pattern I sometimes use for handling a mix of optional and default parameters:\n\r\nprivate string[] defaultData = new []{\"Id\", \"DataModified\"};\r\n\r\n// requires C# >= 4.00\r\n// requires Linq\r\npublic bool myMethod(bool ensureDefaultDataIsUsed = true, params string[] data)\r\n{\r\n    if (ensureDefaultDataIsUsed)\r\n    {\r\n        data = data.Concat(defaultData).Distinct().ToArray();\r\n    }\r\n\r\n    return true;\r\n}Consider these usage examples:\n\r\n// no parameters: 'defaultData is used\r\nbool m0 = myMethod();\r\n\r\n// single parameter: 'defaultData combines with parameter\r\nbool m1 = myMethod(data: \"hello\");\r\n\r\n// multiple parameters: 'defaultData combines with parameters\r\nbool m2 = myMethod(true, \"hello\", \"goodbye\");\r\n\r\n// multiple parameters: 'defaultData is not used\r\nbool m3 = myMethod(false, \"hello\", \"goodbye\");\r\n\r\n// will not compile\r\nbool m4 = myMethod(\"hello\");What I like about this:\n\r\n1 keeping default parameters in a variable makes it easy to change what the defaults are\n\r\n2 all the options are in one method\n\r\n3 control over whether defaults are used, ignored, or combined with user supplied data\n\r\nWhat some might consider the downside: example #m4 illustrates that using an explicitly named parameter for 'ensureDefaultDataIsUsed is required to avoid a clash between a positional and an optional value.\r\n", "id": "2_5161260_1", "owner_tier": 0.5, "score": 1.0}], "link": "https://www.codeproject.com/Questions/5161216/Make-method-with-string-with-optional-default-valu", "question": {"content": "\r\n\t\t\t    Hi Folks,\n\r\nHow to have a method that has a string[] array value with default optional values.\n\r\nIn gridviews most database have the fields ID and DateModified setup for GridView.DataKeyNames.\r\nI have 1 application that have ID and date_modified als columns for GridView.DataKeyNames\n\r\nIn my method I want to do \r\nvoid MyMethod(string[] datakeyNames = new string[] { \"Id\", \"DateModified\"})\n\r\nHow can I set-up default values for a string array in a method?\n\nWhat I have tried:\n\r\nAll I get from C# compiler is the message:\r\n\tDefault parameter value for 'datakeyNames' must be a compile-time constant\r\n\t\t    ", "id": "5161216", "title": "Make method with string[] with optional default values", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C#", "Gridview", "ASP.NET4"]}, {"answers": [{"content": "\r\n    Another possibility for you would be to use the singleton pattern by having a static object.\r\nPlease see this code for your class:\nC#\n\r\nclass Settings\r\n{\r\n   private Settings()\r\n   {\r\n   }\r\n   static Settings m_instance = null;\r\n   public static Settings Core\r\n   {\r\n      get\r\n      {\r\n            if (m_instance == null)\r\n               m_instance = new Settings();\r\n            return m_instance;\r\n      }\r\n   }\r\n   public decimal Density = 21;\r\n   public string SelectedPrinterName = \"ZDesigner GX430t\";\r\n}\r\nYou can then use the class from wherever you want using the follwing code:\nC#\n\r\npublic Form1()\r\n{\r\n   InitializeComponent();\r\n   Settings.Core.Density = 5;\r\n}\n", "id": "2_469366_1", "owner_tier": 0.3, "score": 3.0}, {"content": "\r\n    You are sharing the same class (Type) but not the same instance of that class (Object).\r\nYou should explore the usage of the keyword static if you want to have such \"global\" object or even better have a llok at the singleton pattern. You'll find plenty of articles in code project about it.\r\n", "id": "2_469368_1", "owner_tier": 0.3, "score": 0}, {"content": "\r\n    This is the popular question about form collaboration. The most robust solution is implementation of an appropriate interface in form class and passing the interface reference instead of reference to a \"whole instance\" of a Form. Please see my past solution for more detail: How to copy all the items between listboxes in two forms[^].\n\r\nPlease also see other solutions in this discussion. If the application is simple enough, the solution could be as simple as declaring of some internal property in one form and passing a reference to the instance of one form to the instance of another form. For more complex projects, such violation of strictly encapsulated style and loose coupling could add up the the accidental complexity of the code and invite mistakes, so the well-encapsulated solution would be preferable.\n\r\nPlease see also:\nhttp://en.wikipedia.org/wiki/Accidental_complexity[^],\nhttp://en.wikipedia.org/wiki/Loose_coupling[^].\n\n\u2014SA\n", "id": "2_469451_1", "owner_tier": 0.7, "score": 0}], "link": "https://www.codeproject.com/Questions/469358/Passing-data-between-forms-why-so-complicated", "question": {"content": "\r\n\t\t\t    Hey,\n\r\nUPDATE: Solution 1 accepted!\n\r\nI've been programming in C# for a few weeks (nearly fulltime) and learning every day. I am currently trying to organize the data in my project. This question is a followup question from my previous question Passing data between forms. I have for example some settings which I want to adjust. These settings are used in the main form but set in a different form.\n\r\nI'd like to have a central point in my project where I can store all my settings (variables). It is important that I can acces and update the data from all froms in my project. \n\r\nI create for example a class with all the declarations with a default value. like this:\n\nC#\n\r\nnamespace SerialProgrammer\r\n{\r\n    class Settings\r\n    {\r\n        public decimal Density = 21;\r\n        public string SelectedPrinterName = \"ZDesigner GX430t\";\r\n    }\r\n}\n\n\r\nSo I want to adjust this value in form2; like this: \n\nC#\n\r\nSettings settings = new Settings();\r\nprivate void BTN_Set_Click(object sender, EventArgs e)\r\n{\r\n\r\n    settings.Density = nudDensity.Value;\r\n    this.Close();\r\n\r\n}\n\r\nAnd on my main form I want to use the settings, like this: \n\nC#\n\r\nSettings settings = new Settings();\r\nprivate void printLabel(string snum, string type, int number)\r\n{\r\n    if (IsPrinterOnline(settings.SelectedPrinterName))\r\n    {\r\n        if (settings.SelectedPrinterName.Contains(Dymo_PrinterName))\r\n        {\r\n            dymoPrintLabel(snum, type, number);\r\n        }\r\n        else if (settings.SelectedPrinterName.Contains(Zebra_PrinterName))\r\n        {\r\n            ZebraPrintLabel(snum, type, number);\r\n        }\r\n\r\n    }\r\n}\n\r\nWhat I experienced is that even though it looks like (at least for me) that both forms share the class Settings, they both use a different class Settings with different values. How can I change my code that I have one set of settings which are easily accessable from both forms?\r\n\t\t    ", "id": "469358", "title": "Passing data between forms why so complicated?!~SOLVED", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C#", "C#4.0"]}, {"answers": [{"content": "\r\n    This worked for me (in VS):\n\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\n   public:\r\n     CSmartArray();\r\n\r\n   private:\r\n      const T& m_preset_value;\r\n};\r\n\r\ntemplate <class T> CSmartArray<T>::CSmartArray() : m_preset_value(0)\r\n{\r\n   \r\n}\n\r\nNot sure if it's quite what you want though. (Note I had to make it a const reference. You might just want to use a pointer here instead, it will probably be easier.)\r\n", "id": "2_636702_1", "owner_tier": 0.3, "score": 2.5}, {"content": "\r\n    If we take a look at the generated code then a reference is exactly the same as a pointer. On language level syntactically references have more strict rules: a reference has to be initialized exactly once where you declare/define it. If the reference is the member variable of a class then you have to initialize it from the initializer list of every constructor of the class. A reference can not be changed later to point to something else. After declaration and initialization the identifier of the reference variable works as if it was the identifier of the object to which the reference points. For this reason initializing a reference to zero has no point. If you want to change the reference after initialization to point to something else then you want to use a pointer instead of a reference.\r\n", "id": "2_636705_1", "owner_tier": 0.3, "score": 1.5}, {"content": "\r\n    It does not make much sense to have a reference member to an \"unknown\" type. If this is really what you want to do (assuming that a default constructor exists), you would also have to implement the destructor and ensure that the object is not copyable...\n\r\nIf not, then you have to ensure that the type is a POD type (rules are a bit different with C++ 11 but since I don't know all details).\n\r\nThus, you would have something like this (for simplicity all functions are defined inline):\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\npublic:\r\n  CSmartArray() : m_preset_value(*new T())\r\n  {\r\n  }\r\n\r\n  ~CSmartArray()\r\n  {\r\n    delete &m_preset_value;\r\n  }\r\n\r\nprivate:\r\n  CSmartArray(const CSmartArray &); // No copy\r\n  CSmartArray& operator=(const CSmartArray &); // No copy\r\n\r\n  T& m_preset_value;\r\n};\n\r\nIf an instance is used, then it simplify to this (this is what I would recommand to do):\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\npublic:\r\n  CSmartArray() : m_preset_value() // Empty () will force default value in that case since a long time.\r\n  {\r\n  }\r\n\r\nprivate:\r\n  T m_preset_value;\r\n};\n\r\nBy the way, this is not very flexible as it is not possible to create object not using the default constructor.\r\n", "id": "2_636776_2", "owner_tier": 0.3, "score": 5.0}, {"content": "\r\n    What you are trying to achieve does not make sense, because the template parameter is any arbitrary type, and an arbitrary file does not have a concept of \"null\", but it does not even have to support a concept of some \"default initial value\". Nothing can be assumed for this type.\n\r\nThere are some work-around approaches. Let's think.\n\r\nIt may seem that you can internally use the pointer to T as your private member m_preset_value. Then you could assign this member to the 0 pointer, regardless of the actual type of T. However, it would not solve problem, only delay it, as you don't know the constructor for T if it is required, so how one would instantiate it?\n\r\nThe simplest real resolution could be something like this:\nC++\n\r\ntemplate <class T> class SmartArray {\r\nprotected:\r\n\tT m_preset_value;\r\n\tvirtual void Initialize() = 0;\r\npublic:\r\n\tvoid SomeMethod() { m_preset_value = Initialize(); } // could be anything, for example, constructor\r\n};\n\r\nThis way, with each instantiation of the template you should also create a derived class and the virtual method should be overridden:\nC++\n\r\nclass BooleanSmartArray : public SmartArray<bool> {\r\nprotected:\r\n    virtual void Initialize() { m_preset_value = 0; }\r\n};\n\r\nThis may seem to be not very convenient. As an alternative, you would need to use something like generic constraints of CLI (.NET, in particular). This way, you could create some interface class with operations like Initialize and more. Then, instead of arbitrary unconstrained type T, you could indicate that the template parameter is contrained to be derived from this interface class.\n\r\nYou can see these suggestions by Bjarne Stroustrup:\nhttp://www.stroustrup.com/bs_faq2.html#constraints[^].\n\r\nAnother approach is implemented in boost: http://www.boost.org/doc/libs/1_36_0/libs/concept_check/concept_check.htm[^].\n\r\nSee also:\nhttp://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29[^],\nhttp://www.boost.org/[^].\n\r\nAnd if you can use C++11, you can think about the use of template std::initializer_list:\nhttp://en.wikipedia.org/wiki/C%2B%2B11#Initializer_lists[^]\n\n\u2014SA\n", "id": "2_636718_2", "owner_tier": 0.7, "score": 1.2666666666666666}], "link": "https://www.codeproject.com/Questions/636695/Cplusplus-templates-plus-variable-default-values", "question": {"content": "\r\n\t\t\t    I'm having trouble wrapping my head around this and Mr. Google doesn't seem to know much about it either or I'm just not querying correctly, probably he latter but I've got a template;\n\nC++\n\r\ntemplate<class T> class CSmartArray\r\n{\r\n   public:\r\n     CSmartArray(...);\r\n\r\n      blah...blah...blah\r\n\r\n   private:\r\n      T& m_preset_value;  //<=== The value to set\r\n};\r\n\r\ntemplate <class T> T& CSmartArray<T>CSmartArray(...)\r\n{\r\n   //How do I set the following value to some default value such as zero?\r\n   m_preset_value = 0;     //Nope\r\n   m_preset_value = (T)0;  //Nope\r\n   m_preset_value = (T&)0; //Nope\r\n}\n\r\nQuestion is how do I set the m_preset_value to some default value such as zero?\n\r\nIt's probably very simple but am not seeing it but how do I set any value to m_preset_value?\n\r\nUrgent send code plz......  :)\n\r\nThanks Y'all\n\r\nBTW Templates using GCC is a PITA!\r\n\t\t    ", "id": "636695", "title": "C++ templates + variable default values", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C++"]}, {"answers": [{"content": "\r\n    Oh boy - this is going to be difficult to explain without pictures, so you would be better off looking in a book. But:\n\r\nIn your click handler, you create an instance of Class1, and assign it to a variable called oClass1. What is actually in oClass1? Is it an int - the total data stored by Class1? Or is it something else?\r\nWhat is actually stored in oClass1 is not the actual Class1 instance - it is a reference to the class instance. I.e. the instance you created is on the heap and oClass1 is (probably) on the stack. Why? So that you could have a second variable if you needed it:\n\n\r\nprotected void Button2_Click(object sender, EventArgs e)\r\n{\r\n    Class1 oClass1 = new Class1();\r\n    Class1 oClass2 = oClass1;\r\n    oClass1.MyProperty1 = 10;\r\n    MethodCall(oClass1);\r\n    TextBox2.Text = oClass1.MyProperty1.ToString();\r\n}\r\nAnd then both oClass1 and oClass2 would refer to the same instance of a Class1.\r\nWith me so far? Good.\r\nYou then hand the content of oClass1 to your method. What gets handed through? Answer: the reference to the instance. Not oClass1, but the content of oClass1.\r\nSo when you modify MyProperty in MethodCall you are modifying the object that oClass1 refers to.\n\r\nThis is a lot easier to explain with pictures!\n\r\nTry this and you might see what I mean:\n\n\r\nclass Class1 { public int i;}\r\nprivate void ShowTheDifference()\r\n    {\r\n    Class1 cs = new Class1();\r\n    cs.i = 100;\r\n    Method(cs);\r\n    MessageBox.Show(cs.i.ToString());\r\n    Method2(cs);\r\n    MessageBox.Show(cs.i.ToString());\r\n    }\r\nvoid Method(Class1 cs) { cs = new Class1(); cs.i = 999; }\r\nvoid Method2(Class1 cs) { cs.i = 999; }\r\n\n", "id": "2_101579_1", "owner_tier": 0.9, "score": 1.5}, {"content": "\r\n    Anything other than ValueTypes are passed by reference. ValueTypes includes structures. \r\nInt32 is a structure, so it is passed by value.\n\r\nYour custom object TextBox or any object (which is not ValueType)is always passed by Reference.\r\n", "id": "2_101781_1", "owner_tier": 0.5, "score": 1.7}, {"content": "\r\n    No! Both, value and reference types are passed by value unless you require them to be passed by reference (the ref or out keywords). Since Class1 is a reference type its value is a reference pointing to some object stored on the heap. Thus, changing the value of a property of a reference to oclass in MethodCall  changes the value of oclass.MyProperty on the heap.\n\n\n\r\npublic void MethodCall(Class1 oclass)    {        oclass.MyProperty1 = 100;    }\n\r\nIf you want to pass by reference use ref:\n\n\n\r\npublic void MethodCallByRef(ref Class1 oclass) {\r\nint tOldValue = oclass.MyProperty1;\r\noclass = new Class1();\r\noclass.Property1 = tOldValue;\r\n}\n\r\nthen you have:\n\n\n\r\n...\r\n\r\nClass1 o1 = new Class1();\r\nClass1 o2 = o1;\r\n\r\nMethodCall(o2);\r\n\r\nConsole.Write(Object.Equals(o1.Property1, o2.Property1));// prints true\r\nConsole.Write(Object.ReferenceEquals(o1, o2)); // prints true\r\n\r\nMethodCallByRef(ref o2); // explicit call by reference!\r\n\r\nConsole.Write(Object.Equals(o1.Property1, o2.Property1)); // prints true!\r\nConsole.Write(Object.ReferenceEquals(o1, o2)); // prints false!\r\n...\n", "id": "2_101800_2", "owner_tier": 0.1, "score": 0.5275}, {"content": "\r\n    All register types are default by value, like int, int32 and also reference pointers (not directly visible in c# but they are there). These variables live on the stack and are there only alive in the stackframe of that method call. An object lives on the heap and only the reference lives on the stack. So when changing an object property it is done to the referenced object and therefore can be seen by everyone with a reference to that object. It is an optimization because it means that the object doesn't have to be copied every time it is passed. If it must stay the same you could clone it using that method accordingly.\n\r\nThis is however language specific because c/cpp for example will create copies of structs/objects if you do not explicitly specify differently.\n\r\nHopefully this gave you some idea.\n\r\nGood luck!\r\n", "id": "2_101576_1", "owner_tier": 0.3, "score": 0}, {"content": "\r\n    The answers above are correct, but I find them confusing. I'm a beginner and rather simpleminded, to boot. In simpler terms, objects are passed to methods by reference, while simple types like int and int32 are passed by value. The difference is easy to understand. \n\r\nWhen you pass a simple type to a method, the method gets a copy of the original variable. If the method changes that value, when the method returns the original variable is unchanged, and the copy used in the method is destroyed.\n\r\nWhen you pass an object, the method gets the address of the original variable, and when the method makes a change, the original gets changed. Passing variables by reference sort of opens a pipeline to the original variable, and gives your method access to it. \n\r\nIf you want to preserve the changed value of a simple type, give your method a return type that matches the type used as a parameter, then use a return statement to pass the result out of the method:\n\n\n\r\npublic int32 MyMethod(int32 MyParam)\r\n{\r\n    int32 MyValue = 5 * MyParam;  //MyParam is a local copy of the input parameter\r\n    return MyValue;\r\n}\r\n\r\nint32 MyChangedValue = MyMethod(MyParam);\n\n\r\nI hope a simpleton's explanation is helpful... :)\r\n", "id": "2_101733_1", "owner_tier": 0.5, "score": 0.9}, {"content": "\r\n    A more pictoral reference is explained in the following link. I hope that helps for new comers like me. \n\nhttp://www.javaranch.com/campfire/StoryPassBy.jsp[^]\r\n", "id": "2_699351_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/101574/In-C-objects-are-passed-by-value-or-by-reference-C", "question": {"content": "\n\n\r\npublic class Class1\r\n    {\r\n        private int Prop1;\r\n\r\n        public int MyProperty1\r\n        {\r\n            get { return Prop1; }\r\n            set { Prop1 = value; }\r\n        }\r\n    }\r\n\r\n    protected void Button2_Click(object sender, EventArgs e)\r\n    {\r\n        Class1 oClass1 = new Class1();\r\n        oClass1.MyProperty1 = 10;\r\n        MethodCall(oClass1);\r\n        TextBox2.Text = oClass1.MyProperty1.ToString();\r\n    }\r\n\r\n    public void MethodCall(Class1 oclass)\r\n    {\r\n        oclass.MyProperty1 = 100;\r\n    }\n\r\nAbove code gives TextBox.Text as 100.\r\nThese values are changed in a function which gets class1 object as parameter but not by reference. But still change in value in method is reflected in calling method.\r\nThis doesn't happen with int or Int32.\n\r\nCan anybody please explain me the reason ?\r\nThanks in advance.\n\r\n[edit]Code block added to preserve formatting - OriginalGriff[/edit]\r\n\t\t    ", "id": "101574", "title": "In C# objects are passed by value or by reference ? Confused !!!", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C#", "ASP", ".NET"]}, {"answers": [{"content": "\r\n    The CLR automatically zeros the memory it allocates for variables. This will set all types to their default value - 0 for numbers, false for booleans, null for reference types, etc. \n\r\nFor classes and structs, this will set all fields to their default values.\n\r\nThe C# compiler will generate a CS0165 error if you try to read a local variable without setting it to a value first. But that's only because this is usually an indication of an error with your code. The variable will technically have been initialized to its default value by the CLR.\n\r\nThe compiler will not generate a similar error for an uninitialized field - especially since structs have no good way to initialize their fields to anything other than the default. They can't have parameterless constructors, and they can't have field initializers. IIRC, this is to speed up allocation of arrays of structs - the CLR can just zero out the whole memory, rather than having to run code on each item in the array.\r\n", "id": "2_5305008_1", "owner_tier": 0.7, "score": 5.0}, {"content": "\r\n    I don`t exactly understand your question ... but basicly you as the developer are responsible for initializing a variable - that could be done when you declare it :C#\n\r\nprivate string str1 = \"default-Value\";\r\nprivate int num1 = 123;\n", "id": "2_5304989_1", "owner_tier": 0.3, "score": 0}], "link": "https://www.codeproject.com/Questions/5304983/What-is-responsible-for-initializing-fields-of-a-c", "question": {"content": "\r\n\t\t\t    In C#, instance fields in a struct type (can't be initialized at declaration) are either always initialized by the the default parameter-less constructor with the respective default value or by any parameterized constructor explicitly defined by the programmer.\n\n\n\r\npublic struct MyStruct\r\n{\r\n    private string str1;\r\n\r\n    private int num1;\r\n\r\n    //parametized constructors in a struct always obligated to initialize instance fields\r\n    public MyStruct(string strParameter, int numParameter)\r\n    {\r\n        str1 = stringParameter;\r\n\r\n        num1 = numParameter;\r\n    }\r\n}\r\n\n\r\nWith instance fields in a class type however, fields are either intialized with a default value by the parameter-less constructor, but parameterized constructor are not obligated to initalize the fields as with struct types:\n\n\n\r\npublic class MyClass\r\n{\r\n    private string str1;\r\n\r\n    private int num1;\r\n\r\n    //parametized constructors in a class not obligated to initialize instance fields\r\n    public MyClass(string strParameter, int numParameter)\r\n    {\r\n        //nothing in the body\r\n    }\r\n}\r\n\n\r\nIf a paramterized constructor of a class is not obligated to initialize the instance fields, then what initializes them with their default value, when the parameterized constructor is called?\n\nWhat I have tried:\n\r\nWas unable to resolve this problem after investegation.\r\n\t\t    ", "id": "5304983", "title": "What is responsible for initializing fields of a class, if they were not initialized at its declaration nor by any parameterized constructor?", "traffic_rate": 0}, "saved_time": "Tue, 16 Jul 2024 03:43:18 GMT", "source": "codeproject", "tags": ["C#", "constructor"]}]}