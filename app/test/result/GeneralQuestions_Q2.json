{"result": [{"answers": [{"content": "To solve this, I had to do the following.  I don't know which item(s) below solved the issue, but hopefully this will be helpful to someone.  The Python debugger I was using was called Python File, as opposed to the other two optional Python debuggers, Python File with Arguments and Module. 1.) Deleted the file \"pyvenv.cfg\" in the working folder.  It contained the contents.  This got created automatically somehow from earlier debugger sessions. 2.) The first time I created the virtual environment in GitBash with the Python File debugger not working was the following: 3.) The second time I created the virtual environment in GitBash, I added a new folder in my source directory (path of my Python file being debugged) called venv.", "id": 78053516, "owner_tier": 0.5, "score": -9.433962264150944e-11}, {"content": "Weighing in late here but I'm not sure the version of Python is part of the issue. I think the real issue is with the 32 bit versus 64 bit versions of Python. I am on Python 3.10.11 and changed my interpreter from 64 bit to 32 bit and the debugger started hit the breakponts.", "id": 77671605, "owner_tier": 0.1, "score": -9.433962264150944e-11}, {"content": "This happened to me as I was walking through this VSCode tutorial. My debugger did not work because I accidentally put the file in the .venv folder.  When I moved it out of there it ran fine.", "id": 77275295, "owner_tier": 0.1, "score": -9.433962264150944e-11}, {"content": "I have been battling with this for the last hour, and it finally worked by renaming my python file from camelCase.py to snake_case.py", "id": 73972948, "owner_tier": 0.3, "score": -9.433962264150944e-11}, {"content": "I (re)downloaded VS Code again: https://code.visualstudio.com/\nThe breakpoint got to show up on hover and function with the Run and Debug for the python file I was working on. Additionally, I had to solve a syntax error in my code before the debugger buttons (step over/in, etc) had to go through the code lines", "id": 73952411, "owner_tier": 0.1, "score": -9.433962264150944e-11}, {"content": "For everyone coming here looking for a solution related to breakpoints in python unittests: If not already done add a configuration file, i.e. launch.json, as described in the vscode python debugging tutorial. For me the following configuration settings worked, whereby setting cwd (because of  src and test folders) and purpose (see also here) were essential. Happy debugging!", "id": 70701313, "owner_tier": 0.3, "score": 0.00943396216981132}, {"content": "Another source of debugger not stopping at breakpoint: an homonym file,  from another directory, is open in VS Code. In fact, VS Code can set breakpoints on any Python file, even outside of your Python project's directory; if the path of the file does not match the one in launch.json, \"program\": [your-file-name-here] entry, then breakpoints are not hit. For example: copies of Python source files are located under dist/lib, the output of setuptools (run: python setup.py bdist_wheel to generate them). If dist/lib is not excluded through .gitignore, then its contents shows up in the search results sidebar and can be click open by mistake. Caveat: the above does not hold if the launch.json configuration has \"program\": \"${file}\".", "id": 73258380, "owner_tier": 0.1, "score": -9.433962264150944e-11}, {"content": "Another source of no-breakpoints-working is elevate: The elevate() command restarts the program as a new (child) process, so the entire file becomes un-breakpoint-able.  From the author: On Windows, the new process\u2019s standard streams are not attached to the parent, which is an inherent limitation of UAC. In windows, to debug python applications in VS Code which need to be run as administrator, a work-around is this: Linux users could likely do the same with sudo code.  Now the process will be spawned initially as administrator, so the call to elevate() does nothing and the whole file is debuggable.", "id": 71756673, "owner_tier": 0.5, "score": 0.00943396216981132}, {"content": "My issue was that I was putting the breakpoint on the line of the function declaration itself, so the def foo(x): line, instead of putting the breakpoint on the first non-comment line inside of the function. If the first line of your function is a comment, the debugger will assume you meant to place the breakpoint on the line of the function declaration and move your breakpoint back, so really make sure you aren't placing your breakpoint on a comment!", "id": 69229731, "owner_tier": 0.3, "score": 0.018867924433962263}, {"content": "Downgrading from Python 3.9 to 3.8 worked for me. VC Code 1.56.2 ignored breakpoints running Python 3.9 64-bit on Windows 10 version 20H2.  Installing Python 3.8.10 64-bit fixed the problem.  I just needed to select the Python 3.8.10 interpreter within VS code and it now recognizes breakpoints.  No changes to the configuration file were needed, for example, I did not need \"justMyCode\": false I realize this is an old question, but my google search lead me to it.  Many of the previous answers no longer apply. So I'm posting this fix for others who land here in 2021 trying to use 3.9.", "id": 67630336, "owner_tier": 0.1, "score": 0.018867924433962263}, {"content": "I recently found out ( 5th May 2020) that using Python 3.9 as interpreter the breakpoints were not hitting. Install 3.8 and it will start working again.", "id": 67400796, "owner_tier": 0.1, "score": -9.433962264150944e-11}, {"content": "If you're using a pytest-cov module you might also wanna have a look at pytest configuration settings note: Note If you have the pytest-cov coverage module installed, VS Code doesn't stop at breakpoints while debugging because pytest-cov is using the same technique to access the source code being run. To prevent this behavior, include --no-cov in pytestArgs when debugging tests, for example by adding \"env\": {\"PYTEST_ADDOPTS\": \"--no-cov\"} to your debug configuration. See an example configuration file (launch.json) below:", "id": 67185092, "owner_tier": 0.5, "score": 0.5188679244339622}, {"content": "I had the same problem having upgraded from Python version 3.7 to version 3.9. I later found out that the old version was 32 bit, and the new version I upgraded to was 64 bit, which apparently caused the issues. Uninstalling the 64 bit version and installing the 32 bit version of Python 3.9 solved my problem, and I was then able to use the Visual Studio Code breakpoint functionality again.", "id": 66935483, "owner_tier": 0.1, "score": 0.00943396216981132}, {"content": "I experienced the same behaviour and was able to solve it by installing the virtual environment of Python in the following way: by entering the command in the console. VS Code seems to expect exactly that folder structure. Before I had installed the venv-folder-structure directly in my projects-folder, i.e. which did not work and caused exactly the described debug problems. just as a reference: VS Code version 1.52.1 and Python 3.8.5", "id": 65534376, "owner_tier": 0.1, "score": 0.03773584896226415}, {"content": "Setting \"justMyCode\": false makes it stop at breakpoint: ", "id": 60678160, "owner_tier": 0.5, "score": 0.9999999999056605}], "link": "https://stackoverflow.com/questions/56794940/vscode-why-isnt-debugger-stopping-at-breakpoints", "question": {"content": "I have just installed VS Code and the Python extension, and I have not been able to get the debugger to work. Every time I try to use the debugger, it just skips over any breakpoints that I have set and runs the program like normal.  I am using VS Code on a Windows 10 PC with Python 3.7.3 and the Python extension installed. I followed the instructions here (https://code.visualstudio.com/docs/python/python-tutorial) to make a test folder called 'hello' in C:\\python_work\\hello and create a program called 'hello.py' inside that folder. hello.py is shown below. I tried using the debugger both by pressing the green arrow and by pressing F5, but neither seemed to make the debugger work properly. My 'launch.json' file is also shown below. hello.py: launch.json: I expected the bottom bar to turn orange and the program to stop on the second line, allowing me to examine the local and global variables in the preview pane. Instead, the bottom bar stayed orange for 1/2 a second while the program ran as if I had pressed \"Run Python File in Terminal,\" without stopping at the breakpoint. Please help!", "id": 56794940, "title": "VSCode: Why isn&#39;t debugger stopping at breakpoints?", "traffic_rate": 45}, "saved_time": {"$date": "2024-07-16T03:41:09.863Z"}, "source": "stackoverflow", "tags": ["python", "visual-studio-code", "vscode-debugger"]}, {"answers": [{"content": "Use sys.gettrace:", "id": 78288246, "owner_tier": 0.3, "score": 0.07692307653846155}, {"content": "Pycharm sets the environment variable PYDEVD_LOAD_VALUES_ASYNC when the script is run through the debugger. To check if the debugger is active you can check if PYDEVD_LOAD_VALUES_ASYNC exists in the list of environment variables: or as a function tested in PyCharm 2023.3.4 (Community Edition)", "id": 78118417, "owner_tier": 0.1, "score": 0.07692307653846155}, {"content": "Possible update for Python 3.12+ and PyCharm 2023.3+: The context is PEP 669 \u2013 Low Impact Monitoring for CPython and announced support of those features in PyCharm 2023.3. PEP 669 introduced sys.monitoring module. And PyCharm may use it instead of sys.settrace(). It is indeed so for Debug button, while Python Console still uses settrace.", "id": 77627047, "owner_tier": 0.5, "score": 0.07692307653846155}, {"content": "Just wanted to add a couple alternative implementations. Using contextlib.suppress: Using \"walrus\" operator new since Python 3.8:", "id": 71527398, "owner_tier": 0.5, "score": 0.15384615346153846}, {"content": "The following works for me in VSCode:", "id": 67065084, "owner_tier": 0.5, "score": 0.9999999996153845}, {"content": "If using Python logging module, you could call: for checking if the root logging level is debug. Simple as that.", "id": 73166872, "owner_tier": 0.3, "score": -3.8461538227789577e-10}, {"content": "Adding these three short answer as it seems others are rather long or less to the point.\ngettrace() is already a function so no need to write another... Any of these could (for example) be used to set the logging module logger level. (tested in Py3.9 with VSCode and PyCharm comtemporary to this post date) or if you need a variable or a global - not such a good idea as you risk namespace collisions in large projects.", "id": 72977762, "owner_tier": 0.5, "score": 0.15384615346153846}, {"content": "I don't use pycharm, but to check if the program is being debugged using python -mpdb myFile.py, this code will work: as long as you don't otherwise import pdb.", "id": 71896491, "owner_tier": 0.3, "score": 0.07692307653846155}, {"content": "Tested on PyCharm 2021.3.2:", "id": 71170397, "owner_tier": 0.5, "score": 0.3076923073076923}, {"content": "In Pycharm 2021.1.3 with Python 3.9. Simply used Below, debug mood will show the printed 'Now in debug', and run will print the play Mood", "id": 70277538, "owner_tier": 0.5, "score": 0.07692307653846155}, {"content": "Tested with: There are two ways of debugging in PyCharm: The function below detects method #1 (above), as it always passes in --port=XXXX on the command line. Function:", "id": 64320310, "owner_tier": 0.9, "score": 0.07692307653846155}], "link": "https://stackoverflow.com/questions/38634988/check-if-program-runs-in-debug-mode", "question": {"content": "I use the PyCharm IDE for Python programming. Is there a possibility to check, whether I'm in debugging mode or not when I run my program? I use pyplot as plt and want a Figure only to be shown if I debug my program. Yes, I could have a global boolean _debug_ which is set by myself, but I look for a better solution.", "id": 38634988, "title": "Check if program runs in Debug mode", "traffic_rate": 8}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["python", "python-2.7", "debugging", "pycharm"]}, {"answers": [{"content": "I know it's 11 years on, and I'm a bit late to the game, and I know it's not Notepad++ but please do consider Visual Studio Code. It's free, easy to install (both the editor itself plus any python interpreters it uses) and it's widely used and nowhere near as bloated as it's Visual Studio counterpart.  It also appears to be the IDE of choice for a lot of Cisco-related course material. Write your code, click to the left of code pane to insert your breakpoints click the Debugger icon (highlighted), and you're away: ", "id": 75354980, "owner_tier": 0.5, "score": -1e-09}, {"content": "Does such a plug-in exist?  Not that I know of.  I agree completely with qor72 on that note.   Is it possible to create such a plugin / functionality?  Possibly. After doing some quick digging, I did find a plugin that looks promising, Python Script.  In short it allows you to run python scripts that can access the NPP modules (file menus etc...) as well as the Scintilla Methods which appear to give access to things like the markers on the pages. To accomplish such a feat I could see the task being broken into a few large blocks (I feel a new open-source project coming on...)   Closing Thoughts\nWhile I think it's possible to create such a plug in, it would be quite an undertaking.  Along that line, you might be better off trying to find a different editor that has this built into it already and just create macros (or whatever the IDE calls them) to add in the things you like most about NPP.   Please note that I am a daily user of NPP and have been for many years so I definitely understand why you'd like to have the functionally added to NPP.  One of my favorite things about NPP is the speed in which it opens and searches files... moving to a bloated IDE, IMO, would not be worth it to me.   My current work flow is to do all of my editing in NPP and just double click to run the modules.  If it fails or goes off in the weeds, I launch IDLE to debug it.", "id": 7433655, "owner_tier": 0.5, "score": 0.9999999989999999}, {"content": "I don't really see why Shashi's answer hasn't been upvoted. For the link that he has given supplies a way to step through python scripts as the OP has requested. So for all who don't know about the pdb module, upon importing it the pdb.set_trace() function allows one to step through the area of code after it. And it is very much similar to the visual studios method of debugging. While you're stepping through the code you are able to input a variety of commands. One of them is p <expression> and that allows the user to print the current state of variables within the local and global scope. ", "id": 10376549, "owner_tier": 0.1, "score": 0.199999999}, {"content": "Have you thought of using Komodo.\nIt's open source and has ports for Windows, Linux and MAC (I think). This may be an alternative, and if you want some advice from notepad++ users, have a look at the following post on this very site: Komodo Edit and Notepad++ ::: Pros & Cons ::: Python dev Some npp users here seemed to have made the switch for python editing running etc... personally don't know much about debugging on Komodo but as it's an IDE so would be surprised if you couldn't do it easily", "id": 7431347, "owner_tier": 0.1, "score": 0.199999999}, {"content": "I really hope someone tells me I'm wrong (I'd love to have that feature in Notepad++) but, Notepad++ is designed as a programmers editor, not an IDE. While it has a lot of cool functionality, that level of debugging isn't part of the core tool.  Not seeing anything in the npp-plugins either. ", "id": 7430185, "owner_tier": 0.5, "score": 0.799999999}], "link": "https://stackoverflow.com/questions/7430123/debugging-python-code-in-notepad", "question": {"content": "I use Notepad++ for writing and running Python scripts. It is a great text editor, except for debugging. Is there a way to step through the code, use break points, view variable values etc. in Notepad++ like you can in Visual Studio?", "id": 7430123, "title": "Debugging Python code in Notepad++", "traffic_rate": 6}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["python", "debugging", "notepad++"]}, {"answers": [{"content": "If put import ipdb; ipdb.set_trace() at cell outside function, it will occur error. Using %pdb or %debug, you can only see the filnal error result. You cannot see the code doing step by step. I use following skill: save the code of cell to file temp.py. and then\n%run -i -d temp.py, it will run the cell code by pdb . -i: run the file in IPython\u2019s namespace instead of an empty one. -d: run your program under the control of pdb, the Python debugger.", "id": 74499138, "owner_tier": 0.1, "score": -8.064516129032258e-11}, {"content": "What about ipdb.set_trace() ? In your code : import ipdb; ipdb.set_trace() update: now in Python 3.7, we can write breakpoint(). It works the same, but it also obeys to the PYTHONBREAKPOINT environment variable. This feature comes from this PEP. This allows for full inspection of your code, and you have access to commands such as c (continue), n (execute next line), s (step into the method at point) and so on. See the ipdb repo and a list of commands. IPython is now called (edit: part of) Jupyter. ps: note that an ipdb command takes precedence over python code. So in order to write list(foo) you'd need print(list(foo)), or !list(foo) . Also, if you like the ipython prompt (its emacs and vim modes, history, completions,\u2026) it's easy to get the same for your project since it's based on the python prompt toolkit.", "id": 16894963, "owner_tier": 0.5, "score": 0.9999999999193548}, {"content": "You can start IPython from within ipdb. Induce the ipdb debugger1: Enter IPython from within in the ipdb> console2: Return to the ipdb> console from within IPython: If you're lucky enough to be using Emacs, things can be made even more convenient. This requires using M-x shell.  Using yasnippet and bm, define the following snippet.  This will replace the text ipdb in the editor with the set-trace line.  After inserting the snippet, the line will be highlighted so that it is easily noticeable and navigable.  Use M-x bm-next to navigate. 1 All on one line for easy deletion.  Since imports only happen once, this form ensures ipdb will be imported when you need it with no extra overhead. 2 You can save yourself some typing by importing IPython within your .pdbrc file: This allows you to simply call embed() from within ipdb (of course, only when IPython is installed).", "id": 56977128, "owner_tier": 0.5, "score": 0.0645161289516129}, {"content": "Debugging inside IPython Cell Example: IPython inside debugging I agree with the OP that many things MATLAB does nicely Python still does not have and really should since just about everything in the language favors development speed over production speed. Maybe someday I will contribute more than trivial bug fixes to CPython. https://github.com/ipython/ipython/commit/f042f3fea7560afcb518a1940daa46a72fbcfa68 See also Is it possible to run commands in IPython with debugging?", "id": 61978659, "owner_tier": 0.5, "score": 0.016129032177419355}, {"content": "You can use IPython's %pdb magic. Just call %pdb in IPython and when an error occurs, you're automatically dropped to ipdb. While you don't have the stepping immediately, you're in ipdb afterwards. This makes debugging individual functions easy, as you can just load a file with %load and then run a function. You could force an error with an assert at the right position. %pdb is a line magic. Call it as %pdb on, %pdb 1, %pdb off or %pdb 0. If called without argument it works as a toggle.", "id": 43413318, "owner_tier": 0.5, "score": 0.6774193547580646}, {"content": "the right, easy, cool, exact answer for the question is to use %run macro with -d flag.", "id": 48878063, "owner_tier": 0.1, "score": 0.04032258056451613}, {"content": "If you type exit() in embed() console the code continue and go to the next embed() line.", "id": 33269960, "owner_tier": 0.1, "score": 0.016129032177419355}, {"content": "Did you try this tip? Or better still, use ipython, and call: then you can just use whenever you want to set a breakpoint", "id": 31632777, "owner_tier": 0.5, "score": 0.032258064435483874}, {"content": "Prefixing an \"!\" symbol to commands you type in pdb seems to have the same effect as doing something in an IPython shell. This works for accessing help for a certain function, or even variable names. Maybe this will help you to some extent. For example, But !help(numpy.transpose) will give you the expected help page on numpy.transpose. Similarly for variable names, say you have a variable l, typing \"l\" in pdb lists the code, but !l prints the value of l.", "id": 17112479, "owner_tier": 0.5, "score": 0.05645161282258065}, {"content": "You can start IPython session from pudb and go back to the debugging session as you like. BTW, ipdb is using IPython behind the scenes and you can actually use IPython functionality such as TAB completion and magic commands (the one starts with %).  If you are OK with ipdb you can start it from IPython using commands such as %run and %debug.  ipdb session is actually better than plain IPython one in the sense you can go up and down in the stack trace etc.  What is missing in ipdb for \"object inspection\"? Also, python.el bundled with Emacs >= 24.3 has nice ipdb support.", "id": 16876288, "owner_tier": 0.5, "score": 0.15322580637096775}, {"content": "Running from inside Emacs' IPython-shell and breakpoint set via pdb.set_trace() should work. Checked with python-mode.el, M-x ipython RET etc.", "id": 16870440, "owner_tier": 0.5, "score": 0.008064516048387097}], "link": "https://stackoverflow.com/questions/16867347/step-by-step-debugging-with-ipython", "question": {"content": "From what I have read, there are two ways to debug code in Python: With a traditional debugger such as pdb or ipdb. This supports commands such as c for continue, n for step-over, s for step-into etc.), but you don't have direct access to an IPython shell which can be extremely useful for object inspection. Using  IPython by embedding an IPython shell in your code. You can do from IPython import embed, and then use embed() in your code. When your program/script hits an embed() statement, you are dropped into an IPython shell. This allows the full inspection of objects and testing of Python code using all the IPython goodies. However, when using embed() you can't step-by-step through the code anymore with handy keyboard shortcuts. Is there any way to combine the best of both worlds? I.e. An example of this type of \"enhanced debugging\" can be found  in MATLAB, where the user always has full access to the MATLAB engine/shell, and she can still step-by-step through her code, define conditional breakpoints, etc. From what I have discussed with other users, this is the debugging feature that people miss the most when moving from MATLAB to IPython. I don't want to make the question too specific, but I work mostly in Emacs, so I wonder if there is any way to bring this functionality into it. Ideally, Emacs (or the editor) would allow the programmer to set breakpoints anywhere on the code and communicate with the interpreter or debugger to have it stop in the location of your choice, and bring to a full IPython interpreter on that location.", "id": 16867347, "title": "Step-by-step debugging with IPython", "traffic_rate": 38}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["python", "debugging", "emacs", "ipython", "pdb"]}, {"answers": [{"content": "I recently faced the same problem of debugging an already running python script. I used PyCharm's \"Attach to process\" (Attach a process) utility to set breakpoints and was actually able to set breakpoints and dump the variables I was interested in.\nThe main challenge was the script was already running for last 20hrs and I didn't want to modify that script and start again. Hence, I attached an already running process. For production cases where using an IDE is not possible, one may try to remotely debug the scripts Remote Debugging", "id": 69609854, "owner_tier": 0.1, "score": -2.7027027027027025e-10}, {"content": "Apologies for the longish post; I came back again to a similar problem with debugging - a case where you take a long trip to the debugger, to finally reveal there is no actual bug - so I'd just like to post my notes and some code here (I'm still on Python 2.7, Ubuntu 11.04). In respect to the OP question - in newer gdb's, its also possible to break by using the id(...) function in the Python script, and having gdb break on builtin_id; but here's more details: Again, I had a problem with a C .so shared library module for Python; this time it was svn.client, which is a Swig module (see also here); in Debian/Ubuntu available via sudo apt-get install python-subversion (filelist). The problem occured while trying to run the Example 8.3. A Python status crawler - Using the APIs (svnbook) This example should do the same that the terminal command svn status does; but when I tried it on one of my working copies, it crashed with \"Error (22): Error converting entry in directory 'path' to UTF-8\", even if svn status has been processing the same working copy (WC) directory (for years now) - so I wanted to see where that came from. My version of the test script is python-subversion-test.py; and my full debug log is in logsvnpy.gz (gzipped text file, ~188K uncompressed, should anyone want to wade through endless stepping and backtraces) - this being the abridged version. I have both Python 2.7 and 3.2 installed, but the 2.7 are default on Ubuntu 11.04: The first thing to note is how the Python example functions: there, to obtain the status of all files within a directory, first svn.client.svn_client_status2 is called - aside from the path, also with _status_callback in the arguments, as a callback function in Python to be registered - and then blocks. While status2 is blocking, the underlying module iterates through all files in the WC directory path; and for each file entry, it calls the registered _status_callback which should print out information about the entry. Once this recursion is over, status2 exits. Thus, the UTF-8 failure must come from the underlying module. Inspecting this module further: ... reveals that there are other statusX functions - however, status3 failed with the same UTF-8 error; while status4 caused a segmentation fault (which becomes yet another problem to debug). And again, as in my comment to @EliBendersky's answer, I wanted to issue a breakpoint in Python, so as to obtain some sort of a call stack of C functions later on, which would reveal where the problem occurs - without me getting into rebuilding the C modules from source; but it didn't turn out to be that easy. First of all, one thing that can be very confusing is the relationship between gdb and Python; the typical resources coming up here are: That  release27-maint/Misc/gdbinit is in the Python source tree; defines gdb commands like pylocals and pyframe, but also mentions: # NOTE: If you have gdb 7 or later, it supports debugging of Python directly\n  # with embedded macros that you may find superior to what is in here.\n  # See Tools/gdb/libpython.py and http://bugs.python.org/issue8032.   Features/EasierPythonDebugging - FedoraProject - has an example, mentions a Fedora python-debuginfo package, and libpython From gdb 7 onwards, gdb's build can be configured --with-python, allowing gdb\n  to be extended with Python code e.g. for library-specific data visualizations,\n  such as for the C++ STL types.   ....\n  This module embeds knowledge about the implementation details of libpython so\n  that we can emit useful visualizations e.g. a string, a list, a dict, a frame\n  giving file/line information and the state of local variables   This gets a bit confusing - apart from the pointer, that one better get themselves gdb v.7; I managed to get for my OS: A quick way to test if gdb supports Python is this: ... but gdb supporting Python, doesn't mean Python on its own can access gdb functionality (apparently, the gdb has its own built-in separate Python interpreter). It turns out, in Ubuntu 11.04, the python2.7-dbg package installs a file libpython2.7.so.1.0-gdb.py: ... and this is the one corresponding to the mentioned Tools/gdb/libpython.py; the symlinking will allow us to refer to it as libpython, and use import script mentioned in  Features/EasierPythonDebugging . The test_gdb.py script is actually for Python 3 - I have modified it for 2.7, and posted in test_gdb2.7.py. This script calls gdb through an OS system call, and tests its Python functionality, with printouts to stdout; it also accepts a command line option, -imp-lp, which will import libpython in gdb before other commands are executed. So, for instance: Thus, libpython.py is intended specifically for the Python interpreter inside gdb, and it helps gdb print Python representations (v=[]) instead of just memory addresses (v=0xb7f7506c) - which is only helpful, if gdb happens to debug a Python script (or rather, it will debug the Python executable, that interprets the script). The test_gdb.py script also gives the pointer that you can \"... run \"python -c'id(DATA)'\" under gdb with a breakpoint on builtin_id\"; for testing this, I have posted a bash script, gdb_py_so_test.sh, which creates an executable with a counting thread function, and both plain distutils and swig modules (in both debug and release versions) that interface to the same function. It also creates a .gdbinit with both gdb and gdb's Python class breakpoints - and finally it runs gdb on Python (loading one of the shared modules), where the user can hopefully see if the breakpoints are really triggering. First I focused on the status4 segfault, and I wanted to know exactly which module does the function come from. I used a function, that can be found in debug_funcs.py; which can be called with separate regex for functions and modules, and may generate something like: However, note that: ... python-dbg will load different (debug, _d) versions of the .so modules of libsvn (or python-subversion); and that is because I have the python-subversion-dbg package installed. In any case, we may think we know the adresses where modules and respective functions are loaded upon each Python script call - which would allow us to place a gdb breakpoint on a program address; given that here we work with \"vanilla\" .so's (that haven't been rebuilt from source). However, Python on its own cannot see that _client.so in fact utilizes libsvn_client-1.so: From within Python, we could make a system call, to query /proc/pid/maps for the address where libsvn_client-1.so is loaded, and add to it the address reported by the last nm -D command for the offset of svn_client_status4; and obtain the address where we could break in gdb (with the b *0xAddress syntax) - but that is not necessarry, because if nm can see the symbol, so can gdb - so we can break directly on the function name. Another thing is that in case of a segfault, gdb stops on its own, and we can issue a backtrace (note: use Ctrl-X A to exit the gdb TUI mode after layout asm): So, our error happens somewhere in libsvn_client-1.so, but in memory area before svn_client_status4 function start; and since we don't have debugging symbols - we cannot say much else than that. Using python-dbg may give bit different results: ... but the list command still gives us a source line belonging to frame 5 (not frame 4), and we still don't know more about svn_client_status4: while the python-subversion modules are loaded in their debug versions, debugging information is missing for libsvn_client-1.so. So, time to rebuild from source. It is the actual subversion that we need to rebuild, or rather it's library part - since we already have debug modules from python-subversion; the package on my system is called libsvn1: ... and there is no debug package for it. To rebuild from source, I went through apt-get source libsvn1, with dependencies manually found via apt-rdepends --build-depends --follow=DEPENDS subversion. There are more details in the full log - but here we can note that the source package can built both the SWIG Python bindings (that is, python-subversion) and the Subversion library (libsvn1). Also, I ran make install with a location out of the main kernel tree; that means, that one had to explicitly specify the source-built modules via LD environment variables: One tricky thing here is that building SWIG debug modules requires a call with python-dbg; apparently just doing ./configure --enable-debug doesn't do that; and so, just _core.so, etc are produced, albeit with debugging information. If we then try to enforce its loading as with the above command, but with python-dbg, we will get undefined symbol: Py_InitModule4, because: ... python-dbg has a different Py_InitModule4 function. That, however, wasn't a problem, because simply python was used (as in the above invocation), and gdb still allowed stepping through the relevant functions in the newly built libsvn (the mentioned Bash script  gdb_py_so_test.sh, as an example builds a basic Swig module in both debug and release versions to confirm the right procedure). With debugging symbols for libsvn, the function call stack looks like this (pasted a bit differently): ... and since the same library functions are also used by command line svn client, we can compare, in say, frame 5: So, in case of a Python call to status4, sb->real_status_func is NULL, causing a segfault. The reason for this can be revealed once we start reading the source: in ./subversion/libsvn_client/deprecated.c, the definition for status3 has: ... that is, when status3 is called with a callback function, it creates a struct, and assigns the function to one of the struct properties - and then uses the struct in the further call to status4! Since status3 actually works from Python - the conclusion is that we cannot correctly call status4 from Python (since that would involve creating a C struct in Python); and that doesn't matter anyways, because we can call status3 from Python - which then itself calls status4! Then why is status4 addressible from Python? Probably because swig simply autogenerated an interface for it... In any case, here is an example, where a trip to the debugger reveals the source of the problem - but not really a bug :) Solution? Don't use status4. Going back to the UTF-8 failure, which occured with status2 and status3 - it was easier, given that now source built versions of the modules were available. The problem was obvious in the function entry_name_to_utf8, and by exploring it's argument name, one could first realize that the file name causing the problem, did indeed contain non-ascii - but still legal UTF-8 characters (see Program to check/look up UTF-8/Unicode characters in string on command line? - Super User). I have then used this .gdbinit, to make a Python class breakpoint for gdb, that would print out the filenames, and break only on match with the problematic one. Then the question is - how come, the command line client svn status does not crash on the same filename? By stepping through both svn status and python python-subversion-test.py, one can compare the respective function call stacks: At this point, one encounters the fact that Subversion uses libapr (Apache Portable Runtime) for memory allocation; and it is in fact this part causing the failure - principally, the function apr_xlate_conv_buffer behaves differently in the two cases. But, it can be rather difficult to see what the actual problem is here, because apr_xlate_conv_buffer uses an encoding in node->frompage, which is set to the define APR_LOCALE_CHARSET 1 - and that doesn't change between svn status and Python cases. To come down to this, I've copy-pasted everything related to APR string copying and allocation down the call stack, and reconstructed a simple example that builds a Swig  module, that should just copy a string using APR runtime; that example is in the directory aprtest, built with the bash script build-aprtest.sh. Thanks to that example, it was revealed that the UTF failure problem can be fixed by calling setlocale in C before any APR string memory allocation - for more about that test, see #15977257 - Using utf-8 input for cmd Python module. Correspondingly, all we need to do from Python is execute: ... before any calls to svn.client (and thus to libsvn, and thus to libapr). And here we have yet another example, for a trip to the debugger, without really having a bug :)", "id": 16027750, "owner_tier": 0.9, "score": 0.7027027024324324}, {"content": "Very interesting question. Here's my approach. Create signal_test.py: Then you can run it under gdb: And when you run it, it will go until you reach the call to kill(): You can then look at a backtrace: If you continue on, the rest of the program will run normally. You can, instead, step through in the appropriate frame until you reach the statement you're interested in. You're probably going to want to run a debugging Python for this to make much sense.", "id": 7920256, "owner_tier": 0.9, "score": 0.9999999997297297}, {"content": "This is an interesting question, and I'm eagerly waiting for other answers, but for now: The document http://wiki.python.org/moin/DebuggingWithGdb is mainly for debugging segfaults and hung Python processes, not for normal stepping through Python code.  I'm not sure I understand your intention 100%. Do you want to break in your C (Python C API) code once a certain Python line is reached? Then wouldn't it be just a matter of doing: Where myobj.foo() calls into the C API. Then, just place a breakpoint on the function attached to myobj.foo and you have your breakpoint at the right location. Do you need more functionality, or are you simply looking for a more natural way to achieve the same?", "id": 7412994, "owner_tier": 0.9, "score": 0.054054053783783786}], "link": "https://stackoverflow.com/questions/7412708/debugging-stepping-through-python-script-using-gdb", "question": {"content": "Let's say we have the following mega-simple Python script:  ... and say, I'd like to debug this script by placing a breakpoint at line a=10, and then stepping through the script. Now, I'd like to use gdb for this, because I'd like to debug Python bindings that may come as a part of a shared object (.so) library - hence, I'd ideally place a breakpoint on a Python code line, and then \"step into\" the C part of the shared object... (Note that DebuggingWithGdb - PythonInfo Wiki doesn't really explicitly state that this is possible) The problem is: gdb on its own cannot really recognize breakpoints, placed on a Python script line:  ... and while the entire Python script does run within gdb, the breakpoint is simply never reached.  So - is what I want to do, at all possible with gdb; and if not, what other alternatives would I have for something similar? ", "id": 7412708, "title": "Debugging: stepping through Python script using gdb?", "traffic_rate": 17}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["python", "debugging", "gdb"]}, {"answers": [{"content": "GDB is not a Python debugger. GDB is not debugging your Python script. It is debugging Python, as in the CPython interpreter executable itself. To GDB, your script is data, not code. If your Python executable has the necessary debug info, you could set breakpoints in the C source code of CPython, or step through the C source code, but you cannot set breakpoints in your script. For GDB to understand anything about Python, you would have to bolt on a lot of additional code dedicated to understanding Python and adding Python-level breakpoint/line stepping/etc. functionality. As it happens, this extra code already exists! The Cython project comes with a GDB extension allowing mixed Python/C/Cython debugging, because it's a huge pain to try to debug Cython without this kind of functionality. If you need to perform mixed Python/C/Cython debugging, check it out. If you don't need to perform mixed debugging, stick to PDB.", "id": 58386013, "owner_tier": 0.9, "score": 0.9999999966666667}], "link": "https://stackoverflow.com/questions/58385853/running-gdb-with-python", "question": {"content": "How would one run gdb with python (as opposed to pdb which is pretty straightforward)? For example, if I have this program: I can run gdb with: It seems to 'work' in that it prints 16 but how would I:", "id": 58385853, "title": "Running gdb with python", "traffic_rate": 391}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["python", "gdb"]}, {"answers": [{"content": "This is like asking why is program A faster than program B. The reason may not be specific to the domain of debugging. I would imagine most graphical debuggers are built on top or a frontend to the pdb module provided in the python standard library (though not all are). The performance differences would mostly boil down to implementation details and GUI updating overhead. The difference could be as simple as doing unnecessary deep copies vs direct referencing in some layer of the code. If you are concerned about debugger performance, then you should stick with the faster graphical debugger, unless it is not satisfying some feature you need. You are asking for feature differences; since this is the case, they are both obviously current serving your needs feature-wise.  If one debugger is losing precision or sacrificing robustness, then I would discount it immediately from consideration. I would chance a guess that the slower one is either: Doing extra work or unnecessary checks (if the developer doesn't trust other parts of the code, or their are too many layers or redundancy architecturally). Using some cache-unfriendly or wasteful representation or hasn't tuned or optimised the code algorithmically as much as the faster debugger. Correct data structure choice and algorithmic optimisations can make orders of magnitudes of difference. Using low-level optimisations (like ctypes, psyco, pyrex) etc.. you can make another order of magnitude of a difference. Remember python gives you flexible and powerful default containers that you always \"pay\" for, even if you dont need all their functionality.  I have found that WinPDB is fairly lightweight, and is the one I usually use, since it doesnt tie me to an IDE, and supports remote debugging quite effectively. You might also want to try eclipse with pydev. Another new one I have just started playing around with is Python Tools for Visual Studio which looks very promising. There is also a list of python debuggers on the python wiki. It might be worth giving the others a try. As to why one is faster than the other, there are a multitude of possible factors. If you have access to the source of the debugger, you might be able to profile the debugger itself to identify the performance bottlenecks. But if you just want a fast debugger that handles all the basic use cases, just try a few more out, and stick with the fastest that serves your needs.", "id": 9370974, "owner_tier": 0.5, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/9346622/what-determines-debugger-run-time-performance", "question": {"content": "I have tried debugging Python 3 with Wing IDE (v.4.1.3) and Komodo IDE (v.7.0.0). As, expected the debugger adds a lot of run-time overhead. But what surprised me is how different the debuggers can be between each other. Here are the run-times for the same program. No breakpoints or anything else, just a regular run without any actual debugging: I refer to the debuggers as anonymous #1 and #2 lest this becomes an unintentional (and possibly misguided) advertising for one of them. Is one of the debuggers really 8 times \"faster\"? Or is there some design trade-off, where a faster debugger gives up some features, or precision, or robustness, or whatever, in return for greater speed? If so, I'd love to know those details, whether for Wing/Komodo specifically, or Python debuggers in general.", "id": 9346622, "title": "What determines debugger run-time performance", "traffic_rate": 2}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["python", "performance", "debugging", "python-3.x"]}, {"answers": [{"content": "Light Table was doing that for me, unfortunately it is discontinued: INLINE EVALUTION No more printing to the console in order to view your\nresults. Simply evaluate your code and the results will be displayed\ninline. ", "id": 69402859, "owner_tier": 0.5, "score": 0.0}], "link": "https://stackoverflow.com/questions/3999829/which-python-ide-can-run-my-script-line-by-line", "question": {"content": "I wouldn't call myself programmer, but I've started learning Python recently and really enjoy it. I mainly use it for small tasks so far - scripting, text processing, KML generation and ArcGIS. From my experience with R (working with excellent Notepad++ and NppToR combo) I usually try to work with my scripts line by line (or region by region) in order to understand what each step of my script is doing.. and to check results on the fly. My question: is there and IDE (or editor?) for Windows that lets you evaluate single line of Python script? I have seen quite a lot of discussion regarding IDEs in Python context.. but havent stubled upon this specific question so far. Thanks for help!", "id": 3999829, "title": "Which Python IDE can run my script line-by-line?", "traffic_rate": 7}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["python", "ide"]}, {"answers": [{"content": "Below are some quote from the Intel Software Developer Manual Vol. 3B, Chapter 17: Intel 64 and IA-32 architectures provide debug facilities for use in debugging code and monitoring performance. The Intel 64 and IA-32 architectures dedicate two interrupt\nvectors to handling debug exceptions: vector 1 (debug exception,\n#DB) and vector 3 (breakpoint exception, #BP). Both Debug Exception (#DB) and Breakpoint Instruction (triggeres #BP) are among such facilities. And both of them are meant for: ...transfers program control to a debug procedure or task... Debug Exception (#DB) relies on the several debug registers (DR0~DR7). While the breakpoint instruction (#BP) is: ... an alternative way to set code breakpoints....especially useful when more than four breakpoints are desired, or when breakpoints are being placed in the source code. The breakpoint instruction doesn't have as much power as the debug exception which is backed by DR0~DR7. Breakpoint instruction cannot be placed in ROM code. But and debug exception can be generated for ROM code as long as the DR0-DR7 are properly configured. For the debug exception: The debug-exception handler is usually a debugger program or part of a\nlarger software system. The processor generates a debug exception for\nany of several conditions. The debugger checks flags in the DR6 and DR7 registers to determine which condition caused the exception\nand which other conditions might apply. The conditions that may trigger a debug-exception can be many. Such as by setting EFLAGS[TF] the single-step debug-exception will be triggered.\nBy checking the DR6 (debug status register) and configuring the DR7 (debug control register), a Debug Exception handler can get the details of how a debug exception is triggered. For the breakpoint exception: The breakpoint exception (interrupt 3) is caused by execution of an\nINT 3 instruction. Debuggers use breakpoint exceptions ... as a\nmechanism for suspending program execution to examine registers and\nmemory locations. With the Intel386 and later IA-32 processors, it is more convenient to\nset breakpoints with the breakpoint-address registers (DR0 through\nDR3). However, the breakpoint exception still is useful for\nbreakpointing debuggers, because a breakpoint exception can call a\nseparate exception handler. The breakpoint exception is also useful\nwhen it is necessary to set more breakpoints than there are debug\nregisters or when breakpoints are being placed in the source code of a\nprogram under development. So we can see, breakpoint exception enables you to suspend the program execution, while the debug exception checks for several conditions and treat them differently. Only after you break at some location, you can then configure the processor for single-step or other things. You can configure the debug registers to specify the condition (such as code, memory or I/O locations, etc.) you want to break into, which will trigger #DB. Or place the breakpoint instruction in the code where you want to break into, which will trigger #BP. INT 3 is a single-byte op-code. So it can over-write any existing instruction with controllable side-effect to break into the execution of current program flow. Without it, how could you have the chance to set the single-step flag in EFLAGS at an appropriate time with no side-effect? So it is a two-step break-and-then-debug mechanism. The whole flow is: First, wire a debugger as the handler to both int 1(#DB) and int 3(#BP). Then put int3 to where you want to break in. Then debugger has the chance to step in. Once debugger starts to handle the int3 (#BP), if you want single-stepping, tell the debugger to set the Trap Flag (TF) in EFLAGS. Then CPU will generate a int 1 (#DB) after each single instruction. Since debugger is also wired to int 1 (#DB), it will have a chance to step in, too. (I discussed with one of my friends about how debugger works. He wrote a debugger before.) It seems the INT 3 (#BP) is the most important one. You can explicitly place an INT 3 instruction at the location you want to break into. Or you can let the debugger to do that for you. Once the INT 3 is hit, CPU will save the context of the broken program and switch to the INT 3 handler, which is usually part of the debugger. Now, the broken program is suspended because the execution is in the exception #3 handler now. The debugger is just a normal Windows or whatever desktop application. It can use the normal desktop message-loop to wait for user's commands to decide how to treat the program being debugged. So it seems both the debugee and the debugger are waiting now. But the reasons are very different. Then programmer (the human) can instruct the debugger (the software) to examine the saved context of the debugee. Or just restore debugee's saved context and let it resume. Or it may set the TF flag in EFLAGS so that a #DB will be generated by the processor after each instruction. But often, users may not want single-stepping at the instruction level. They may want to debug at the C statements level, which can be composed of many instructions. So the debugger can use the debug information, such as the PDB file, to find the location info. If users want to single-step at the C statement level, the debugger can find the beginning instruction of next C statement and rewrite the 1st byte of it with an INT 3. And then everything starts all over again. It's just a delicate cooperation between human, the debugger software and the processor. A related thread: Strange memory content display in Visual Studio debug mode", "id": 55806185, "owner_tier": 0.9, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/7941988/why-single-stepping-instruction-on-x86", "question": {"content": "So there is \"int 3\" which is an interrupt instruction used for breakpoints in debuggers. But then there is also \"int 1\" which is used for single stepping. But why is this needed? I've read that setting the Trap Flag (TF) in EFLAGS register will enable single stepping and will trap into the OS for each instruction. So why is a separate interrupt type needed? Thanks!", "id": 7941988, "title": "Why Single Stepping Instruction on X86?", "traffic_rate": 2}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["debugging", "gdb", "x86"]}, {"answers": [], "link": "https://stackoverflow.com/questions/19564019/debugger-implementation-step-over-issue", "question": {"content": "I am currently writing a debugger for a script virtual machine.\nThe compiler for the scripts generates debug information, such as function entry points, variable scopes, names, instruction to line mappings, etc. However, and have run into an issue with step-over. Right now, I have the following:\n1. Look up the current IP\n2. Get the source line from that\n3. Get the next (valid) source line\n4. Get the IP where the next valid source line starts\n5. Set a temporary breakpoint at that instruction or: if the next source line no longer belongs to the same function, set the temp  breakpoint at the next valid source line after return address. So far this works well. However, I seem to be having problems with jumps. For example, take the following code: Given this code, if I'm on line B and choose to step-over, the IP determined for the breakpoint will be on line C. If, however, the conditional jump evaluates to false, it should be placed on line D. Because of this, the step-over wouldn't halt at the expected location (or rather, it wouldn't halt at all). There seems to be little information on debugger implementation of this specific issue out there. However, I found this. While this is for a native debugger on Windows, the theory still holds true. It seems though that the author has not considered this issue, either, in section \"Implementing Step-Over\" as he says: Again: The debugger-thread locates next executable line and address (0x41141e), it places an IBP on that location. This statement does not seem to hold true in cases where jumps are involved, though. Has anyone encountered this problem before? If so, do you have any tips on how to tackle this?", "id": 19564019, "title": "Debugger implementation - Step over issue", "traffic_rate": 1}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "stackoverflow", "tags": ["debugging", "breakpoints"]}, {"answers": [{"content": "Debug prints are a valid choice at any level really, but in python specifically [breakpoint()](https://www.python.org/dev/peps/pep-0553/) is often easier to add to code and provides an easy way to check values that I find easier that bothering with adding a bunch of prints.", "id": "g8k3x4v", "owner_tier": 0.5, "score": 0.9999999900000001}, {"content": "eventually you will graduate to loggers in some projects but don't worry too much about it frankly.  when you are ready to have more control over your outputs then check out logging:\nhttps://realpython.com/python-logging/\n\nAnd at some point breakpoints maybe. Matlab is great for this, Python IDEs not so much.", "id": "g8ka7ld", "owner_tier": 0.5, "score": -9.99999993922529e-09}], "link": "https://www.reddit.com/r/learnpython/comments/j9j1v3/is_it_generally_a_good_practice_to_debug_code/", "question": {"content": "I have been programming with python for 8 months now and most of my time coding is spent debugging with print statements. I use VSCode and Pycharm for most of my development, I know both of them have a debugger but I never find a use for it. \n\nBreakpoints, Step in, step out, etc... am I missing out? Most of my code isn\u2019t very advanced, it\u2019s beginner to relatively intermediate code (for me)..", "id": "j9j1v3", "title": "Is it generally a good practice to debug code using print statements?", "traffic_rate": 153.1240740740741}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "I've always been using Python and pytest to test my PyO3 modules. As for debuggers and breakpoints/single-stepping/etc., I generally consider this a waste of time, unless you are investigating a segfault, but then again Rust code doesn't _usually_ segfault. Time invested into implementing good logging and writing test cases pays off tenfold, while time spent \"debugging\" only solves your immediate probem.\n\nThe code base is extremely complex and my purpose for debugging isn't focused around solving any \"immediate problems\" but making sure the whole system behaves as it should, looking for \"silent\" issues. Similar to the reason described here: [https://www.youtube.com/watch?v=tzr7hRXcwkw](https://www.youtube.com/watch?v=tzr7hrxcwkw)", "id": "krc88do", "owner_tier": 0.5, "score": 0.9999999966666667}, {"content": "I've worked both in PyO3 and Python + C++ projects, and the workflow that I've always done is: get the Python process id, then attach the debugger to that process.  \n  \nTo get the process id, I need to pause the Python process. If I'm working in the REPL, I don't need to to anything special. If I'm debugging a unit test, I'll add a `breakpoint()` call in the unit test where I want to pause. Either way, I type:\n\n    import os\n    os.getpid()\n\nThen I attach LLDB / GDB to that process id. I use VS Code and have a debug task that asks for the process id. \n\n>Is it recommended that I build a script that can run the module from rust internally and allow debugging?\n\nI actually prefer to debug these kinds of projects from Python bindings. The nice thing if you can rewrite your test script without having to recompile. Plus, the reproductions users give me are often in Python, so being able to debug those scripts directly saves time.\n\n>I've just been using\u00a0`println!`\u00a0thus far.\n\nIf you haven't used `dbg!()` yet, that's often a nice step up. I still often resort to this when debugging Rust tests. One nice thing about debug is that it just returns whatever is passed into it, so a line like `let x = do_something()` can just be rewritten as let `x = dbg!(do_something());` to print out the value returned by `do_something()`.", "id": "krembto", "owner_tier": 0.1, "score": 0.33333333000000004}, {"content": "Adding logging on the Rust side helps in understanding the code flow from a high level.\n\nYou can also run unit tests on Rust side and import/run python source code so it is close to what high level users do but you can have more insights with the object itself.\n\n    impl MyItem {    \n        /// creates a new instance from python source code. \n        /// name refers to the variable name in the source code (to search in locals)    \n        pub fn from_py(source: &str, name: &str) -> Result<Self, Error> {\n        pyo3::prepare_freethreaded_python();\n\n        // load python source and replace imports in locals with current rust structs\n        let source = source.replace(\"from myextension import *\", \"\")\n\n        fn create_module(py: Python) -> PyResult<&PyModule> {\n            let m = PyModule::new(py, \"my_module\")?;\n            m.add_class::<crate::A>()?;\n            m.add_class::<crate::B>()?;\n                // etc ...\n            Ok(m)\n        }\n\n        // extract grp\n        let it = Python::with_gil::<_, PyResult<_>>(|py| {\n            let locals = create_module(py)?.dict();\n            py.run(&source, None, Some(locals))?;\n            locals\n                .get_item(name)? // expect the variable\n                .unwrap_or_else(|| panic!(\"Can't find '{}' variable\", grp_name))\n                .extract::<Self>()\n        })?;\n\n        Ok(it)\n    }\n    }", "id": "krf41sk", "owner_tier": 0.3, "score": 0.33333333000000004}, {"content": "Once, I compiled my own python and added its debug symbols so I could use GDB to catch a memory corruption issue in pyo3. You can use any tool you want at the end of the day the interpreter is just another process. I now have tests for the pure rust part In rust, and test the python api using unittests in python.", "id": "krc9uui", "owner_tier": 0.3, "score": -3.3333333130750966e-09}, {"content": "You can always build a small test-case reproducing your bug out of hardcoded inputs in a Python file importing your Rust module.\n\nIf the main body of the library is separated from the code doing the binding, you could make a small Rust program calling the function with hardcoded values too, if you're convinced that the bug comes from the Rust side :)", "id": "krciah6", "owner_tier": 0.1, "score": -3.3333333130750966e-09}], "link": "https://www.reddit.com/r/rust/comments/1avnbwf/optimal_workflow_for_debugging_pyo3_based_project/", "question": {"content": "I'm fairly new to rust and a novice in hard CS in general coming from DS. I'm working on a large repo that is implemented as a python module using PyO3. The project has many useful unit tests, but no great way to test the entire module without calling it from python.   \n\n\nIt is my understanding that this will prevent me from setting breakpoints and using debuggers. I want this functionality as the whole system is quite complex and it's behavior hard to \"interpret\" without walking through the program. I've just been using `println!` thus far.  \n\n\nThe inputs needed to run the program from python are quite expansive. Is it recommended that I build a script that can run the module from rust internally and allow debugging? I'm trying to avoid this as the logic to get the inputs is quite complex on the python side and involves permissions to various DBs.  Would this be considered an integration test? Any advice is greatly appreciated thanks!", "id": "1avnbwf", "title": "Optimal Workflow For Debugging PyO3 Based Project?", "traffic_rate": 60.419380780056294}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "Debugging and unit testing is something beginners should learn early on, yet most courses and books barely talk about it.\n\n[deleted]\n\nI need to get into unit tests. What are your thoughts about unittest vs pytest?\n\nAny good sources for learning unit testing ?\n\nLast year, my boss (german, 60, 30yr XP in perl, C, python, embedded systems) told me off for using the debugger so much.  \n\nHe mentioned that printf's or UART transmissions were better (in tandem with a logic analyser) ajd that i shouldnt be so lazy.  From day 1 of coding, i have used the debugger to step through unfamiliar code.  \n\nI asked some of my colleagues at my new job and they use the debugger quite a bit.  \n\nI didnt really care for his comments but apparently i do, because i have been thinking about it since then.  Is using the debugger that bad?  I use it to explore the context, get to a step and see what I can do to it by injecting lines of code and seeing the result since documentation was hard to come by.\n\n[deleted]\n\nSo true.\n\nMost people are, it at least they feel like it.\n\nBoth will get the job done fine. Neither is a huge investment to learn; if you start off with one you can easily learn the other. With that said, having used both (unittest at work; pytest at home), I do prefer pytest. \n\n* pytest is more Pythonic - you can write tests in top-level functions and use the built-in `assert` keyword. unittest will force you to write a class for every test module, even if you only have a handful of test cases; unittest also uses its own assert methods rather than the built-in `assert`.\n* pytest has more features - for example, it contains a way to parameterise tests, so that you can run the same test with multiple inputs if required.\n* pytest has backwards-compatibility with unittest - if you write tests in the unittest style, you can use the pytest runner to run them. So you can move from unittest to pytest without losing any of the tests you've previously written.\n\nI tend to use unittest mainly because is a std module, but in the end is all personal preference.\n\nhttps://realpython.com/pytest-python-testing/\n\nAny time you think \"I am going to check this function in the console\" make it a test instead.  It makes life a million times easier down the road.\n\nhttps://docs.python.org/3/library/unittest.html\n\nI would recommend codewars too, since all the challenges will be unittested. Do a challenge, and setup the unittests on your local machine.\n\nSoftware Engineer here 10 years of experience. Using a debugger isn't lazy, nor a bad practice. If something doesn't work or you want to see how it works internally use a debugger. That's why they exist. I don't see how using print statements make you not lazy lol. I don't work in embedded nor German so not sure where he's coming from with that thinking, but is a bit weird to discourage debugger use.\n\nThat's probably one of the dumbest things I've read. It reeks a bit of \"real programmers use X\", where X is a low level programming language or editor or whatever. Debuggers are insanely useful. It's not lazy to use a debugger; it's a waste of time to write print statements directly in the code everywhere.\n\nDid they remove pycharm community?\n\nI tend to use pycharm and vscode. Overall I like jetbrains tooling since you get the same feeling across language IDEs. I get the free license for maintaining open source \ud83d\ude01. Been a fan for years since I switched from eclipse to intellij.\n\nHonestly, once you learn how to use one debugger, it's very easy to use the others. \n\nThe basics of debugging are universal - set a breakpoint, run the code until the breakpoint, step through the code line by line and inspect variables, use the REPL to do more advanced introspection if required, know the difference between stepping into a function call vs stepping over it, go up and down stack frames if required, and then run the code until the next breakpoint.\n\nOnce you know the above, using other debuggers is just a case of figuring out how to do all those things in the new debugger, and maybe taking advantage of more advanced features (e.g. conditional breakpoints in PyCharm).\n\nFantastic response and agree on all counts. Hat's off.\n\nWhat are the other drawbacks of unit test module besides writing a chunk of the same code again and again? Just wondering!\n\n[deleted]\n\nI personally don't have experience with the built in unittest module. I have always used pytest because of how straight forward it is to use and how cleanly it works in pycharm.\n\nThere are no drawbacks to unit testing, you don't write the same code again, if you do then you're doing it wrong.\n\n- unit testing tells you this class, module, piece of code is good\n- make one change downstream or upstream, unit test fails, caught it before sending to prod\n- in a huge project, manual testing is just not feasible, nor sane\n- unit tests give you a % coverage, you'd want as high as possible\n- unit tests also work in automated CI pipelines where multiple SREs are working on a code base\n\nThink about it this way the code you're testing against is a black box, and the unit tests are testing with different arguments making sure the return value is what is supposed to be. More often than not in a business, these are two different engineers.\n\nTo me, pytest just feels more pythonic in the way it tells you how unit tests should be. Its features are also simple to understand.\n\nAs a side note, repetitive code in unit test is not bad per se, and is actually quite common. You want to be able to see the sequence of steps in whatever you are testing.\n\nI'm not sure I follow your question. Are you talking about what the drawbacks are of manual testing (i.e. writing code in the shell repeatedly) vs automated testing (using unittest/pytest to write tests)?\n\nUnit tests are unrelated to code repetition.\n\nUnit tests are specialized objects that test whether a function is bug-free and working as expected; there are major benefits to unit testing, and the only drawback is the extra time needed to write and maintain your tests. By contrast, code repetition is just bad practice.\n\nIf you are writing code where a single chunk is repeated again and again, consider encapsulating that chunk as a function. That way you can just write the logic of that chunk in one place (i.e., inside the function), then simply call that function again and again as needed. That way, if the logic ever needs to change, you only need to change it in one place. You can also then write a unit test for that function to essentially keep tabs on it and ensure that it keeps working even as other changes are made elsewhere in the codebase during the development lifecycle.\n\nIn this way, unit tests help you easily test your entire code ecosystem to confirm that all the components continue working nicely together even as you make tweaks.\n\nBecause it doesn't directly generate revenue", "id": "hf8yd3y", "owner_tier": 0.3, "score": 0.999999999951923}, {"content": "Agreed. The debugger has helped reduce the number of questions my students ask, because they can see for themselves how things are changing and how values are interacting with their functions. We use Thonny, as I find it easier for beginner programmers to set up and use, and I have waxed poetically about its debugger in the past.\n\nSince you have students and I am currently a student, a relatively new programming student at that, would you suggest any resources on debugging to get started? \n\nIf it means anything the IDE my java class has me using is Eclipse, would you suggest IDE specific debugging resources or is there a more generalized approach to learning you would suggest as a teacher?\n\nSorry to put you on the spot, and if anyone else feels inclined to offer advice to me, please do! I just want to equip myself with the best tools to become a better problems solver early on.\n\nI teach high school Comp Sci, so we just get into the basics in the third year (input/output, conditionals, loops, functions, arrays) and expand on some of that in the fourth year (OOP, algorithm design/efficiency, data structures). Typically, after we learn enough commands to start making programs that are more than a few lines long (that is, sometime during loops and conditionals), we look at how we can use the debugger to avoid littering our code with print statements and test cases.\n\nI don't have any real suggestions about using the debugger, other than to just use it. The sooner you get a feel for toggling breakpoints, or knowing when to step in vs. step over, the sooner you'll reach for it as a tool when you're working on a complex project. And for the most part, the students find it fairly easy to navigate, once we've spent a class or two working through examples together and practicing on some simple pieces of code.\n\nHave you tried IntelliJ for your IDE?\n\nIIRC, in eclipse, you can click the the left of a line number in a file to make a breakpoint (it will appear as a red dot). Then, up by the \"run\" button, there should be another button to debug. (Just to the right. Looks the same as the run button, but with a little bug on it). It might ask you about switching to debug perspective at some point. Press okay to that, and it will add a debug window.\n\nNow, whenever your program gets to the line of the code with the breakpoint, it will pause and hilight that line. The debug window should have some tabs for stack frames and local variables. The local variables will show you the value of all the variables in that method call. The stack frame will show the method that's being called, as well as the method that's calling that, and the method that's calling that, all the way up to the main method. Selecting any of those will cause eclipse to switch to showing that method, and the local variables inside of it.\n\nThis is all happening while the code is paused, so if you want to continue (until another breakpoint is hit) you can (it's a little play button). If you want to continue only up to the next line, you can (called \"step over\").\n\nIt's pretty helpful.\n\nI appreciate the response and perspective, thank you!\n\nNo, but am considering giving it a shot... Though considering I am already partially familiar woth eclipse I may just stick with it.\n\nThanks for the detailed response, I will be using this in my upcoming work/assignments to improve my workflow!\n\nI\u2019ve used both. I honestly think you\u2019ll really come to love IntelliJ if you give it a chance. And I\u2019m not a jetbrains fanboy or anything. I don\u2019t like pycharm and use vs code instead for python.", "id": "hf8czwn", "owner_tier": 0.5, "score": 0.23076923072115385}, {"content": "Pycharm debugger and terminal integration for interactive coding/debugging is simply outstanding and the primary reason why I never have transitioned away to VSCode. The latter is great in many ways but debugging and integration with an amazing interactive python/ipython terminal with excellent variable viewer support makes Pycharm so much better than VSC. Iterating on code and/or fixing bugs is so stupidly easy in Pycharm that I will often times just stub out new classes/functions I am writing, break point into them with the params I plan to use and just interactively develop the entire function/class while catching tons of stupid mistakes you'd normally have made if you were coding \"blind\" by coding, running, printing/logging and then repeating.", "id": "hfayisa", "owner_tier": 0.5, "score": 0.014423076875}, {"content": "If you are learning (or teaching) Python, check out Thonny's (Nicer) debugger, Run > Debug current script (Nicer). \n\nIt makes a nice visual representation as you go through the breakpoints, replacing the values for your variables and stuff. It's quite good fun too.", "id": "hfbrsni", "owner_tier": 0.3, "score": 0.009615384567307693}, {"content": "I'd like to point out that there is nothing wrong with print statements. It is the most lightweight, portable debugger that you can ever have. There are some scenarios that you need to debug without an IDE and those could be times where you'll be glad you know enough about using the ol' handy print debugger. That said, learning your debugger is a game changer especially for very large projects.", "id": "hfcb9is", "owner_tier": 0.5, "score": 0.009615384567307693}, {"content": "As a beginner I tend to go into auto intimidated mode when I see words like Advanced in a title; maybe just me, probably is, but perhaps the yt vids title should be re-written which might make the debugger seem less scary (just a theory)\n\nIt's pretty simple actually. Give it a shot.\n\nI just added it to my bookmarks; getting to it first thing after I had my shit , shave and shower.\n\n> shit , shave and shower\n\nThat is indeed the proper order.", "id": "hfb2951", "owner_tier": 0.1, "score": 0.03365384610576923}, {"content": "I'll let me name speak for itself.", "id": "hg67rwj", "owner_tier": 0.1, "score": -4.807692307692308e-11}, {"content": "I can't fathom this idea that the debugger is \"too complex\".  You set a break point where you want the code to stop, then you press \"debug\"...the code runs until it hits the point you marked, then it waits. \n\nWhile it's waiting, you can look in the little debug panel to see the values of all your variables. \n\nFrom here, you can let it continue to run, or you can run it one line at a time. \n\nThus isn't much different than washing your dishes by hand because figuring out how to start the dishwasher is \"too complex\".\n\nAll things are hard when starting out. The UI for a debugger might look intimidating. Someone might not know how to interpret what they're looking at. They probably don't know what a breakpoint is yet. For someone just starting out, it's not hard to think a debugger is gonna be off-putting at first.\n\nOne man's too simple is another man's too complex.\n\nGoing by your dishwasher example: I didn't know that you're supposed to get the solid food gunk off the plates before putting it in, I didn't know that only certain plates and utensils are safe to put inside the dishwasher, I didn't know that they run for hours and hours, I didn't know they had special dishwasher detergent, etc. \n\nAnd this is because I didn't know what dishwashers - the electrical appliances - were until I was like 20 because, in my house, we had dishwashers - people with hands standing by the sink.\n\nNow GDB... that _is_ intimidating!\n\nAnd did you look at the appliance, throw your hands up and say \"well, I'll never figure this out?\" \n\nBecause that's what we're talking about here. Not trying and failing, but just refusing the attempt. \n\nIf you want to be a developer, you kinda need to be a problem solver. If you can't even solve the problem of \"how do my tools work?\", how are you going to make a career out of this?\n\nLol, that's the first debugger I learned, and it was crazy. It was still a big upgrade from print statements though.\n\nSure, but a lot of people learning python just wanna write their little pet project or run quick pandas operations on datasets. They don't want to be developers who solve lots of problems, they want to solve their problem. And learning the debugger isn't the problem they wanted to solve.\n\nThat doesn't mean they won't benefit from solving it, they will. But \"you're a software dev, learn to solve problems\" isn't an effective line to take with them.\n\nI know several people who prefer washing dishes by hand. It\u2019s not that feasible to imagine people being comfortable with what they know\u2026\n\nPretty much, yeah. The appliance is intended for large families. I have a two-person household, I don't have that space in my kitchen, I don't want to buy new plates. \n\nWhat if I'm not a software dev? What if I'm just someone trying to learn python so that I reorganize a bajillion files, or automate another program? I don't need a debugger for that.\n\nI don't need it, why should I learn it?", "id": "hf8mz8p", "owner_tier": 0.9, "score": 0.05288461533653846}, {"content": "Sold.", "id": "hfb0kya", "owner_tier": 0.3, "score": 0.0048076922596153844}, {"content": "Import pdb\n\n> ~~pdb~~~ ipdb\n\n:)\n\nAlso, I'm pretty sure you don't need to manually import `pdb`. Unless you have set a custom debugger e.g., via the `PYTHONBREAKPOINT` environment variable, just inserting `breakpoint()` into your code will call `pdb.set_trace`.", "id": "hfbyao2", "owner_tier": 0.3, "score": 0.009615384567307693}, {"content": "Nina Zakharenko's PyCon talk, \"[Goodbye Print Hello Debugger](https://www.nnja.io/post/2020/pycon2020-goodbye-print-hello-debugger/)\" is excellent. While in-IDE debuggers are discussed, a big chunk of the talk is focused on debugger tools that can be run outside of an IDE.\n\nI'm well-acquainted with PyCharm's debugger at this point, but it was super cool to learn about these built-in debugging options.", "id": "hfcbrwz", "owner_tier": 0.3, "score": 0.0048076922596153844}, {"content": "Is there something magical about \"IDE debuggers\"? I just use `ipdb.set_trace`, and I agree it is a totally game-changer. But I just use it in an interactive shell (where I do all my development), so never inside an IDE. In fact I don't really use IDEs at all.\n\nSo is there anything different about how I do it compared to doing all my debugging via an \"IDE debugger\"?", "id": "hfcptlw", "owner_tier": 0.7, "score": 0.0048076922596153844}], "link": "https://www.reddit.com/r/learnpython/comments/q0iv8t/learning_your_ide_debugger_will_change_your_life/", "question": {"content": "Don't make that same mistake that I did. I've been coding for more than 6 months always debugging by using print functions, spending several hours trying to run the code a thousand times hoping to get it right eventually.\n\nWhen I tried to use the debugger on my own it seemed too complicated, stuff for advanced users, and never really gave it a shot. But in the past week, I decided to learn how it works, and holy fucking shit I could not believe it.\n\nYou can do so much stuff with it it is incredible. Not only you're able to keep track of all variables as the code runs line by line, you can tell it to print the variables if would like, you can set conditional breakpoints, you can evaluate new things mid debugging session like a scratchpad calculator for code. In Pycharm it allows you to see dataframes with a beautiful layout with color formatting.\n\nI wish I knew this when I was beginning. My life would be so much easier. My productivity increased so much I feel dumb for not stopping to learn the debugging tools earlier.\n\nPlease, if you don't know how to use the debugging tool, take 30min of your day to learn it. It will change your life.\n\nI used the first half of this video to learn the Pycharm debugger: https://www.youtube.com/watch?v=k6j1NkVAsuU", "id": "q0iv8t", "title": "Learning your IDE Debugger will change your life", "traffic_rate": 153.1240740740741}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "You can upgrade your code to use logging.\n\nThen you can use debug level of logging for these messages and in production just change the log level filter to info or above.\n\nhttps://realpython.com/python-logging/\n\nIs there any specific package you recommend?\n\nI remembered having some trouble with logging because my variable data were Unicode characters (Chinese, Korean, Japanese etc). And logging module didn't like those.\n\nI heard its easier to do those now with 3.9 onward but I need to use tensorflow :/\n\nEdited my comment, the official python logging module is awesome.\n\nTry [Loguru](https://github.com/Delgan/loguru)\n\nthank you!\n\nWhat are the pros and cons of `logging` over `loguru`? I've only ever used the former, but unscientifically feel like I'm seeing that latter more and more...\n\nZero setup logging is basically the biggest value prop of loguru for me. One less thing to worry about.\n\nThe biggest issue I have with the logging module is a lack of an easy way to just do something basic.  I don't want that fancy of a logger.  I just want color enabled screen printer (using colorama) with a way to dump it to a file (that doesn't write the color) and a way to write that to a file without dumping it.  I don't need 10 handlers to do that.\n\nI should be able to start and stop a logger without getting double logs.  I should be able to change the desired print level at any point.  I should also have a way to buffer logs and write them to either text or html.\n\nI use cpylog.", "id": "gsx667t", "owner_tier": 0.7, "score": 0.9999999998113207}, {"content": "For debugging There\u2019s a Python debugger called pdb, but I\u2019d look at pudb instead; it\u2019s graphic (on the command line) and much easier to navigate. I still use print statements sometimes, but learning h a debugger will make things go so much faster. \n\nTesting is a different topic, but you should absolutely learn good testing techniques. I don\u2019t do TDD, my brain doesn\u2019t work that way, but I always write tests. Learning g good testing techniques is vital as you grow as a developer. Both testing and debugging are time well spent.\n\n> TDD\n\nDefinition for the uninitiated: [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development)\n\nThanks for bringing this up in the thread\nAs a beginner, I\u2019ve always wrote a lot of print statements (or console.log) but have recently been using pycharm with breakpoints\n\nCan you write a sort of evolution of debugging for a beginner? It seems like everyone starts at print()ing their variables to see what they\u2019re up to\n\nI\u2019m at the breakpoint/watchvar list\n\nI always thought testing was for the \u201cautomated testing\u201d (eg. Selenium) guys.\nHow does a regular developer use \u201ctesting techniques\u201d ?\n\nI\u2019m heading to a cabin in the woods with no internet access for a few days, so I\u2019m a bit limited to reply now. But, I would start by looking into unit tests; they\u2019re a type of testing that is usually easiest to understand since it typically just involves a test that calls a single function and checks that the function returns what you\u2019d expect. The overall concepts for unit tests are the same regardless of the language. There are other kinds of tests, but unit tests are the most widely used in my experience and will give you a good grounding in thinking about testing. \n\nUsing a debugger vs print or log statements will let you stop your code at a point in time, look at the complete state of all the variables, see the call stack and then step into the next method call or just let your program run. Rather than just giving you the state of a variable at a certain time it will give you the tools to better understand how your program got into that state. \n\nFeel free to DM me if you want and I can probably go a bit deeper in a few days.", "id": "gsx6ph8", "owner_tier": 0.1, "score": 0.3396226413207547}, {"content": "Yes, I use print statements all the time. It's a perfectly cromulent way to debug, but there are better ways. Testing really has changed the way I write code, and I started using it when teaching classes of college students to program. That worked well, so I wrote a couple of books on how to write Python with tests and types. I'd be happy to share more information and some sample chapters with you (or anyone). DM for links.", "id": "gsx655s", "owner_tier": 0.3, "score": 0.09433962245283019}, {"content": "print statements and logging only get you so far. I use pycharm and its integrated debugger. It's so handy.\n\nSeeing this a lot, I will check it out. Thank you!", "id": "gsx9wqw", "owner_tier": 0.5, "score": 0.0754716979245283}, {"content": "Everything has its time and place.\n\n`print` (and in other cases, `input`, if e.g., iterating too quickly to read the `print` output) is great for just inspecting the contents of your variables, but is very basic and so limited beyond that use case. `logging` is much more useful, but correspondingly it takes more effort to set up, so will be overkill for simple problems. So the TL;DR is that which technique to use really just depends on factors like (1) how deep your bug is, (2) how frequently you need to debug, (3) whether it's important to log your errors for posterity, etc.\n\nI personally find debuggers to be the most useful in most cases. They're vastly more flexible than `print` and also much easier to set up than `logging` - just drop a `breakpoint` wherever you want to debug (you may need to import something first, dep. your debugger and Python version). Once you code gets to the breakpoint, it drops you into interpreter mode, so you can actually interact with and manipulate your data, rather than just getting static output a la `print`. This is nice because it allows you to both find your bug AND trial some solutions all within the same step, often no need to rerun your code.", "id": "gsy118c", "owner_tier": 0.7, "score": 0.037735848867924526}, {"content": "No I don't. Have a look at the logging module. You can specify your log line to have a level, for e.g. debug or info. When debugging you set the loglevel to debug and you will see all lines and when you run normally you set the level to info and you won't see the debug lines. The logging module can do much more but suppressing debug messages in one of the features\n\nI've been reading through the docs for that and I think I need a little more time to understand exactly how that works. It's quite dense and I need to see some real applications of it but looks quite useful\n\nJust wondering if there\u2019s a streamlined way to keep an eye on the log file. Do you run \u201ctail -f\u201d on it and leave it running while programming?\n\nYeah I had the same thing. I got the basics from the logging module from a website called python module of the week. They introduce a lot of often used modules amongst which the logging module. I found that easier to understand than the docs of the module itself. After I got the basics down at pmotw the actual docs made more sense to me.\n\nYou can do all kinds of things. Like log to a file, stdout or to the foreground like you would in a docker container. One of these I usually do.\nWhen I am waiting a script I run it and let it log to stdout. When programming flask I just start flask in the foreground and the logs show up there.", "id": "gsxnpev", "owner_tier": 0.3, "score": 0.11320754698113207}, {"content": "Yes. \n\nEddit: since I am used to it, from writing code for microcontrollers, in which my only debug method is the serial port and a bluetooth module", "id": "gsy8928", "owner_tier": 0.7, "score": -1.8867924413632623e-10}, {"content": "I use a mix of everything.  The more debug tools you know the better, but yeah, a lot of print statements.  Usually it's the fastest way.   \n\nI don't really see tests as debug tools.  They give me confidence that I haven't broken what's tested.  That may not seem like much, but in practice it lets you be a bit bolder when making changes.", "id": "gsycbod", "owner_tier": 0.9, "score": -1.8867924413632623e-10}, {"content": "there's a difference between debugging a finished program and debugging something you're building.\n\nhaving logs is the best way to figure out what happened to a live system, especially in async or multi threaded apps. debuggers can change the timing of things and actually make it harder.\n\nwhen developing, write a test that calls your code before writing a single line of the code. print what is passed in, make sure it's what you expected, then replace the print with an assignment or loop or whatever. rinse and repeat until it works. that's basically how TDD works.\n\nsome people love debuggers, but I haven't actively used them in more than a decade. I find them to be much slower than TDD. in college, I didn't think I could live without debuggers. once I started working on real world projects, though, debuggers became tedious and inefficient to me.", "id": "gsz2j43", "owner_tier": 0.3, "score": -1.8867924413632623e-10}, {"content": "Consensus seems to be \u201cit depends\u201d. Simple programs can probably get away with print statements. When you are writing more complex stuff you\u2019ll need more complex tools.", "id": "gsz7vi7", "owner_tier": 0.3, "score": -1.8867924413632623e-10}, {"content": "With respect `print()` to debug is the sign of an inexperienced developer there are many better options. The easiest improvement is to swap your print statement with a `breakpoint()`. This is incredibly powerful as you now have an interactive debugger that you can use to step through your code, and evaluate variables to your heart's content.\n\nstepping through is like 99 million times better. playing with breakpoints now. thanks!", "id": "gszrl63", "owner_tier": 0.3, "score": 0.018867924339622644}, {"content": "Just use pycharm and put a break point!", "id": "gszsbu6", "owner_tier": 0.3, "score": -1.8867924413632623e-10}, {"content": "Since no one has mentioned it Visual Studio Code has a built in debugger.  You can set break points and then see what is in the variables at that stage and if you dig through you can usually find the cause of your issue.\n\nI haven't used anything else, once i had it working i didn't see a reason to!", "id": "gszuqqa", "owner_tier": 0.3, "score": -1.8867924413632623e-10}], "link": "https://www.reddit.com/r/learnpython/comments/mh7vh7/does_everyone_just_do_print_commands_as_you_go_to/", "question": {"content": "I started my Python journey several years ago and am actually working in a job where I use it every day, now it feels like a cool friend and I love it.\n\nI never got good at writing (or understanding) the concept of tests, especially as I develop something, and I always end up making a bunch of print commands as I go to check on variables. It feels like a sure shot, but sometimes is a little clunky and Im wondering if there's some important process I never figured out that I should be doing instead. It feels embarassing to review code with those statements (but I always remove most of them and comment out the most useful ones when I push to production).\n\nHow do you do it?", "id": "mh7vh7", "title": "Does everyone just do print commands as you go to debug?", "traffic_rate": 153.1240740740741}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "Just practice on my code\n\nLol \ud83d\ude06", "id": "jbhunsn", "owner_tier": 0.3, "score": 0.9999999998876405}, {"content": "Start by debugging code that works. Step through it. Watch it work. Watch it do the right thing.\n\nThis will let you focus on the debugger as a tool without thinking of actually solving a problem. How do you set breakpoints? How do you evaluate variables? Can you change variables? Can you step around out of order a bit?\n\nOnce your are familiar with and trust the debugger, then start debugging things that are broken that you need to fix.\n\nThe art of it is just regular troubleshooting. You must have a theory about what's wrong, you need to know how code works, and you need to be able to prove (not guess or assume) what happened when things didn't work or didn't happen as you expected.\n\nThis sounds great", "id": "jbhimyu", "owner_tier": 0.7, "score": 0.49438202235955053}, {"content": "There are already quite a few answers regarding the _tools_ you'd use for debugging, but if you're interested in more generalized debugging methodology, I can recommend the book **[Debugging Rules! by David J Agans](https://debuggingrules.com/)**.\n\nIt's been many years since I read it but I remember finding it a really fun and entertaining read. It talks about debugging \"rules\" in a generalized way that honestly even applies to day-to-day problem solving, outside of code.\n\nWhile the examples used might feel a little dated and with an engineering spin, it's never too technical, the tone is lighthearted, and most importantly, I find it really helpful.\n\nOk looks great will look into getting the book\n\nSecond this.", "id": "jbhntg3", "owner_tier": 0.1, "score": 0.12359550550561797}, {"content": "If you re new defintly use thonny. This is really the best debugger for beginners, its intuitive to use and you will learn things like 10x faster.\n\nIs it a download?\n\nYes. It's a lightweight IDE with an epic debugging function. It'll show you step by step how variables are filled and used and while debugging (as in, press the debug button instead of the run button and go to the next step with F7) it'll visually replace variables with the actual values so you can very specifically see what's going on.\n\n[https://thonny.org/](https://thonny.org/)\n\nOk thanks \ud83d\ude4f", "id": "jbi4wms", "owner_tier": 0.1, "score": 0.12359550550561797}, {"content": "Write buggy code...", "id": "jbhsyc1", "owner_tier": 0.7, "score": 0.05617977516853933}, {"content": "I usually put print(whatever i need to check) in parts that I have issues with.\n\nWhat advantage does debugger have over print besides speed?\n\nSome advantages are that, if you\u2019re using a debugger, then the application is basically \u201cpaused\u201d while you can inspect whatever you want in the current state \u2013 values of any variables, etc. \u2013 and do things like step through and into its execution process piece by piece (e.g. things still look good at the first breakpoint? step slowly forward bit by bit, or let the program run until you hit the next breakpoint).\n\nWith print, on the other hand, if you make a mistake (e.g. don\u2019t log the right property), you have to update the print and do it all over again. Then you find out your guess was wrong, or not enough, so you change your print again and start over again. Eventually, once you\u2019ve figured things out, you then have to clean your code of all the print(s) you added.\n\nAppreciate it very helpful. I always get confused between next continue and skip lol", "id": "jbj8m95", "owner_tier": 0.1, "score": 0.10112359539325842}, {"content": "I just use print statements and experience\n\nMuch better than debugger?\n\nDepends who you ask. I\u2019d rather spend time debugging rather than learning how to use the debugger. Now to say I haven\u2019t tried over the years. For some reason I just never had an aha moment with the debugger.", "id": "jbjmkzn", "owner_tier": 0.3, "score": 0.08988764033707865}, {"content": "You got a lot of really great answers but I'll add one just for an extra tool if you need a visual of what your code is going. \n\nPythontutor.com\n\nYour script can't be overly long but it's a great extra tool. It's not a replacement for any of the things people mentioned but the visual is sometimes helpful.\n\nThank you", "id": "jbjp860", "owner_tier": 0.5, "score": 0.05617977516853933}, {"content": "Honestly, a good start is to just place print statements everywhere. Every if/else condition, start/end of every function, and at the start and end of main. ( Make them different things of course, I do different foods). The statements that get printed will show you what parts of the code are running. The ones that don't  print/ that's what's failing.\n\nDo you use a debugger?", "id": "jbkts55", "owner_tier": 0.7, "score": 0.05617977516853933}, {"content": "Break stuff in predictable way", "id": "jbkwqsk", "owner_tier": 0.1, "score": 0.044943820112359555}, {"content": "Look for a youtube tutorial. I debug with pycharm's integrated debugger and there's a lot of useful stuff to learn. For example. The first thing i learned was the use of breakpoints but recently I learned about conditional breakpoints. \n\nIt's better to learn all those stuff in one go.\n\nDamn sounds confusing thanks", "id": "jbll1dy", "owner_tier": 0.5, "score": 0.05617977516853933}, {"content": "Here are 5 tips I want to give to beginners if they are planning to learn it:\n\n1. Understand the problem:\u00a0Be resourceful as you try to understand what\u2019s gone wrong. Make sure that you\u2019ve been correctly using any functions, methods, or features by referencing documentation and other resources.\n2. Talk to yourself aloud:\u00a0Calmly walk yourself through the problem at hand and how you\u2019ve approached it. As you explain aloud, you may discover assumptions you\u2019ve made or details you\u2019ve missed along the way.\n3. Use debugging tools:\u00a0There are various tools that will help you debug, and you should use them when you can! You can use specialized debugging software or built-in language tools like Python\u2019s pdb module.\n4. Seek feedback:\u00a0The coding community is very willing to share knowledge and give feedback, so don\u2019t hesitate to ask for help from other developers.\n5. Sleep on it:\u00a0Sometimes, all it takes to solve what seems to be an insurmountable problem is to look at it with fresh eyes. If you\u2019re stuck on a problem and don\u2019t know how to move forward, sometimes the best thing to do is walk away. Just disconnect from the problem entirely. If it comes down to it, sleep on it.", "id": "kzssfip", "owner_tier": 0.1, "score": 0.044943820112359555}, {"content": "I would learn to execute code in your head and be able to maintain a mental model of execution. You should be able to walk through code line by line in your head, and for simple programs, accurately guess what the output will be (using paper as your memory if need be). Being able to do this helps immensely when debugging. While debuggers and logging are nice, they aren't always necessary, and many bugs can be solved in the time it takes the debugger to load.\n\nI practiced this by speed-debugging code on Stack Overflow, and still practice that here and on other subreddits.\n\nWow that\u2019s next level\n\nNot OP, but it's really just good ol' experience. Years of making mistakes and fixing them will teach you a lot of skills.", "id": "jbh7vus", "owner_tier": 0.9, "score": 0.10112359539325842}, {"content": "The best debugging starts with a good logger. Good exception handling after that.\n\nWhat\u2019s a logger?\n\n[https://realpython.com/python-logging/](https://realpython.com/python-logging/)\n\nIt should be one of the first things you import for any project. Production code can't write to the terminal. The \\`print\\` function is also performance heavy try running\n\n```\nfor i in range(1000000):\n    print(i)\n    pass\n```\n\nand then comment out the print statement - you'll be surprised how much faster it runs.\n\nInstead of printing things to the terminal - you write that information to a log file. Log files don't go away everything you run a program - this is good when something crashes and no one is looking. If your code is over say 500 files long, spread across a few Python files, or needs to run when you are not looking you need logging.\n\nThat\u2019s great thanks\n\nThe benefits you list for logging are true.  I've long noticed how much slower things go when you print out thousands or millions of lines.\n\nBut it's just conceptually so easy to just quickly put a print statement somewhere, and see what happens, instead of messing around with other files.  These things have never been an issue for me.\n\nOh 100% printing is 10x easier \u2026 most of the time lol\n\nIf you\u2019ve got code running another another machine, a program that\u2019s 24/7, etc - those sort of thing then printing isn\u2019t an option\n\nHell at work when I test code it gets shipped to a Docker environment - the container doesn\u2019t exists once the tests finish. So all I have for debug is a report of what tests passed/failed and a log dump to dig through", "id": "jbh4v6p", "owner_tier": 0.3, "score": 0.13483146056179773}, {"content": "Try using **type hinting** to help identify bugs as you write your code.", "id": "jbhyrg0", "owner_tier": 0.3, "score": -1.1235954987893585e-10}, {"content": "Writing some code with bugs, of course!", "id": "jbledrc", "owner_tier": 0.5, "score": 0.03370786505617977}], "link": "https://www.reddit.com/r/learnpython/comments/11mb9yr/what_is_best_way_to_learn_debugging/", "question": {"content": "Hello new programmer here\n\nInterested in learning to use proper debugger and debugging techniques.\n\nWhat wound you recommend best way to learn and get better with debugging and a debugger?", "id": "11mb9yr", "title": "What is best way to learn debugging?", "traffic_rate": 153.1240740740741}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "In the book \"The Practice of Programming\" Kernighan and Pike specifically recommend using print() statements, because they put the lightest touch on code. If you are running code in a debugger, there is a chance you will run into an issue that is caused by the debugger itself, while a print() statement is much more reliably harmless.\n\nThey also state that the most useful tool any programmer has for debugging is the brain. Think about exactly how the program is misbehaving and how that might have happened before diving into a debugger or sprinkling print() statements in your code.\n\n> They also state that the most useful tool any programmer has for debugging is the brain.\n\nI definitely disagree, that one never works for me!\n\nIn all seriousness though, they were writing at a time when fast IDE's with integrated debuggers and simple UI were not as prevalent as today. I really can't get over how piss easy it is to use the debugger in pycharm.\n\nIf I write a line and run the code and it doesn't work, I can throw a break point in while thinking through what's happening and it often sheds some light. I've had a ton of situations where somebody named a variable poorly (eg my_name_list that isn't a list) and I'd have to go back to the source and be distracted by 20 other possible errors. If I use the debugger I immediately know more information and it will help me use my brain.\n\nI also think things are different depending on whether you're handed code you know nothing about to fix a bug or are debugging something you have been working on. The former, I agree, isn't helped as much by a debugger. But once I've spent sometime familiarizing myself, usually the debugger speeds up the fix.\n\nPersonally debugger/print reliance is probably 80:20 unless you count logs as print(), then it's probably flipped.\n\nGreat comment. Thanks for sharing\n\n[deleted]\n\nThe other issue is that you don't want to develop debugging habits that only work well with interpreted languages. If you're in the habit of using print() it works in C++ world etc.\n\nDefinitely get good at using print() if you're a pro...\n\n[deleted]\n\nI'm still gonna use the debugger over print.\n\n> OP is wrong, I'm glad that the top comment is sensible.\n\nOP is right and Kernighan's advice is outdated. Heck, it was even becoming outdated back then in 1999 and it's definitely outdated now.\n\nUse the Python debugger and/or the `Logging` module.\n\nPEP 282 -- Feb 2002 -- A Logging system for Python: https://www.python.org/dev/peps/pep-0282/\n\nIt's 18+ years old at this point. Know it, live it, love it. \n\nIt's easy to use. I swear.\n\nDebuggers work fine in compiled languages.\n\nI think it's called sleep, but I'll just make more coffee first.\n\nNot really.  When the issue is in line 5, and your errors are showing in lines 7, 9, 15, 40, and 200... No.  I'd honestly rather it just say \"hey you messed up somewhere\", than spend an hour trying to rework the wrong bit of code.  \nFor newbies, this is one of the hardest things to wrap our minds around.  I've come to the point where I just treat it as a general idea I've bungled.  Then go through looking for the mistyped variable, missing semicolons or braces or what have you.\n\nDefine \"fine\". It's one more thing to wrestle with. Print statements are lightweight and universal, as other people have pointed out. I use the same general troubleshooting methodology via print statements for C++, Haskell, and Powershell. Now extending that methodology to Python.\n\nI'm not interested in keeping abreast of four different debuggers because - well - I have a life.\n\n> keeping abreast of four different debuggers\n\nGenerally, you don't have to. \n\nMy first debugger. Turbo Pascal. Compiled language. Debugging support built-in to the Turbo Pascal IDE. I honestly didn't know what it was, but I knew it was there and that I could set up watches and conditional breakpoints.\n\nC#. Compiled Language. Debugger built-in to the Visual Studio IDE. Only once did I ever run into a race condition where the debugger allowed the code to run properly, but when optimized and debugging symbols turned off the program would occasionally crash. (I eventually solved the problem. As I said it was a multi-threaded race condition.)\n\nPython. Interpreted. PyCharm IDE has fantastic support.\n\nIf you're still using `print()` statements everywhere, you're playing the programming game on `hard`.\n\nPlease, friend. Please consider switching to using the Python debugger and send your error/warning messages to the Python `logging` module. It's like using `print()` but much more manageable.\n\nhttps://docs.python.org/3/library/logging.html\n\nThose are different debuggers. I used Turbo Pascal, then Turbo C. Even those were different debuggers with different configurations. And VS is definitely different from the other two. Let's not get into gdb.\n\nMeanwhile, in 30+ years of programming, the print statement has worked like a charm, and always been handy. I agree with the Kernighan mentality of keeping it simple. Our younger programmers who use twenty seven different tricks and frameworks turn out crap code compared to the old school programmers who keep their methods brutally simple.\n\n> the print statement has worked like a charm\n\nNo it hasn't. It's created a mess in your code which you then have to clean up later.\n\nAnd every modern framework has a logger. [Use the Python logger to debug](https://docs.python.org/3/library/logging.html) if you really want to print something. It's built-in and been around for years. Don't use print statements unless you're, you know, actually needing to print something to the screen/console.\n\nSee PEP282: https://www.python.org/dev/peps/pep-0282/\n\n> Our younger programmers ... turn out crap code\n\nBecause they're less experienced than we are and only have 1 or 2 languages under their belt and have only used one framework and one IDE (and maybe only 1 debugger).\n\nMeanwhile you and I have dozens of languages and frameworks and years and years of experience behind us. It's not the fault of \"tricks\" (?) and frameworks.\n\nDo you understand that you're arguing against Brian Kernighan's view? The guy who co-invented Unix, and created C?\n\nIf it's good enough for Kernighan, it's good enough for me. I'm a big believer in KISS. The print statement doesn't create any sort of \"mess\" in code - all I do is search for \"debug\" and I find each comment associated with a debug print statement.\n\nIt's better to be nimble and use your brain, than rely on some bloated debugger from Microsoft.", "id": "foulnxw", "owner_tier": 0.5, "score": 0.9999999999324324}, {"content": "I agree that debugger is the go-to tool when a bug is reproducible and it is feasible to control execution. But there are times, it is just not feasible. For example, a (micro-)service in production, when an error happens, only diagnostic tool available is the logs (aka systematic print statements).\n\nBy itself, no single tool or technique is sufficient. Writing prod-quality code requires several tools working together:\n\n* compilers, linters, other static analysis tools\n* unit, integration, end-to-end tests (this is where debuggers are very useful in debugging a failure)\n* logging (structural/canonical logs for querying and automated alerting)\n* perf/load test coupled with profiling\n\nJust like using print/log statement where debugger is more suitable can not be considered wise, same is true for the inverse too.\n\nSo even while in IDE, do not ignore print statements. Instead, use log() systematically with levels. What you are debugging is hot in your brain at that time, and you are best placed to think what log should be there to diagnose it later in production when you would not have IDE control at your disposal.", "id": "fouog63", "owner_tier": 0.1, "score": 0.08783783777027027}, {"content": "I totally disagree. The debugger is great if you have a real bug and/or your code won't run but it'll not necessarily help you if the only problem is that you're not getting the result you were expecting.\n\nI find the debugger more useful when the code *does* run, but gives unexpected results.\n\nprint() is for when I need to quickly confirm that a specific function is being called as expected.\n\nA debugger with breakpoints can do anything a print statement can as you can use it see the values at different points in your code. I don't think there's anything wrong with print debugging (especially in an interactive context), but debuggers can do the same thing.\n\nI had a project that was printing the wrong results earlier this week. Once I used the debugger I was able to see how each variable changed in my code as it ran and therefore was able to figure out where my problem was. Way better than writing 7 print statements.\n\nThat's what the `logging` module is for.\n\n[logging \u2014 Logging facility for Python](https://docs.python.org/3/library/logging.html)\n\nThis is a standard built-in module for Python.\n\nMy point was that a debugger is not necessarily faster or more efficient in term of workflow, especially for small mistakes.\n\nHow does this work if the error is in the output for just 1 iteration of a large loop? Say a rare error that occurs in 1/500 iterations? Is there something other than clicking through 499 times to reach the 'correct' break point?\n\nI agree, not necessarily faster, but you get more of a punch using it when you're learning a new concept, stepping in and out can guide you visually without guessing if the print statement was placed. It's helpful if there are code comparisons (my implementation vs tutors implementation) as a building block.\n\nConditional breakpoints probably, but I guess it would depend on the exact situation.", "id": "fou1nt8", "owner_tier": 0.3, "score": 0.35810810804054055}, {"content": "My opinion: use a logger instead of print messages (for example with the builtin logging library). Then you replace\n\n    print(\"abc\")\n\nwith \n\n    logger.debug(\"abc\")\n\nAnd when you don't need to read the debug messages anymore, you change the log level from ```logging.DEBUG``` to ```logging.INFO```\n\nand you can also make good use of other debugging levels : CRITICAL, WARNING\n\nAssertions are also a useful feature\n\nAs someone who deals with application logs day in and day out i cant stress how helpful it is to have good logging for going back to figure out what happened. With poorly planned logging I cant count how many times a developer has come back saying an issue isnt reproducible so cant fix it or need more steps for how to reproduce an issue or something that is happening today was caused by something else on a previous day. \n\nSecondly, with a logger you can direct the logging to a file rather than the terminal window. When reading my own code or someone else's it makes it easier to distinguish between output from the program vs logging. If you have put good log levels into your log lines it can be helpful to identify what is important.\n\nNot only that... you can add your own debugging levels! \n\nMy development team together agreed to 2 more levels: MSG (between INFO and WARNING) and DEEPDEBUG (even lower than DEBUG)\n\nJust create a new class inheriting the `logging` class, add your extra debugging levels, and instantiate all instances of `logger` from your new custom `logging` class.", "id": "fouy9za", "owner_tier": 0.1, "score": 0.1148648647972973}, {"content": "This is absolutely true. Please note that PyCharm also allows for conditional breakpoints (by right-clicking the breakpoint) and you could still use the prompt while using the debugger to execute additional commands, allowing for additional verifications/checks while working. \n\nFor any remaining print usages use a proper logger instead. This even holds true when working on solo projects.", "id": "foub6uh", "owner_tier": 0.1, "score": 0.05405405398648649}, {"content": "What are some of those newsletters if you don't mind sharing them?\n\n[https://lerner.co.il/newsletter/](https://lerner.co.il/newsletter/)\n\nI've signed up for his weekly exercises as well found here ([https://store.lerner.co.il/](https://store.lerner.co.il/)), and purchased his book on Manning Publication, into it about a year now and can say that I've learned a lot of the fundamentals in a hands on way, with supplied reading. Hope you enjoy it. He has some free stuff from time to time and discounts..", "id": "foufcog", "owner_tier": 0.1, "score": 0.05405405398648649}, {"content": "I don't like these very generalized statements about using or not using something. There are thousands of different use cases for Python. To say that print is never the best option in an IDE is ludicrous. There are definitely people out there using Python that have run across a situation where print was the best option.\n\nNow that I re read it I should preface with \"depending on use case\" my notion is that debugger can visually display coverage better than print via the ide.", "id": "fovkzqe", "owner_tier": 0.7, "score": 0.04054054047297297}, {"content": "I use Pycharm daily... got a quick tutorial laying out how to use this feature ?    \n\n\nI use print() a lot to see what's going on in my program at a given point.\n\nJust click on the left of the lines you want to put a breakpoint in (a red dot will appear). Then run your program using the Debug option (or click the bug icon in the top right).\n\nYour program will stop executing when it reaches a breakpoint, and then you can either look at whatever variables/expressions you want, or resume execution by pressing F9.\n\nAwesome; thanks!", "id": "foujj4x", "owner_tier": 0.7, "score": 0.04054054047297297}, {"content": "Same, last week I also discovered the PyCharm debugger.", "id": "foulmsw", "owner_tier": 0.1, "score": 0.02702702695945946}, {"content": "You can also use `import pdb; pdb.set_trace()` in the place you want to debug. It will stop executing rest of the code and let you play with data in the shell.", "id": "fovjork", "owner_tier": 0.3, "score": 0.02702702695945946}, {"content": "You are totally right! The Pycharm debugger is AMAZING!", "id": "fovx38w", "owner_tier": 0.3, "score": 0.02702702695945946}, {"content": "The main problem I have with debuggers is not using one or knowing to use one. I've used Visual Studio's quite extensively with .NET applications, and it's very nice to have when you need it. The problem I have with the debugger is that it's not a free action. Using the debugger requires organizing and configuring your project in such a way that *the IDE* can execute (and in some software platforms, also build) the program. This is frequently a massive pain in the neck, but alleviating it is also problematic. As evidenced by my experience with Visual Studio, if your IDE makes it easy to *use* the debugger, this is typically accomplished by being extremely invasive in the process of building and managing the project as a whole. This makes it difficult to build, test, and manage the project *without* the IDE, and an IDE is a massive dependency that you should not have in either your build environment or any deployment environment. Most IDEs pay little mind to ensuring that managing them outside of the IDE remains simple, but instead they optimize for making their own functionality simple. So the result is that you're stuck with two nasty choices: hand over building, packaging, managing dependencies, and deploying to your IDE and lose 80% of your control over it, or give up the debugger and other IDE niceties.\n\nWhat I have found is that I prefer giving up the IDE's niceties most of the time. I would rather be in full control over the tooling and operations of my project and deal with slightly more difficult debugging/diagnostics. If you don't solve those problems cleanly up front, they will become a nightmare *at the very end* when you're ready to release your project, and you will typically need to rewrite portions of your project to account for these difficulties.\n\n---\n\nAs a small aside, one downside to working in a debugger is that I found  it more difficult to understand the execution of my code in a debugger. If a function happened to be invoked more than once, I would frequently not realize my breakpoint was in a different call than the one I was trying to debug, and having to stare at it and figure out that was what was happening would actually waste a noticeable block of time. `print` statements, on the other hand, consistently show me each call separately, so I can easily see the multiple invocations and find the one I'm interested in, whether I realized that was what would happen ahead of time or not.", "id": "fouq5in", "owner_tier": 0.5, "score": 0.020270270202702702}, {"content": "At the top:\n\ndebug=True\n\nAt prints:\nif debug: \n    print(msg)\n\nSeems easy to me.\n\n[`__debug__`](https://docs.python.org/3/library/constants.html#__debug__)\n\nOh man... I would not accept that in pull request.\n\nThat's great for small projects, but that's a bitch for somebody else to read. Don't get me wrong, I've done stuff like that plenty of times especially for short data science scripts that probably only need to be run one time after I know they're working. However, it will quickly make a project awful to read through especially when everyone just adds their own every time they need to figure something out.\n\nWhat's better - going through and adding prints, then commenting them out?  The next time you need it, you uncomment the ones you \\*might\\* need?\n\nI guess maybe I don't have the time to screw around with things that aren't essential at work - normally busy doing actual work.  But checking a variable every now and then for truthiness is literally meaningless in the context of running an application.\n\nI do this all the time.  Normally debug would be a variable set in config, then optionally passed in with -d, however.\n\nIf you're going through the work of building it into a project, I'd definitely use logging rather than print. Plus then you don't need to worry about running it again unless you want to change the logging level.\n\n> I guess maybe I don't have the time to screw around with things that aren't essential at work - normally busy doing actual work.\n\nI'm trying my best to not be rude, but if you think making code readable for others isn't part of your job, you do you. I think you'll find a lot of people consider that actual work.\n\nLol. What\u2019s not readable about a print statement?\n\nI actually still use syslog instead of logging at work. Good thing we don\u2019t work together, you seem really difficult to get along with lol. You do you bud.\n\nIf you add enough to really help with debugging that's a ton of extra code that's not used most of the time and will grow every a new problem arises. *A* print statement isn't a problem, but it's not going to be *a* print statement. Maybe I'm just overly bothered by this because I used to work on a team that did this a lot and ended up having 100 line scripts turn into 500 lines extra print statements (don't even ask about the real code).\n\nIf there are places you want to console log a message (which is definitely helpful in certain spots), why not use the logging module which automatically provides you significantly more information and gives the option to log to a file?\n\nWhen you say syslog, do you mean that you're emitting system messages instead of use the logging module in python? Why would you do that (unless it's legacy and you're stuck with it)? If you're writing system specific shell programs, it's not an awful idea, but even then, why not lean on the power of a standard library module like logging?\n\nAs far as difficult goes, all of my work has been on teams with very bad code cleanliness with my primary goal to be standardization of code. I've found that it's very difficult make adjustments when print statements are used. I've had to grep through 4,000 lines of code and change hundreds of print statements when we decided to change how we logged messages. If it had been implemented with logging, I could have just changed everything from one spot. I agree that I am a bit difficult when it comes to logging and code cleanliness, but it's due to that burning me the most over the years.\n\nsyslog is a standard library module, just like logging is.\n\nIt's just not platform independent.  It only works with linux.  We only use RHEL systems so, I guess I got used to that.\n\nAll of our code it set up basically the same way - if we do pass in a -d, the lines that are passed to syslog are not only logged in the configured log, but also to STDOUT.\n\nAt the same time, a log line can be set to only debug - right - so if config.log\\_level is \"info\" or whatever, it simply does nothing with those debug lines.  I definitely see both sides of it...I'm not certain there's a right or a wrong way, personally.  I've been coding for over 20 years now - a lot of the standard 'stuff' these days, I've just always done manually - heck, I just learned within the last year what argparse was and moved our entire codebase away from getopt.\n\nI'm certain that I write clean code - more often than not, I'm the guy revisiting it anyway - and I can't remember what or why I wrote what I wrote a year ago, let alone a month ago - normally when a project is done and shipped, my brain just kind of moves on...that's also why I like flipping the \"debug=True\" switch and just seeing what gets spit out - sometimes it's a pain to go back through and try to find where you need to print or debug or whatever.\n\n> syslog is a standard library module, just like logging is.\n\nTIL! I'm personally a linux person, but worked for my first few years in python at a Windows company... I never realized the nix syslog was built into python, but I should have.\n\nI'll say /u/deapee, I'm warming to you and your ways! I'd still strongly recommend OP's rule to use debugging in your IDE, but this is definitely a better option than adding print statements when you need to check something in production (or like you said to get an overview of what's happening).\n\nAlthough, on my team, I'm still going to make them use the logging module :)", "id": "fouvm3p", "owner_tier": 0.3, "score": 0.0675675675}, {"content": "I disagree. Using print() statements makes a programmer go through and check each piece of their code. It offers an opportunity to take a piece of data and interpret what the issue is, putting it up to the programmer to debug it. It\u2019s a valuable tool for problem solving. \n\nAlso my debugger crashes my program anytime I\u2019ve tried to run it, so I am a little sour on it.", "id": "fouxww8", "owner_tier": 0.7, "score": 0.020270270202702702}, {"content": "Hi,\nSolid advice.. I also use print statements to debug.. but I work in jupyter so I don't know wheather are there any debugger or not.. so I would like to ask you two things..\n\u2022Is pycharm the best ide you've ever used? As I am planning to switch from jupyter..\n\u2022which weekly newsletter you buy?\n\nYour response is very much awaited! And also if anyone else is willing to answer please, you're welcome..\n\n>https://lerner.co.il/newsletter/  \n>  \n>I've signed up for his weekly exercises as well found here (https://store.lerner.co.il/), and purchased his book on Manning Publication, into it about a year now and can say that I've learned a lot of the fundamentals in a hands on way, with supplied reading. Hope you enjoy it. He has some free stuff from time to time and discounts..\n\nPyCharm is the only one I have used other than like Sublime etc.. Have not used VSCode or the like to compare..\n\nThere is a free pycharm version that's pretty good. I know a lot of people that prefer visual studio and I think VS Code is the \"free version\" although it's quite different. I can't give advice about VS because I have personally sold my soul to JetBrains... I just really like their products, but that's a personal opinion, not a technical evaluation.\n\nMost of them are pretty good. Are you doing mostly data science and scripting? Jupyter is amazing at what it does and I think it's great for things like that.\n\nOhkay.. thanks mate! I'll look into that\n\nFirst I would say sorry for late reply as I rarely check notifications..\nMostly I use jupyter because of its cell type environment which gives me a freedom to execute different parts of a program independently.. and yes jetbrains products are awesome..", "id": "fouy9dl", "owner_tier": 0.3, "score": 0.08108108101351351}, {"content": "Guilty as charged here", "id": "fov0xdl", "owner_tier": 0.3, "score": 0.020270270202702702}, {"content": "Did you not working with PL/SQL Developer? That has a pretty decent debugger built in.\n\nNo, with SQL Developer. I have heard great things about PL/SQL developer across the board.", "id": "fov2o3a", "owner_tier": 0.3, "score": 0.02702702695945946}, {"content": "Learning to use a debugger is absolutely essential. However I do think `print` debugging is still useful, especially when you are interested in seeing a sequence of output instead of just looking at the state of a specific line of code. For example, print statements are great when looking at the output of iterators and generators because what you are interested in is the entire output sequence.", "id": "fov6pwy", "owner_tier": 0.7, "score": 0.020270270202702702}, {"content": "There are many cases where debugger can not freeze all of the application, and  a breakpoint notably changes the behavior. Especially when you are debugging something that works with a remote system or a daemon, that is not running in debugger.", "id": "fovd4nn", "owner_tier": 0.7, "score": 0.020270270202702702}, {"content": "if i'm going deep into a difficult to work out bug  i will use the debugger, but often a print statement is far quicker to use. it gets the job done just fine for smaller issues", "id": "fovwpbh", "owner_tier": 0.7, "score": 0.020270270202702702}, {"content": "I'd love to know more about these python newsletters.", "id": "fow2l59", "owner_tier": 0.3, "score": 0.020270270202702702}, {"content": "I use logger primarily to debug since I want to leave those in for later use anyway. I can typically try 7 things and read the logs in the time I can try 1 in the debugger. \n\nI only ever use the debugger for very complex stuff like reading the value of a big dictionary or something. And I rarely need to do that. \n\nI generally find the debugger to be unnecessary if you really understand the algorithms you're implementing but might just be me. Either the logs or the stack trace will tell me what's wrong.", "id": "fowug2g", "owner_tier": 0.5, "score": 0.020270270202702702}, {"content": "I propose that using a debugger is equivalent to a code smell. It can indicate that your code has gotten away from you.\n\nDefinitely think there are use cases, but I wouldn't say that they are in the majority", "id": "foxgo3d", "owner_tier": 0.5, "score": 0.020270270202702702}, {"content": "Stop telling us how to write code.\n\nThere is nothing and I mean absolutely NOTHING wrong with using print statements to debug code nor is there anything wrong using a logger or a debugger.\n\nPersonally I use prints most of the time.  If it's REALLY hairy and I'm having a hard time chasing it down then I'll use a debugger.   To be honest I rarely need a debugger in Python.   When I use it it's almost alway's an issue in a library we are using.", "id": "foy92cz", "owner_tier": 0.1, "score": 0.020270270202702702}, {"content": "using the IDE debugger is a tighter software lock-in, since it forces you to use said IDE\n\nthis being said, sometimes when I'm not in the mood to fiddle with pdb/pudb I really miss winpdb and it feels sad about it becoming abandonware and me not knowing any GUI standalone python debugger - not a full IDE, just a debugger", "id": "foudbty", "owner_tier": 0.3, "score": 0.020270270202702702}, {"content": "But what if I need debug FUNCTION? Debugger don't run through function every time.\n\nYou can set break points to call those specific parts of code?", "id": "fovfl6z", "owner_tier": 0.1, "score": 0.02702702695945946}, {"content": "NO!\n\nMore arguments or reasoning might help you make a case for your claim - whatever that claim is exactly...?", "id": "fouj6a4", "owner_tier": 0.5, "score": -6.756756715692764e-11}], "link": "https://www.reddit.com/r/learnpython/comments/g9laze/opinion_stop_using_print_to_debug_within_your_ide/", "question": {"content": "I've been using PyCharm for well over a year, and have been too lazy to use the debug functionality, rather lazily used print statements. I come from a procedural PL/SQL background so writing dbms out statements has been the norm the past seven years.. \n\nI subscribe to a few weekly Python newsletters, that go over basic concepts (this month it's all about iterators). I decided to, while reading these newsletters try the steps in/out, but do it using the debugger rather than using print statements. Seriously, I can't get over how helpful the PyCharm debugger is. Reading material and pressing \"step into my own code\" really helps solidify reading material.\n\nWhat has me thinking even more is that, it takes longer to write, figure out where to place print() than it does to plop a single breakpoints.. So yeah that's my Tuesday advice to newbs like me that want to learn better. Stop doing yourself a disservice, print stmts take longer and are less useful!\n\ndisclaimer: i do not work for PyCharm, I'm truly just amazed right now.\n\ntl;dr use the IDE debugger, rather than print().", "id": "g9laze", "title": "Opinion - Stop using print() to debug within your IDE!", "traffic_rate": 153.1240740740741}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "My life changed when someone introduced me to IPython embedding. \n\nfrom IPython import embed; embed() \n\nIf you are at all familiar with ipython, this will drop you to an ipython shell when you hit this point in code. \n\nOne better if you are using a web framework like django or flask, if you are using the dev Web server it drops you to a shell in that window allowing you to check variables etc. \n\nAlong those lines, ipdb. pdb except it uses ipython as the interpreter.\n\nFirst:\n\n    pip install debug\n\nThen in python code:\n\n    import debug\n\nYou, sir, just made my life a lot easier. \n\n[deleted]\n\n> import ipdb; ipdb.set_trace()\n\nOne of the greatest discoveries in the history of my life.  And that includes sex.\n\nnose_ipdb for reproducibility\n\nYou dont need iPython.\n\nfrom code import interact; interact()\n\n*Use ctrl+D to exit.\n\nYou can do it with pdb.\n\nI have been using ``import pdb;pdb.set_trace()`` forever with great success.  Now you've got me curious!\n\nThis is something I also use. Pretty awesome.\n\nOr with ipdb if you want iPython console.\n\npip install ipdb  \n\nimport ipdb; ipdb.set_trace() \n\n\n\nipdb has everything from pdb plus tab complete, colors, and indentation.\n\nAbout sex?\n\nipdb is awesome, sadly it doesn't play well with gevent.", "id": "cbdzqcd", "owner_tier": 0.5, "score": 0.9999999999411764}, {"content": "I've been coding python for ~6 years professionally.  I've never used anything other than print and logging statements for debugging ... and well one other important thing...  The big secret, is to use iPython ... and to code and debug predominantly in the interactive shell.\n\nSo rather than coding everything in an IDE, sprinkling break-points and log-statements ... I spend 99% of my time working out my logic in the interactive shell.  Once I have things working as they should, it gets pasted into vim and tested once more in the actual app before I hit commit.\n\nIf you are so inclined iPython has pdb built-in with some convenience methods as well.  So though you may be used to coding predominately inside an IDE ... that's not really the way to go with a language like python ... you'll be a lot better off learning iPython inside and out and pretending it's your IDE.\n\nFor large applications I usually will take the time to sprinkle a modicum of logging statements at various levels (error, debug, etc).  You can use pygments to format tracebacks, sql, etc for fancy colored output to your terminal session ... or html or what-have-you.  These are mostly for issues encountered in production though  (usually performance tweaks and the like), rather than debugging issues encountered while initially putting something together.\n\nAlso ... another simple, yet effective trick with print statements is to remember that you can access most python object's attributes with \\_\\_dict\\_\\_ ... iPython has tab-completion ... but it's not always easy to go the shell-route ... especially with existing/crap code.\n\n*formatting\n\nCan you talk more about your workflow for this? I've mostly been using Django and sometimes I'll go to the shell (with manage.py shell) and mess around with my DB models or other code.\n\nThe problem is that then I may want to modify a class somewhere. So I switch to my editor and change it. Since there doesn't seem to be a good way to reload things I need to exit the shell and restart it and then rerun imports and all that. IPython makes the last part a little easier (can type 'from' and hit up to get to the last couple of imports, etc) but still a pain. After doing that couple of times, I usually end up making a little script file that I run from the command-line instead just to make things easier and then delete it when I'm done.\n\nHow do you handle that kind of situation? Are you modifying the class definition directly and then just getting a new instance? What if you're modifying a function? Is there an easy way to get and modify the source of the function from in ipython? How do you keep track of the various different stuff you changed to make sure it all gets back into the sourcecode?\n\n> So though you may be used to coding predominately inside an IDE ... that's not really the way to go with a language like python ... you'll be a lot better off learning iPython inside and out and pretending it's your IDE.\n\nThis is indeed a very different approach to development. I'll have to read up on IPython and try it out. Thanks.\n\ndoes this work when developing applications that run in a loop, like PyQt GUIs?\n\nYep, I concur.\n\nThis is a sentiment I've heard echoed several times recently about creating in Lisp's various REPLs. I guess I've been doing it for years without thinking of it this way, because I work in Maya, which has the Script Editor. I can select any code in it and hit Ctrl+Enter to run it. For a decade prior to that I was using MEL (Maya Embedded Language) in the same, integrated editor, so it's just how I've known working forever.\n\nOne thing that I don't know how to do in various Python shells is go up and edit the code without just inputting every line of a class or function over again (using up arrow, of course). I'm guessing this is easy in IPython. The Script Editor in Maya allows this by default, as it's not so much a REPL as a text input box.\n\n+1. A major productivity gain comes from embracing IPython and learning a few magic commands like%run and %hist that let you gradually move code from interactive mode to a file...\n\nI thought I was the only one coding this way. Thanks for your post\n\nYou can reload modules in ipython like such:\n\n    my_module = reload(my_module)\n\nYou'll need to reinstantiate any objects that have changed though.  I think I recall there being a way to automatically update the code in ipython.  Oh yeah, here:\n\n    %load_ext autoreload\n    %autoreload 2\n\nBut I can't remember that usually and I don't like typing it for every session.\n\nAs the other guy said .. you can reload your imports in iPython ... which should be a lot easier than restarting and re-importing everything.\n\nUsually I try and avoid that as well and edit/subclass within iPython.  A lot of times I'll try and work with a concatenated version of what's actually in the source code.  When things start to get a bit longer than a couple lines ... I'll use a scratch-pad ... where I'm editing what I need for the shell and copy/pasting it back and forth.\n\nThe other slightly more elegant option is to sub-class what-ever class you are working on ... allowing you to add/modify a class or class's method without much effort (super comes in handy here).\n\n...and as far as guaranteeing everything makes it into the source code ... I use the lord jesus christs' mighty powers ... kidding I just try and do it by memory.\n\nThe short answer is yes, but it can take some work.\n\nIt can sometimes be a useful in this sort of situation to setup fake classes so that you aren't actually running your event-loop ... allowing you to focus on the code you want to.\n\nYou can do this with any number of different use-cases ...for example you can setup a minimal request-class for a web-app... where your views follow a pattern like this...\n\ndef my_view(request):  return response\n\nSo I would generally just create a FakeRequeset class with the minimal attributes to satisfy my use-case.  You can do the same for event loops and the like ... if you want to avoid actually running the event-loop ... to focus on another attribute of the code.  Create a fake QT class, that includes the methods you use ... but instead of instantiating a window or ev-loop or what-ever they just output the debug info you want.\n\nYou can get fancier and fancier and these sorts of classes can double for test-harnesses.\n\nUp arrow in iPython will bring back the last code-block not just the last line ... way more useful ... though still has its limitations. i.e.; when you need to change one char 10-lines up in the code-block.\n\nThanks! I think when I was first learning about Python I saw all the warnings about issues with reload (and some confusion about it being removed in 3 when it was really just moved) and stayed away. Seems like it'd be fine in most cases for the repl though.\n\nI think even `reload(my_module)`, without the assignment, will work. Not sure why, but it seems to in my interpreter.\n\nI like the idea of doing a subclass in the repl. Seems like something you'd want in some cases for new functionality anyway.\n\nI think some of my difficulty with Python is sometimes it feels a bit between the extremes. In C#, you can't do too much in a repl so experimentation would usually be done in a special scratchpad like LinqPad. Then in something like Clojure, the editors usually have capabilities to easily send a code block to the repl and change things on the fly.\n\n\n\nYou need to compile python + qt with debugging, then you can use gdb.\n\nI was going to write something like it, but then found [Vimya](http://gitorious.org/vimya), which did what I wanted. It's a Vim plugin that lets me send visual selections or the entire current buffer to Maya for evaluation. I have my leader key mapped to comma, and the mappings I use for each are `,sm` and `,sb`, respectively. Because I build tools and pipelines for Maya for my job, it's a natural environment for me to work in all day.\n\nVimya writes the selection or buffer - whatever you asked to run - out to a temp file (using Vim's temp file abilities), then talks through a Python socket to Maya's commandPort (which is a socket) to tell it to source and run the temp file. It all happens instantly. I'll have Vim on one monitor, Maya on another, and the Script Editor on the third.\n\nThe Script Editor has an input half at the bottom, and an output half at the top. The output acts like a shell output, so I end up with a kind of REPL, where the output is on a different screen, but where the input environment is Vim itself, so I have enormous, textual powers. I'm sure the workflow is very similar to IPython, but I'm guessing I have a lot more convenience on the text-editing side, because of Vim. I often tweak a block of code, then run it with `vip,sm`, or select a line and run it with `V,sm`.\n\nI sent a patch to the maintainer of Vimya that allows for sending user commands directly from mappings, which opened up the ability to send things that aren't in a buffer. I've added several Maya controls under the `,m` prefix to let me do things in Maya from Vim, like start and stop scene playback (`,mp`, `,ms`), frame all visible items (`,mf`), change the frame range in and out points (e.g. `<count>,m<<`), and force create a new scene (`,mn`), which is very helpful when loading assets over and over while working on tools.\n\nIt can also capture command results to a new tab through a tail plugin, if installed, but I haven't found that to be very useful. Print statements here and there work fine. If I want to print a variable, I just hop to it and hit `,p`, which is a mapping I made that adds `print variablename` on a new line below that line. I also have mappings to tag lines like this, and other mappings that let me toggle them on and off as comments, individually, or all together, or strip all of them from the buffer in one go. I haven't used IPython. Is it programmable in these kinds of ways?", "id": "cbdzqdp", "owner_tier": 0.5, "score": 0.4176470587647059}, {"content": "Break points are fine, print statement are .. fine-ish. In a IDE is much easier.\n\nYou can also consider:\n\nThis will set a hard coded \"break point\" in your code (yes it is a one liner).\n\n    import pdb; pdb.set_trace()\n\n\nIf your script raises an uncaught exception then it will enter the pdb debugger.\n\n    import sys, pdb\n    sys.excepthook = lambda x,y,z: pdb.pm()\n\n\nFor more about debugging please see this video for an overview about technique for debugging python at all levels:\n   \n   http://skillsmatter.com/podcast/scala/intro-to-python-debug\n\n\n\n\n\nThanks. I'll have to experiment with that and see how it ties into eclipse. ", "id": "cbdyoqa", "owner_tier": 0.1, "score": 0.12352941170588234}, {"content": "If you have IPython and you want to drop into a full IPython shell at a point in your code (and will have all local variables in scope etc),  add this at the line you want to drop to:\n\nimport IPython; IPython.embed()\n\nOtherwise, if you do want a debugging stuff like step, continue etc, you can also use \n\nimport ipdb; ipdb.set_trace()\n\nwhich is much nicer than pdb mainly because of tab completion... Can't remember what property of my_obj you should be using? As easy as  my_obj.<tab>\n\n", "id": "cbdzsid", "owner_tier": 0.1, "score": 0.029411764647058823}, {"content": "There's always the tried and true [pdb](http://docs.python.org/2/library/pdb.html). I find I use\n\n    import pdb; pdb.set_trace()\n\na lot more than I should :-)\n\nOthers have mentioned IPython embedding,\n\n    from IPython import embed; embed()\n\nwhich is vastly superior to pdb, but for me pdb is just hardwired unfortunately...\n\nYou would probably love ipdb\n\n>  ipdb\n\nHonestly... I've never heard of it. It looks pretty nice.. This especially has me excited:\n\n    with launch_ipdb_on_exception():", "id": "cbe0tv9", "owner_tier": 0.7, "score": 0.047058823470588235}, {"content": "I've started using [wdb](https://github.com/Kozea/wdb) in my projects. It's really useful, especially when you use the `w` builtin, allowing one to invoke the debugger whenever `w.tf` is encountered, along with unhandled exceptions.", "id": "cbe2966", "owner_tier": 0.7, "score": 0.017647058764705882}, {"content": "For the past week, I've been using pudb. It really speaks for itself, and I am really in love with this debugger.", "id": "cbe1unz", "owner_tier": 0.3, "score": 0.011764705823529412}, {"content": "I also come from a Visual Studio background and found it hard to give up breakpoints. Using the Python plugin for VS gave me breakpoints that worked just as I expected them to. You should try it out.", "id": "cbecagb", "owner_tier": 0.5, "score": 0.023529411705882353}, {"content": "Coming from visual studio I used IDLE for a bit and never debugged there and then moved to pycharm and I debug here.\n\nThis supports standards visual studio usage \nhttp://pytools.codeplex.com/", "id": "cbeivkh", "owner_tier": 0.7, "score": 0.011764705823529412}, {"content": "I mostly use print statements.  I reach for pdb.set_trace once in a while.\n\nI tend to write unit tests for non-trivial functions and catch most of the bugs there.  So the bugs that survive tend to be the complicated kind where debuggers don't help so much due to timing issues.  Or they're buried several layers deep in a daemon where it's not easy to get at a console to use the debugger.  Print statements are a pain but they work almost everywhere.", "id": "cbe1c73", "owner_tier": 0.7, "score": 0.011764705823529412}, {"content": "I rarely use breakpoints. My first step is to just read the stack trace and see if I can figure out whats going on. My second step is to write some additional unit tests that can test a hypothesis about the bug. My third step is instrument the tests with additional print statements, and various introspection methods. My final step is get in there in the shell by placing a breakpoint with pdb. I usually don't have to resort to that.\n\nCould you elaborate a little on how to use these introspection methods? I don't quite follow what they mean.\n\nits not as complex as it sounds. here's a few of the ones I use most commonly:\n\n* calling the .\\_\\_class\\_\\_() method on an object to make sure it is what its supposed to be\n* calling the .\\_\\_dict\\_\\_() method on an object so I can take a quick look at the values of all its attributes\n* putting a suspect block of code in a try/except statement and catching as many values as I can think of (that might be useful) in the exception that I expect will be raised\n* in the case of a bug that isn't raising an exception, I'll put in a logger set to the most verbose log level and try to log entering and returning from every method that might be responsible for the bug\n\nI can see that test driven development ties in nicely with python's __class__() and __dict__() methods. Thanks for reminding me about starting to use that. :)\n\n\nFor inspecting an object to see what variables / functions it has, I use these methods:\n\n    from pprint import pprint\n \n    def print_variables_of(obj):\n        \"\"\"variables of an object\"\"\"\n        pprint (vars(obj))\n \n    def print_callables_of(obj):\n        \"\"\"callables (functions too) of an object\"\"\"\n        li = []\n        for name in dir(obj):\n            attr = getattr(obj, name)\n            if hasattr(attr, '__call__'):\n                li.append(name)\n        pprint(li)", "id": "cbe3p7f", "owner_tier": 0.7, "score": 0.05882352935294117}, {"content": "I personally like the pycharm IDE the debugging features in that are a dream. If you are coming from a visual studio background it will come easily to you! ", "id": "cbe2vd8", "owner_tier": 0.1, "score": 0.005882352882352941}, {"content": "I just use logging, print, unit tests, and breakpoints (Eclipse debugger).\n\nAwesome question though, I see there have been a lot of answers I can get good tools from ^_^", "id": "cbe38dm", "owner_tier": 0.1, "score": 0.005882352882352941}, {"content": "I try to use \"assert\" and \"raise\" when I'm debugging.", "id": "cbe39lq", "owner_tier": 0.5, "score": 0.005882352882352941}, {"content": "WingIDE has a great debugger that will jump to the point of a crash automatically.  You can then print out any needed info and jump up levels to print out the values going into a function.  You can also stick a little breakpoint in your code as well as track how variables change.\n\nI don't get why more people on /r/python don't use it.  PyCharm is pretty meh for debugging.\n\nhttp://www.wingware.com/\n\n>I don't get why more people on /r/python don't use it. PyCharm is pretty meh for debugging.\n\nBecause JetBrains semi-regularly have sales that massively decrease the cost as a barrier to entry; contrast this with WingIDE, which I've literally never heard of going on sale (nor should it need to)\n\nBecause JetBrains produce other IDEs, which provides name familiarity and reassurance to those coming in via other languages. Additionally to that, because JetBrains provide many apps, their name recognition is more widespread, and thus more likely discussed.\n\nBecause Wingware seem to do nothing in the way of marketing.\n\nBecause WingIDE apparently requires an X11 server on OSX. I don't think that's available by default in 10.8?\n\nThose are the reasons I cash think up, good or not.\n\n\nWhat does WingIDE debugger do that PyCharm doesn't?\n\nI haven't used Wing in a while, I've been trialling PyCharm because it also has good JS support.\n\nI like Wing's Source Assistant far better than any of the other code popover thingoes.\n\n\n\nI've never had any problem with debugging in PyCharm. There are a couple things that aren't intuitive if you've been working in VS (e.g. it is not immediately apparent how you would set exceptions to break at the top of the stack), but most of the things I'm used to getting out of VS in C# are present for PyCharm.\n\nFair enough.  JetBrains does a good job marketing.\n\n> Because WingIDE apparently requires an X11 server on OSX.\n\nReally?  Weird...\n\nDo many programmers use Mac?\n\n> JetBrains semi-regularly have sales\n\nHow regularly? I'm actually testing PyCharm now and it's a clear improvement over Eclipse/PyDev for me, so considering buying it\u2026\n\nYou're on reddit, this sample of programmers is heavily skewed.\n\n>Really? Weird...\n\nWell, v4 says it needs one. I just installed the v5 beta, which made no mention of it, and OSX didn't complain, so maybe that's not the concern it should be.\n\n>Do many programmers use Mac?\n\nAnecdotal evidence from various conferences seems to favour OSX (certainly over Windows), and `homebrew` makes it an acceptable environment for a good chunk of developers. How big a market it is by comparison to *nix proper, I couldn't begin to guess.\n\nThey had one at Christmas which was 75% off personal licenses IIRC, and they had X% off for ... Earth Day, I think it was? There be been more, I'm sure, but my memory isn't that good.", "id": "cbe5qf2", "owner_tier": 0.7, "score": 0.07058823523529412}, {"content": "There was a good video on blip.tv or youtube by Barry Warsaw (I believe) showing basic usage of pdb from the command line.\n\nI don't use pdb much.  In vim, I have the following setup to run the current buffer using pdb   \n   \n*autocmd FileType python   map <buffer> <M-d> :w<CR>:lcd %:h<CR>:!start python -m pdb \"%\" <CR>*   \n\nHow do you handle larger projects that is split up over several source files? The current buffer might not be the program's entry point. I.e. you can't just execute a class. Do you have to switch to the buffer containing the main function first?\n\n\nAnother pdb video: http://pyvideo.org/video/644/introduction-to-pdb\n\nThe assumption is it is the main project file.\n\nTo answer your second question, you could have a switch that goes to the primary python script file.  The simplest approaches would be to use the same name main file name for all your projects or have some configuration file that defines what it is (I believe that's what most IDEs do.).\n\nThat's the video.  I thought it was the Barry Warsaw dude though.", "id": "cbe6k7o", "owner_tier": 0.3, "score": 0.035294117588235294}, {"content": "IPython's %run takes parameters for debugging, too.\n\nFor example \"%run -d -b11 script.py\" would run script.py, breaking into ipdb on line 11 or on exceptions.\n\nYou've probably got IPython running anyway to try out stuff. And with %run, you never need to place debug method calls in your code (like pdb.set_trace() or embed()).", "id": "cbe77n4", "owner_tier": 0.3, "score": 0.005882352882352941}, {"content": "python -mpdb script is my buddy. Surprised not to see it here...it's everywhere and enough to see what's happening. If I could list functions in other files it'd do everything I want. ", "id": "cbe7f16", "owner_tier": 0.7, "score": 0.005882352882352941}, {"content": "If you're comfortable in IDEs you should definitely try out [PyCharm](http://www.jetbrains.com/pycharm/). Best Python IDE currently available (not free though).", "id": "cbeb6rv", "owner_tier": 0.5, "score": 0.005882352882352941}, {"content": "For code I write.  Generally I write unit tests which catch nearly all the issues.  For those issues that still exist I look at the traceback and most of the time that's all that is needed to figure out what went wrong.  Next I'll use a print statements and at times logging.  If all that doesn't help I'll pdb.set_trace() and use the debugger but that only happens 1-2 times every couple of years.\n\nFor code I didn't write.  I'll look at the traceback and/or place some print statements to try to get a quick answer.  If that fails next get a feel for the design of the sw by either adding a few 0/0 to get a divide by zero traceback to so that I can view the call stack or for more complicated code I may profile the library or part of the library with a case that doesn't fail and open the pstats data in runsnakerun to get a good understanding of the architecture of the code.  After that I generally follow the same methods I do with my own code.", "id": "cbf7r4m", "owner_tier": 0.1, "score": 0.005882352882352941}, {"content": "I'm a long time eclipse user for java and started debugging some python this week with eclipse and the pydev plugin.\n\n* download \"Eclipse Standard\" [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/)\n* unzip\n* launch the eclipse binary\n* Menu: Help > Eclipse Market Place\n* Search for Pydev and install\n* Restart Eclipse\n* With the source file open in eclipse double-click on the left of a line to set a breakpoint\n* Debug by Right-Click > Debug as Python\n", "id": "cbdzhbt", "owner_tier": 0.1, "score": -5.882352905426641e-11}, {"content": "Also - print statements are nice but look at using a logger.  Makes it much easier.  ", "id": "cbe0u91", "owner_tier": 0.5, "score": -5.882352905426641e-11}, {"content": "I switched from pyscripter debugger (which is nice!) to ipython / import ipdb; ipdb.set_trace(). Cuz i like ipython.\n\nDon't forget pyscripter post morterm debugger", "id": "cbe1c4s", "owner_tier": 0.1, "score": 0.005882352882352941}, {"content": "I mainly use print statement as well but on some occasion, I'll use the pdb debugger by simply placing the following statements in the code where I want to break:\n\n> import pdb; pdb.set_trace()\n\nI'm also using Flask and I often use its [interactive web debugger](http://flask.pocoo.org/docs/quickstart/#debug-mode). It's pretty nice.", "id": "cbe1ulp", "owner_tier": 0.5, "score": -5.882352905426641e-11}, {"content": "I like [winpdb](http://winpdb.org/about/). I don't use an IDE (emacs), but I like GUI debuggers better than straight pdb because I can visualize things a bit better. Even works on remote python processes.\n\n(To defuse a common misconception: no, *win*pdb is not just for *win*dows, it's just an unfortunate name.)\n\nAlso very useful for applications that mess with stdout or do interesting things with their process model that cause the standard pdb debugger to be fairly useless.", "id": "cbe23m7", "owner_tier": 0.3, "score": 0.005882352882352941}, {"content": "If you're coming from VS might want to check out any of the popular Python IDEs out there that give you project management, interactive debugging, breakpoints, watches, etc. \n\nI've used Pydev (add-on for Eclipse) and Pycharm but there are others out there worth checking out.", "id": "cbe2vqu", "owner_tier": 0.5, "score": -5.882352905426641e-11}, {"content": "You can set breakpoints in IDLE. (No one seems to use this feature but me.)", "id": "cbe35m3", "owner_tier": 0.5, "score": -5.882352905426641e-11}, {"content": "I prefer print statements and spending time to really get to know the code.\n\nIt isn't always the best approach, but it is often *far* better than using a debugger - which tends to make it harder to see the big picture.  I've known quite a few programmers that use a debugger too much and only modify code through tiny little ugly duct-tape patches because they don't get the big picture.", "id": "cbe7ze6", "owner_tier": 0.7, "score": -5.882352905426641e-11}, {"content": "When I'm using  PyDev or pycharm then I do use breakpoints for my debugging.  That way I don't accidentally leave debugging print statements in place as I tend to do when I'm developing using emacs/vim/st2/etc where I usually just add print statements rather than using pdb.", "id": "cbe9wlw", "owner_tier": 0.1, "score": -5.882352905426641e-11}, {"content": "Reading all the replies in this thread, the only thing that stands out is \"no you can't\", but there are crazy workarounds.\n\nThis should be changed. If there was an IDE like visual studio for Python, life would be glorious... so much more efficient debugging via breakpoints (for me anyway).\n\nIt feels dirty littering my code with all sorts of logging statements. I don't know if this is the standard way in other languages, but when I was coding in Java I desperately wanted something that could mimic the breakpoint/debug features of VS. Closest I've found was eclipse and even that was \"meh\".\n\nPyCharm debugging is much like VS.\n\nYou can use visual studio for Python. Just download the add-on.\n\nThere is a Microsoft-made plugin for VS that you can download [here](http://pytools.codeplex.com).\n\nI haven't personally used it, though. I use PyCharm from JetBrains, while others out there use wing. \n \n\n\n\nBut if course you can. Even pdb does breakpoints and there are loads of more complex options. \n\n> so much more efficient debugging via breakpoints (for me anyway)\n\nThe \"for me anyway\" is key.\n\nOh nice!! I didn't even know about this, thanks so much!\n\n", "id": "cbe0srt", "owner_tier": 0.1, "score": 0.11764705876470588}], "link": "https://www.reddit.com/r/Python/comments/1jeurc/do_you_debug_python_with_breakpoints/", "question": {"content": "Hi all.\n\nI'm coming from a C#/Visual Studio background where placing breakpoints and stepping through the code is second nature. But for python code I tend to use print() statements a lot more and just run the code. For any project beyond very small things it feels like the wrong thing to do yet that's what I end up doing. I'm using eclipse and PyDev so I have the tool support for \"real\" debugging. \n\nSo, /r/python, what's your preferred debugging method? Print statements or breakpoints in an ide? Perhaps something else?\n", "id": "1jeurc", "title": "Do you debug python with breakpoints?", "traffic_rate": 207.93551603789263}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "I use PyCharm and always use the debugger.\n\nHonestly this is one of the reasons I\u2019m very hesitant to try any other IDE/dev environment. That combined with years of muscle memory. \n\nPlus the new experimental design is a very nice step forward giving it a less cluttered semi VS Code layout.\n\nI really should learn that. I still diagnose by moving print statements around and checking if it executes.\n\nI don\u2019t think I\u2019d actually be able to code without the debugger and especially the interactive console. I had to work on a C# project and debugging was an absolute nightmare compared to Python\n\nI had few problems switching from PyCharm to VSCode and got a significant productivity boost from the fact that it didn't spend half the day hanging.\n\n>experimental design\n\nomg I had no idea this existed\n\nJust took a look and I think I'll stick with O.G. Pycharm.\n\nJesus Christ, now I can use pycharm without pain in my eyes. Didn't know about new UI, thanks\n\ntry pdb (it comes by default in Python), ipdb or pdb++, it seems to me more powerful and you are not tied to any ide\n\nI tend to start with this, putting prints in places to see how the code works. Then I turn on the pycharm debugger and look from there.\n\nUse debug logging statements instead of print. Then you can keep them in and be of help to the next developer or future you. But also yes, use the debugger.\n\nThis is like cowboy coding!\n\nI\u2019ve never had issues with hanging. Stoked you found a more productive tool for you.\n\nDon\u2019t blame you for that. I stuck with it for the first week and ended up liking it. There\u2019s only one annoying thing that\u2019s hidden behind a menu now\n\nI like pdb for sublime*-written scripts and projects, but I will default to integrated debuggers for bigger, organized objects.\n\n\\* insert your favourite text/code editor\n\nThanks for the recommendation. I'm already using Pycharm though, so maybe it's simplest to just go with the debugger there.\n\nPudb is also an excellent option\n\nFWIW, I find pdb is very useful to know in the rare cases where you don't have pycharm available. I rely heavily on pycharm, but it's still useful to break out 'old reliable' sometimes and you look like a wizard when you use it :D", "id": "j85c2kv", "owner_tier": 0.5, "score": 0.9999999999456521}, {"content": "As soon as you develop more complex projects, the debugger is your best friend", "id": "j859l9o", "owner_tier": 0.7, "score": 0.43478260864130436}, {"content": "My workflow basically lives in the python debugger. \n\nIt works best IMO if you have a test suite to dev against, that way you can trigger a pdb repl in the context of a test instead of trying to run everything from a main entrypoint.\n\nusing the debugger simply comes down to adding a `breakpoint()` in your source code, and when the interpreter hits it, say during execution of a test, it drops you into the pdb repl. (If you're using something earlier than 3.7 use `__import__('pdb').set_trace()` for the same effect).\n\nif you're using pytest for your test suite, adding a `--pdb` flag will drop you into the pdb repl when an exception is raised.\n\nthings to highlight about pdb; you can jump up and down the call stack using `u/d`, use `l` to list your source code, you can run arbitrary python code in the repl, and `interact` puts you in an interactive console.\n\nEdit: the standard pdb module is good, but there's also `pdb++` and `ipdb` that are worth looking into.\n\n>if you're using pytest for your test suite, adding a --pdb flag will drop you into the pdb repl when an exception is raised.\n\nThank you! Didn't know this.\n\n> If you're using something earlier than 3.7 use `__import__('pdb').set_trace()` for the same effect\n\nWhat? Why? As I recall,`import pdb;pdb.set_trace()` was just enough.\n\nThank you very much, thats helpful!\n\nSame thing, `__import__(x)` is just the builtin function equivalent of `import x`, just doesn\u2019t assign it to a variable and no semicolon is necessary\n\nOther things to remember:\n\n1) if you set a breakpoint and it drops you into the debugger pretty print is automatically imported \n\n2) you can then pretty print the output of any variable set up to the current breakpoint \n\nPressing the \u201cc\u201d key will continue to the next breakpoint if one is set (otherwise end of program)\n\nPressing the e key will exit the debugger", "id": "j85iiup", "owner_tier": 0.5, "score": 0.44021739125000003}, {"content": "A debugger is a great tool to debug code. Besides stepping through code is a great why to learn what happens in the libs\n\nAlright, I should probably take a look how to use it.\n\nI love stepping though code", "id": "j85e667", "owner_tier": 0.1, "score": 0.13586956516304347}, {"content": "You probably don't need a debugger if your a hobbyist writing short scripts.  In a professional stetting, knowing how to use a debugger effectively is an absolute necessity.   PyCharm's is fantastic, I'm sure people reading my comment history will accuse me of being an InteliJ shill, but honestly PyCharm is a damn good ide for python, better than VSCode in my opinion.\n\nPyCharm is great but the company I work for flagged JetBrains as a potential threat.  Something about having links to Russia.  They were brought up in the SolarWinds hack too which was kind of weird.\n\nVS Code Python support is incredible.  So many 3rd party extensions available in the marketplace as well.  Super easy to get it downloaded and start coding away.  Works super well with tons of other languages too which is sweet.\n\nPycharm is indeed better, and well no wonder, it's a python IDE, while vscode is a general purpose text editor which can be extended to be a python IDE. However pycharm is not that superior than vscode, only feature that is way better is refactoring. With the rest vscode can keep up pretty well\n\n[I mean they suspended their operations in Russia after the invasion](https://blog.jetbrains.com/blog/2022/03/11/jetbrains-statement-on-ukraine/), but I see your company's point.  As for VS Code, the engineers I work with who insist on using it over PyCharm are consistently slower and make mistakes that linting and other built in stuff with PyCharm consistently catches.  But they just might be bad engineers and VS Code is fine.    I've used both, where I work I have to do front end work and so I use it for that, but for python I found it pretty lacking and to make it meet my expectations it seemed like I needed to go add a bunch of plugins. So no thanks to that.", "id": "j85ykos", "owner_tier": 0.5, "score": 0.05434782603260869}, {"content": "Most of the time I simply use [icecream](https://github.com/gruns/icecream) (a more powerful version of `print`), and sometimes, I use [pudb](https://github.com/inducer/pudb/) (a visual debugger) for tougher/trickier bugs. `pudb` is similar to PyCharm/VS Code's visual debugger, but runs in the terminal (like `pdb`/`pdb++`).\n\n+1 for pudb. I'll have to check out ice cream.", "id": "j88nc0c", "owner_tier": 0.1, "score": 0.059782608641304344}, {"content": "20 years Python experience here. I don't need the debugger much. I do use VS Code's debugger, and pdb, but 9 times out of 10 I think it's faster to put in print statements to show intermediate states and re-run a test, and reason about the program state given outputs and test failures. It's kind of equivalent to running a debugger with watches set, I just find I get more information faster that way. I get information out of all my failing tests; I don't need to stop in each one and collect it myself.\n\nI also think there's a certain way of programming, and a certain level of experience, where you don't let complexity build to the point where you're completely baffled about what is going on, such that you need to freeze program state and explore it to make progress.\n\nI'd add to this that if you deal with web dev you will mostly have a short request/response cycle and not develop complex state, therefore print statements or a stack trace will suffice.\n\nIf you have an app that builds complex state over time a debugger would be more useful.", "id": "j88g0jk", "owner_tier": 0.3, "score": 0.03804347820652174}, {"content": "If you are referring to the command line Python debugger \"pdb\" ([https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)) then I think few people use it. Instead they use the debuggers that are built into all modern IDE like Pycharm, Visual Code, and so on. They're much easier to use compared to pdb.\n\nWhen debugging code I use pdbpp. I imagine a lot of vim users do too.\n\nWork on systems where you ssh without x11 and you'll use pdb a lot. The stuff I can do with a .pdbrc and pdb is pretty strong. One thing I miss from a traditional ide is a lsp. Raw vim can be tough like that at times.\n\nI find pdb really handy when working with a Docker container but don't want to deal with the hassle of connecting an IDE's debugger to the container.", "id": "j85q5ze", "owner_tier": 0.5, "score": 0.16304347820652174}, {"content": "I debug python code using a debugger all the time and so do my colleagues.", "id": "j85b785", "owner_tier": 0.5, "score": 0.027173912989130435}, {"content": "Honestly, I wish I could properly debug using PyCharm. I have a lightweight Python IDE called Thonny that I go to when I need to debug, where I can step into and through the code, but I wish I could do the same thing with a more vastly superior IDE like PyCharm. If anyone has any links to videos or articles that can help with this (for a beginner), I would appreciate it.\n\nHave you searched Youtube for \"how to use pycharm's debugger\"? The videos found in my own search seemed very relevant.\n\nI've been using python personally and professionally for years. You absolutely can debug in pycharm. Its  one of the better IDE's for that.\n\nIf you know how to use PyCharm in the first place, it's really easy, no need to look up a tutorial...\n\nJust set a breakpoint (click on the numbers on the left until you see a red circle) and then run it in debug mode (the bug shaped button next to the run button on the top right). The rest is really straight forward and intuitive.", "id": "j85gvfo", "owner_tier": 0.1, "score": 0.059782608641304344}, {"content": "In the laptop I use debugpy with remote debugging via SSH to attach the VS Code debugger to Python running on another device (this device has specific hardware not available on the laptop)\n\nhttps://code.visualstudio.com/docs/python/debugging#\\_remote-script-debugging-with-ssh\n\nThanks! I also use VSCode with Remote SSH so gonna check this out as well.", "id": "j85xy3o", "owner_tier": 0.1, "score": 0.021739130380434783}, {"content": "VS Code/PyCharm debugging is great for using during tests, because pytest swallows all the stdout during execution. I still use pdb a lot though because it's really easy to use and is a really quick to set up. A lot of the time the UX is actually better than VS Code because the single letter keystrokes make it really easy to navigate.\n\nHaving said that, I often don't bother with any debugging and just chuck in a load of print statements. Old school FTW!\n\n`-s` will let you see stdout in pytest\n\nYes, when the execution finishes. This means that all the keystrokes you do during the test aren't seen until it's finished. Which makes debugging pretty difficult.\n\nNo, you see stdout live, not after execution finishes. However it does not accomodate stdin since that does not make sense during a unit test. If you need to debug a test, set breakpoints and use `--pdb`.", "id": "j860fj6", "owner_tier": 0.1, "score": 0.03260869559782609}, {"content": "Well when I started coding, using PyCharm, the first thing I wondered about was how to use the debugger. When you're working on an existing project, it's very hard to get familiar with the code without actually stepping through it.\n\nBut one thing I learned much later is how to use pdb by itself. It is not as fancy as pycharm (which uses pdb under the hood, but ties it to the files in the editor, and displays the callstack in a visual way). \n\nVisually it is much more challenging, and you need to get familiar with the keyboard shortcuts, but the beauty is that you can use it on any existing bit of code much more easily. You may have code already deployed on a machine, running in a virtual env, and it may be cumbersome to replicate the exact state of the deployment in your Pycharm session. With pdb you can just add a single line to add a breakpoint, and debug directly from a linux command prompt. I find it very powerful.", "id": "j868obm", "owner_tier": 0.5, "score": 0.01630434777173913}, {"content": "Generally I'm using ipdb I find it more comfortable that using the debugger of a ide(navigation through the code and printing variables is way more comfortable and faster). Although sometimes I debug with pycharm's debugger for very specific things.", "id": "j86bcqc", "owner_tier": 0.1, "score": 0.01630434777173913}, {"content": "All the time and recommend everyone who uses Python regularly to learn its basics. There's sort of a weird phenomenon that I've observed, which is the amount of code I write is seemingly inversely proportional to the amount of time I spend in the debugger. Which is to say, I can use the debugger to write more succinct code with better confidence. It removes a lot of guess work or writing tests for cases that don't make practical sense.", "id": "j86f0ax", "owner_tier": 0.5, "score": 0.01630434777173913}, {"content": "I use pudb all the time. Has a nice visual side in the terminal.", "id": "j87fnkj", "owner_tier": 0.1, "score": 0.01630434777173913}, {"content": "Yes, i generally use pudb rather than pdb, but usage is more or less the same, put a break point (pudb.set_trace()) or an error handler (try/except/pudb.post_mortem()) and then use mostly up/down/step/next commands to see what happens, and evaluate expressions at important steps.", "id": "j88eguf", "owner_tier": 0.3, "score": 0.01630434777173913}, {"content": "My last project was rewritting java code in python and to guarantee functionality I copied line for line before optimizing it.\n\nOfc, it still wasn't identical. Using VSCode and Eclipse Debugger side-by-side was a great way to understand functionality and correct errrors.", "id": "j89iua5", "owner_tier": 0.7, "score": 0.01630434777173913}, {"content": "All the time. Put in a  breakpoint() in the code where you want to pause and figure out what's going on", "id": "j89kxa4", "owner_tier": 0.3, "score": 0.01630434777173913}, {"content": "Python debugger is a beast in complex projects. If you are using leet code it may seem useless. I have a video on how to use it by the way! If you want to learn more ;)\n\n[https://youtu.be/iypGtDvSb4U](https://youtu.be/iypGtDvSb4U)\n\nBut yes I use it every day in practice at my job!", "id": "j8af7mr", "owner_tier": 0.1, "score": 0.01630434777173913}, {"content": "People are answering two distinct questions:  \n\n\n1. **Should you use a debugger when debugging Python?** Yes, obviously.\n2. **Should you use Python's built-in CLI debugger?** It's worth getting to know for those situations where no better alternative is available (or setting one up would be too much trouble). But generally a better alternative *is* available, and you should use that instead. In particular, your IDE's built-in debugger lets you do all the same things as pdb but it shows you your code, variables, watches and call-stack by default rather than you having to ask for them; by basic principles of HCI this is a more productive interface.\n\nThere are at least two groups of crazy people who answer \"no\" to question 1. To explain why they're crazy, I'll need you to understand that debugging is **science**, in the sense that we are applying the scientific method to determine why our code is going wrong. Form hypotheses, make observations to confirm or disprove those hypotheses, narrow in on the explanation. For more on this approach to debugging, see Pirsig (1974), *Zen and the Art of Motorcycle Maintenance.* Anyway, the two (crazy) reasons usually given for not using debuggers are:  \n\n\n1. **No need to use a debugger! Print statements are good enough.** Print statements are a useful tool, and sometimes they're all you have. They also have advantages like \"you can pipe the output to another script for analysis, or a file for later reading\". But for any substantial program, debugging with print statements will massively increase the length of your hypothesise-observe-deduce cycle compared to using a debugger. Also, a good debugger should provide *watchpoints*, which are like print statements but less intrusive.\n2. **Debuggers just encourage you to blindly step through your code poking at things, when you should be stepping back and thinking harder.** This is mostly cope by Haskell programmers and the like who have to live with bad tooling. But they have a point! It is indeed possible to get into a state where you spend ages stepping through your code without a clear idea of what you're doing, saying \"aaaaargh why isn't this working I don't understaaaaaaand.....\". But the solution is not to give up on the superior observability benefits of debuggers! Instead, learn to recognise when you're doing this, and take it as a sign that you need to step back and start forming concrete testable hypotheses (possibly after going for a walk).\n\nThank you for the perfect summary! Definitely gonna use the debugger:)", "id": "j8czym5", "owner_tier": 0.5, "score": 0.027173912989130435}, {"content": "PyCharm debugger: Yes, all the time.  \n\npdb: Never", "id": "j85tjlc", "owner_tier": 0.5, "score": 0.01086956516304348}, {"content": "I do not use it a lot when writing my own code, but once I get to writing unit tests, the debugger is my best friend.\n\nWhen I inherit someone else\u2019s code, I might use the debugger a lot as well, just to see what the ideas of the original developer were and what the flows are, but only when my code inspection does not give me the full (enough) picture.\n\nHmmm.. Maybe some library that would visualize the flows would be nice\n\nCheck out [code2flow](https://pypi.org/project/code2flow/). Used it once when checking code that was a Python wrapper around a C API.\n\nLooks good, thanks!\n\n>Looks good, thanks!\n\nYou're welcome!", "id": "j85y2uy", "owner_tier": 0.5, "score": 0.03804347820652174}, {"content": "ipdb \n\nI have a mapping to insert a new line with set_trace.", "id": "j86bcyk", "owner_tier": 0.5, "score": 0.01086956516304348}, {"content": "I use it all the time! The number of times I drop in a `import pdb; pdb.set_trace()` is huge. I mostly use it to confirm the value and type of a variable(s) is what I expect", "id": "j872r2u", "owner_tier": 0.5, "score": 0.01086956516304348}, {"content": "I have not used a debugger in decades. \n\nMost of what I would need it for requires live data from random users that I can't simply replicate. If I have that data, I can easily figure out what went wrong. If I don't, I can guess pretty effectively based on the errors I see.", "id": "j877beq", "owner_tier": 0.9, "score": 0.01086956516304348}, {"content": "Also useful with `pytest --pdb`", "id": "j87q8oe", "owner_tier": 0.1, "score": 0.01086956516304348}, {"content": "I do. IDE when I have an IDE, pdb when I don't.", "id": "j87qtor", "owner_tier": 0.3, "score": 0.01086956516304348}, {"content": "I had this one project to do a a ML CV routine which must run on a Jetson Nano (Ubuntu 18, Python 3.7), i tried installing vscode but the debugger just doesnt work, so i ran the program with pdb on the command line and added breakpoints using the command line on lines i want to stop on. Iirc I couldn\u2019t debug more than one python script, so it was really hard for me", "id": "j882etw", "owner_tier": 0.5, "score": 0.01086956516304348}, {"content": "Yes, daily. Pytest --pdb and / or with breakpoint() sprinkled where needed to pinpoint where things go off the rails. \n\nAm old school terminal person who was trained on C and gdb.", "id": "j88ds39", "owner_tier": 0.7, "score": 0.01086956516304348}, {"content": "Vscode and debugpy can be great together.\n\nhttps://code.visualstudio.com/docs/python/debugging", "id": "j88jfpe", "owner_tier": 0.1, "score": 0.01086956516304348}, {"content": "I'm personally a huge fan of pudb with an IPython shell.", "id": "j899amd", "owner_tier": 0.7, "score": 0.01086956516304348}, {"content": "if you have a script, module, package locally that needs debugging one approach is to add \u201cbreakpoint()\u201d on the line to break.  this syntax works on 3.7 and later.  it will break and give you the pdb debugger prompt. \n\nthen you can print, step, next, etc.\n\nIMO this is an easy way to start and valuable in many situations where you may not know what IDE is installed or available.\n\nthen you can always do more with conditional breakpoints and alternate ways to setup breakpoints", "id": "j8b4idb", "owner_tier": 0.5, "score": 0.01086956516304348}, {"content": "%%debug magic is amazing. Unless your code hides exceptions\u2026", "id": "j8b9u2c", "owner_tier": 0.1, "score": 0.01086956516304348}, {"content": "Setup Visual Studio Code for Python and write more complex code and you will find it useful in a daily basis", "id": "j85ijib", "owner_tier": 0.5, "score": -5.4347826086956525e-11}, {"content": "Just FYI: not using a debugger means a low skill.", "id": "j881yxa", "owner_tier": 0.5, "score": -5.4347826086956525e-11}, {"content": "All the time. You should definitely learn how to use it.\n\nAlright, will take a look. Thanks\n\nLet us know if you get stuck with anything!", "id": "j85u35c", "owner_tier": 0.1, "score": 0.021739130380434783}, {"content": "All the time. I use vscode and it has great support for running the debugger.", "id": "j86mhtr", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "yes, almost all the time. I use it for debugging. Usually with complex objects, seeing what getting passed, or strange errors.", "id": "j86mjk4", "owner_tier": 0.5, "score": 0.0054347825543478254}, {"content": "pdbpp or VSCode debugger depending on situation.", "id": "j86pn28", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "It's important", "id": "j871dk9", "owner_tier": 0.3, "score": 0.0054347825543478254}, {"content": "Absolutely!!! Never code without it.", "id": "j877gwc", "owner_tier": 0.3, "score": 0.0054347825543478254}, {"content": "I will restore to pdb if print fails to find the bug\n\nA bad example to not to follow", "id": "j87fndd", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "What is a debugger ? Isn't it just the error?", "id": "j87fr8k", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "Sure", "id": "j87s4gy", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "Vs code debugger is dope", "id": "j87s78y", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "It's next on my list of things to learn. That and break points but I think they are connected.", "id": "j87sd7d", "owner_tier": 0.9, "score": 0.0054347825543478254}, {"content": "I almost always use debugger in DataSpell / Pycharm. Whenever I write a code it crashes and then I can easily debug and fix the minor issues fast", "id": "j87yl5f", "owner_tier": 0.5, "score": 0.0054347825543478254}, {"content": "Me. Often. Debugger is important part of software tooling. I would say crucial part.", "id": "j881m81", "owner_tier": 0.5, "score": 0.0054347825543478254}, {"content": "Works exactly like every other language debugger...", "id": "j88dxyz", "owner_tier": 0.7, "score": 0.0054347825543478254}, {"content": "Debugger is useful with hard-coded or high dependency codes (I hate both of them, so\u2026 yes, debugger can save your life many times if you use it properly)", "id": "j88fa2f", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "I don't, but most people where I work use ipdb", "id": "j88m9ng", "owner_tier": 0.3, "score": 0.0054347825543478254}, {"content": "There are people who don\u2019t use the debugger?  I\u2019m not sure I understand that.   How can someone write anything of consequence without a debugger.   I use Pycharm and VS code so debugging is just a different shortcut key.  \n\nAnd if your not using a free IDE with integrated debugging, I suggest you do so today.\n\nJust using print instead of debugger? :D", "id": "j88rccw", "owner_tier": 0.1, "score": 0.01086956516304348}, {"content": "Depends on what you are doing. If you have a big project like I do regularly, then yes, debugging is a must in many cases. If you have small projects though or single files, then not really.", "id": "j893ueh", "owner_tier": 0.1, "score": 0.0054347825543478254}, {"content": "Lmao I use it every day at work. In fact the job mainly revolves around being able to debug very well as the code is complex and no one developer really knows what's going on (a lot of data scientist written stuff).\n\nPycharm ftw.", "id": "j89i93d", "owner_tier": 0.5, "score": 0.0054347825543478254}, {"content": "**Yes**, many developers use the Python debugger to help them debug their code. \r  \n\r  \nDebuggers are tools that help developers identify and fix bugs in software code. Debuggers allow developers to step through their code line by line, inspect variables and data structures, and set breakpoints to pause the execution of their code at specific points. This can be especially helpful for identifying errors or unexpected behaviours that may not be immediately apparent from simply reading the code. The Python debugger is built into the Python standard library and is called \"pdb\" (short for \"Python Debugger\").\r  \n\r  \nUsing the pdb debugger involves setting breakpoints in your code at specific lines or functions where you want the program to pause and enter debugging mode. Once the program hits a breakpoint, you can use the interactive pdb prompt to step through the code, inspect variables, and execute commands.\n\n\r  \nTo set a breakpoint in your code, you can use the pdb.set\\_trace() function. This function inserts a breakpoint at the current line of execution and pauses the program, dropping you into the pdb prompt.\n\n\r  \nOnce you're in the pdb prompt, you can use various commands to control the flow of execution, inspect variables, and interact with the program. Some of the commonly used pdb commands include:\r  \nn or next: execute the current line and move to the next line\r  \ns or step: step into a function call\r  \nc or continue: continue execution until the next breakpoint\r  \np or print: print the value of a variable\r  \nl or list: list the source code around the current line\r  \nq or quit: quit the debugger and terminate the program\r  \nFor example, suppose you have a function that's behaving unexpectedly and you want to debug it using pdb. Here's how you could do that:\r  \n\r  \nimport pdb\r  \n\r  \ndef my\\_function(x, y):\r  \nz = x + y\r  \npdb.set\\_trace()\r  \nreturn z\r  \n\r  \nresult = my\\_function(2, 3)\r  \nprint(result)\r  \n\r  \n**In this example**, we import the pdb module and define a function my\\_function that adds two numbers together and returns the result. We insert a breakpoint in the function using pdb.set\\_trace() to pause the program and enter debugging mode when this line is executed.\r  \nWhen we run the program and call my\\_function with arguments 2 and 3, the program will pause at the breakpoint and enter the pdb prompt. From here, we can use pdb commands like n, s, and p to step through the code, inspect variables, and print their values.\r  \nUsing pdb can be a powerful way to debug complex programs and find bugs that might be difficult to locate otherwise. However, it can also be time-consuming and require a lot of patience and attention to detail. That\u2019s why many developers refrain from using a debugger while working in python. So, it's important to use pdb judiciously and only when other debugging techniques (like logging and unit tests) aren't sufficient.", "id": "jbna87c", "owner_tier": 0.1, "score": 0.0054347825543478254}], "link": "https://www.reddit.com/r/Python/comments/10zuyqf/does_anyone_use_python_debugger/", "question": {"content": "If so, how do you use it? Personally I have not seen anyone using it.", "id": "10zuyqf", "title": "Does anyone use python debugger?", "traffic_rate": 207.93551603789263}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "I\u2019m not sure about this but sounds like you are trying to debug issues with the code generator while running it in your custom runtime. I think you could and should separate them and somehow validate (and possibly debug) the generated code (using some sets of constraints) and validate, debug separately the runtime.\n\nMy language is interpreted, I dont understand what you are trying to say.\u00a0\n\nThat does not matter. I assume that you still generate something that is executed by the interpreter. That something is your generated code, and the interpreter is the runtime. The interpreter assumes certain things about the generated code. Some of those things could be validated before running the code! That could help you catching faults faster and in a more predictable manner. The other source of bugs is the interpreter itself. Maybe some kind of code makes it go awry, you could try and test the interpreter with various bits and pieces of code and see that it behaves well in all the situations you can think of. The general idea is that by separating these things and testing the various abstraction levels separately you save yourself from bugs where some constraint of the interpreter is broken by the generated code and it does something truly stupid and you have to figure out the root cause (the incorrect pieces in your generated code) by looking at the damage done by the crazy interpreter.\n\nI wonder if \u201esuspended py generator\u201c threw you off. Its a literal generator, as in: yielding function. Not a stuff thst generates code or whatever. You are lost with your logic. Of course testing interpreter separately is a must. I am saying exactly the thing that debugging interpreted code is a nightmare, as there is an interpreter level between host (impl lang) and target (your pl).\u00a0\n\nNo, it did not throw me off, the py generator is an implementation detail, it does not matter from my point of view. I\u2019m saying that yes, debugging interpreted code is a nightmare that\u2019s why you shouldn\u2019t do it. Try to find issues earlier, in the input of the interpreter (I call that the generated code but you can call it whatever you want).\n\nI think they understood and that it's just a terminology debate. You implemented a compiler and are interpreting the output with a pre existing target language.\n\nYou are in a situation where reading the compiler output feels too complicated and unreliable, so that you have to actually run the code to be confident it is working right. But the generated.code is huge and hard to understand and debug.\n\nThe way out of such a nightmare will involve changing the conditions why it is true, because in general it's just as you say. Trying to run the whole compiler and debug the output is generally not going to go well. You can get better at it, but it's a very limiting place to be.\n\n\"You implemented a compiler and are interpreting the output with a pre existing target language.\" what?!\n\nThat's what bytecode interpreters are, a bundle compiler and interpreter. Hell, that's what python is.\n\nI have direct AST walker :) no bytecode. But yeah, compiled bytecode is even worse, since then there are 2 layers, compiler and bytecode interpreter", "id": "ksu5quz", "owner_tier": 0.1, "score": 0.9999999996969696}, {"content": "I created a debugger obviously.\nThis predates VSCode.\n\nLearning from lua's debug API, I just need an execution hook and some way to examine the VM.\nThen I built the GUI in web.\nMake it so that the debugger library host a web server that can be connected to.\n\nI can see the stack between my code and C code and step in/out of it.\nAlthough the entire C function is considered one atomic instruction (`CALL`) because the VM has no knowledge of  native code.\nIt's just one stackframe.\n\n> I am actively looking into debug adapter documentation in VSCode , but it seems like a huge undertaking as is\n\nI am building a TUI frontend for gdb/lldb with DAP. Yes, it is a PITA.\nThat pseudo HTTP protocol is dumb.\nShould have gone with binary.\n\nThere are quite a number of RPC methods to deal with and it has a very specific model of inspecting locals and stack frames.\n\n> stop in a breakpoint my stacktrace in VSCode has only two entries: trampoline and suspended py generator primitive\n\nThat's why I make a debugger that targets my language, not the host.\nOtherwise I would see a bunch of switch cases in C, not how the source code in my language executes.\n\nyeah so what I am getting is that writing a debugger is an inevitability. damn.\n\nWhy is that a \"damn\"? Tooling is a very important part of PL development, arguably just as important as the compiler. \n\nWhy design a language that's impossible to debug?", "id": "ksuegg9", "owner_tier": 0.7, "score": 0.21212121181818183}, {"content": "It's relatable from some projects I have picked up and fixed. Here are two things I would try in this kind of case.\n\nOne is to test smaller parts of the code in isolation. A lot of times if I would pick out one part of the system and really think about how it's supposed to work, the code in front of me wouldn't match that. I'd write tests for the difference and indeed show problems. Then I'd write more tests and redo that component's implementation until the tests pass. So for each component you sant a clean API, a strong theory of how it should work, test cases, and a careful line by line review of the code.\n\nThis alone is a way past the wall you describe. Think smaller rather than bigger. Shore up each small part rather than trying to wrestle the whole goliath.\n\nSecond is to develop debugging tools. Think about the information you want, and then think about how the kind of tool chain that could provide you that information.\n\nParticularly helpful for debugging can be trace tools. Things that emit a log message at each step of execution. You can read the log for a small program and observe where it does something other than what you wanted.\n\nGood luck! It sounds really fun.\n\nyeah, tracing is what I usually end up doing, tracing each message send, environment change, each effect taken. this is what killed my productivity, as it takes a long time going through a trace.\n\nHave you ever heard of time-travel debugging? Or reverse-stepping?\n\nOne of the issue with debugging is that often time you only realize there's an issue when reaching a breakpoint, but you don't know _how_ the issue came to be.\n\nTherefore, a number of debuggers (try to) support reverse-stepping, the ability to step _back_ to the previous instruction, and back, and back, allowing you to see how the bizarre state you reached came to be.\n\nNow... I don't recommend implementing a debugger with reverse-debugging from scratch -- it may take a long time.\n\nOn the other hand, if instead of logging human-readable messages you built a _trader_ right in the interpreter, which minutely records everything that happens in a machine-readable way, and quite importantly records the _links_ between the various bits of execution, then...\n\n... you could use an _assert_ in the code instead of a breakpoint, and let the tracer _trace_ the assert, with all the linking.\n\nFrom then on, you can use a _tool_ to inspect the trace, which allows you to step back in time from the assert to interesting points in the past. Not on the live process, just on the trace, which should be easier than a full-blown debugger, and faster than manually reading through the logs.", "id": "ksufi7w", "owner_tier": 0.5, "score": 0.1212121209090909}, {"content": "Well, recently, I made a [stack-based N Queens Puzzle solution](https://flatassembler.github.io/nQueensPuzzle.html) in my programming language (the dialect that is targeting x86). I did that by first writing it in C and then rewriting it to my programming language.", "id": "ksuquq3", "owner_tier": 0.3, "score": -3.030303011886452e-10}, {"content": "> Every single bug hunt is an adventure of pausing, re-enabling different breakpoints, sprinkling in some conditional breakpoints, prints, custom printing stack trace and reifed stacks, etc. Huge pain.\n\nYeah, it do be that way sometimes.", "id": "ksvczyw", "owner_tier": 0.9, "score": -3.030303011886452e-10}, {"content": "This is a pending problem for me too.\n\nBack in the day, AppleSoft BASIC had a `TRACE` mode which would print every line of BASIC code as it executed. It was no panacea, but it helped: You could watch code scroll by and notice something looked wrong.\n\nMy VM has a mode where it logs every instruction and the state of the stack, but that's probably way more detail than I need for most bugs. I have a pretty sophisticated type-checker and a decent back-trace system in place for actual panics, but I recently hit what I thought was a performance cliff. It actually turned out to be an infinite loop caused by reading bad data from the wrong file.\n\nI'm toying with ideas for source-level tracing. Perhaps a line for every call and return would be a better level of detail than for each VM instruction.", "id": "kt7gtor", "owner_tier": 0.3, "score": -3.030303011886452e-10}], "link": "https://www.reddit.com/r/ProgrammingLanguages/comments/1b3qjty/debugging_your_own_pls/", "question": {"content": "Can we exchange our experience regarding this? I feel a huge cliff-like drop of productivity recently when the language development moved from developing primitives in host language (my case its python) to continuing developing in target language.\n\nEspecially, since I am not relying on the host-languages stack, my activation records are tree of stacks (parent pointer tree) and if I ever stop in a breakpoint my stacktrace in VSCode has only two entries: trampoline and suspended py generator primitive.\n\nEvery single bug hunt is an adventure of pausing, re-enabling different breakpoints, sprinkling in some conditional breakpoints, prints, custom printing stack trace and reifed stacks, etc. Huge pain.\n\nI am actively looking into debug adapter documentation in VSCode , but it seems like a huge undertaking as is, having my doubts regarding pouring so many hours into that.\n\nWhat are your thoughts on this?\n\n&#x200B;", "id": "1b3qjty", "title": "Debugging your own PLs", "traffic_rate": 16.869484046164292}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "You can use [`pdb`](https://docs.python.org/3/library/pdb.html), Python's built-in debugger. It will let you set \"breakpoints\" at particular lines of the code, and when a breakpoint is hit, the program will pause and the debugger will take over. From there, you can step through the program one line at a time, examining values of variables and expressions as you go.\n\nIf you use a proper IDE or editor that has Python debugging support, you'll get a nice display in your editor showing exactly which line you're on. But even without that, you can just use it from the command line and it'll still be a powerful tool.\n\nThis, I would really advice using proper IDE for debugger. No need to make things too complicated by limiting use of tools.\n\npycharm for example\n\nOr you can just use pdb, pdbpp and sticky. It's not perfect, but way better than vanilla pdb\n\nOk I think I will switch over from Notepad++. I've gotten to the point now where I feel very comfortable writing out my code without relying on autocomplete, so having access to a a proper tool that people actually use is the next logical step. Thank you.\n\nSince the op is a noobie Notepad++ is just an editor. An IDE will flag syntax errors and do code completion.\n\nPycharm is great. Alternatively, vscode is lighter weight but with the python extension will have basically all the same features\n\nyou are right, I didnt finish reading :D", "id": "l5ksy7f", "owner_tier": 0.7, "score": 0.9999999998809525}, {"content": "    def log(str):\n        if log_enabled:\n            print(str)\n\nNot a Python guy so I don't know if there is a more idiomatic way to do this but this works. Alternatively, use a debugger.\n\nI think this and `pdb` are good starting points for further exploration of debugging practices!\n\nThis simple logic is nice and direct :)\n\nTo build on this function, i usually use 2 toggles. 1 to print the log message, 1 to log the message to a file. That way i don't have to rely on scrolling through the debug messages, and can ctrl-f much easier", "id": "l5krvog", "owner_tier": 0.5, "score": 0.21428571416666667}, {"content": "It's not a super common thing to do. Most people prefer to use debuggers like u/teraflop recommends.\n\nThat said, yes, you can do it. Python has a \"trace\" module that can produce this sort of thing. Run your program like this:\n\n    python -m trace -t my_program.py\n\nThe trace module will print out each line that executes, as it executes. If your program calls out to a lot of other files, this will be a LOT of noise. You can use the `--ignore-module` flag to filter things out.", "id": "l5kvk28", "owner_tier": 0.9, "score": 0.11904761892857142}, {"content": "I am also new to python, started with angela yu 100 days of codes, automate the boring stuffs, and python crash course.\n\nI havent got to the debugger chapter yet, but so far i've been using [thonny's](https://thonny.org/) debugging feature to see what each lines do so I could see what I did wrong if I didnt get the output as I wanted. It helps me understand things better.\n\nBut i'm not sure if it's what you really wanted? Apologies!", "id": "l5kya03", "owner_tier": 0.3, "score": 0.023809523690476193}, {"content": "You could use :\n\nhttps://pythontutor.com/python-compiler.html#mode=edit\n\n\nIt shows exactly how your code is running, step by step.. Just copy and paste your code", "id": "l5l4gg2", "owner_tier": 0.1, "score": 0.023809523690476193}, {"content": "Others have mentioned debbugers, which I also recommend you learn how to use. I'll leave this here as well, since you specifically mentioned \"print out\"\n\nhttps://m.youtube.com/watch?v=9L77QExPmI0", "id": "l5kwtl5", "owner_tier": 0.3, "score": 0.011904761785714287}, {"content": "Go to futurecoder.io. It has three tools that go over your code iirc, birdseye, snoop, and something else.\nShould be helpful as it\u2019ll explain each line of code", "id": "l5l345g", "owner_tier": 0.3, "score": 0.011904761785714287}, {"content": "Maybe it is the right time to switch to an IDE, that makes the process of debugging super convenient. I like PyCharm, it has free community license, and is really a bliss to use, but any Python IDE should do the job. Just tap next to the line you want to break on, press the little green bug icon, and explore the code execution at that point.", "id": "l5lc7rp", "owner_tier": 0.5, "score": 0.011904761785714287}, {"content": "Learn how to use debugger - its much better way to monitor program state during execution.", "id": "l5m5upi", "owner_tier": 0.3, "score": 0.011904761785714287}, {"content": "There are some pretty good suggestions in the comments already, but I thought I\u2019d add one more that could be useful in the future, and in any language.\nWhen you are debugging and trying to locate the source of the bug, you don\u2019t have to add all 50 print statements at once. In fact I\u2019d recommend not no.\nInstead, add only one or two to the function you\u2019d like to check. If the print statements there show you that the function is infact correct, and does what it is supposed to, delete the prints and write some to the function that calls the function you just checked. And so on until you find the culprit.\n\nAlso a tip, if you are not sure what to check in a specific function, the inputs and outputs are always a good start. Check what comes in and what goes out", "id": "l5l2zp5", "owner_tier": 0.1, "score": -1.1904761832411059e-10}, {"content": "Maybe this helps you\n\nhttps://github.com/guettli/tracing-python-code", "id": "l5l6qkh", "owner_tier": 0.3, "score": -1.1904761832411059e-10}, {"content": "Your best bet is to run a debugger that allows you to step through your code like others have said", "id": "l5lcxda", "owner_tier": 0.3, "score": -1.1904761832411059e-10}, {"content": "You should be able to turn off autocomplete in any ide, they generally have pretty comprehensive settings.", "id": "l5lr77s", "owner_tier": 0.7, "score": -1.1904761832411059e-10}, {"content": "Welcome to the thorny topic of application logging. You MIGHT consider writing a logging function, then liberally use it where you want, make the first parameter the currently executing function, you can get that like so:\n```\n\u279c  tmp git:(main) \u2717 cat ref.py\nimport inspect\n\ndef fn1():\n    print(\"IN \", inspect.stack()[0].function)\n\nfn1()\n\n\u279c  tmp git:(main) \u2717 python3.12 ref.py\nIN  fn1\n```\nSo, if you had a logger function you can have logic inside it to decide what functions can log and those that can't.", "id": "l5m2tem", "owner_tier": 0.5, "score": -1.1904761832411059e-10}, {"content": "Use Thonny IDE which has easy to use debugger for new users", "id": "l5md78z", "owner_tier": 0.3, "score": -1.1904761832411059e-10}, {"content": "I think you're onto something with a variable that sets your logging level.  You can even make it an enum for different purposes/level of verbosity.  \n\nOthers are saying use a debugger.  This can be useful sometimes.  But if you are trying to debug something that happens inside a loop, it can be easier to log lots of data and parse through it than to hit the same break points lots of times.  Also, in a real-life application you won't usually have access to a source-code debugger, but you can always find ways to log things.  Also also, debuggers can change the real-time execution of your program, making it hard to find things like race conditions.\n\nYou should definitely learn to use a debugger, but logs/printed output are your goto for most debugging purposes.", "id": "l5mi0zz", "owner_tier": 0.3, "score": -1.1904761832411059e-10}, {"content": "Debugger or trace may be what you want for what you're describing. I often employ the logging module which is configurable, so you can decide at runtime how verbose you want the output -- for normal output maybe log only EXCEPTION, CRITICAL, or INFO, and then enable DEBUG when you need more granular tracing.  It can be further tweaked by adding more levels, timestamps and context to the output, writing to file vs. stderr, etc.\n\nYou wouldn't want to have logging statements at every line, though what you do add can narrow down the problem area then you can throw in a few temporary logging statements in the problematic area then remove them once problem is solved.\n\nI realize that debuggers and IDE's exist but I tend to do a lot of my scripting in the terminal on various remote systems so it often feels like more work for me to set up the environment with all the right arguments etc. in such an environment, and polishing the logging code will be useful in diagnosing later production problems.", "id": "l5mtky6", "owner_tier": 0.3, "score": -1.1904761832411059e-10}, {"content": "If you want to go the route of adding print statements I\u2019d recommend  looking into \u2018logging\u2019 module, it will definitely be a very useful tool under your belt in the future. But as many stated use debugging. My recommendation is VSCode. Look up best Python extensions for VSCode and install them, very-very useful. And debugger is really easy to setup. Look into launch.json for VSCode debugging", "id": "l5nce0p", "owner_tier": 0.1, "score": -1.1904761832411059e-10}, {"content": "Learning to use a debugger might be a good idea, but you should also try using a proper logger: https://docs.python.org/3/howto/logging.html \n\nInstead of just a boolean log it or don't value to trigger standard print calls, each \"print\" statement would include a logging level. You would set this log level at runtime, and those statements are only output to the log if they are above that level. \n\nSo instead of `print()` everywhere, you would call `logger.critical()` for major issues that should basically always be output, `logger.debug()` for tedious little things you only want to see if you explicitly enable it,  and `info`, `warning`, and `error` falling somewhere in between. You can even define custom log levels if you want more granularity, but that should be more than enough for most cases.", "id": "l5neuv4", "owner_tier": 0.7, "score": -1.1904761832411059e-10}, {"content": "You can use the logging package, it allows you to set a higher or lower level depending on how verbose you want your program to be", "id": "l5otzzt", "owner_tier": 0.1, "score": -1.1904761832411059e-10}], "link": "https://www.reddit.com/r/learnprogramming/comments/1d04spn/is_there_an_easy_way_to_print_out_what_my_program/", "question": {"content": "I am new--on chapter 5 of automate the boring stuff. I ran into an issue where my code was producing unexpected results, but not crashing.\n\nI considered adding print() statements in my code, but I thought it would be hard to toggle all of them on and off using individual comments. Then I thought I might use a Boolean variable, and if that variable was True, it would allow all the print() functions to fire. But this adds a lot of lines of code to a project, 1 line for the if statement and then another line for the print. So that's 2 lines every time I want to check, and if I have 50 things I want to check that's 100 extra lines of code.\n\nI don't know what this is called but I feel like being able to print out the precise steps a program is executing is important information and I haven't seen it discussed in the book yet. \n\nMy IDE is Notepad++. I am specifically using Notepad++ because it doesn't have any autocomplete and it forces me to type everything out by hand--but I'm wondering if another IDE might have something that allows this print() debugging thing to be easier for me.\n\nThank you.\n\n\n\n", "id": "1d04spn", "title": "Is there an easy way to print out what my program does as it executes? [Python]", "traffic_rate": 759.4447115384615}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "reddit"}, {"answers": [{"content": "\r\n    It depends on the platform, but it looks like your don't have to \"attach\" the debugger. You simple need to run the code under debugger and go by breakpoints and then step-by-step.\n\r\nThe term \"attach\" the debugger refers to much more complex debugging problem when it is not possible to run the code under debugger. Example of such cases include debugging of Windows Service of some code started when the OS is being loaded. In some cases, you can attach the debugger to already running process. I don't see where you need it.\n\r\nFor more information, you need to see the documentation of your debugger: they are all different, especially on different platforms.\n\n\u2014SA\n", "id": "2_171047_1", "owner_tier": 0.7, "score": 0}, {"content": "\nPut the breakpoint and press f5. Microsoft has provided the debug window which can have the all break point lines.\r\nNo need to attach any aditional debugger to the application.\n", "id": "2_171471_1", "owner_tier": 0.1, "score": 0}, {"content": "\r\n    it depends on the OS and the debugger your  attempting to use if its is windows i suggest win debug   attaching the debugger is not a simple process as you need to provide the symbols (generated when you compile the application)  \n\r\nif you want to analysis the behavior of a program (like a profiler) you need to trace the stack and heap and then analyse the information acquired. note this not trivial stuff and it can get pretty complex \n\r\nGood Luck!!\r\n", "id": "2_171486_1", "owner_tier": 0.1, "score": 1.0}], "link": "https://www.codeproject.com/Questions/171042/How-to-attach-a-debugger-to-an-application", "question": {"content": "\r\n\t\t\t    Hi there,\r\n I am trying to create an application which should do the following:\n\r\n1. It should parse an executable C/C++ program and insert appropriate comments in that at appropriate positions... like: //main starts....//call to fun1...etc.\n\r\n2. It should create a tree/ control flow graph of the application\n\r\n3. It should provide the dynamic information about the input like...how much it takes to execute and which loop/function takes the most time etc etc.\n\n\r\n1 and 2 I am able to achieve by parsing the input program using flex and bison....third point is a problem..cause I dont have any idea how to do it.....shall I attach a debugger to my application..if yes then shall I create it or I can attach any one...or can I use the information from a custom build debugger...plz help....\r\n\t\t    ", "id": "171042", "title": "How to attach a debugger to an application", "traffic_rate": 0}, "saved_time": {"$date": "2024-07-16T03:41:09.864Z"}, "source": "codeproject", "tags": ["C++", "C", "debugging"]}]}