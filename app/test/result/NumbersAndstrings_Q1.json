{"result": [{"answers": [{"content": "How about:", "id": 77447518, "owner_tier": 0.5, "score": -4.347826060532735e-12}, {"content": "or you could always get geekier with regexps", "id": 9507807, "owner_tier": 0.5, "score": 0.01695652173478261}, {"content": "Try the method rstrip() (see doc Python 2 and Python 3) Python's rstrip() method strips all kinds of trailing whitespace by default, not just one newline as Perl does with chomp. To strip only newlines: In addition to rstrip(), there are also the methods strip() and lstrip(). Here is an example with the three of them:", "id": 275025, "owner_tier": 0.9, "score": 0.9999999999956523}, {"content": "It looks like there is not a perfect analog for perl's chomp.  In particular, rstrip cannot handle multi-character newline delimiters like \\r\\n. However, splitlines does as pointed out here.\nFollowing my answer on a different question, you can combine join and splitlines to remove/replace all newlines from a string s: The following removes exactly one trailing newline (as chomp would, I believe). Passing True as the keepends argument to splitlines retain the delimiters.  Then, splitlines is called again to remove the delimiters on just the last \"line\": ", "id": 43641376, "owner_tier": 0.5, "score": 0.004347826082608695}, {"content": "There are three types of line endings that we normally encounter: \\n, \\r and \\r\\n. A rather simple regular expression in re.sub, namely r\"\\r?\\n?$\", is able to catch them all. (And we gotta catch 'em all, am I right?) With the last argument, we limit the number of occurences replaced to one, mimicking chomp to some extent. Example: ... where a == b == c is True.", "id": 40750864, "owner_tier": 0.3, "score": 0.002173913039130435}, {"content": "A catch all:", "id": 26554128, "owner_tier": 0.1, "score": -4.347826060532735e-12}, {"content": "And I would say the \"pythonic\" way to get lines without trailing newline characters is splitlines().", "id": 275659, "owner_tier": 0.5, "score": 0.08173913043043478}], "link": "https://stackoverflow.com/questions/275018/how-can-i-remove-a-trailing-newline", "question": {"content": "How can I remove the last character of a string if it is a newline?", "id": 275018, "title": "How can I remove a trailing newline?", "traffic_rate": 444}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["python", "newline", "trailing"]}, {"answers": [{"content": "gawk", "id": 1654115, "owner_tier": 0.9, "score": 0.1594202897101449}, {"content": "Here's a simple solution that uses sed.\nYour versions of sed needs to support the -z option. It can either be used in a pipe or used to edit the file in place with the -i option", "id": 72138792, "owner_tier": 0.1, "score": -1.4492753623188407e-10}, {"content": "You can do this with head from GNU coreutils, it supports arguments that are relative to the end of the file. So to leave off the last byte use: To test for an ending newline you can use tail and wc. The following example saves the result to a temporary file and subsequently overwrites the original: You could also use sponge from moreutils to do \"in-place\" editing: You can also make a general reusable function by stuffing this in your .bashrc file: As noted by KarlWilbur in the comments and used in Sorentar's answer, truncate --size=-1 can replace head -c-1 and supports in-place editing.", "id": 12579554, "owner_tier": 0.9, "score": 0.8260869563768116}, {"content": "You can take advantage of the fact that shell command substitutions remove trailing newline characters: Simple form that works in bash, ksh, zsh: Portable (POSIX-compliant) alternative (slightly less efficient): Note: A guide to the other answers: If Perl is available, go for the accepted answer - it is simple and memory-efficient (doesn't read the whole input file at once). Otherwise, consider ghostdog74's Awk answer - it's obscure, but also memory-efficient; a more readable equivalent (POSIX-compliant) is: awk 'NR > 1 { print prev } { prev=$0 } END { ORS=\"\"; print }' in.txt Printing is delayed by one line so that the final line can be handled in the END block, where it is printed without a trailing \\n due to setting the output-record separator (OFS) to an empty string. If you want a verbose, but fast and robust solution that truly edits in-place (as opposed to creating a temp. file that then replaces the original), consider jrockway's Perl script.", "id": 12148703, "owner_tier": 0.9, "score": 0.9999999998550726}, {"content": "See also Match any character (including newlines) in sed.", "id": 1654040, "owner_tier": 0.9, "score": 0.04347826072463768}, {"content": "If you want to do it right, you need something like this: We open the file for reading and appending; opening for appending means that we are already seeked to the end of the file.  We then get the numerical position of the end of the file with tell.  We use that number to seek back one character, and then we read that one character.  If it's a newline, we truncate the file to the character before that newline, otherwise, we do nothing. This runs in constant time and constant space for any input, and doesn't require any more disk space, either.", "id": 1658873, "owner_tier": 0.9, "score": 0.1014492752173913}, {"content": "The only time I've wanted to do this is for code golf, and then I've just copied my code out of the file and pasted it into an echo -n 'content'>file statement.", "id": 1656988, "owner_tier": 0.9, "score": -1.4492753623188407e-10}, {"content": "Yet another perl WTDI:", "id": 1656218, "owner_tier": 0.9, "score": 0.07246376797101449}, {"content": " Edit 2:  Here is an awk version (corrected) that doesn't accumulate a potentially huge array:     awk '{if (line) print line; line=$0} END {printf $0}' abc", "id": 1654049, "owner_tier": 0.9, "score": 0.28985507231884056}], "link": "https://stackoverflow.com/questions/1654021/how-can-i-delete-a-newline-if-it-is-the-last-character-in-a-file", "question": {"content": "I have some files that I'd like to delete the last newline if it is the last character in a file.  od -c shows me that the command I run does write the file with a trailing new line: I've tried a few tricks with sed but the best I could think of isn't doing the trick: Any ideas how to do this?", "id": 1654021, "title": "How can I delete a newline if it is the last character in a file?", "traffic_rate": 24}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["linux", "perl", "shell", "awk", "sed"]}, {"answers": [{"content": "There have been great responses so far. Here is an efficient way to do this in Python: You can use the above functions to retrieve sequences/headers from a fasta file without line breaks, manipulate them, and write back to a fasta file.", "id": 64288602, "owner_tier": 0.5, "score": 0.166666665}, {"content": "Do not reinvent the wheel. If the goal is simply removing newlines in multi-line fasta file (unwrapping fasta file), use any of the specialized bioinformatics tools, for example seqtk, like so: Example: Output: SEE ALSO: seqtk usage: To install this tool, use conda, specifically miniconda, for example: REFERENCES: seqtk: https://github.com/lh3/seqtk\nconda: https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html\nconda create: https://docs.conda.io/projects/conda/en/latest/commands/create.html", "id": 64266547, "owner_tier": 0.5, "score": 0.9999999983333333}, {"content": "Use this Perl one-liner, which does all of the common reformatting that is necessary in this and similar cases: removes newlines and whitespace in the sequence (which also unwraps the sequence), but does not change the sequence header lines. Note that unlike some of the other answers, this properly handles leading and trailing whitespace/newlines in the file: Output: The Perl one-liner uses these command line flags:\n-e : Tells Perl to look for code in-line, instead of in a file.\n-n : Loop over the input one line at a time, assigning it to $_ by default. chomp : Remove the input line separator (\\n on *NIX).\nif ( /^>/ ) : Test if the current line is a sequence header line.\n$n : This variable is undefined (false) at the beginning, and true after seeing the first sequence header, in which case we print an extra newline. This newline goes at the end of each sequence, starting from the first sequence.\nEND { print \"\\n\"; } : Print the final newline after the last sequence.\ns/\\s+//g; print; : If the current line is sequence (not header), remove all the whitespace and print without the terminal newline.", "id": 63972868, "owner_tier": 0.5, "score": -1.6666666666666667e-09}, {"content": "Another variation :-)", "id": 41263012, "owner_tier": 0.5, "score": -1.6666666666666667e-09}], "link": "https://stackoverflow.com/questions/15857088/remove-line-breaks-in-a-fasta-file", "question": {"content": "I have a fasta file where the sequences are broken up with newlines.  I'd like to remove the newlines.  Here's an example of my file: I'd like to convert it into this: I found a potential solution on this site, which looks like this: However, this places an extra line break between each entry, so file looks like this: I'm an awk noob, but I took a shot at modifying the command.  My guess was the if (p){print \"\\n\";} was the culprit...potentially print \"\\n\" is adding two line breaks.  I couldn't figure out how to add just one newline...this is probably something easy, but like I said, I'm a noob.  Here was my (unsuccessful) solution: However, this adds an empty line at the beginning of the file because it's always printing a new line before it prints the first accession number: Anyone have a solution to get my file in the correct format?  Thanks!", "id": 15857088, "title": "Remove line breaks in a FASTA file", "traffic_rate": 8}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["unix", "awk", "newline", "bioinformatics", "fasta"]}, {"answers": [{"content": "Adding this for my reference more than anything else ^_^ You can also strip a new line from the output using the bash expansion magic", "id": 68526649, "owner_tier": 0.5, "score": 0.017582417560439562}, {"content": "Using Awk: Explanation:", "id": 67596503, "owner_tier": 0.5, "score": -2.1978021844451187e-11}, {"content": "If you want to print output of anything in Bash without end of line, you echo it with the -n switch. If you have it in a variable already, then echo it with the trailing newline cropped: Or you can do it in one line, instead:", "id": 12525977, "owner_tier": 0.3, "score": 0.02637362635164835}, {"content": "If your expected output is a single line, you can simply remove all newline characters from the output. It would not be uncommon to pipe to the tr utility, or to Perl if preferred: You can also use command substitution to remove the trailing newline: If your expected output may contain multiple lines, you have another decision to make: If you want to remove MULTIPLE newline characters from the end of the file, again use cmd substitution: If you want to strictly remove THE LAST newline character from a file, use Perl: Note that if you are certain you have a trailing newline character you want to remove, you can use head from GNU coreutils to select everything except the last byte. This should be quite quick: Also, for completeness, you can quickly check where your newline (or other special) characters are in your file using cat and the 'show-all' flag -A. The dollar sign character will indicate the end of each line:", "id": 12524345, "owner_tier": 0.9, "score": 0.9999999999780219}, {"content": "One way:", "id": 12524320, "owner_tier": 0.5, "score": 0.20659340657142858}], "link": "https://stackoverflow.com/questions/12524308/bash-strip-trailing-linebreak-from-output", "question": {"content": "When I execute commands in Bash (or to be specific, wc -l < log.txt), the output contains a linebreak after it. How do I get rid of it?", "id": 12524308, "title": "Bash: Strip trailing linebreak from output", "traffic_rate": 117}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["bash", "newline", "line-breaks"]}, {"answers": [{"content": "In Python, start reading the file without writing in a loop until you get a non-empty line.", "id": 59795703, "owner_tier": 0.9, "score": 0.499999995}, {"content": "Set a flag when you find a line that's not just a newline and print when that flag is set: e.g.:", "id": 59797313, "owner_tier": 0.9, "score": -5e-09}, {"content": "This is what I came up with, I'm sure it can still be improved a bit. Here is an alternative solution, which opens the file twice.", "id": 59797001, "owner_tier": 0.5, "score": -5e-09}, {"content": "Simple filter to skip leading empty lines One liner version perl -0777 -pe 's/^\\n+//' filename", "id": 59796800, "owner_tier": 0.5, "score": -5e-09}, {"content": "The equivalent-opposite Perl code to chomp is s/^\\n//. Instead of doing it on the last line (eof), do it on the first line. Even though it will only be an empty line, removing the newline will mean that line will print nothing in the output. or in place: Since starting newlines are by definition empty lines, you can also just skip printing them by using -n instead of -p (same behavior but without printing, so you can determine which lines to print). If you want to remove potentially multiple starting newlines, you could take another approach; advance the handle yourself in the beginning until you receive a non-empty line. It's all much easier if you don't mind reading the entire file into memory at once rather than line by line: To avoid doing any excess work editing the file unless it starts with newline characters, you could condition the edit by prefixing it with another command (reads first line of the file and causes a non-zero exit status if it doesn't start with a newline):", "id": 59795559, "owner_tier": 0.5, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/59795526/how-to-remove-starting-newlines-or-the-starting-new-from-a-binary-file", "question": {"content": "I see there are discussions about removing trailing newlines. How can I delete a newline if it is the last character in a file? But I don't find a discusion about removing starting newlines. Could anybody let me know what is the best way to delete starting newlines (one liner preferred)? Thanks.", "id": 59795526, "title": "How to remove starting newlines or the starting new from a binary file?", "traffic_rate": 1051}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["python", "shell", "perl", "sed", "command-line"]}, {"answers": [{"content": "To handle many newline delimiters, including character combinations like \\r\\n, use splitlines.\nCombine join and splitlines to remove/replace all newlines from a string s: To remove exactly one trailing newline, pass True as the keepends argument to retain the delimiters, removing only the delimiters on the last line: ", "id": 43641128, "owner_tier": 0.5, "score": 0.0}], "link": "https://stackoverflow.com/questions/3849509/how-to-remove-n-from-a-list-element", "question": {"content": "I'm trying to get Python to a read line from a .txt file and write the elements of the first line into a list. The elements in the file were tab- separated so I used split(\"\\t\") to separate the elements. Because the .txt file has a lot of elements I saved the data found in each line into a separate list. The problem I currently have is that it's showing each list like this: How can I remove \\n from the last element of the list and make it just '7.3'?", "id": 3849509, "title": "How to remove \\n from a list element?", "traffic_rate": 139}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["python", "list", "newline"]}, {"answers": [], "link": "https://stackoverflow.com/questions/35940583/remove-new-line-from-array-in-perl", "question": {"content": "I m trying to filtering the filenames from a text file The context of the file is like below But when i print the @filenames array its like Even though i add the chomp the new line was not removed from array elements.", "id": 35940583, "title": "remove new line from array in perl", "traffic_rate": 3668}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["arrays", "perl"]}, {"answers": [], "link": "https://stackoverflow.com/questions/6852719/templated-configuration-in-python-or-perl", "question": {"content": "I'm trying to implement a templated configuration file.\nI'd prefer python, but I'd take an answer in perl too.\nI've used perl for my example. I've searched a bit and found\n - python single configuration file\n - ConfigObj\n - python configuration file generator\n - ePerl\nbut I could not from those solve my problem. I'm trying generate a configuration file mostly in the INI format (with not even sections): and I need that generated from a template where I'm embedding a scripting language inside the text: The text in between the '<:' and ':>' would be in the scripting language (python or perl). As with a template, its stdout is captured and inserted in the resulting text. The templating used in the example is basically eperl, but I'd prefer python if available. and finally, the defined variables should be reusable: Here's the test source file that I read in: And I'm looking to get this result out of the script.\nI could not figure how to have the variables defined in the config file be part of the interpreter? Thanks for your suggestions.", "id": 6852719, "title": "templated configuration in python or perl?", "traffic_rate": 588}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["python", "perl", "templates", "configuration"]}, {"answers": [{"content": "First of all, you don't even try to change the CRLF to LF. You just print back out what you got. On a Windows system, Perl adds the :crlf layer to your file handles. That means that CRLF gets changed to LF on read, and LF gets changed to CRLF on write. That last bit is the problem. By default, Perl assumes you're create a text file, but what you're creating doesn't match the definition of a text file on Windows. As such, you need to switch your output to binmode. Solution that only works on a Windows system: Or if you want it to work on any system, Without binmode on the input, s/\\r?\\n\\z// handles all of those.", "id": 15735143, "owner_tier": 0.9, "score": 0.9999999993333333}, {"content": "if you are on Unix like command line, on the shell prompt the following with do the trick: \n\n\nperl -pe 's/^M//g' file.txt # ^M mean control-M, press control-v control-M, the CRLF character\n\n \nperl -pe 's#\\r\\n$#\\n#g' file.txt \n", "id": 15825270, "owner_tier": 0.3, "score": 0.13333333266666667}, {"content": "This works for me on a Mac (Mac OS X 10.7.5, Perl 5.16.2): Sample output: The odx program gives me a hex dump of the data file; you can see that there are 0D 0A (CRLF) line endings.  The vis -c program shows control characters (other than newline and tab) as ^M (for example).  You can see that the raw input includes the ^M (lines starting 1:) but the chomp'd lines are missing both the newline and the carriage return. The only issue will be whether the input on Windows is a text file or a binary file.  If it is a text file, the I/O system should do the CRLF mapping automatically.  If it is a binary file, it won't.  (Unix doesn't have a meaningful distinction between text and binary files.)  On Windows, you may need to investigate binmode, as discussed on the open page.", "id": 15732890, "owner_tier": 0.9, "score": 0.066666666}, {"content": "I think \\s* should work.", "id": 15733855, "owner_tier": 0.5, "score": -6.666666666666666e-10}, {"content": "That would be a one-liner in Perl... Try the following under Linux: and the following under Windows:", "id": 15732711, "owner_tier": 0.3, "score": -6.666666666666666e-10}], "link": "https://stackoverflow.com/questions/15732552/how-to-remove-cr-lf-end-of-line-in-perl", "question": {"content": "I need to remove and of the line which looks like CR LF. Coding - Windows-1250\nWindows 7 EN I have been trying to chomp, chomp, change \\R to nothing change \\r\\n etc but nothing works... Thank you in advance", "id": 15732552, "title": "How to remove CR LF end of line in Perl", "traffic_rate": 9}, "saved_time": 1721101574, "source": "stackoverflow", "tags": ["perl"]}, {"answers": [{"content": "I've said this before: have a bunch of library functions that handle this for you. There is no point in writing the exact same code for every day. \n\nI would, but generally the data changes from day to day. It's been different enough that each type of data has only been seen once or twice:\n\n* day 1, 9: one line of characters\n* day 2: multiple lines of integers separated by whitespace\n* day 3: no input file\n* day 4: lines of words separated by whitespace\n* day 5: one integer per line\n* day 6: one line of integers separated by whitespace\n* day 7, 8: lines of mixed data\n* day 10: one line of integers separated by commas\n* day 11: one line of words separated by commas\n\n... and the idiomatic way to write this in Python is already super-concise, it would take longer to write a library function and be less readable:\n\n* `[c for c in f.readline()]`\n* `[[int(n) for n in line.split()] for line in f]`\n* ...\n* `[line.split() for line in f]`\n* `[int(line) for line in f]`\n* `[int(n) for n in f.readline().split()]`\n* ...\n* `[int(n) for n in f.readline().split(\",\")]`\n* `[w for w in f.readline().strip().split(\",\")]`\n\n> ... and the idiomatic way to write this in Python is already super-concise, it would take longer to write a library function and be less readable\n\nAs someone who wrote Python professionally: you're focussing way too much on 'conciseness'. What you want to do if have a set of well tested standard functions that you reuse. Making the same mistake again and again is a great example that you should reuse more. Code is much more readable that way too. \n\nAnd basically there's really only two types of inputs: one long string and a list of strings. You can then easily map / split those any way you want. So it's just two functions you can easily reuse. [All my solutions sofar](https://github.com/nielsutrecht/adventofcode/tree/master/src/main/kotlin/com/nibado/projects/advent/y2017) use my [resourceString](https://github.com/nielsutrecht/adventofcode/blob/master/src/main/kotlin/com/nibado/projects/advent/Util.kt#L18) or [resourceLines](https://github.com/nielsutrecht/adventofcode/blob/master/src/main/kotlin/com/nibado/projects/advent/Util.kt#L30) function. \n\nI recommend treating the input as lines of data.\n\nIf there's one line, just use that one line!\n\nIf there are many, loop over them, and process them as needed - split by character, parse with regex, whatever. \n\nThe important point is you can always count on there being a discrete, continuous chunk of data with no newlines.\n\nFWIW I just stored the input for day 3 in its own `input.txt` and treated it just as any other day.\n\nTo propose an alternative to /u/nutrecht's suggestion for this particular issue: crash early and loudly.\n\nYou're making control flow decisions based on individual tokens ('n', 'sw', 'sw\\n') at some point in your code. Maybe converting the strings to objects via a dict, maybe an if tree, maybe a switch of some sorts. See if there's an easy way of making it loudly fail in case of unexpected input.\n\nE.g. in my Scala code, I converted the tokens via a Map (throwing an exception on 'sw\\n'), or did stuff based on a switch (which would again, throw an exception on 'sw\\n').\n\nPython's conciseness is a plus here - once you've crashed due to an unexpected value, you can quickly find it (if needed) by creating a set of all the tokens.\n\n> To propose an alternative to /u/nutrecht's suggestion for this particular issue: crash early and loudly.\n\nActually; do both. I tend to use regular expressions for the non-trivial parsing stuff and I crash whenever the regex does not match. It means I made a mistake and need to correct it.\n\nSo both; have a standard function to read input and make sure that the input is what you expect. ", "id": "dr2xc8s", "owner_tier": 0.9, "score": 0.9999999995238095}, {"content": "Here's what I do:\n\nI click on the input link, CTRL+A, CTRL+C, then open an empty text file where I do CTRL+V. I'm on Windows, I never get \\n at the end of the input.\n\nBut always adding a `strip()` when you read a file is a good habit to have anyway. Very rarely are you interested in the newline at the end of the file.\n\nI generally prefer `rstrip()` when reading lines from a file because in most cases leading whitespace is meaningful. That said,`strip()` is also pretty useful. \n\nGood point!", "id": "dr2xad7", "owner_tier": 0.3, "score": 0.38095238047619046}, {"content": "Except for a few lines of code in the mid-1990s, I've never written any Python code, but doesn't\n\n    f.readline().rstrip().split(\",\")\n\ndo what you want? \n\ni just did:\n\n    commands=open(\"2017_11_input.bin\").read()\n    steps=commands.strip().split(\",\")\n\n(this lets me replace `commands` with test data easily)", "id": "dr30f3x", "owner_tier": 0.1, "score": 0.14285714238095237}, {"content": "This is part of the Perl template I start every problem with\n\n    #### INIT - load input data from file into array\n    my $testing = 0;\n    my @input;\n    my $file = $testing ? 'test.txt' : 'input.txt';\n    open( my $fh, '<', \"$file\" );\n    while (<$fh>) { chomp; s/\\r//gm; push @input, $_; }\n \nNote the `chomp; s/\\r//gm;` - this strips `\\n` and `\\r` from the input line.   \n\n\n\nI've been burnt enough times by trying to process a file with Windows line endings on a unixish system and chomp leaving the `\\r` behind that I just started using `$_ =~ s/\\s+$//;` instead. Has the bonus of stripping any trailing spaces that I usually don't want at the same time.", "id": "dr2wojv", "owner_tier": 0.7, "score": 0.14285714238095237}, {"content": "Having a readline function that strips the newline from the end is very useful. I'm a bit surprised that Python's doesn't do that.", "id": "dr2y7ho", "owner_tier": 0.9, "score": -4.761904732964423e-10}, {"content": "LOL! I'm using C++ and had written a function that I use in almost every puzzle. It parses the input into tokens and put them into a vector of vectors. Basically, the outer vector is the set of lines. And the inner vector contains each token. Simple enough. I used it for today's puzzle and got the right answer on part 1. But could not get the correct answer on part 2.\n\nAfter a LONG while, I finally notice that I'm getting \"e\" as input. There is no east. Ends up I was using a buffer of 1024 characters for each line. This puzzle has a single line of 21K characters. It was splitting up the input into multiple lines of 1024 characters each.\n\nHow I got the correct answer for part 1 is beyond me.\n", "id": "dr4334m", "owner_tier": 0.3, "score": -4.761904732964423e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/7j1f5b/2017_day_11_again_with_the_damn_newline/", "question": {"content": "I've been debugging my code for today multiple times over, still couldn't see why it was getting a wrong answer.\n\nThere is a single line of input. **IT ENDS IN A NEWLINE**. Stripping out the newline gives the right answer.\n\nPython's `f.readline().split(\",\")` gives a list where the final element is `\"sw\\n\"` (or such) rather than `\"sw\"`. I wrote no code to warn about unknown directions, so I didn't notice this.\n\nThis is exactly the same problem I encountered yesterday. You get the correct answer if you strip the newline from the input, and you get the wrong answer if you don't.\n\nI'm going to have to start remembering this.", "id": "7j1f5b", "title": "[2017 Day 11] Again with the damn newline!", "traffic_rate": 38.33703939008895}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "90/98\n\nThis was very reminiscent of the Syacor challenge. Loved it!\n\n\n    #!/usr/bin/env python3\n\n    def list_map(f, s):\n        return list(map(f, s))\n\n    def addr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] + result[b]\n        return result\n\n    def addi(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] + b\n        return result\n\n    def mulr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] * result[b]\n        return result\n\n    def muli(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] * b\n        return result\n\n    def banr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] & result[b]\n        return result\n\n    def bani(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] & b\n        return result\n\n    def borr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] | result[b]\n        return result\n\n    def bori(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] | b\n        return result\n\n    def setr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a]\n        return result\n\n    def seti(registers, a, b, c):\n        result = registers[::]\n        result[c] = a\n        return result\n\n    def gtir(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(a > result[b])\n        return result\n\n    def gtri(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] > b)\n        return result\n\n    def gtrr(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] > result[b])\n        return result\n\n    def eqir(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(a == result[b])\n        return result\n\n    def eqri(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] == b)\n        return result\n\n    def eqrr(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] == result[b])\n        return result\n\n    OPERATIONS = [\n        addr, addi,\n        mulr, muli,\n        banr, bani,\n        borr, bori,\n        setr, seti,\n        gtir, gtri, gtrr,\n        eqir, eqri, eqrr\n    ]\n\n    def possible_operations(instruction, before, after):\n        result = set()\n        for operation in OPERATIONS:\n            op_result = operation(before, *instruction[1:])\n            if op_result == after:\n                result.add(operation)\n        return result\n\n    def problem1(LINES):\n        i = 0\n        experiments = []\n        while LINES[i].strip():\n            before, instruction, after = LINES[i:i+3]\n            i += 4\n            experiments.append((\n                list_map(int, instruction.split(' ')),\n                eval(before[8:]),\n                eval(after[8:])\n            ))\n        return len([experiment for experiment in experiments if len(possible_operations(*experiment)) >= 3])\n\n    def problem2(LINES):\n        i = 0\n        experiments = []\n        while LINES[i].strip():\n            before, instruction, after = LINES[i:i+3]\n            i += 4\n            experiments.append((\n                list_map(int, instruction.split(' ')),\n                eval(before[8:]),\n                eval(after[8:])\n            ))\n\n        operations = {opcode : set(OPERATIONS) for opcode in range(16)}\n        for experiment in experiments:\n            opcode = experiment[0][0]\n            operations[opcode].intersection_update(possible_operations(*experiment))\n\n        while True:\n            unique_ops = {}\n            for op, ops in operations.items():\n                if len(ops) == 1:\n                    unique_ops[op] = ops\n            for op_, ops_ in unique_ops.items():\n                for op, ops in operations.items():\n                    if op != op_:\n                        ops.difference_update(ops_)\n            if len(unique_ops) == len(operations):\n                break\n\n        for op in operations:\n            operations[op] = operations[op].pop()\n        registers = [0, 0, 0, 0]\n        for line in LINES[i:]:\n            if not line.strip():\n                continue\n            opcode, a, b, c = list_map(int, line.split(' '))\n            registers = operations[opcode](registers, a, b, c)\n        return registers[0]\n\n    def parse_input_file(fname):\n        s = open(fname).read()\n        if s and s[-1] == '\\n':\n            s = s[:-1]\n        return s.splitlines()\n\n    def main():\n        l = parse_input_file('input.txt')\n        print(problem1(l))\n        print(problem2(l))\n\n    if __name__ == '__main__':\n        main()\n", "id": "ebw73yj", "owner_tier": 0.3, "score": 0.22222222185185186}, {"content": "Rank 18/43, Python. Video of me solving at https://www.youtube.com/watch?v=-AvYZufvZPQ (still uploading)\n\nNeat problem! The idea of having to figure out part of the language is great! I wish the two parts of the input had been delimited better though...\n\n    import re\n    \n    def do_cmd(fn):\n        def final(before, instr):\n            after = list(before)\n            after[instr[3]] = fn(before, instr[1], instr[2])\n            return after\n        return final\n    \n    addr = do_cmd(lambda before,x,y: before[x]+before[y])\n    addi = do_cmd(lambda before,x,y: before[x]+y)\n    mulr = do_cmd(lambda before,x,y: before[x]*before[y])\n    muli = do_cmd(lambda before,x,y: before[x]*y)\n    banr = do_cmd(lambda before,x,y: before[x] & before[y])\n    bani = do_cmd(lambda before,x,y: before[x] & y)\n    borr = do_cmd(lambda before,x,y: before[x] | before[y])\n    bori = do_cmd(lambda before,x,y: before[x] | y)\n    setr = do_cmd(lambda before,x,y: before[x])\n    seti = do_cmd(lambda before,x,y: x)\n    gtir = do_cmd(lambda before,x,y: 1 if x > before[y] else 0)\n    gtri = do_cmd(lambda before,x,y: 1 if before[x] > y else 0)\n    gtrr = do_cmd(lambda before,x,y: 1 if before[x] > before[y] else 0)\n    eqir = do_cmd(lambda before,x,y: 1 if x == before[y] else 0)\n    eqri = do_cmd(lambda before,x,y: 1 if before[x] == y else 0)\n    eqrr = do_cmd(lambda before,x,y: 1 if before[x] == before[y] else 0)\n    \n    cmds = [ addr, addi\n           , mulr, muli\n           , banr, bani\n           , borr, bori\n           , setr, seti\n           , gtir, gtri, gtrr\n           , eqir, eqri, eqrr\n           ]\n    \n    options = {}\n    for code in range(16):\n        options[code] = list(enumerate(cmds))\n    \n    lines,program = open('16.in').read().strip().split('\\n\\n\\n')\n    lines = lines.strip().split('\\n')\n    ans = 0\n    for i in range(0, len(lines), 4):\n        if 'Before' in lines[i]:\n            assert 'After:' in lines[i+2]\n            before = map(int, re.findall('-?\\d+', lines[i]))\n            instr = map(int, re.findall('-?\\d+', lines[i+1]))\n            after = map(int, re.findall('-?\\d+', lines[i+2]))\n            options[instr[0]] = [(idx,fn) for (idx,fn) in options[instr[0]] if fn(before,instr) == after]\n    \n            matches = 0\n            for idx,cmd in options[instr[0]]:\n                if cmd(before, instr) == after:\n                    matches += 1\n            if matches >= 3:\n                ans += 1\n    \n    print ans\n    for _ in range(16):\n        for code in range(16):\n            if len(options[code]) == 1:\n                for other_code in range(16):\n                    if other_code != code:\n                        options[other_code] = [(idx,fn) for (idx,fn) in options[other_code] if idx!=options[code][0][0]]\n            \n    \n    #for code in range(16):\n    #    print code, options[code]\n    \n    registers = [0,0,0,0]\n    for line in program.strip().split('\\n'):\n        instr = map(int, re.findall('-?\\d+', line))\n        old_registers = list(registers)\n        registers = options[instr[0]][0][1](registers, instr)\n    print registers[0]\n\n\nI just used the four existing consecutive line breaks as delimiter.\n\nYeah, I personally ended up adding my own delimiter rather than mucking with parsing.\n\nI guess it didn't help to get the right answer on part 1 without having mulr/muli in place...\n\nHmm, your solution is off on part 1 of my input (yours gives me 458, while the correct answer is 500).\n\nHuh. I just blanked out `before` after processing every \"After:\" line and if I encountered a line of numbers while `before` was `None`, added it to the program.\n\nYeah, I should've gone this way. I spent way too long parsing the input. Even manually copying and pasting the second part of the input into another file would've been faster.\n\nCan you pastebin your input?\n\nOf course: https://gist.github.com/tobiasvl/759ef5b2848a368305f2f9d9ba8255d7\n\nMy code is here btw: https://github.com/tobiasvl/adventofcode/blob/master/2018/16/2018_16.py\n\nCould you also help me please, my code does give 500 as answer to your code @tobiasvl and gives 577 as answer to my own input ([https://gist.github.com/arcogelderblom/7b72181bb346053315f01c308995a3ba](https://gist.github.com/arcogelderblom/7b72181bb346053315f01c308995a3ba)). But this is not correct when I input this as answer on the AoC site. My code is here: [https://github.com/arcogelderblom/AdventOfCode2018/blob/master/16thDecember2018/1stPuzzle/src/main.go](https://github.com/arcogelderblom/AdventOfCode2018/blob/master/16thDecember2018/1stPuzzle/src/main.go)\n\n>\\[2018   \n>  \n>Day 16  \n>  \n>\\] Puzzle inspiration\n\nAlready fixed it, rookie mistake, forgot that i was doing assignments instead of returning after if statement, after all if statements it was overwriting a possible 1. Fixed now! :)", "id": "ebw78eu", "owner_tier": 0.3, "score": 0.9999999996296296}, {"content": "Lua 91/38. Really doesn't help that Lua 5.1 doesn't have bitwise operations, had to implement them manually using strings.\n\n    local examples, program = {}, {}\n    local before, data;\n    for v in getinput():gmatch(\"[^\\n]+\") do\n    \tlocal numbers, index = {}, 0\n    \tfor n in v:gmatch(\"%d+\") do\n    \t\tnumbers[index] = tonumber(n)\n    \t\tindex = index + 1\n    \tend\n    \tif v:match(\"Before\") then\n    \t\tbefore = numbers\n    \telseif v:match(\"After\") then\n    \t\texamples[#examples+1] = {before = before, after = numbers, data = data}\n    \t\tbefore, data = nil\n    \telseif before then\n    \t\tdata = numbers\n    \telse\n    \t\tprogram[#program+1] = numbers\n    \tend\n    end\n    \n    function binary(n)\n    \tlocal s = \"\"\n    \trepeat\n    \t\ts = (n%2)..s\n    \t\tn = (n - n%2)/2\n    \tuntil n == 0\n    \treturn (\"0\"):rep(16-#s)..s\n    end\n    \n    function AND(a, b)\n    \ta, b = binary(a), binary(b)\n    \tlocal s = \"\"\n    \tfor i = 1, #a do\n    \t\ts = s..((a:sub(i, i) == \"1\" and b:sub(i, i) == \"1\") and \"1\" or \"0\")\n    \tend\n    \treturn tonumber(s, 2)\t\n    end\n    \n    function OR(a, b)\n    \ta, b = binary(a), binary(b)\n    \tlocal s = \"\"\n    \tfor i = 1, #a do\n    \t\ts = s..((a:sub(i, i) == \"1\" or b:sub(i, i) == \"1\") and \"1\" or \"0\")\n    \tend\n    \treturn tonumber(s, 2)\t\n    end\n    \n    local r;\n    local operations = {\n    \taddr = function(a, b) return r[a] + r[b] end;\n    \taddi = function(a, b) return r[a] + b end;\n    \tmulr = function(a, b) return r[a] * r[b] end;\n    \tmuli = function(a, b) return r[a] * b end;\n    \tbanr = function(a, b) return AND(r[a], r[b]) end;\n    \tbani = function(a, b) return AND(r[a], b) end;\n    \tborr = function(a, b) return OR(r[a], r[b]) end;\n    \tbori = function(a, b) return OR(r[a], b) end;\n    \tsetr = function(a, b) return r[a] end;\n    \tseti = function(a, b) return a end;\n    \tgtir = function(a, b) return a > r[b] and 1 or 0 end;\n    \tgtri = function(a, b) return r[a] > b and 1 or 0 end;\n    \tgtrr = function(a, b) return r[a] > r[b] and 1 or 0 end;\n    \teqir = function(a, b) return a == r[b] and 1 or 0 end;\n    \teqri = function(a, b) return r[a] == b and 1 or 0 end;\n    \teqrr = function(a, b) return r[a] == r[b] and 1 or 0 end;\n    }\n    local possible = {}\n    for _, f in pairs(operations) do\n    \tlocal t = {}\n    \tfor i = 0, 15 do t[i] = true end\n    \tpossible[f] = t\n    end\n    \n    local count = 0\n    for _, e in pairs(examples) do\n    \tlocal valid = 0\n    \tlocal n, a, b, c = unpack(e.data, 0, 3)\n    \tr = e.before\n    \tfor _, f in pairs(operations) do\n    \t\tif f(a, b) == e.after[c] then\n    \t\t\tvalid = valid + 1\n    \t\telse\n    \t\t\tpossible[f][n] = false\n    \t\tend\n    \tend\n    \tif valid >= 3 then count = count + 1 end\n    end\n    print(count)\n    \n    local opcode, list = {}, {}\n    for f, t in pairs(possible) do list[#list+1] = f end\n    for i = 1, #list do\n    \ttable.sort(list, function(a, b)\n    \t\tlocal c1, c2 = 0, 0\n    \t\tfor k, v in pairs(possible[a]) do if v then c1 = c1 + 1 end end\n    \t\tfor k, v in pairs(possible[b]) do if v then c2 = c2 + 1 end end\n    \t\treturn c1 < c2\n    \tend)\n    \tlocal f = table.remove(list, 1)\n    \tfor k, v in pairs(possible[f]) do\n    \t\tif v then\n    \t\t\topcode[k] = f\n    \t\t\tfor _, y in pairs(possible) do\n    \t\t\t\ty[k] = false\n    \t\t\tend\n    \t\t\tbreak\n    \t\tend\n    \tend\n    end\n    \n    r = {[0] = 0, 0, 0, 0}\n    for _, line in pairs(program) do\n    \tlocal n, a, b, c = unpack(line, 0, 3)\n    \tr[c] = opcode[n](a, b)\n    end\n    print(r[0])\n\n&#x200B;\n\nHonest question... Why are you using a lua version that was replaced in 2011? Lua 5.3 which has bitwise operators is almost 4 years old now.\n\nLua 5.1 is still the most popular version. I started using it in 2007. I would only ever use a different version outside the context of a platform, which is what this would be. It would probably be a good idea to start using 5.3 for these problems.\n\nCurious if/why 5.1 would be the most popular version. It does not match what I see for the linux distribution I use (only one data point, but still) where install frequency is something like\n\n|5.3|90%|\n|:-|:-|\n|5.2|80%|\n|5.1|40%|\n\nIs there breaking changes post 5.1 or is adoption just slow?\n\nI was about to assume you were using LuaJIT, since that still runs 5.1 (and probably will for the foreseeable future). I always use LuaJIT myself, when I use Lua for AoC, for the extra speed. And, of course, LuaJIT adds bitwise operators to 5.1 (the `bit` module).\n\nAnother big factor is luajit. It's one of the fastest dynamic language implementations but it's fixed on Lua 5.1 as the actual language.\n\nLuajit ships with a BitOps library though.\n\nLater versions aren't backwards compatible with certain things. 5.1 doesn't have \"integers\", so in newer versions sometimes a \".0\" is added to the end of a string when a number is coerced. Another change is function environments but that's an obscure language feature. I'm not used to any differences so I didn't take the risk of being thrown off by something subtle. Development platforms like Roblox and L\u00d6VE and CryEngine still use Lua 5.1.\n\nFair enough. I'm a python guy myself, so I get the issues with subtle bugs. What is a generator and what's not between python2 and python3 can catch you off guard. Also stupid things like `min(0,None)` being valid in 2 but not 3 is weird.\n\nDon't tell me lua is another language that chooses to have double for all numbers... I kinda hoped that was contained to the likes of js. Not a fan, although I guess it makes sense considering that lua is deliberately minimal.", "id": "ebw74ql", "owner_tier": 0.1, "score": 0.7037037033333333}, {"content": "Python. 3/19. Minimal code cleanup. Took a few minutes to realize that Part 2 would require some repeated deduction.\n\n    import advent\n    import re\n    \n    from collections import *\n    from itertools import *\n    from math import *\n    \n    def addr(R, a, b, c):\n        R[c] = R[a] + R[b]\n    \n    def addi(R, a, b, c):\n        R[c] = R[a] + b\n    \n    def mulr(R, a, b, c):\n        R[c] = R[a] * R[b]\n    \n    def muli(R, a, b, c):\n        R[c] = R[a] * b\n    \n    def banr(R, a, b, c):\n        R[c] = R[a] & R[b]\n    \n    def bani(R, a, b, c):\n        R[c] = R[a] & b\n    \n    def borr(R, a, b, c):\n        R[c] = R[a] | R[b]\n    \n    def bori(R, a, b, c):\n        R[c] = R[a] | b\n    \n    def setr(R, a, b, c):\n        R[c] = R[a]\n    \n    def seti(R, a, b, c):\n        R[c] = a\n    \n    def gtir(R, a, b, c):\n        R[c] = 1 if a > R[b] else 0\n    \n    def gtri(R, a, b, c):\n        R[c] = 1 if R[a] > b else 0\n    \n    def gtrr(R, a, b, c):\n        R[c] = 1 if R[a] > R[b] else 0\n    \n    def eqir(R, a, b, c):\n        R[c] = 1 if a == R[b] else 0\n    \n    def eqri(R, a, b, c):\n        R[c] = 1 if R[a] == b else 0\n    \n    def eqrr(R, a, b, c):\n        R[c] = 1 if R[a] == R[b] else 0\n    \n    instructions = [\n        addr, addi, mulr, muli, banr, bani, borr, bori,\n        setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr,\n    ]\n    \n    def parse(line):\n        return list(map(int, re.findall(r'\\d+', line)))\n    \n    def behaves_like(instruction, before, after):\n        count = 0\n        for f in instructions:\n            R = list(before)\n            f(R, *instruction[1:])\n            if R == after:\n                count += 1\n        return count\n    \n    def remove_candidates(candidates, instruction, before, after):\n        for f in instructions:\n            R = list(before)\n            f(R, *instruction[1:])\n            if R != after:\n                candidates[instruction[0]].discard(f)\n    \n    def main():\n        data = advent.fetch(16)\n    \n        lines = data.split('\\n')\n        lines = [x.strip() for x in lines]\n    \n        # part 1\n        count = 0\n        for line in lines:\n            if 'Before' in line:\n                before = parse(line)\n            elif 'After' in line:\n                after = parse(line)\n                if behaves_like(instr, before, after) >= 3:\n                    count += 1\n            else:\n                instr = parse(line)\n        print(count)\n    \n        # part 2\n        known = set()\n        opcodes = {}\n        while len(known) < len(instructions):\n            candidates = {}\n            for i in range(16):\n                candidates[i] = set(instructions) - set(known)\n            for line in lines:\n                if 'Before' in line:\n                    before = parse(line)\n                elif 'After' in line:\n                    after = parse(line)\n                    remove_candidates(candidates, instr, before, after)\n                else:\n                    instr = parse(line)\n            for i in range(16):\n                if len(candidates[i]) == 1:\n                    f = candidates[i].pop()\n                    opcodes[i] = f\n                    known.add(f)\n    \n        R = [0] * 4\n        for line in lines[3353:]:\n            line = line.strip()\n            if not line:\n                continue\n            o, a, b, c = parse(line)\n            f = opcodes[o]\n            f(R, a, b, c)\n        print(R[0])\n    \n    if __name__ == '__main__':\n        main()", "id": "ebw75dq", "owner_tier": 0.3, "score": 0.18518518481481483}, {"content": "A very fun logic puzzle!\n\nPart 1: Oh no, reading error... I thought the problem was asking for `== 3` instead of the actual `>= 3`, submitted multiple wrong answers, and frantically tried to figure out what was wrong for 5 minutes before rereading the problem and slapping myself on the forehead.\n\nPart 2: My thought here was \"Eric must have made this problem actually possible\". I started by printing out the possible operations corresponding w/ each opcode, seeing a specific property >!there was an opcode that had only one possibility!< that would make it possible, and so I implemented that process in code for all opcodes.\n\nRuby:\n\n    instructions = {\n      addr: ->(a, b, c, r) { r[c] = r[a] + r[b] },\n      addi: ->(a, b, c, r) { r[c] = r[a] + b },\n      mulr: ->(a, b, c, r) { r[c] = r[a] * r[b] },\n      muli: ->(a, b, c, r) { r[c] = r[a] * b },\n      banr: ->(a, b, c, r) { r[c] = r[a] & r[b] },\n      bani: ->(a, b, c, r) { r[c] = r[a] & b },\n      borr: ->(a, b, c, r) { r[c] = r[a] | r[b] },\n      bori: ->(a, b, c, r) { r[c] = r[a] | b },\n      setr: ->(a, _, c, r) { r[c] = r[a] },\n      seti: ->(a, _, c, r) { r[c] = a },\n      gtir: ->(a, b, c, r) { r[c] = a > r[b] ? 1 : 0 },\n      gtri: ->(a, b, c, r) { r[c] = r[a] > b ? 1 : 0 },\n      gtrr: ->(a, b, c, r) { r[c] = r[a] > r[b] ? 1 : 0 },\n      eqir: ->(a, b, c, r) { r[c] = a == r[b] ? 1 : 0 },\n      eqri: ->(a, b, c, r) { r[c] = r[a] == b ? 1 : 0 },\n      eqrr: ->(a, b, c, r) { r[c] = r[a] == r[b] ? 1 : 0 },\n    }.freeze\n\n    raise 'You forgot an instruction...' if instructions.size != 16\n\n    could_be = Array.new(instructions.size) { instructions.keys }\n\n    verbose = ARGV.delete('-v')\n    input = (ARGV.empty? ? DATA : ARGF).each_line.map(&:chomp)\n\n    last_after = input.rindex { |l| l.start_with?('After: ') }\n\n    puts input[0..last_after].each_slice(4).count { |before, op, after, _|\n      before = before.scan(/\\d+/).map(&:to_i).freeze\n      after = after.scan(/\\d+/).map(&:to_i).freeze\n      opcode, a, b, c = op.split.map(&:to_i)\n\n      alike = instructions.select { |_, v|\n        regs = before.dup\n        begin\n          v[a, b, c, regs]\n        rescue\n          # Actually this line isn't necessary...\n          # I did it to defend against registers >= 4\n          # but it never happens in input?\n          next false\n        end\n        regs == after\n      }\n      could_be[opcode] &= alike.keys\n\n      alike.size >= 3\n    }\n\n    could_be.each_with_index { |c, i| puts \"#{i} (#{c.size}) -> #{c}\" } if verbose\n\n    assignments = [nil] * instructions.size\n    until assignments.all?\n      only_one = could_be.index { |a| a.size == 1 }\n      raise \"I'm not smart enough to do this one: #{could_be}\" unless only_one\n\n      assigned = could_be[only_one][0]\n      puts \"Assign #{only_one} #{assigned}\" if verbose\n      assignments[only_one] = instructions[assigned]\n      could_be.each { |e| e.delete(assigned) }\n    end\n\n    regs = [0, 0, 0, 0]\n\n    input.drop(last_after + 1).drop_while(&:empty?).each { |l|\n      opcode, a, b, c = l.split.map(&:to_i)\n      assignments[opcode][a, b, c, regs]\n    }\n\n    p verbose ? regs : regs[0]\n\n    __END__\n    Before: [3, 1, 0, 1]\n    9 3 3 2\n    After:  [3, 1, 0, 1]\n\n    omitted\n\n\n> raise 'You forgot an instruction...' if instructions.size != 16\n\n\nI wish I'd written this, would have saved me a lot of time!!\n\nregarding your spoiler/hint: I just assuned that this was the case and implemented the necessary code.\n\nHahaha :( I lost so much time because i forgot to add one of the commands to the list.  ", "id": "ebw7asl", "owner_tier": 0.1, "score": 0.3333333329629629}, {"content": "**Python 3**, 26/8:\n\n    import re, collections\n\n    *samples, _, program = open('inputs/day16').read().split('\\n\\n')\n\n    ops = {\n        'addr': lambda regs, a, b: regs[a] + regs[b],\n        'addi': lambda regs, a, b: regs[a] + b,\n        'mulr': lambda regs, a, b: regs[a] * regs[b],\n        'muli': lambda regs, a, b: regs[a] * b,\n        'banr': lambda regs, a, b: regs[a] & regs[b],\n        'bani': lambda regs, a, b: regs[a] & b,\n        'borr': lambda regs, a, b: regs[a] | regs[b],\n        'bori': lambda regs, a, b: regs[a] | b,\n        'setr': lambda regs, a, b: regs[a],\n        'seti': lambda regs, a, b: a,\n        'gtir': lambda regs, a, b: 1 if a > regs[b] else 0,\n        'gtri': lambda regs, a, b: 1 if regs[a] > b else 0,\n        'gtrr': lambda regs, a, b: 1 if regs[a] > regs[b] else 0,\n        'eqir': lambda regs, a, b: 1 if a == regs[b] else 0,\n        'eqri': lambda regs, a, b: 1 if regs[a] == b else 0,\n        'eqrr': lambda regs, a, b: 1 if regs[a] == regs[b] else 0,\n    }\n\n    indeterminate = 0\n\n    possible = collections.defaultdict(lambda: set(ops.keys()))\n\n    for sample in samples:\n        before, op, after = map(lambda s: list(map(int, re.findall(r'-?\\d+', s))), sample.splitlines())\n\n        count = 0\n\n        for opcode in ops:\n            result = ops[opcode](before, op[1], op[2])\n\n            if [*before[:op[3]], result, *before[op[3]+1:]] == after:\n                count += 1\n            elif opcode in possible[op[0]]:\n                possible[op[0]].remove(opcode)\n\n        if count >= 3:\n            indeterminate += 1\n\n    print('part 1:', indeterminate)\n\n    mapping = {}\n\n    while any(possible.values()):\n        for number, opcodes in possible.items():\n            if len(opcodes) == 1:\n                mapping[number] = op = opcodes.pop()\n                for remaining in possible.values():\n                    remaining.discard(op)\n\n    regs = [0, 0, 0, 0]\n\n    for line in program.splitlines():\n        op, a, b, c = [int(x) for x in line.split()]\n        regs[c] = ops[mapping[op]](regs, a, b)\n\n    print('part 2:', regs[0])\n\n\nThank you for this nice way of splitting the input! I'm so embarrassed by my own input-reading process that I've adapted it to post my code here.", "id": "ebw74jx", "owner_tier": 0.1, "score": 0.18518518481481483}, {"content": "C++, 53/34. Pretty interesting Part 2 today. Did some pretty lazy copy-pasting from Part 1 to run the program, but hey it was plenty fast enough.\n\n    #include <bits/stdc++.h>\n\tusing namespace std;\n\n\tint main(){\n\t\tstring s;\n\t\tchar junk;\n\t\tvector<int> bef(4);\n\t\tvector<int> af(4);\n\t\tvector<int> op(4);\n\n\t\tint ans = 0;\n\n\t\tset<int> full;\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tfull.insert(i);\n\t\t}\n\t\tvector<set<int>> poss(16, full);\n\n\t\twhile(cin >> s) {\n\t\t\t// manually added SPLIT to input between the two parts\n\t\t\tif(s == \"SPLIT\") break;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcin >> junk >> bef[i];\n\t\t\t}\n\t\t\tcin >> junk;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcin >> op[i];\n\t\t\t}\n\t\t\tcin >> s;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcin >> junk >> af[i];\n\t\t\t}\n\t\t\tcin >> junk;\n\t\t\tint opCode = op[0];\n\t\t\tint A = op[1], B = op[2], C = op[3];\n\t\t\t// compute all expected final register states\n\t\t\tvector<vector<int>> afExpect;\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tafExpect.push_back(bef);\n\t\t\t}\n\t\t\tafExpect[0][C] = bef[A] + bef[B];\n\t\t\tafExpect[1][C] = bef[A] + B;\n\n\t\t\tafExpect[2][C] = bef[A] * bef[B];\n\t\t\tafExpect[3][C] = bef[A] * B;\n\n\t\t\tafExpect[4][C] = bef[A] & bef[B];\n\t\t\tafExpect[5][C] = bef[A] & B;\n\n\t\t\tafExpect[6][C] = bef[A] | bef[B];\n\t\t\tafExpect[7][C] = bef[A] | B;\n\n\t\t\tafExpect[8][C] = bef[A];\n\t\t\tafExpect[9][C] = A;\n\n\t\t\tafExpect[10][C] = A > bef[B];\n\t\t\tafExpect[11][C] = bef[A] > B;\n\t\t\tafExpect[12][C] = bef[A] > bef[B];\n\n\t\t\tafExpect[13][C] = A == bef[B];\n\t\t\tafExpect[14][C] = bef[A] == B;\n\t\t\tafExpect[15][C] = bef[A] == bef[B];\n\t\t\tint cnt = 0;\n\t\t\tfor(int cur = 0; cur < 16; cur++) {\n\t\t\t\tbool match = true;\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tif(afExpect[cur][i] != af[i]) match = false;\n\t\t\t\t}\n\t\t\t\t// rule out impossible number-operation combos\n\t\t\t\tif(!match) poss[opCode].erase(cur);\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\n\t\twhile(true) {\n\t\t\tint numOnes = 0;\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\t// For any opcode with only one possibility,\n\t\t\t\t// we can remove the possibility from other opcodes.\n\t\t\t\tif(poss[i].size() == 1) {\n\t\t\t\t\tnumOnes++;\n\t\t\t\t\tfor(int j = 0; j < 16; j++) {\n\t\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\t\tposs[j].erase(*poss[i].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(numOnes == 16) break;\n\t\t}\n\n\t\tint opCode, A, B, C;\n\t\tvector<int> reg(4, 0);\n\t\twhile(cin >> opCode) {\n\t\t\tcin >> A >> B >> C;\n\t\t\tint op = *poss[opCode].begin();\n\n\t\t\t// Lazy copy-paste, but it's fast enough\n\t\t\tvector<vector<int>> afExpect;\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tafExpect.push_back(reg);\n\t\t\t}\n\t\t\tafExpect[0][C] = reg[A] + reg[B];\n\t\t\tafExpect[1][C] = reg[A] + B;\n\t\t\t\n\t\t\tafExpect[2][C] = reg[A] * reg[B];\n\t\t\tafExpect[3][C] = reg[A] * B;\n\n\t\t\tafExpect[4][C] = reg[A] & reg[B];\n\t\t\tafExpect[5][C] = reg[A] & B;\n\n\t\t\tafExpect[6][C] = reg[A] | reg[B];\n\t\t\tafExpect[7][C] = reg[A] | B;\n\n\t\t\tafExpect[8][C] = reg[A];\n\t\t\tafExpect[9][C] = A;\n\n\t\t\tafExpect[10][C] = A > reg[B];\n\t\t\tafExpect[11][C] = reg[A] > B;\n\t\t\tafExpect[12][C] = reg[A] > reg[B];\n\n\t\t\tafExpect[13][C] = A == reg[B];\n\t\t\tafExpect[14][C] = reg[A] == B;\n\t\t\tafExpect[15][C] = reg[A] == reg[B];\n\n\t\t\treg = afExpect[op];\n\t\t}\n\n\t\tfor(auto cur : reg) cout << cur << \" \" ;\n\n\t\treturn 0;\n\t}", "id": "ebw74yk", "owner_tier": 0.3, "score": 0.07407407370370371}, {"content": "Javascript, 81/60. Figuring out which opcode was which was fun. I was trying it manually first.\n\n&#x200B;\n\nSuper ugly code:\n\n    #!/usr/bin/env node\n    \n    const ops = [\n      (r, a, b, c) => { r[c] = r[a] + r[b] },\n      (r, a, b, c) => { r[c] = r[a] + b },\n      (r, a, b, c) => { r[c] = r[a] * r[b] },\n      (r, a, b, c) => { r[c] = r[a] * b },\n      (r, a, b, c) => { r[c] = r[a] & r[b] },\n      (r, a, b, c) => { r[c] = r[a] & b },\n      (r, a, b, c) => { r[c] = r[a] | r[b] },\n      (r, a, b, c) => { r[c] = r[a] | b },\n      (r, a, b, c) => { r[c] = r[a] },\n      (r, a, b, c) => { r[c] = a },\n      (r, a, b, c) => { r[c] = a > r[b] ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] > b ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] > r[b] ? 1 : 0 },\n      (r, a, b, c) => { r[c] = a === r[b] ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] === b ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] === r[b] ? 1 : 0 }\n    ]\n    \n    let r = [0, 0, 0, 0]\n    let result = []\n    let count = 0\n    \n    let possibilities = []\n    let pos = []\n    for (let i = 0; i < 16; i++) {\n      pos.push(i)\n    }\n    for (let i = 0; i < 16; i++) {\n      possibilities.push(new Set(pos))\n    }\n    let opcode = 0\n    \n    for (const line of require('fs').readFileSync('input.txt', 'utf8').trimEnd().split('\\n')) {\n      let m = line.match(/Before: \\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/)\n      if (m) {\n        r = m.slice(1).map(n => Number(n))\n      }\n      m = line.match(/^(\\d+) (\\d+) (\\d+) (\\d+)/)\n      if (m) {\n        m = m.slice(1).map(n => Number(n))\n        opcode = m[0]\n        result = []\n        for (const op of ops) {\n          let res = [...r]\n          op(res, m[1], m[2], m[3])\n          result.push(res)\n        }\n      }\n      m = line.match(/After: *\\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/)\n      if (m) {\n        const t = m.slice(1).map(n => Number(n))\n        let c = 0\n        let i = 0\n        for (const res of result) {\n          if (res.every((cur, idx) => cur === t[idx])) {\n            c++\n          } else {\n            possibilities[opcode].delete(i)\n          }\n          i++\n        }\n        if (c >= 3) {\n          count++\n        }\n      }\n    }\n    \n    console.log(count)\n    \n    let todo = new Set()\n    for (let i = 0; i < 16; i++) {\n      todo.add(i)\n    }\n    \n    let optable = []\n    while (todo.size > 0) {\n      for (const i of todo) {\n        if (possibilities[i].size === 1) {\n          optable[i] = [...possibilities[i]][0]\n          todo.delete(i)\n          for (let j = 0; j < 16; j++) {\n            possibilities[j].delete(optable[i])\n          }\n        }\n      }\n    }\n    \n    r = [0, 0, 0, 0]\n    for (const line of require('fs').readFileSync('input.txt', 'utf8').trimEnd().split('\\n').slice(3343)) {\n      const [, op, a, b, c] = line.match(/(\\d+) (\\d+) (\\d+) (\\d+)/).map(n => Number(n, 10))\n      ops[optable[op]](r, a, b, c)\n    }\n    console.log(r)\n    \n    \n    \n\n&#x200B;\n\nI'm doing these in JS too, but getting the wrong answer for Pt2.\n\n&#x200B;\n\nPart 1 went fine (though I was missing \\`borr\\` and \\`bori\\` \ud83d\ude2c -- they didn't matter). Now my final answer is a huuuuge number, and getting marked wrong as too high.\n\n&#x200B;\n\nStepping through the logic of each op seems to be doing the right thing, so I'm not sure where this is breaking. Though now that I'm rubber ducking this all out, I wonder if I've hit JS's int limit / max safe integer.\n\nMy Output for Part 2 is less then 1000 and looking over it no single register ever gets a value above 1000.\n\nFor what it's worth: all register values during execution of part 2 for my problem were three digits or less.\n\nYea, I suspected something was broken since these problems rarely reach into such arbitrarily large territory.\n\n&#x200B;\n\nGoing to double check my ops code mapping is right.\n\nYepp, my op codes were wrong. Boo-hiss. But, much better now. Thanks for the sanity check!\n\nGlad you figured it out :)", "id": "ebw7cka", "owner_tier": 0.3, "score": 0.37037036999999995}, {"content": "Ruby, #117/127. Somehow skipped over the binary OR instructions in part 1, and had brain lag trying to figure out part 2. But overall happy with the solution!\n\n    require 'pry'\n    \n    lines = $<.readlines.map(&:strip)\n    \n    class Sample\n      attr_accessor :before, :inst, :after\n      def initialize(before, inst, after)\n        @before = before\n        @inst = inst\n        @after = after\n      end\n    end\n    \n    def addr(r, a, b, c) r[c] = r[a] + r[b] end\n    def addi(r, a, b, c) r[c] = r[a] + b end\n    def mulr(r, a, b, c) r[c] = r[a] * r[b] end\n    def muli(r, a, b, c) r[c] = r[a] * b end\n    def banr(r, a, b, c) r[c] = r[a] & r[b] end\n    def bani(r, a, b, c) r[c] = r[a] & b end\n    def borr(r, a, b, c) r[c] = r[a] | r[b] end\n    def bori(r, a, b, c) r[c] = r[a] | b end\n    def setr(r, a, b, c) r[c] = r[a] end\n    def seti(r, a, b, c) r[c] = a end\n    def gtir(r, a, b, c) r[c] = a > r[b] ? 1 : 0 end\n    def gtri(r, a, b, c) r[c] = r[a] > b ? 1 : 0 end\n    def gtrr(r, a, b, c) r[c] = r[a] > r[b] ? 1 : 0 end\n    def eqir(r, a, b, c) r[c] = a == r[b] ? 1 : 0 end\n    def eqri(r, a, b, c) r[c] = r[a] == b ? 1 : 0 end\n    def eqrr(r, a, b, c) r[c] = r[a] == r[b] ? 1 : 0 end\n    \n    opcodes = (0..15).to_a\n    named_codes = [:addr, :addi, :mulr, :muli, :banr, :bani, :borr, :bori, :setr, :seti, :gtir, :gtri, :gtrr, :eqir, :eqri, :eqrr]\n    \n    samples = []\n    program = []\n    lines.each_slice(4).map do |slice|\n      if slice[0].start_with? 'Before'\n        samples << Sample.new(*slice[0..2].map { |line| line.scan(/\\d+/).map(&:to_i) })\n      else\n        program += slice.map { |line| line.scan(/\\d+/).map(&:to_i) }\n      end\n    end\n    \n    possible = opcodes.each_with_object({}) do |code, h|\n      h[code] = named_codes\n    end\n    \n    samples.each do |sample|\n      possible[sample.inst[0]] &= named_codes.select do |code|\n        r = sample.before.dup\n        send(code, r, *sample.inst[1..-1])\n        r == sample.after\n      end\n    end\n    \n    code_map = {}\n    until code_map.size == 16\n      possible.each do |num, codes|\n        next if code_map[num]\n        codes.each do |code|\n          next if possible.any? { |num2, code2| num2 != num && code2.include?(code) }\n          possible[num] = [code]\n          code_map[num] = code\n          break\n        end\n      end\n    end\n    \n    registers = [0] * 4\n    program.each do |prog|\n      send(code_map[prog[0]], registers, *prog[1..-1])\n    end\n    \n    puts registers.first", "id": "ebw7hzj", "owner_tier": 0.7, "score": 0.07407407370370371}, {"content": "Perl, 250ish/168.\n\n    #!/usr/bin/perl -s\n    use warnings;\n    use strict;\n    use feature qw/say/;\n    use integer;\n    use English;\n    \n    our $part2;\n    \n    $RS = \"\\n\\n\";\n    \n    our @registers = (0, 0, 0, 0);\n    \n    my %opcodes = (\n        addr => sub { $registers[$_[2]] = $registers[$_[0]] + $registers[$_[1]] },\n        addi => sub { $registers[$_[2]] = $registers[$_[0]] + $_[1] },\n        mulr => sub { $registers[$_[2]] = $registers[$_[0]] * $registers[$_[1]] },\n        muli => sub { $registers[$_[2]] = $registers[$_[0]] * $_[1] },\n        banr => sub { $registers[$_[2]] = $registers[$_[0]] & $registers[$_[1]] },\n        bani => sub { $registers[$_[2]] = $registers[$_[0]] & $_[1] },\n        borr => sub { $registers[$_[2]] = $registers[$_[0]] | $registers[$_[1]] },\n        bori => sub { $registers[$_[2]] = $registers[$_[0]] | $_[1] },\n        setr => sub { $registers[$_[2]] = $registers[$_[0]] },\n        seti => sub { $registers[$_[2]] = $_[0] },\n        gtir => sub { $registers[$_[2]] = $_[0] > $registers[$_[1]] },\n        gtri => sub { $registers[$_[2]] = $registers[$_[0]] > $_[1] },\n        gtrr => sub { $registers[$_[2]] = $registers[$_[0]] > $registers[$_[1]] },\n        eqir => sub { $registers[$_[2]] = $_[0] == $registers[$_[1]] },\n        eqri => sub { $registers[$_[2]] = $registers[$_[0]] == $_[1] },\n        eqrr => sub { $registers[$_[2]] = $registers[$_[0]] == $registers[$_[1]] }\n        );\n    \n    my %opnums;\n    my $total_matches = 0;\n    while (<>) {\n        last if m/\\A\\s+\\z/;\n        if (/Before:\\s+\\[(\\d+),\\ (\\d+),\\ (\\d+),\\ (\\d+)\\]\\s+\n             (\\d+)\\ (\\d+)\\ (\\d+)\\ (\\d+)\\s+\n             After:\\s+\\[(\\d+),\\ (\\d+),\\ (\\d+),\\ (\\d+)\\]/x) {\n            my $matches = 0;  \n            my $opname = \"\";\n            while (my ($name, $op) = each %opcodes) {\n                local @registers = ($1, $2, $3, $4);\n                $op->($6, $7, $8);\n                if ($registers[0] == $9 && $registers[1] == $10\n                    && $registers[2] == $11 && $registers[3] == $12) {\n                    $matches += 1;\n                    $opname = $name;\n                }\n            }\n            if ($part2 && $matches == 1) {\n                $opnums{$5} = $opcodes{$opname};\n                delete $opcodes{$opname};\n            }\n            $total_matches += 1 if $matches >= 3;\n        }\n    }\n    \n    if (not $part2) {\n        say \"Part 1: $total_matches\";\n        exit 0;\n    }\n    \n    $RS = \"\\n\";\n    while (<>) {\n        if (/(\\d+) (\\d+) (\\d+) (\\d+)/) {\n            $opnums{$1}->($2, $3, $4);\n        } else {\n            die \"Invalid input $_\";\n        }\n    }\n    say \"Part 2: $registers[0]\";\n    ", "id": "ebw7utu", "owner_tier": 0.9, "score": 0.07407407370370371}, {"content": "**Ruby** 177/321\n\nI really thought I could do better when I read the description, as I've played around with simple VMs before (eg the [Synacor Challenge](https://challenge.synacor.com/)). Ah well, still fun.\n\nI cost myself at least 20 minutes on part 2 because I kept attempting to work out the opcode values using the initial register settings from the samples, instead of the actual instructions. :facepalm: :headdesk:\n\n\tOPCODES = {\n\t\taddr: -> regs, a, b, c { regs[c] = regs[a] + regs[b] },\n\t\taddi: -> regs, a, b, c { regs[c] = regs[a] + b },\n\t\tmulr: -> regs, a, b, c { regs[c] = regs[a] * regs[b]},\n\t\tmuli: -> regs, a, b, c { regs[c] = regs[a] * b  },\n\t\tbanr: -> regs, a, b, c { regs[c] = regs[a] & regs[b] },\n\t\tbani: -> regs, a, b, c { regs[c] = regs[a] & b },\n\t\tborr: -> regs, a, b, c { regs[c] = regs[a] | regs[b] },\n\t\tbori: -> regs, a, b, c { regs[c] = regs[a] | b },\n\t\tsetr: -> regs, a, b, c { regs[c] = regs[a] },\n\t\tseti: -> regs, a, b, c { regs[c] = a },\n\t\tgtir: -> regs, a, b, c { regs[c] = a > regs[b] ? 1 : 0 },\n\t\tgtri: -> regs, a, b, c { regs[c] = regs[a] > b ? 1 : 0 },\n\t\tgtrr: -> regs, a, b, c { regs[c] = regs[a] > regs[b] ? 1 : 0 },\n\t\teqir: -> regs, a, b, c { regs[c] = a == regs[b] ? 1 : 0 },\n\t\teqri: -> regs, a, b, c { regs[c] = regs[a] == b ? 1 : 0 },\n\t\teqrr: -> regs, a, b, c { regs[c] = regs[a] == regs[b] ? 1 : 0 },\n\t}\n\n\tdef solve\n\t\topcodes = (0...16).map{ |n| [n,nil] }.to_h\n\t\tpart1_count = 0\n\t\tsamples = 0\n\t\tsmallest_sizes = {}\n\t\tidx = 0\n\t\t@input.lines.each_slice(4) do |before,input,after,_|\n\t\t\tsamples += 1\n\t\t\tregisters = /Before:\\s+\\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/.match(before)[1..-1].map(&:to_i)\n\t\t\texpected_regs = /After:\\s+\\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/.match(after)[1..-1].map(&:to_i)\n\n\t\t\top, a, b, out = /(\\d+) (\\d+) (\\d+) (\\d+)/.match(input)[1..-1].map(&:to_i)\n\n\t\t\tidx += 4\n\t\t\trs = nil\n\t\t\tpossibles = OPCODES.select do |opcode,oper|\n\t\t\t\trs = registers.dup\n\t\t\t\toper.call(rs,a,b,out)\n\t\t\t\trs == expected_regs\n\t\t\tend\n\n\t\t\tpart1_count += 1 if possibles.size >= 3\n\t\t\tif possibles.size == 1\n\t\t\t\topcodes[op] = possibles.keys.first\n\t\t\t\tsmallest_sizes[op] = 1\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif opcodes[op].nil?\n\t\t\t\t\t\topcodes[op] = possibles.keys\n\t\t\t\t\t\tsmallest_sizes[op] = possibles.keys.size\n\t\t\t\t\telsif opcodes[op].is_a?(Array)\n\t\t\t\t\t\tintersection = opcodes[op] & possibles.keys\n\t\t\t\t\t\tif smallest_sizes[op] > intersection.size\n\t\t\t\t\t\t\tsmallest_sizes[op] = intersection.size\n\t\t\t\t\t\tend\n\t\t\t\t\t\topcodes[op] = intersection\n\t\t\t\t\t\tif opcodes[op].size == 1\n\t\t\t\t\t\t\topcodes[op] = opcodes[op].first\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\trescue => e\n\t\t\t\t\tputs e\n\t\t\t\t\tputs op\n\t\t\t\t\tputs possibles.keys\n\t\t\t\t\tputs opcodes\n\t\t\t\t\tputs smallest_sizes\n\t\t\t\t\traise\n\t\t\t\tend\n\t\t\tend\n\t\trescue\n\t\t\tbreak\n\t\tend\n\n\t\tchanged = true\n\t\tuntil !changed do\n\t\t\tchanged = false\n\t\t\tknown_ops = opcodes.values.select{|op| op.is_a?(Symbol)}\n\t\t\topcodes.each do |k,v|\n\t\t\t\tnext if v.is_a?(Symbol)\n\t\t\t\tres = v - known_ops\n\t\t\t\tif res != v\n\t\t\t\t\tchanged = true\n\t\t\t\t\tif res.size == 1\n\t\t\t\t\t\topcodes[k] = res.first\n\t\t\t\t\telse\n\t\t\t\t\t\topcodes[k] = res\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tputs \"There are #{opcodes.values.uniq.size} known opcocdes\"\n\t\tputs \"There are #{part1_count} samples out of #{samples} that behave like 3 or more opcodes\"\n\n\t\tregisters = [0,0,0,0]\n\t\tinstrs = 0\n\t\t@lines[idx..-1].each do |line|\n\t\t\tnext if line.empty?\n\t\t\tinstrs += 1\n\t\t\tif instrs == 1\n\t\t\t\tputs \"The first instruction is #{line}\"\n\t\t\tend\n\t\t\top, a, b, out = /(\\d+) (\\d+) (\\d+) (\\d+)/.match(line)[1..-1].map(&:to_i)\n\t\t\tOPCODES[opcodes[op]].call(registers,a,b,out)\n\t\tend\n\n\t\tputs \"The value of register 0 after running the program is #{registers.join(\" \")} (#{instrs} instructions were run)\"\n\tend\n\n\nTabs?! In Ruby?! HERESY!", "id": "ebw8q6u", "owner_tier": 0.3, "score": 0.07407407370370371}, {"content": "Although no longer trendy - I tend to solve these in Perl - as usually it's the best language (without going to compiled languages like C) especially when this version codes really quickly... Took too long for (a) as I didn't read what answer was being looked for and solved part (b) first {I'd optimized out the checking code was valid} ... code below...  \n\n\nSteps - are set up opcode map, read in input into training set and real input (possibly the hardest bit of the code <g>, looping through all reading sets and working out which opcodes are possible...; reducing this set into the final map and then applying it to the real input...  \n\n\nExecution is very fast - wrong timezone to get on leaderboard!\n\n    my %ops = (\n      'addr' => sub { return $_[0][$_[1]] +  $_[0][$_[2]]  },\n      'addi' => sub { return $_[0][$_[1]] +        $_[2]   },\n      'mulr' => sub { return $_[0][$_[1]] *  $_[0][$_[2]]  },\n      'muli' => sub { return $_[0][$_[1]] *        $_[2]   },\n      'banr' => sub { return $_[0][$_[1]] &  $_[0][$_[2]]  },\n      'bani' => sub { return $_[0][$_[1]] &        $_[2]   },\n      'borr' => sub { return $_[0][$_[1]] |  $_[0][$_[2]]  },\n      'bori' => sub { return $_[0][$_[1]] |        $_[2]   },\n      'setr' => sub { return $_[0][$_[1]]                  },\n      'seti' => sub { return       $_[1]                   },\n      'gtir' => sub { return       $_[1]  >  $_[0][$_[2]] ? 1 : 0 },\n      'gtri' => sub { return $_[0][$_[1]] >        $_[2]  ? 1 : 0 },\n      'gtrr' => sub { return $_[0][$_[1]] >  $_[0][$_[2]] ? 1 : 0 },\n      'eqir' => sub { return       $_[1]  == $_[0][$_[2]] ? 1 : 0 },\n      'eqri' => sub { return $_[0][$_[1]] ==       $_[2]  ? 1 : 0 },\n      'eqrr' => sub { return $_[0][$_[1]] == $_[0][$_[2]] ? 1 : 0 },\n    );\n    \n    open my $fh, q(<), 'in.txt';\n    while(my $row = <$fh>) {\n      if( $row =~ m{Before:} ) {\n        push @tr, [[ $row =~ m{(\\d+)}g ],[ <$fh> =~ m{(\\d+)}g ],[ <$fh> =~ m{(\\d+)}g ]];\n      } elsif ( $row =~ m{\\d} ) {\n        push @in, [ $row =~ m{(\\d+)}g ];\n      }\n    }\n    \n    foreach my $e (@tr) {\n      my ($o,$a,$b,$c) = @{$e->[1]};\n      $poss{ $o }    ||= { map { $_=>1 } keys %ops };\n      foreach my $ro ( grep { exists $poss{$o}{$_} } keys %ops )\n        delete $poss{ $o }{ $ro } unless &{$ops{$ro}}( $e->[0], $a, $b ) == $e->[2][$c];\n      }\n    }\n    \n    while( scalar keys %poss ) {\n      my ($o)     = grep { 1 == scalar keys %{$poss{$_}} } keys %poss;\n      my ($ro)    = keys %{delete $poss{$o}};\n      $actual{$o} = $ro;\n      delete $poss{$_}{$ro} foreach grep { exists $poss{$_}{$ro} } keys %poss;\n    }\n    \n    $R[ $_->[3] ] = &{$ops{$actual{$_->[0]}}}(\\@R,$_->[1],$_->[2]) foreach @in;\n    \n    print \"$R[0]\\n\";", "id": "ebwcy13", "owner_tier": 0.1, "score": 0.07407407370370371}, {"content": "This one was way more my idea of fun than yesterday. \n\nAfter part 1, I figured out the right order for the commands by hand, then just re-ordered the enum accordingly.\n\nJava\n\nhttps://pastebin.com/hswcGrGf\n\n    public class Day16 extends AdventOfCode {\n    \n        public Day16(List<String> input) {\n            super(input);\n            title = \"Chronal Classification\";\n            part1Description = \"Samples with 3 or more valid opcodes: \";\n            part2Description = \"Value at register 0 after running test program: \";\n        }\n    \n        class Sample {\n            int[] before = new int[4];\n            int[] after = new int[4];\n            int[] codes = new int[4];\n        }\n    \n        List<Sample> samples;\n        List<int[]> program;\n    \n        class Operation {\n            int aReg;\n            int aVal;\n            int bReg;\n            int bVal;\n            int c;\n            Command cmd;\n    \n            public Operation(int aReg, int aVal, int bReg, int bVal, int c, Command cmd) {\n                this.aReg = aReg;\n                this.aVal = aVal;\n                this.bReg = bReg;\n                this.bVal = bVal;\n                this.c = c;\n                this.cmd = cmd;\n            }\n        }\n    \n    \n        enum Command {\n            EQRI(Command::eq, Command::ri),\n            BANI((x, y) -> x & y, Command::ri),\n            SETI((x, y) -> x, Command::ir),\n            BORI((x, y) -> x | y, Command::ri),\n            EQIR(Command::eq, Command::ir),\n            BANR((x, y) -> x & y, Command::rr),\n            BORR((x, y) -> x | y, Command::rr),\n            MULI((x, y) -> x * y, Command::ri),\n            SETR((x, y) -> x, Command::rr),\n            ADDR((x, y) -> x + y, Command::rr),\n            EQRR(Command::eq, Command::rr),\n            ADDI((x, y) -> x + y, Command::ri),\n            GTIR(Command::gt, Command::ir),\n            GTRR(Command::gt, Command::rr),\n            GTRI(Command::gt, Command::ri),\n            MULR((x, y) -> x * y, Command::rr);\n    \n    \n            IntBinaryOperator function;\n            ToIntFunction<Operation> opcode;\n            Command(IntBinaryOperator function, ToIntFunction<Operation> opcode) {\n                this.function = function;\n                this.opcode = opcode;\n            }\n    \n    \n            static int gt(int x, int y) {\n                return x > y ? 1 : 0;\n            }\n    \n            static int eq(int x, int y) {\n                return x == y ? 1 : 0;\n            }\n    \n            static int rr(Operation op) {\n                return op.cmd.function.applyAsInt(op.aReg, op.bReg);\n            }\n    \n            static int ri(Operation op) {\n                return op.cmd.function.applyAsInt(op.aReg, op.bVal);\n            }\n    \n            static int ir(Operation op) {\n                return op.cmd.function.applyAsInt(op.aVal, op.bReg);\n            }\n    \n        }\n    \n        void run(int[] reg, int[] codes, Command cmd) {\n            int a = codes[1];\n            int b = codes[2];\n            int c = codes[3];\n    \n            Operation op = new Operation(reg[a], a, reg[b], b, reg[c], cmd);\n            reg[codes[3]] = cmd.opcode.applyAsInt(op);\n        }\n    \n        @Override\n        public Object part1() {\n            int hasthree = 0;\n    \n            // use this to order enums for part 2\n            Map<Integer, Set<Command>> cmdmap = new HashMap<>();\n    \n            for (Sample sample : samples) {\n                int count = 0;\n                for (Command cmd : Command.values()) {\n                    int[] copy = new int[sample.before.length];\n                    System.arraycopy(sample.before, 0, copy, 0, sample.before.length);\n                    run(copy, sample.codes, cmd);;\n                    if (Arrays.equals(copy, sample.after)) {\n                        cmdmap.putIfAbsent(sample.codes[0], new HashSet<>());\n                        cmdmap.get(sample.codes[0]).add(cmd);\n                        count++;\n                    }\n                }\n                if (count > 2) hasthree++;\n            }\n            return hasthree;\n        }\n    \n        @Override\n        public Object part2() {\n            int[] register = { 0, 0, 0, 0 };\n            for (int[] line : program) {\n                run(register, line, Command.values()[line[0]]);\n            }\n            return register[0];\n        }\n    \n        @Override\n        public void parse() {\n            samples = new ArrayList<>();\n            program = new ArrayList<>();\n            boolean part2 = false;\n            Sample sample = new Sample();\n            samples.add(sample);\n            for (String line : input) {\n                if (line.equals(\"stop\")) {\n                    part2 = true;\n                    continue;\n                }\n                if (part2) {\n                    program.add(FileIO.StringArrayToInt(line.split(\" \")));\n                } else {\n                    if (line.isEmpty()) {\n                        sample = new Sample();\n                        samples.add(sample);\n                        continue;\n                    }\n                    if (line.startsWith(\"Before\")) {\n                        String[] split = line.substring(9, line.indexOf(']')).split(\", \");\n                        sample.before = FileIO.StringArrayToInt(split);\n                    } else {\n                        if (line.startsWith(\"After\")) {\n                            String[] split = line.substring(9, line.indexOf(']')).split(\", \");\n                            sample.after = FileIO.StringArrayToInt(split);\n                        } else {\n                            sample.codes = FileIO.StringArrayToInt(line.split(\" \"));\n                        }\n                    }\n                }\n    \n            }\n        }\n    \n    }\n\nCleaned up and added code to solve the command order\n\nhttps://pastebin.com/9Kbeqgd5", "id": "ebwhyxk", "owner_tier": 0.9, "score": 0.14814814777777777}, {"content": "(This taken also from my **[Daily Haskell Reflecitons](https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md#day-16)** blog!)\n\n---------------\n\nToday was fun because I got to re-use some techniques I discussed in a blog\npost I've written in the past: [Send More Money: List and\nStateT][send-more-money].  I talk about using `StateT` over `[]` to do\nimplement prolog-inspired constraint satisfaction searches while taking\nadvantage of laziness.\n\n[send-more-money]: https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html\n\nFirst of all, our types.  I'll be using the *[vector-sized][]* library with\n*[finite-typelits][]* to help us do safe indexing.  A `Vector n a` is a vector\nof `n` `a`s, and a `Finite n` is a legal index into such a vector.  For\nexample, a `Vector 4 Int` is a vector of 4 `Int`s, and `Finite 4` is 0, 1, 2,\nor 3.\n\n[vector-sized]: https://hackage.haskell.org/package/vector-sized\n[finite-typelits]: https://hackage.haskell.org/package/finite-typelits\n\n\timport           Data.Vector.Sized (Vector)\n\timport           Data.Finite       (Finite)\n\n\ttype Reg = Vector 4 Int\n\n\tdata Instr a = I { _iOp  :: a\n\t                 , _iInA :: Finite 4\n\t                 , _iInB :: Finite 4\n\t                 , _iOut :: Finite 4\n\t                 }\n\t  deriving (Show, Functor)\n\n\tdata Trial = T { _tBefore :: Reg\n\t               , _tInstr  :: Instr (Finite 16)\n\t               , _tAfter  :: Reg\n\t               }\n\t  deriving Show\n\n\tdata OpCode = OAddR | OAddI\n\t            | OMulR | OMulI\n\t            | OBanR | OBanI\n\t            | OBorR | OBorI\n\t            | OSetR | OSetI\n\t            | OGtIR | OGtRI | OGtRR\n\t            | OEqIR | OEqRI | OEqRR\n\t  deriving (Show, Eq, Ord, Enum, Bounded)\n\nWe can leave `Instr` parameterized over the opcode type so that we can use it\nwith `Finite 16` initially, and `OpCode` later.\n\nWe do need to implement the functionality of each op, which we can do by\npattern matching on an `OpCode`.  We use some lens functionality to simplify\nsome of the editing of indices, but we could also just manually modify indices.\n\n\trunOp :: Instr OpCode -> Reg -> Reg\n\trunOp I{..} = case _iOp of\n\t    OAddR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  +  r ^. V.ix _iInB\n\t    OAddI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  +  fromIntegral _iInB\n\t    OMulR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  *  r ^. V.ix _iInB\n\t    OMulI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  *  fromIntegral _iInB\n\t    OBanR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .&. r ^. V.ix _iInB\n\t    OBanI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .&. fromIntegral _iInB\n\t    OBorR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .|. r ^. V.ix _iInB\n\t    OBorI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .|. fromIntegral _iInB\n\t    OSetR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA\n\t    OSetI -> \\r -> r & V.ix _iOut .~                     fromIntegral _iInA\n\t    OGtIR -> \\r -> r & V.ix _iOut . enum .~ (fromIntegral _iInA  > r ^. V.ix _iInB   )\n\t    OGtRI -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA     > fromIntegral _iInB)\n\t    OGtRR -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA     > r ^. V.ix _iInB   )\n\t    OEqIR -> \\r -> r & V.ix _iOut . enum .~ (fromIntegral _iInA == r ^. V.ix _iInB   )\n\t    OEqRI -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA    == fromIntegral _iInB)\n\t    OEqRR -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA    == r ^. V.ix _iInB   )\n\nNow, from a `Trial`, we can get a set of `OpCode`s that are plausible\ncandidates if the output matches the expected output for a given `OpCode`, for\nthe given input.\n\n\tplausible :: Trial -> Set OpCode\n\tplausible T{..} = S.fromList (filter tryTrial [OAddR ..])\n\t  where\n\t    tryTrial :: OpCode -> Bool\n\t    tryTrial o = runOp (_tInstr { _iOp = o }) _tBefore == _tAfter\n\nPart 1 is, then, just counting the trials with three or more plausible\ncandidates:\n\n\tday16a :: [Trial] -> Int\n\tday16a = length . filter ((>= 3) . S.size . plausible)\n\nPart 2 is where we can implement our constraint satisfaction search.  Following\n[this blog post][send-more-money], we can write a search using `StateT (Set\nOpCode) []`.  Our state will be the `OpCode`s that we have already used.  We\nfill up a vector step-by-step, by picking only `OpCode`s that have not been\nused yet:\n\n\tfillIn :: Set OpCode -> StateT (Set OpCode) [] OpCode\n\tfillIn candidates = do\n\t    unseen <- gets (candidates `S.difference`)  -- filter only unseen candidates\n\t    pick   <- lift $ toList unseen              -- branch on all unseen candidates\n\t    modify $ S.insert pick                      -- in this branch, 'pick' is seen\n\t    pure pick                                   -- return our pick for the branch\n\nNow, if we have a map of `Finite 16` (op code numbers) to their candidates (a\n`Map (Finite 16) (Set OpCode)`), we can populate all legal\nconfigurations.  We'll use `Vector 16 OpCode` to represent our configuration:\n`0` will represent the first item, `1` will represent the second, etc.  We can\nuse `V.generate :: (Finite n -> m a) -> m (Vector n a)`, and run our `fillIn`\naction for every `Finite n`.\n\n\tfillVector\n\t    :: Map (Finite 16) (Set OpCode)\n\t    -> StateT (Set OpCode) [] (Vector 16 OpCode)\n\tfillVector candmap = V.generateM $ \\i -> do\n\t    Just cands <- pure $ M.lookup i candmap\n\t    fillIn cands\n\n\tfromClues\n\t    :: Map (Finite 16) (Set OpCode)\n\t    -> Maybe (Vector 16 OpCode)\n\tfromClues m = listToMaybe $ evalStateT (fillVector m) S.empty\n\nIf this part is confusing, the [blog post][send-more-money] explains how\n`StateT` and `[]`, together, give you this short-circuting search behavior!\n\nSo our Part 2 is using `fromClues` from all of the candidates (making sure to\ndo a set intersection if we get more than one clue for an opcode number), and a\n`foldl'` over our instruction list:\n\n\tday16b :: [Trial] -> [Instr (Finite 16)] -> Int\n\tday16b ts = V.head . foldl' step (V.replicate 0)\n\t  where\n\t    candmap    = M.fromListWith S.intersection\n\t               $ [ (_iOp (_tInstr t), plausible t)\n\t                 | t <- ts\n\t                 ]\n\t    Just opMap = fromClues candmap\n\t    step r i = runOp i' r\n\t      where\n\t        i' = (opMap `V.index`) <$> i", "id": "ebwk4w0", "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "**K**:\n\n    addr:{r[z]:r[x]+r y}\n    addi:{r[z]:r[x]+y}\n    mulr:{r[z]:r[x]*r y}\n    muli:{r[z]:r[x]*y}\n    banr:{r[z]:bd db[r x]&db r y}\n    bani:{r[z]:bd db[r x]&db y}\n    borr:{r[z]:bd db[r x]|db r y}\n    bori:{r[z]:bd db[r x]|db y}\n    setr:{r[z]:r x}\n    seti:{r[z]:x}\n    gtir:{r[z]:0+x>r y}\n    gtri:{r[z]:0+r[x]>y}\n    gttr:{r[z]:0+r[x]>r y}\n    eqir:{r[z]:0+x=r y}\n    eqri:{r[z]:0+r[x]=y}\n    eqrr:{r[z]:0+r[x]=r y}\n    instr:16#!`.\n    r:4#0\n    db:{((8-#c)#0b),c:|1_*+({x 1}{(1=x-2*d;d:div[x:x 1;2])}\\(0b;x))} /8bit binary\n    bd:{`long$+/2 xexp &|x}\n    input:.q.cut[4]3136#i:{.?[x in .Q.n;x;\" \"]}'0:`p16\n    process:{[state;cmd;instruction]r::state;`.[instruction]. 1_cmd;r}\n    handle:{[before;cmd;after]after~/:process[before;cmd;]'instr}\n    +/2<+/'handle .'3#'input\n    /part 2 - converge extract cmds that are the only match\n    lookup:()!()\n    find:{i:last@&1=+/'x;cmd:input[i;1;0];col:&x@i;\n    \tif[~^*col;lookup[cmd]:*instr col;x[;col]:0b];x}\n    find/handle .'3#'input;\n    r:4#0;{`.[lookup x 0]. 1_x}'3138_i;r 0\n\nTo decipher the instructions I looked for the commands that were the single correct option in a test run.  Somehow using the first match didn't converge but the last did. Also had to throw in a binary-to-decimal convertor as K doesn't have native bitwise operators.", "id": "ebwq9dg", "owner_tier": 0.1, "score": 0.07407407370370371}, {"content": "Python 3, 8/10. I just need to get better at input parsing.\n\n[Card] copy/paste\n\n    cases = []\n    testprog = []\n    with open('16.txt') as inp:\n        while True:\n            before = inp.readline()\n            if before == '\\n': break\n            before = eval(before[8:])\n            opc, *args = map(int,inp.readline().split())\n            after = eval(inp.readline()[8:])\n            assert inp.readline() == '\\n'\n            cases.append((before, opc, args, after))\n        inp.readline()\n        while True:\n            line = inp.readline()\n            if line == '': break\n            if line == '\\n': break\n            opc, *args = map(int,line.split())\n            testprog.append((opc,args))\n\n    def addr(regs,a,b,c):\n        regs[c]=regs[a]+regs[b]\n    def addi(regs,a,b,c):\n        regs[c]=regs[a]+b\n\n    def mulr(regs,a,b,c):\n        regs[c]=regs[a]*regs[b]\n    def muli(regs,a,b,c):\n        regs[c]=regs[a]*b\n\n    def banr(regs,a,b,c):\n        regs[c]=regs[a]&regs[b]\n    def bani(regs,a,b,c):\n        regs[c]=regs[a]&b\n\n    def borr(regs,a,b,c):\n        regs[c]=regs[a]|regs[b]\n    def bori(regs,a,b,c):\n        regs[c]=regs[a]|b\n\n    def setr(regs,a,b,c):\n        regs[c]=regs[a]\n    def seti(regs,a,b,c):\n        regs[c]=a\n\n    def gtir(regs,a,b,c):\n        regs[c]=1 if a>regs[b] else 0\n    def gtri(regs,a,b,c):\n        regs[c]=1 if regs[a]>b else 0\n    def gtrr(regs,a,b,c):\n        regs[c]=1 if regs[a]>regs[b] else 0\n\n    def eqir(regs,a,b,c):\n        regs[c]=1 if a==regs[b] else 0\n    def eqri(regs,a,b,c):\n        regs[c]=1 if regs[a]==b else 0\n    def eqrr(regs,a,b,c):\n        regs[c]=1 if regs[a]==regs[b] else 0\n\n    insns = ['addr','addi','mulr','muli','banr','bani','borr','bori','setr','seti','gtir','gtri','gtrr','eqir','eqri','eqrr']\n\n    def main():\n        op_to_insn = {}\n        cool = 0\n        done_cases = []\n        for before, opc, args, after in cases:\n            works = []\n            for insn in insns:\n                regs = list(before)\n                insn = globals()[insn]\n                insn(regs,*args)\n                if regs == after:\n                    works.append(insn)\n            #print(works)\n            done_cases.append((opc, works))\n        print(cool)\n        while True:\n            for c in done_cases:\n                op = c[0]\n                if len(c[1]) == 1:\n                    op_to_insn[op] = c[1][0]\n                    for c in done_cases:\n                        try:\n                            c[1].remove(op_to_insn[op])\n                        except ValueError: pass\n                    break\n            else:\n                break\n\n        regs = [0]*4\n        for opc, args in testprog:\n            op_to_insn[opc](regs,*args)\n        print(regs[0])\n\n        print(op_to_insn)\n\n    if __name__ == '__main__':\n        main()\n\n> [Card] copy/paste\n\nSo, StackOverflow?  >_>\n\nFor the instructions, I wrote the add one and copy pasted the rest", "id": "ebw79n8", "owner_tier": 0.3, "score": 0.22222222185185186}, {"content": "Unlike yesterday, this one was a breeze! :)\n15/21\n\n    import sys\n    from collections import defaultdict as dd, deque\n\n    R = [0]*4\n\n    # Super fun implementing all these functions...\n    def addr(a,b,c): R[c] = R[a] + R[b]\n    def addi(a,b,c): R[c] = R[a] + b\n\n    def mulr(a,b,c): R[c] = R[a] * R[b]\n    def muli(a,b,c): R[c] = R[a] * b\n\n    def banr(a,b,c): R[c] = R[a] & R[b]\n    def bani(a,b,c): R[c] = R[a] & b\n\n    def borr(a,b,c): R[c] = R[a] | R[b]\n    def bori(a,b,c): R[c] = R[a] | b\n\n    def setr(a,b,c): R[c] = R[a]\n    def seti(a,b,c): R[c] = a\n\n    def gtir(a,b,c): R[c] = int(a > R[b])\n    def gtri(a,b,c): R[c] = int(R[a] > b)\n    def gtrr(a,b,c): R[c] = int(R[a] > R[b])\n\n    def eqir(a,b,c): R[c] = int(a == R[b])\n    def eqri(a,b,c): R[c] = int(R[a] == b)\n    def eqrr(a,b,c): R[c] = int(R[a] == R[b])\n\n    L = list(sys.stdin)\n\n    ### Part 1 ###\n    ops = [addr, addi, mulr, muli,\n           banr, bani, borr, bori,\n           setr, seti, gtir, gtri,\n           gtrr, eqir, eqri, eqrr]\n\n    opcode = dd(set)\n\n    res = 0\n    i = 0\n    while i < len(L):\n        if L[i] == L[i+1] == '\\n':\n            i += 2\n            break\n\n        orig = eval(L[i].split(':')[1])\n        o,a,b,c = map(int,L[i+1].split())\n        Ra = eval(L[i+2].split(':')[1])\n        \n        count = 0\n        for op in ops:\n            R = orig[:]\n            op(a,b,c)\n            if R == Ra:\n                count += 1\n                opcode[op].add(o)\n        if count >= 3:\n            res += 1\n        i += 4\n\n    print('3+ ops:',res)\n\n    ### Part 2 ###\n    \"\"\"\n    opcode = {eqir: {0, 1, 2, 3, 5, 6, 7, 8, 12, 13, 14, 15},\n              eqrr: {2, 5, 6, 7, 8, 13, 15},\n              gtri: {0, 1, 2, 3, 5, 7, 8, 11, 15},\n              gtrr: {0, 1, 2, 3, 5, 8, 11, 13, 15},\n              eqri: {1, 2, 3, 5, 8, 12, 13, 15},\n              banr: {5, 8, 11, 12, 13, 15},\n              bani: {1, 5, 11, 12, 13, 15},\n              seti: {1, 4, 5, 9, 11},\n              gtir: {1, 2, 5, 8, 10, 11, 13, 15},\n              muli: {1, 11, 12, 13},\n              bori: {1, 11, 12},\n              setr: {1, 10, 11, 12},\n              addr: {9, 11, 4, 1},\n              addi: {9, 11, 1},\n              borr: {1, 11},\n              mulr: {11}}\n    \"\"\"\n\n    # (...manual labor...)\n\n    oplist = [gtrr, borr, gtir, eqri,\n              addr, seti, eqrr, gtri,\n              banr, addi, setr, mulr,\n              bori, muli, eqir, bani]\n\n    for line in L[i:]:\n        o,a,b,c = map(int,line.split())\n        oplist[o](a,b,c)\n\n    print('Register state:',R)\n", "id": "ebw7cc7", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "C++ -- 75/62. I followed my typical style of embedding my input into the program and formatting it with multiple cursors into a datastructure; unfortunately it took a good 30 seconds or so to compile all the static data, which probably lost me a few spots :D\n\nCleaned it up here to actually read the file.\n\n\t#include \"assert.h\"\n\n\t#include <map>\n\t#include <set>\n\t#include <list>\n\t#include <stack>\n\t#include <array>\n\t#include <deque>\n\t#include <string>\n\t#include <vector>\n\t#include <fstream>\n\t#include <functional>\n\t#include <unordered_set>\n\n\t#include \"utils.h\"\n\t#include \"tinyformat.h\"\n\n\n\tusing registers_t = std::array<int, 4>;\n\n\n\n\tregisters_t compute(const registers_t& before, int real_opcode, int a, int b, int c)\n\t{\n\t\tregisters_t out = before;\n\t\t/* addr */      if(real_opcode == 0)        out[c] = out[a] + out[b];\n\t\t/* addi */      else if(real_opcode == 1)   out[c] = out[a] + b;\n\t\t/* mulr */      else if(real_opcode == 2)   out[c] = out[a] * out[b];\n\t\t/* muli */      else if(real_opcode == 3)   out[c] = out[a] * b;\n\t\t/* andr */      else if(real_opcode == 4)   out[c] = out[a] & out[b];\n\t\t/* andi */      else if(real_opcode == 5)   out[c] = out[a] & b;\n\t\t/* orr */       else if(real_opcode == 6)   out[c] = out[a] | out[b];\n\t\t/* ori */       else if(real_opcode == 7)   out[c] = out[a] | b;\n\t\t/* setr */      else if(real_opcode == 8)   out[c] = out[a];\n\t\t/* seti */      else if(real_opcode == 9)   out[c] = a;\n\t\t/* ge (i/r) */  else if(real_opcode == 10)  (a > out[b]) ? out[c] = 1 : out[c] = 0;\n\t\t/* ge (r/i) */  else if(real_opcode == 11)  (out[a] > b) ? out[c] = 1 : out[c] = 0;\n\t\t/* ge (r/r) */  else if(real_opcode == 12)  (out[a] > out[b]) ? out[c] = 1 : out[c] = 0;\n\t\t/* eq (i/r) */  else if(real_opcode == 13)  (a == out[b]) ? out[c] = 1 : out[c] = 0;\n\t\t/* eq (r/i) */  else if(real_opcode == 14)  (out[a] == b) ? out[c] = 1 : out[c] = 0;\n\t\t/* eq (r/r) */  else if(real_opcode == 15)  (out[a] == out[b]) ? out[c] = 1 : out[c] = 0;\n\t\telse                                        assert(false);\n\n\t\treturn out;\n\t}\n\n\tstruct observation\n\t{\n\t\tobservation(const registers_t& b4, int op, int a, int b, int c, const registers_t& aft)\n\t\t\t: before(b4), opcode(op), a(a), b(b), c(c), after(aft) { }\n\n\t\tregisters_t before;\n\n\t\tint opcode;\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\n\t\tregisters_t after;\n\t};\n\n\tstruct instruction\n\t{\n\t\tinstruction(int o, int a, int b, int c) : opcode(o), a(a), b(b), c(c) { }\n\n\t\tint opcode;\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\t};\n\n\n\tint main()\n\t{\n\t\tstd::vector<instruction> program;\n\t\tstd::vector<observation> observations;\n\t\t{\n\t\t\tstd::vector<std::string> lines;\n\t\t\t{\n\t\t\t\tauto input = std::ifstream(\"day16/input.txt\", std::ios::in);\n\t\t\t\tfor(std::string line; std::getline(input, line); )\n\t\t\t\t\tlines.push_back(line);\n\t\t\t}\n\n\t\t\tfor(size_t i = 0; i < lines.size(); i++)\n\t\t\t{\n\t\t\t\tauto line = lines[i];\n\t\t\t\tif(line.find(\"Before\") == 0)\n\t\t\t\t{\n\t\t\t\t\tint br0, br1, br2, br3;\n\t\t\t\t\tsscanf(line.c_str(), \"Before: [%d, %d, %d, %d]\", &br0, &br1, &br2, &br3);\n\n\t\t\t\t\tline = lines[++i];\n\n\t\t\t\t\tint op, a, b, c;\n\t\t\t\t\tsscanf(line.c_str(), \"%d %d %d %d\", &op, &a, &b, &c);\n\n\t\t\t\t\tline = lines[++i];\n\n\t\t\t\t\tint ar0, ar1, ar2, ar3;\n\t\t\t\t\tsscanf(line.c_str(), \"After:  [%d, %d, %d, %d]\", &ar0, &ar1, &ar2, &ar3);\n\n\t\t\t\t\tobservations.push_back(observation({ br0, br1, br2, br3 }, op, a, b, c, { ar0, ar1, ar2, ar3 }));\n\n\t\t\t\t\t// empty line.\n\t\t\t\t\tline = lines[++i];\n\t\t\t\t}\n\t\t\t\telse if(line != \"\\n\")\n\t\t\t\t{\n\t\t\t\t\tint op, a, b, c;\n\t\t\t\t\tsscanf(line.c_str(), \"%d %d %d %d\", &op, &a, &b, &c);\n\n\t\t\t\t\tprogram.push_back(instruction(op, a, b, c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tstd::array<std::set<int>, 16> opcode_matches = { };\n\t\tstd::vector<int> matches;\n\n\t\tfor(const auto& obs : observations)\n\t\t{\n\t\t\tmatches.push_back(0);\n\n\t\t\tfor(int op = 0; op < 16; op++)\n\t\t\t{\n\t\t\t\tauto out = compute(obs.before, op, obs.a, obs.b, obs.c);\n\t\t\t\tif(out == obs.after)\n\t\t\t\t{\n\t\t\t\t\tmatches.back()++;\n\n\t\t\t\t\topcode_matches[op].insert(obs.opcode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto count = std::count_if(matches.begin(), matches.end(), [](int k) -> bool {\n\t\t\treturn k >= 3;\n\t\t});\n\n\t\ttfm::printfln(\"part 1: %d samples match 3 or more ops\", count);\n\n\n\t\t// maps from fake to real!\n\t\tstd::map<int, int> real_opcode_map;\n\n\n\t\twhile(real_opcode_map.size() < 16)\n\t\t{\n\t\t\tfor(int k = 0; k < 16; k++)\n\t\t\t{\n\t\t\t\tconst auto& fake_matches = opcode_matches[k];\n\n\t\t\t\tif(fake_matches.size() == 1)\n\t\t\t\t{\n\t\t\t\t\tint fake = *fake_matches.begin();\n\t\t\t\t\treal_opcode_map[fake] = k;\n\n\t\t\t\t\t// erase it from the rest.\n\t\t\t\t\tfor(int m = 0; m < 16; m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m == k) continue;\n\t\t\t\t\t\topcode_matches[m].erase(fake);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t{\n\t\t\tregisters_t state = { 0, 0, 0, 0 };\n\n\t\t\tfor(auto instr : program)\n\t\t\t{\n\t\t\t\tstate = compute(state, real_opcode_map[instr.opcode], instr.a, instr.b, instr.c);\n\t\t\t\t// tfm::printfln(\"part 2: register 0 has value %d\", state[0]);\n\t\t\t}\n\n\t\t\ttfm::printfln(\"part 2: register 0 has value %d\", state[0]);\n\t\t}\n\t}", "id": "ebw7iao", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "This space intentionally left blank.", "id": "ebw7sg5", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "**92**/290, I cannot believe I finally scored on the leaderboard! Yeah!\n\nI lost so much time because I switched keyboard from ITA layout to US layout around a week ago and I still very often type `a =+ b` instead of `a += b`... which doesn't even give a warning since is perfectly correct syntax, D'OH!\n\nGuess I'll have to post my solution now, I feel obliged. Here it is, the longest Python3 script you've ever seen:\n\n    #!/usr/bin/env python3\n\n    fin = open('inputs/2018_16.txt')\n    # print(*fin)\n\n    ##################################################\n\n    def simulate(r1, o, r2):\n        op, a, b, c = o\n        count = 0\n\n        # addr\n        if r2[c] == r1[a] + r1[b]: count += 1\n        elif 'addr' in ops[op]: ops[op].remove('addr')\n\n        # addi\n        if r2[c] == r1[a] + b: count += 1\n        elif 'addi' in ops[op]: ops[op].remove('addi')\n\n        # mulr\n        if r2[c] == r1[a] * r1[b]: count += 1\n        elif 'mulr' in ops[op]: ops[op].remove('mulr')\n\n        # muli\n        if r2[c] == r1[a] * b: count += 1\n        elif 'muli' in ops[op]: ops[op].remove('muli')\n\n        # banr\n        if r2[c] == r1[a] & r1[b]: count += 1\n        elif 'banr' in ops[op]: ops[op].remove('banr')\n\n        # bani\n        if r2[c] == r1[a] & b: count += 1\n        elif 'bani' in ops[op]: ops[op].remove('bani')\n\n        # borr\n        if r2[c] == r1[a] | r1[b]: count += 1\n        elif 'borr' in ops[op]: ops[op].remove('borr')\n\n        # bori\n        if r2[c] == r1[a] | b: count += 1\n        elif 'bori' in ops[op]: ops[op].remove('bori')\n\n        # setr\n        if r2[c] == r1[a]: count += 1\n        elif 'setr' in ops[op]: ops[op].remove('setr')\n\n        # seti\n        if r2[c] == a: count += 1\n        elif 'seti' in ops[op]: ops[op].remove('seti')\n\n        # gtir\n        t = 1 if a > r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'gtir' in ops[op]: ops[op].remove('gtir')\n\n        # gtri\n        t = 1 if r1[a] > b else 0\n        if r2[c] == t: count += 1\n        elif 'gtri' in ops[op]: ops[op].remove('gtri')\n\n        # gtrr\n        t = 1 if r1[a] > r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'gtrr' in ops[op]: ops[op].remove('gtrr')\n\n        # eqir\n        t = 1 if a == r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'eqir' in ops[op]: ops[op].remove('eqir')\n\n        # eqri\n        t = 1 if r1[a] == b else 0\n        if r2[c] == t: count += 1\n        elif 'eqri' in ops[op]: ops[op].remove('eqri')\n\n        # eqrr\n        t = 1 if r1[a] == r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'eqrr' in ops[op]: ops[op].remove('eqrr')\n\n        return count\n\n    def execute(opmap, machine_code, r1):\n        n, a, b, c = machine_code\n        mnemonic = opmap[n]\n\n        r2 = r1[:]\n\n        if   mnemonic == 'addr':\n            r2[c] = r1[a] + r1[b]\n        elif mnemonic == 'addi':\n            r2[c] = r1[a] + b\n        elif mnemonic == 'mulr':\n            r2[c] = r1[a] * r1[b]\n        elif mnemonic == 'muli':\n            r2[c] = r1[a] * b\n        elif mnemonic == 'banr':\n            r2[c] = r1[a] & r1[b]\n        elif mnemonic == 'bani':\n            r2[c] = r1[a] & b\n        elif mnemonic == 'borr':\n            r2[c] = r1[a] | r1[b]\n        elif mnemonic == 'bori':\n            r2[c] = r1[a] | b\n        elif mnemonic == 'setr':\n            r2[c] = r1[a]\n        elif mnemonic == 'seti':\n            r2[c] = a\n        elif mnemonic == 'gtir':\n            r2[c] = 1 if a > r1[b] else 0\n        elif mnemonic == 'gtri':\n            r2[c] = 1 if r1[a] > b else 0\n        elif mnemonic == 'gtrr':\n            r2[c] = 1 if r1[a] > r1[b] else 0\n        elif mnemonic == 'eqir':\n            r2[c] = 1 if a == r1[b] else 0\n        elif mnemonic == 'eqri':\n            r2[c] = 1 if r1[a] == b else 0\n        elif mnemonic == 'eqrr':\n            r2[c] = 1 if r1[a] == r1[b] else 0\n\n        return r2\n\n    def simplify(ops):\n        definitive = {}\n\n        while len(definitive) != 16:\n            added = []\n            for num, candidates in ops.items():\n                if len(candidates) == 1:\n                    assert num not in definitive\n\n                    definitive[num] = candidates.pop()\n                    added.append(num)\n\n            for k in added:\n                ops.pop(k)\n                op = definitive[k]\n\n                for kk in ops:\n                    if op in ops[kk]:\n                        ops[kk].remove(op)\n\n                        if len(ops[kk]) == 0:\n                            ops.pop(kk)\n\n        return definitive\n\n    names = ['addr','addi','mulr','muli','banr','bani','borr','bori','setr','seti','gtir','gtri','gtrr','eqir','eqri','eqrr']\n\n    ops = {}\n\n    for op in range(16):\n        ops[op] = set(names[:])\n\n    data = fin.read().split('\\n\\n\\n\\n')\n    sims = data[0].split('\\n\\n')\n\n    ans = 0\n\n    for s in sims:\n        before, op, after = s.split('\\n')\n\n        before = eval(before[before.find(':')+1:])\n        op     = list(map(int, op.split()))\n        after  = eval(after[after.find(':')+1:])\n\n        if simulate(before, op, after) >= 3:\n            ans += 1\n\n    print('Part 1:', ans)\n\n    ok = simplify(ops)\n\n    # for k, o in ok.items():\n    #     print(k, o)\n\n    program = list(map(lambda l: list(map(int, l.split())), data[1].strip().split('\\n')))\n\n    regs = [0] * 4\n\n    for instr in program:\n        regs = execute(ok, instr, regs)\n\n    ans2 = regs[0]\n\n    print('Part 2':, ans2)\n\n", "id": "ebw8fqe", "owner_tier": 0.7, "score": 0.03703703666666667}, {"content": "Python 3: Fun problem! Unlike yesterday's problem which gave me a headache (literally). \n\nPython's `eval` (This is dangerous kids; don't use it unless you are completely sure about the input) and `itertools.product` really helped in shortening the solution length and not having to code all the 16 opcode behaviour individually. 'yaml.load` helped in reading the 'Before' and 'After' register states easily.\n\n  \n    from copy import deepcopy  \n    from collections import defaultdict  \n    from itertools import product  \n    import yaml  \n      \n    test_cases = []  \n      \n    with open('Day16part1.txt') as i_stream:  \n        test_case = {}  \n        for line_count, line in enumerate(i_stream.readlines()):  \n            if line_count % 2 == 0:  \n                test_case.update(yaml.load(line))  \n            if line_count % 4 == 1:  \n                test_case['opcode'], test_case['A'], test_case['B'], test_case['C'] = map(int, line.split())  \n            if line_count % 4 == 3:  \n                test_cases.append(test_case)  \n                test_case = {}  \n      \n    overall_stats = []  \n      \n    def operation(A, B, C, registers, operation, variant):  \n        registers = deepcopy(registers)  \n        if operation in \"+*|&\":  \n            format_string = {'r': \"registers[A] {operation} registers[B]\", 'i': \"registers[A] {operation} B\"}  \n        elif operation == '=':  \n            format_string = {'r': \"registers[A]\", 'i': \"A\"}  \n        elif operation in ['>', '==']:  \n            format_string = {'rr': \"int(registers[A] {operation} registers[B])\",  \n                             'ri': \"int(registers[A] {operation} B)\",  \n                             'ir': \"int(A {operation} registers[B])\"}  \n      \n        result = eval(format_string[variant].format(operation=operation))  \n      \n        registers[C] = result  \n      \n        return registers  \n      \n    def test_all_opcodes(test):  \n        count = 0  \n        registers = test['Before']  \n        opcode = test['opcode']  \n        A, B, C = test['A'], test['B'], test['C']  \n        for oper, variant in product(\"+*|&=\", \"ri\"):  \n            result = operation(A, B, C, registers, oper, variant)  \n            if result == test['After']:  \n                count += 1  \n                overall_stats.append((opcode, oper, variant))  \n      \n        for oper, variant in product([\">\", \"==\"], [\"ri\", \"rr\", \"ir\"]):  \n            result = operation(A, B, C, registers, oper, variant)  \n            if result == test['After']:  \n                count += 1  \n                overall_stats.append((opcode, oper, variant))  \n      \n        return count  \n      \n    answer = 0  \n    for test in test_cases:  \n        result = test_all_opcodes(test)  \n        answer += int(result >= 3)  \n      \n    print('part 1:', answer)  \n      \n    opcode_to_operation_map = defaultdict(set)  \n    for opcode,oper,variant in overall_stats:  \n        opcode_to_operation_map[opcode].add((oper, variant))  \n      \n    final_map = {}  \n    finalized = set()  \n    while len(final_map) != 16:  \n        for opcode, oper in opcode_to_operation_map.items():  \n            if len(oper) == 1:  \n                final_map[opcode] = list(oper)[0]  \n                finalized.update(oper)  \n            else:  \n                for item in finalized.intersection(oper):  \n                    oper.discard(item)  \n      \n    registers = [0]*4  \n      \n    with open('Day16part2.txt') as i_stream:  \n        for line in i_stream.readlines():  \n            opcode, A, B, C = map(int, line.split())  \n            oper, variant = final_map[opcode]  \n            registers = operation(A, B, C, registers, oper, variant)  \n      \n    print('part 2:', registers[0])  \n    \n\n\nYour formatting is... off...\n\nThe idea is all fine and dandy, but I think you lost more than you gained (time writing, nerves, loc, etc.)\n\nWriting is much faster with repetitive patterns when using a powerful text editor.  \nIt actually is shorter contrary to what you claim.  \nNot to mention readability.\n\nAs for reading the input, you could've done it much simpler;  \n1. turn every line into sequence of only digits (using regex or own function)  \n2. test\\_cases, program = split input on '\\\\n\\\\n\\\\n\\\\n'  \n3. read 3 (4) by 3 (4) lines from test\\_cases\n\nThis approach makes it super readable in my opinion.\n\ncheers!\n\n[here](https://github.com/MasterMedo/aoc/blob/master/2018/day/16.py) is my solution if you're interested.\n\nThanks for pointing it out! Edited it now. \n\nAh Yes, I see your point. Your solution is neat! It's simpler to understand. I guess I over-engineered my solution. ", "id": "ebwacxb", "owner_tier": 0.3, "score": 0.18518518481481483}, {"content": "[Card] SMT Solver\n\nC++ 345/603 (I made a typo in my function/register name map, took me way too long to find)\n\nIn step 1 I outputted the possible assignments as an SMTLIB2 program, which I pushed through Z3 to obtain the assignment of registers. This needed to be copied over manually, but hey, at least I don't have to write a solver manually.\n\n[Paste as I'm unable to get Reddit code formatting to work](https://pastebin.com/mM6i6Lwe)", "id": "ebwaf85", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "**Q**:\n\n    //WTF these are still not built in in 2018?!\n    .q.bitand:{0b sv (0b vs x)and 0b vs y};\n    .q.bitor:{0b sv (0b vs x)or 0b vs y};\n\n    d16ins:()!();\n    d16ins[`addr]:{[op;reg]reg[op 3]:reg[op 1]+reg[op 2];reg};\n    d16ins[`addi]:{[op;reg]reg[op 3]:reg[op 1]+op 2;reg};\n    d16ins[`mulr]:{[op;reg]reg[op 3]:reg[op 1]*reg[op 2];reg};\n    d16ins[`muli]:{[op;reg]reg[op 3]:reg[op 1]*op 2;reg};\n    d16ins[`banr]:{[op;reg]reg[op 3]:reg[op 1] bitand reg[op 2];reg};\n    d16ins[`bani]:{[op;reg]reg[op 3]:reg[op 1] bitand op 2;reg};\n    d16ins[`borr]:{[op;reg]reg[op 3]:reg[op 1] bitor reg[op 2];reg};\n    d16ins[`bori]:{[op;reg]reg[op 3]:reg[op 1] bitor op 2;reg};\n    d16ins[`setr]:{[op;reg]reg[op 3]:reg[op 1];reg};\n    d16ins[`seti]:{[op;reg]reg[op 3]:op 1;reg};\n    d16ins[`gtir]:{[op;reg]reg[op 3]:`long$op[1]>reg[op 2];reg};\n    d16ins[`gtri]:{[op;reg]reg[op 3]:`long$reg[op 1]>op 2;reg};\n    d16ins[`gtrr]:{[op;reg]reg[op 3]:`long$reg[op 1]>reg[op 2];reg};\n    d16ins[`eqir]:{[op;reg]reg[op 3]:`long$op[1]=reg[op 2];reg};\n    d16ins[`eqri]:{[op;reg]reg[op 3]:`long$reg[op 1]=op 2;reg};\n    d16ins[`eqrr]:{[op;reg]reg[op 3]:`long$reg[op 1]=reg[op 2];reg};\n\n    d16match:{[ins;c;bf;af]\n        paf:.[;(c;bf)]each ins#d16ins;\n        where paf~\\:af};\n\n    d16filt:{[poss;cba]\n        ins:cba[0][0];\n        match:d16match[poss ins;cba 0;cba 1;cba 2];\n        poss[ins]:poss[ins]inter match;\n        if[1=count poss[ins]; poss[til[16]except ins]:poss[til[16]except ins] except\\:poss[ins][0]];\n        poss};\n\n    d16p1:{\n        split:first where 0=3 msum count each x;\n        eff:4 cut -1_split#x;\n        code:value each eff[;1];\n        before:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;0];\n        after:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;2];\n        matches:d16match[key d16ins]'[code;before;after];\n        sum 3<=count each matches\n        };\n\n    d16p2:{\n        split:first where 0=3 msum count each x;\n        eff:4 cut -1_split#x;\n        test:value each (1+split) _x;\n        code:value each eff[;1];\n        before:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;0];\n        after:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;2];\n        poss:til[16]!16#enlist key d16ins;\n        poss2:d16filt/[poss;(;;)'[code;before;after]];\n        insmap:first each poss2;\n        first {[insmap;r;c]d16ins[insmap c 0][c;r]}[insmap]/[0 0 0 0;test]};\n", "id": "ebwarm9", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "**Common Lisp**\n\n**Part 1** is complete and can be found [here](https://github.com/rabuf/advent-of-code/blob/master/2018.16.org).\n\nI've created one function and corresponding predicate per opcode, and then iterated over all the inputs counting how many predicates match that particular input.\n\n~~I know how I'll do part 2, but I haven't finished it yet (it'll show up in that same link once it's done). Looking at the data I've already determined several of the opcodes, now I'm just writing a program to do it for me.~~\n\n**Part 2** is complete.\n\n    (unless (find-package :cl-ppcre)\n      (ql:quickload \"cl-ppcre\"))\n    (unless (find-package :iterate)\n      (ql:quickload \"iterate\"))\n    (defpackage :aoc-2018-16\n      (:use :common-lisp\n            :iterate)\n      (:export :problem-a\n               :problem-b))\n    (in-package :aoc-2018-16)\n    \n    (defun addr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (+ (aref registers a)\n                 (aref registers b)))\n        registers))\n    (defun addrp (pre command post)\n      (equalp (addr (copy-seq pre) command) post))\n    \n    (defun addi (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (+ (aref registers a)\n                 b))\n        registers))\n    (defun addip (pre command post)\n      (equalp (addi (copy-seq pre) command) post))\n    (defun mulr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (* (aref registers a)\n                 (aref registers b)))\n        registers))\n    (defun mulrp (pre command post)\n      (equalp (mulr (copy-seq pre) command) post))\n    \n    (defun muli (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (* (aref registers a)\n                 b))\n        registers))\n    (defun mulip (pre command post)\n      (equalp (muli (copy-seq pre) command) post))\n    (defun banr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logand (aref registers a)\n                      (aref registers b)))\n        registers))\n    (defun banrp (pre command post)\n      (equalp (banr (copy-seq pre) command) post))\n    \n    (defun bani (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logand (aref registers a)\n                      b))\n        registers))\n    (defun banip (pre command post)\n      (equalp (bani (copy-seq pre) command) post))\n    (defun borr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logior (aref registers a)\n                      (aref registers b)))\n        registers))\n    (defun borrp (pre command post)\n      (equalp (borr (copy-seq pre) command) post))\n    \n    (defun bori (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logior (aref registers a)\n                      b))\n        registers))\n    (defun borip (pre command post)\n      (equalp (bori (copy-seq pre) command) post))\n    (defun setr (registers command)\n      (let ((a (aref command 1))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (aref registers a))\n        registers))\n    (defun setrp (pre command post)\n      (equalp (setr (copy-seq pre) command) post))\n    \n    (defun seti (registers command)\n      (let ((a (aref command 1))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              a)\n        registers))\n    (defun setip (pre command post)\n      (equalp (seti (copy-seq pre) command) post))\n    (defun gtir (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (> a (aref registers b)) 1 0))\n        registers))\n    (defun gtirp (pre command post)\n      (equalp (gtir (copy-seq pre) command) post))\n    \n    (defun gtri (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (> (aref registers a) b) 1 0))\n        registers))\n    (defun gtrip (pre command post)\n      (equalp (gtri (copy-seq pre) command) post))\n    \n    (defun gtrr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (> (aref registers a) (aref registers b)) 1 0))\n        registers))\n    (defun gtrrp (pre command post)\n      (equalp (gtrr (copy-seq pre) command) post))\n    (defun eqir (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (= a (aref registers b)) 1 0))\n        registers))\n    (defun eqirp (pre command post)\n      (equalp (eqir (copy-seq pre) command) post))\n    \n    (defun eqri (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (= (aref registers a) b) 1 0))\n        registers))\n    (defun eqrip (pre command post)\n      (equalp (eqri (copy-seq pre) command) post))\n    \n    (defun eqrr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (= (aref registers a) (aref registers b)) 1 0))\n        registers))\n    (defun eqrrp (pre command post)\n      (equalp (eqrr (copy-seq pre) command) post))\n    (defun read-input (file)\n      (iter (for line in-file file using #'read-line)\n            (collect line)))\n    (defun parse-input (lines)\n      (let ((triples nil)\n            (instructions nil))\n        (iter (until (and (string= \"\" (car lines))\n                          (string= \"\" (cadr lines))))\n              (push (list (make-array 4 :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines))))\n                          (make-array 4 :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines))))\n                          (make-array 4 :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines)))))\n                    triples)\n              (pop lines))\n        (pop lines)\n        (pop lines)\n        (iter (while lines)\n              (push (make-array 4\n                                :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines))))\n                    instructions))\n        (list triples (reverse instructions))))\n    (defparameter *input*\n      (parse-input (read-input \"input/16.txt\")))\n    (defun solve-a (to-test)\n      (let ((predicates (list #'addrp #'addip #'mulrp #'mulip\n                              #'banrp #'banip #'borrp #'borip\n                              #'setrp #'setip #'gtirp #'gtrip\n                              #'gtrrp #'eqirp #'eqrip #'eqrrp)))\n        (iter (for (pre command post) in to-test)\n              (count (iter (for p in predicates)\n                           (with i = 0)\n                           (when (funcall p pre command post)\n                             (incf i))\n                           (finally (return (>= i 3))))))))\n    (defun problem-a () (format t \"Problem 16 A: ~a~%\" (solve-a (car *input*))))\n    (defun tally-codes (to-test)\n      (let ((predicates (list #'addr #'addi #'mulr #'muli\n                              #'banr #'bani #'borr #'bori\n                              #'setr #'seti #'gtir #'gtri\n                              #'gtrr #'eqir #'eqri #'eqrr))\n            (mapping (make-hash-table)))\n        (iter (for p in predicates)\n              (let ((opcodes (iter (for (pre command post) in to-test)\n                                   (when (equalp (funcall p (copy-seq pre) command) post)\n                                     (collect (aref command 0))))))\n                (setf (gethash p mapping) (remove-duplicates opcodes))))\n        mapping))\n    (defun get-opcodes (to-test)\n      (let ((tally (tally-codes to-test))\n            (result (make-hash-table)))\n        (iter (until (iter (for (k v) in-hashtable tally)\n                           (always (= 1 (length v)))))\n              (iter (for (k v) in-hashtable tally)\n                    (when (= 1 (length v))\n                      (iter (for (k0 v0) in-hashtable tally)\n                            (unless (equal k k0)\n                              (setf (gethash k0 tally) (remove (car v) v0)))))))\n        (iter (for (k v) in-hashtable tally)\n              (setf (gethash (car v) result) k))\n        result))\n    (defun solve-b (to-test to-run)\n      (let ((codes (get-opcodes to-test))\n            (registers (make-array 4 :initial-element 0)))\n        (iter (for command in to-run)\n              (funcall (gethash (aref command 0) codes)\n                       registers\n                       command))\n        registers))\n    (defun problem-b () (format t \"Problem 16 B: ~a~%\" (solve-b (car *input*) (cadr *input*))))\n    (problem-a)\n    (problem-b)\n", "id": "ebwazi5", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "**C++**\n\nRather than using something like std::set. I used 16-bit integer bitmasks and reduced them all using fast bit-wise arithmetic.\n\n    #include <cstddef>\n    #include <cstdint>\n    #include <cstdio>\n    #include <algorithm>\n    #include <array>\n    \n    struct Device\n    {\n    \tusing RegisterState = std::array<std::uintmax_t,4>;\n    \tusing Instruction = RegisterState;\n    \tRegisterState Register;\n    \ttemplate< typename FunctorT , bool RegisterA = true, bool RegisterB = true>\n    \tstatic void OpRegister( RegisterState& Registers, std::size_t A, std::size_t B, std::size_t C )\n    \t{\n    \t\tFunctorT Function;\n    \t\tRegisters[C] = Function(\n    \t\t\tRegisterA ? Registers[A]:A,\n    \t\t\tRegisterB ? Registers[B]:B\n    \t\t);\n    \t}\n    \ttypedef void(*Operation)( RegisterState&,std::size_t,std::size_t,std::size_t);\n    \tconstexpr static std::array<Operation,16> Opcodes = {{\n    \t\t// addr\n    \t\tOpRegister<std::plus<std::size_t>, true, true>,\n    \t\t// addi\n    \t\tOpRegister<std::plus<std::size_t>, true, false>,\n    \t\t// mulr\n    \t\tOpRegister<std::multiplies<std::size_t>,true,true>,\n    \t\t// muli\n    \t\tOpRegister<std::multiplies<std::size_t>,true,false>,\n    \t\t// bandr\n    \t\tOpRegister<std::bit_and<std::size_t>,true,true>,\n    \t\t// bandi\n    \t\tOpRegister<std::bit_and<std::size_t>,true,false>,\n    \t\t// borr\n    \t\tOpRegister<std::bit_or<std::size_t>,true,true>,\n    \t\t// bori\n    \t\tOpRegister<std::bit_or<std::size_t>,true,false>,\n    \t\t// setr\n    \t\t[]( RegisterState& Registers, std::size_t A, std::size_t, std::size_t C ) constexpr -> void\n    \t\t{\n    \t\t\tRegisters[C] = Registers[A];\n    \t\t},\n    \t\t// seti\n    \t\t[]( RegisterState& Registers, std::size_t A, std::size_t, std::size_t C ) constexpr -> void\n    \t\t{\n    \t\t\tRegisters[C] = A;\n    \t\t},\n    \t\t// gtir\n    \t\tOpRegister<std::greater<std::size_t>,false,true>,\n    \t\t// gtri\n    \t\tOpRegister<std::greater<std::size_t>,true,false>,\n    \t\t// gtrr\n    \t\tOpRegister<std::greater<std::size_t>,true,true>,\n    \t\t// eqii\n    \t\tOpRegister<std::equal_to<std::size_t>,false,true>,\n    \t\t// eqri\n    \t\tOpRegister<std::equal_to<std::size_t>,true,false>,\n    \t\t// eqrr\n    \t\tOpRegister<std::equal_to<std::size_t>,true,true>\n    \t}};\n    };\n    \n    int main()\n    {\n    \tstd::array<std::uint16_t,16> OpcodeMapping = {0};\n    \tstd::size_t Tautology3 = 0;\n    \tDevice::RegisterState Before, After;\n    \tDevice::Instruction CurInstruction;\n    \twhile(\n    \t\tstd::fscanf(\n    \t\t\tstdin,\n    \t\t\t\"Before: [%zu , %zu, %zu, %zu]\"\n    \t\t\t\"%zu %zu %zu %zu \"\n    \t\t\t\"After: [%zu , %zu, %zu, %zu] \",\n    \t\t\t&Before[0], &Before[1], &Before[2], &Before[3],\n    \t\t\t&CurInstruction[0],&CurInstruction[1],&CurInstruction[2],&CurInstruction[3],\n    \t\t\t&After[0],  &After[1],  &After[2],  &After[3]\n    \t\t) == 12\n    \t)\n    \t{\n    \t\tstd::size_t Tautologous = 0;\n    \t\tfor(std::size_t i = 0; i < Device::Opcodes.size(); ++i )\n    \t\t{\n    \t\t\tDevice::RegisterState State(Before);\n    \t\t\tDevice::Opcodes[i](\n    \t\t\t\tState,CurInstruction[1],CurInstruction[2],CurInstruction[3]\n    \t\t\t);\n    \n    \t\t\tif(std::equal(State.begin(),State.end(),After.begin()) )\n    \t\t\t{\n    \t\t\t\tOpcodeMapping[CurInstruction[0]] |= 1 << i;\n    \t\t\t\tTautologous++;\n    \t\t\t}\n    \t\t}\n    \t\tTautology3 += Tautologous >= 3;\n    \t}\n    \tstd::printf(\"Part 1: %8zu\\n\",Tautology3);\n    \n    \t// Keep iterating until all mappings are reduced to equivalences\n    \twhile(\n    \t\tstd::any_of(\n    \t\t\tOpcodeMapping.begin(),OpcodeMapping.end(),\n    \t\t\t[](const std::uint16_t& Set) -> bool\n    \t\t\t{\n    \t\t\t\treturn __builtin_popcount(Set) != 1;\n    \t\t\t}\n    \t\t)\n    \t)\n    \t{\n    \t\tfor(std::size_t i = 0; i < OpcodeMapping.size(); ++i )\n    \t\t{\n    \t\t\t// Only 1 bit set in this set, solved\n    \t\t\tif( __builtin_popcount(OpcodeMapping[i]) == 1 )\n    \t\t\t{\n    \t\t\t\t// Remove it from all the other sets\n    \t\t\t\tfor(std::size_t j = 0; j < OpcodeMapping.size(); ++j )\n    \t\t\t\t{\n    \t\t\t\t\t// Skip itself\n    \t\t\t\t\tif( i == j )\n    \t\t\t\t\t{\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\tOpcodeMapping[j] &= ~(OpcodeMapping[i]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \t// Log2 bit masks into integers\n    \tfor(std::size_t i = 0; i < OpcodeMapping.size(); ++i )\n    \t{\n    \t\tOpcodeMapping[i] = 32 - __builtin_clz(OpcodeMapping[i]) - 1;\n    \t}\n    \n    \tDevice::RegisterState Registers = {0};\n    \twhile(\n    \t\tstd::fscanf(\n    \t\t\tstdin,\n    \t\t\t\"%zu %zu %zu %zu \",\n    \t\t\t&CurInstruction[0], &CurInstruction[1], &CurInstruction[2], &CurInstruction[3]\n    \t\t) == 4\n    \t)\n    \t{\n    \t\tDevice::Opcodes[\n    \t\t\tOpcodeMapping[CurInstruction[0]]\n    \t\t](Registers,CurInstruction[1],CurInstruction[2],CurInstruction[3]);\n    \t}\n    \tstd::printf(\"Part 2: %8zu\\n\",Registers[0]);\n    \treturn EXIT_SUCCESS;\n    }", "id": "ebwg1r6", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "**Rust**\n\nI <3 these puzzles, there's just something so satisfying with fiddling with pretend assembly for fake machines.\n\n\\[CARD\\] The secret technique to beat today's puzzles is sacrifice to the Great Old Ones.\n\n    use aoc2018::*;\n    \n    #[derive(Debug, Default, Clone, PartialEq, Eq)]\n    pub struct Device([u64; 4]);\n    \n    impl Device {\n        /// Try to decode a device.\n        /// Devices take the form `[a, b, c, d]` representing all registries.\n        pub fn decode(state: &str) -> Option<Device> {\n            let mut it = state\n                .trim_matches(|c| c == '[' || c == ']')\n                .split(\", \")\n                .flat_map(|d| str::parse(d).ok());\n    \n            Some(Device([it.next()?, it.next()?, it.next()?, it.next()?]))\n        }\n    \n        pub fn reg(&mut self, reg: u64) -> Result<&mut u64, Error> {\n            match self.0.get_mut(reg as usize) {\n                Some(reg) => Ok(reg),\n                None => bail!(\"no such register: {}\", reg),\n            }\n        }\n    }\n    \n    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n    pub enum OpCode {\n        Addr,\n        Addi,\n        Mulr,\n        Muli,\n        Banr,\n        Bani,\n        Borr,\n        Bori,\n        Setr,\n        Seti,\n        Gtir,\n        Gtri,\n        Gtrr,\n        Eqir,\n        Eqri,\n        Eqrr,\n    }\n    \n    impl OpCode {\n        /// Iterate over all variants.\n        fn variants() -> impl Iterator<Item = OpCode> {\n            use self::OpCode::*;\n    \n            vec![\n                Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori, Setr, Seti, Gtir, Gtri, Gtrr, Eqir,\n                Eqri, Eqrr,\n            ]\n            .into_iter()\n        }\n    \n        fn apply(&self, d: &mut Device, inputs: &[u64; 2], o: u64) -> Result<(), Error> {\n            use self::OpCode::*;\n    \n            let [a, b] = *inputs;\n    \n            *d.reg(o)? = match *self {\n                Addr => *d.reg(a)? + *d.reg(b)?,\n                Addi => *d.reg(a)? + b,\n                Mulr => *d.reg(a)? * *d.reg(b)?,\n                Muli => *d.reg(a)? * b,\n                Banr => *d.reg(a)? & *d.reg(b)?,\n                Bani => *d.reg(a)? & b,\n                Borr => *d.reg(a)? | *d.reg(b)?,\n                Bori => *d.reg(a)? | b,\n                Setr => *d.reg(a)?,\n                Seti => a,\n                Gtir => {\n                    if a > *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Gtri => {\n                    if *d.reg(a)? > b {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Gtrr => {\n                    if *d.reg(a)? > *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Eqir => {\n                    if a == *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Eqri => {\n                    if *d.reg(a)? == b {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Eqrr => {\n                    if *d.reg(a)? == *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n            };\n    \n            Ok(())\n        }\n    }\n    \n    /// An instruction.\n    #[derive(Debug)]\n    pub struct Instruction {\n        op_code: u64,\n        inputs: [u64; 2],\n        output: u64,\n    }\n    \n    impl Instruction {\n        pub fn decode(state: &str) -> Option<Instruction> {\n            let mut it = state.split(\" \").flat_map(|d| str::parse(d).ok());\n    \n            Some(Instruction {\n                op_code: it.next()?,\n                inputs: [it.next()?, it.next()?],\n                output: it.next()?,\n            })\n        }\n    }\n    \n    #[derive(Debug, Default)]\n    struct Registry(HashMap<u64, HashSet<OpCode>>);\n    \n    impl Registry {\n        /// Try to reduce the number of definitive matches.\n        pub fn regress(&mut self) -> Vec<(u64, OpCode)> {\n            let mut known = Vec::new();\n            let mut current = 0;\n    \n            self.known(&mut known);\n    \n            while current != known.len() {\n                current = known.len();\n    \n                for (known_num, known_op) in known.iter().cloned() {\n                    for (num, values) in self.0.iter_mut() {\n                        if *num == known_num {\n                            values.clear();\n                            values.insert(known_op);\n                            continue;\n                        }\n    \n                        values.remove(&known_op);\n                    }\n                }\n    \n                known.clear();\n                self.known(&mut known);\n            }\n    \n            known\n        }\n    \n        /// Extract exactly known op-codes.\n        fn known(&self, known: &mut Vec<(u64, OpCode)>) {\n            for (key, value) in &self.0 {\n                if value.len() == 1 {\n                    if let Some(op) = value.iter().cloned().next() {\n                        known.push((*key, op));\n                    }\n                }\n            }\n        }\n    }\n    \n    struct Decoder {\n        codes: HashMap<u64, OpCode>,\n    }\n    \n    impl Decoder {\n        pub fn new(codes: impl IntoIterator<Item = (u64, OpCode)>) -> Decoder {\n            Decoder {\n                codes: codes.into_iter().collect(),\n            }\n        }\n    \n        pub fn decode(&self, code: u64) -> Result<OpCode, Error> {\n            match self.codes.get(&code).cloned() {\n                Some(op) => Ok(op),\n                None => bail!(\"no such op: {}\", code),\n            }\n        }\n    }\n    \n    fn main() -> Result<(), Error> {\n        let mut it = input_str!(\"day16.txt\").lines();\n    \n        let mut part1 = 0;\n    \n        let mut registry = Registry::default();\n    \n        // NB: all op codes are initially possible for all op numbers.\n        for c in 0..16u64 {\n            for op in OpCode::variants() {\n                registry.0.entry(c).or_default().insert(op);\n            }\n        }\n    \n        while let Some(test) = Test::decode(&mut it) {\n            let mut matches = HashSet::new();\n    \n            for op in OpCode::variants() {\n                let mut device = test.before.clone();\n                op.apply(&mut device, &test.inst.inputs, test.inst.output)?;\n    \n                if device == test.after {\n                    matches.insert(op);\n                } else {\n                    if let Some(codes) = registry.0.get_mut(&test.inst.op_code) {\n                        codes.remove(&op);\n                    }\n                }\n            }\n    \n            // definitive proof that a specific op-code is the one.\n            if matches.len() == 1 {\n                if let Some(op) = matches.iter().cloned().next() {\n                    if let Some(values) = registry.0.get_mut(&test.inst.op_code) {\n                        values.clear();\n                        values.insert(op);\n                    }\n                }\n            }\n    \n            if matches.len() >= 3 {\n                part1 += 1;\n            }\n        }\n    \n        let known = registry.regress();\n    \n        assert_eq!(known.len(), 16);\n        assert_eq!(part1, 596);\n    \n        let decoder = Decoder::new(known);\n    \n        assert_eq!(it.next(), Some(\"\"));\n    \n        let mut device = Device::default();\n    \n        for inst in it.flat_map(Instruction::decode) {\n            let op = decoder.decode(inst.op_code)?;\n            op.apply(&mut device, &inst.inputs, inst.output)?;\n        }\n    \n        assert_eq!(*device.reg(0)?, 554);\n        Ok(())\n    }\n    \n    #[derive(Debug)]\n    struct Test {\n        before: Device,\n        inst: Instruction,\n        after: Device,\n    }\n    \n    impl Test {\n        fn decode<'a>(it: &mut impl Iterator<Item = &'a str>) -> Option<Test> {\n            let before = it.next()?;\n    \n            if before == \"\" {\n                return None;\n            }\n    \n            let inst = it.next()?;\n            let after = it.next()?;\n            let blank = it.next()?;\n    \n            if !before.starts_with(\"Before: \") {\n                return None;\n            }\n    \n            if !after.starts_with(\"After: \") {\n                return None;\n            }\n    \n            if blank != \"\" {\n                return None;\n            }\n    \n            let before = Device::decode(before.split(\": \").nth(1)?.trim())?;\n            let inst = Instruction::decode(&inst)?;\n            let after = Device::decode(after.split(\": \").nth(1)?.trim())?;\n    \n            Some(Test {\n                before,\n                inst,\n                after,\n            })\n        }\n    }\n\n> [CARD] The secret technique to beat today's puzzles is sacrifice to the Great Old Ones.\n\n[A sacrifice](https://i.imgur.com/q5OdF0bm.jpg), you say?", "id": "ebwgq9u", "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "F#\n\n[Full code link](https://github.com/CameronAavik/AdventOfCode/blob/master/Challenges/2018/Day16.fs)\n\nToday's was fun to do in a functional language and figuring out how to express each of the 16 instructions in a short way. Here is an extract showing how I got that working:\n\n    let inst f v1 v2 c = set c (f v1 v2)\n    let instir f (a, b, c) regs = inst f a (get b regs) c regs\n    let instri f (a, b, c) regs = inst f (get a regs) b c regs\n    let instrr f (a, b, c) regs = inst f (get a regs) (get b regs) c regs\n    \n    let useFirst a _ = a\n    let gt a b = if a > b then 1 else 0\n    let eq a b = if a = b then 1 else 0\n    \n    // instructions\n    let addr = instrr (+)\n    let addi = instri (+)\n    let mulr = instrr (*)\n    let muli = instri (*)\n    let banr = instrr (&&&)\n    let bani = instri (&&&)\n    let borr = instrr (|||)\n    let bori = instri (|||)\n    let setr = instri useFirst\n    let seti = instir useFirst\n    let gtir = instir gt\n    let gtri = instri gt\n    let gtrr = instrr gt\n    let eqir = instir eq\n    let eqri = instri eq\n    let eqrr = instrr eq\n\nBenchmarks: Part 1 = 13.442ms, Part 2 = 7.382ms\n\nIt is interesting to see that part 2 is faster than part 1 here, but it makes sense because in part 1 we compare each sample with all 16 instructions. In part 2 we only need to compare each instruction against the samples grouped by opcode and we can terminate that comparison early if we find a sample that doesn't match.", "id": "ebwknjp", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "**FORTRAN**\n\n[Pastebin](https://pastebin.com/JeZzys9s). Decided to try out procedure pointers and figured out a way to get an array of pointers. Used the info from part 1 for which opcode/instruction combos didn't work with some simple logic to create an array mapping the opcodes to the correct elements of the procedure pointer array.", "id": "ebwugxe", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "**Perl 6** solution.  This one was fun, and a lot more straightforward than yesterday's.  I especially like how brief the instructions for part two are...\n\n    #!/usr/bin/env perl6\n    use v6.c;\n\n    $*OUT.out-buffer = False;   # Autoflush\n\n    # Advent of Code 2018 day 16 -- https://adventofcode.com/2018/day/16\n\n    enum Opcode <addr addi mulr muli banr bani borr bori setr seti gtir gtri gtrr eqir eqri eqrr>;\n\n    grammar WristDeviceInstructions\n    {\n        rule TOP { <sample>+ <test-program> }\n\n        rule sample { 'Before:' '[' <registers> ']'\n                      <input>\n                      'After:' '[' <registers> ']' }\n        rule registers { <n> ** 4 % ',' }\n        rule input { <n> ** 4 }\n\n        rule test-program { <program-line>+ }\n        rule program-line { <n> ** 4 }\n\n        token n { \\d+ }\n    }\n\n    class WristDevice\n    {\n        has @.register = 0 xx 4;\n        has @.samples;\n        has @.program;\n\n        has @.opcode-candidates = Opcode::.values.Set xx 16;\n        has @.opcode-by-id;\n\n        has Bool $.verbose = False;\n\n        # Actions for grammar WristDeviceInstructions\n        method sample($/)\n        {\n            @!samples.push: { :before($<registers>[0]<n>\u00bb.Int),\n                              :input($<input><n>\u00bb.Int),\n                              :after($<registers>[1]<n>\u00bb.Int) };\n        }\n        method program-line($/)\n        {\n            @.program.push: $<n>\u00bb.Int;\n        }\n\n        # Process an instruction\n        method process(Opcode $opcode, ($a, $b, $c))\n        {\n            given $opcode {\n                @!register[$c] = @!register[$a] + @!register[$b] when addr;\n                @!register[$c] = @!register[$a] + $b when addi;\n                @!register[$c] = @!register[$a] \u00d7 @!register[$b] when mulr;\n                @!register[$c] = @!register[$a] \u00d7 $b when muli;\n                @!register[$c] = @!register[$a] +& @!register[$b] when banr;\n                @!register[$c] = @!register[$a] +& $b when bani;\n                @!register[$c] = @!register[$a] +| @!register[$b] when borr;\n                @!register[$c] = @!register[$a] +| $b when bori;\n                @!register[$c] = @!register[$a] when setr;\n                @!register[$c] = $a when seti;\n                @!register[$c] = +($a > @!register[$b]) when gtir;\n                @!register[$c] = +(@!register[$a] > $b) when gtri;\n                @!register[$c] = +(@!register[$a] > @!register[$b]) when gtrr;\n                @!register[$c] = +($a == @!register[$b]) when eqir;\n                @!register[$c] = +(@!register[$a] == $b) when eqri;\n                @!register[$c] = +(@!register[$a] == @!register[$b]) when eqrr;\n            }\n        }\n\n        # Find any opcodes that match a sample instruction\n        method find-possible-opcodes($instr)\n        {\n            my @before = $instr<before>[];\n            my $id = $instr<input>[0];\n            my @input = $instr<input>[1..3];\n            my @after = $instr<after>[];\n            my @cand;\n\n            # For each possible opcode, set the before values of the register, perform the opcode\n            # and verify the after values.  If they match, this is a possible opcode.\n            for Opcode::.values.sort -> $opcode {\n                @!register = @before;\n                self.process($opcode, @input);\n                if @!register eqv @after {\n                    @cand.append($opcode);\n                }\n            }\n\n            # Limit the candidate opcodes for this ID to at most these candidates\n            @!opcode-candidates[$id] \u2229= @cand;\n\n            return @cand;\n        }\n\n        # Match opcode IDs to opcodes, based on the candidates found before.\n        method match-opcode-ids\n        {\n            for ^16 {\n                # Find an ID with only one possible opcode.\n                # If there isn't one, we can't complete the match.\n                my ($id, $op) = @!opcode-candidates.first(*.keys == 1, :kv);\n                die \"Unable to find opcode mapping!\\n\" unless $id.defined;\n\n                # Remember the match, and remove the matched opcode from every ID's candidates\n                my $opcode = $op.keys[0];\n                @!opcode-by-id[$id] = $opcode;\n                for @!opcode-candidates -> $op is rw {\n                    $op \u2216= $opcode;\n                }\n            }\n        }\n\n        # Execute the test program\n        method execute\n        {\n            # Reset the register\n            @!register = 0 xx 4;\n            say '  ', @!register if $!verbose;\n\n            # Process each line\n            for @!program -> @line {\n                say @!opcode-by-id[@line[0]], ' ', @line[1..3] if $!verbose;\n                self.process(@!opcode-by-id[@line[0]], @line[1..3]);\n                say '  ', @!register if $!verbose;\n            }\n        }\n    }\n\n    #| Process wrist device instructions\n    multi sub MAIN(Str $instructions, Bool :v(:$verbose)=False)\n    {\n        my $dev = WristDevice.new(:$verbose);\n        WristDeviceInstructions.parse($instructions, :actions($dev)) or die \"Invalid input\";\n\n        # Part 1\n        my $min3count = 0;\n        for $dev.samples.kv -> $i, $instr {\n            my @opcodes = $dev.find-possible-opcodes($instr);\n            say \"Sample #$i: id #{$instr<input>[0]} has possible opcodes @opcodes[]\" if $verbose;\n            $min3count++ if @opcodes \u2265 3;\n        }\n        say \"There are $min3count samples which behave like at least three opcodes\";\n\n        # Part 2\n        $dev.match-opcode-ids;\n        if $verbose {\n            say \"Opcode mapping:\";\n            for ^16 -> $id {\n                say \" - #$id: $dev.opcode-by-id()[$id]\";\n            }\n        }\n        $dev.execute;\n        say \"The contents of the register after executing the test program are: $dev.register()\";\n    }\n\n    #| Process wrist device instructions from a file (default aoc16.input)\n    multi sub MAIN(Str $inputfile where *.IO.f = ~$*PROGRAM.sibling('aoc16.input'), Bool :v(:$verbose)=False)\n    {\n        MAIN($inputfile.IO.slurp, :$verbose);\n    }\n\n[All my Perl 6 solutions in Github](https://github.com/mscha/aoc/tree/master/aoc2018)", "id": "ebxepgn", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "**Swift**\n\n    extension Sequence {\n    \tvar tuple4: (Element, Element, Element, Element)? {\n    \t\tvar iter = makeIterator()\n    \t\tguard let first  = iter.next(),\n    \t\t      let second = iter.next(),\n    \t\t      let third  = iter.next(),\n    \t\t      let fourth = iter.next()\n    \t\telse { return nil }\n    \t\treturn (first, second, third, fourth)\n    \t}\n    }\n    \n    enum Opcode {\n    \tcase addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr\n    \n    \tstatic let allCases: [Opcode] = [.addr, .addi, .mulr, .muli, .banr, .bani, .borr, .bori, .setr, .seti, .gtir, .gtri, .gtrr, .eqir, .eqri, .eqrr]\n    \n    \tfunc exec(instr: Instruction, input: [Int]) -> [Int] {\n    \t\tvar output = input\n    \t\tswitch self {\n    \t\tcase .addr: output[instr.c] = output[instr.a] + output[instr.b]\n    \t\tcase .addi: output[instr.c] = output[instr.a] + instr.b\n    \t\tcase .mulr: output[instr.c] = output[instr.a] * output[instr.b]\n    \t\tcase .muli: output[instr.c] = output[instr.a] * instr.b\n    \t\tcase .banr: output[instr.c] = output[instr.a] & output[instr.b]\n    \t\tcase .bani: output[instr.c] = output[instr.a] & instr.b\n    \t\tcase .borr: output[instr.c] = output[instr.a] | output[instr.b]\n    \t\tcase .bori: output[instr.c] = output[instr.a] | instr.b\n    \t\tcase .setr: output[instr.c] = output[instr.a]\n    \t\tcase .seti: output[instr.c] = instr.a\n    \t\tcase .gtir: output[instr.c] = instr.a > output[instr.b] ? 1 : 0\n    \t\tcase .gtri: output[instr.c] = output[instr.a] > instr.b ? 1 : 0\n    \t\tcase .gtrr: output[instr.c] = output[instr.a] > output[instr.b] ? 1 : 0\n    \t\tcase .eqir: output[instr.c] = instr.a == output[instr.b] ? 1 : 0\n    \t\tcase .eqri: output[instr.c] = output[instr.a] == instr.b ? 1 : 0\n    \t\tcase .eqrr: output[instr.c] = output[instr.a] == output[instr.b] ? 1 : 0\n    \t\t}\n    \t\treturn output\n    \t}\n    }\n    \n    struct Instruction {\n    \tvar opcode: Int\n    \tvar a: Int\n    \tvar b: Int\n    \tvar c: Int\n    \tinit?<S: Sequence>(_ seq: S) where S.Element == Int {\n    \t\tguard let tuple4 = seq.tuple4 else { return nil }\n    \t\t(opcode, a, b, c) = tuple4\n    \t}\n    }\n    \n    func aocD16a(_ input: [(from: [Int], instr: Instruction, to: [Int])]) {\n    \tprint(input.lazy.map { (from, instr, to) in\n    \t\tOpcode.allCases.lazy.filter { $0.exec(instr: instr, input: from) == to }.count\n    \t}.filter({ $0 >= 3 }).count)\n    }\n    \n    func aocD16b(_ input: [(from: [Int], instr: Instruction, to: [Int])], program: [Instruction]) {\n    \tvar possibleMappings = Array(repeating: Opcode.allCases, count: 16)\n    \tfor (from, instr, to) in input {\n    \t\tpossibleMappings[instr.opcode].removeAll(where: { $0.exec(instr: instr, input: from) != to })\n    \t}\n    \tvar finalMappings = possibleMappings.map { $0.count == 1 ? $0[0] : nil }\n    \tvar new = finalMappings.compactMap { $0 }\n    \twhile let next = new.popLast() {\n    \t\tfor index in possibleMappings.indices {\n    \t\t\tif let i = possibleMappings[index].firstIndex(of: next) {\n    \t\t\t\tpossibleMappings[index].remove(at: i)\n    \t\t\t\tif possibleMappings[index].count == 1 {\n    \t\t\t\t\tfinalMappings[index] = possibleMappings[index][0]\n    \t\t\t\t\tnew.append(possibleMappings[index][0])\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tlet mappings = finalMappings.map { $0! }\n    \tvar arr = [0, 0, 0, 0]\n    \tfor instruction in program {\n    \t\tarr = mappings[instruction.opcode].exec(instr: instruction, input: arr)\n    \t}\n    \tprint(arr)\n    }\n    \n    import Foundation\n    let str = try! String(contentsOf: URL(fileURLWithPath: CommandLine.arguments[1]))\n    \n    \n    let input = str.components(separatedBy: \"\\n\\n\").compactMap { block -> (from: [Int], instr: Instruction, to: [Int])? in\n    \tlet numbers = block.split(whereSeparator: { !\"0123456789\".contains($0) }).lazy.map { Int($0)! }\n    \tguard numbers.count == 12 else { return nil }\n    \tlet from = Array(numbers[0..<4])\n    \tlet instr = Instruction(numbers[4..<8])!\n    \tlet to = Array(numbers[8..<12])\n    \treturn (from, instr, to)\n    }\n    \n    let testProgram = str.components(separatedBy: \"\\n\\n\\n\\n\")[1].split(separator: \"\\n\").map { line in\n    \treturn Instruction(line.split(separator: \" \").lazy.map { Int($0)! })!\n    }\n    \n    aocD16a(input)\n    aocD16b(input, program: testProgram)\n\n\nAnother Swift solution:\n\n    func addr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] + rx[b]\n    }\n    \n    func addi(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] + b\n    }\n    \n    func mulr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] * rx[b]\n    }\n    \n    func muli(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] * b\n    }\n    \n    func banr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] & rx[b]\n    }\n    \n    func bani(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] & b\n    }\n    \n    func borr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] | rx[b]\n    }\n    \n    func bori(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] | b\n    }\n    \n    func setr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a]\n    }\n    \n    func seti(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = a\n    }\n    \n    func gtir(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = a > rx[b] ? 1 : 0 \n    }\n    \n    func gtri(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] > b ? 1 : 0 \n    }\n    \n    func gtrr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] > rx[b] ? 1 : 0 \n    }\n    \n    func eqir(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = a == rx[b] ? 1 : 0 \n    }\n    \n    func eqri(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] == b ? 1 : 0 \n    }\n    \n    func eqrr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] == rx[b] ? 1 : 0 \n    }\n    \n    let ops = [addi, addr, mulr, muli, banr, bani, borr, bori, setr, seti,\n               gtir, gtri, gtrr, eqir, eqri, eqrr]\n    \n    typealias Sample = (before: [Int], instruction: [Int], after: [Int])\n    \n    func matchingOpIndices(sample: Sample) -> [Int] {\n        let ins = sample.instruction\n        let (before, a, b, c, after) = (sample.before, ins[1], ins[2], ins[3], sample.after)\n        return ops.enumerated().filter({ _, op in\n            var registers = before\n            op(&registers, a, b, c)\n            return registers == after\n        }).map({ $0.0 })\n    }\n    \n    func parseInts(_ line: String?) -> [Int]? {\n        let digits = \"0123456789\"\n        return line?.split(whereSeparator: { !digits.contains($0) }).compactMap({ Int($0) })\n    }\n    \n    var samples = [Sample]()\n    while let line = readLine(), line.hasPrefix(\"Before:\") {\n        if let before = parseInts(line), \n            let instruction = parseInts(readLine()), \n            let after = parseInts(readLine()),\n            let _ = readLine() {\n            samples.append((before, instruction, after))\n        }\n    }\n    \n    var program = [[Int]]()\n    if readLine()?.isEmpty == true {\n        while let instruction = parseInts(readLine()) {\n            program.append(instruction)\n        }\n    }\n    \n    print(samples.filter({ matchingOpIndices(sample: $0).count >= 3 }).count)\n    \n    var choices = Array(repeating: Set(0..<ops.count), count: ops.count)\n    for sample in samples {\n        let opcode = sample.instruction[0]\n        let m = Set(matchingOpIndices(sample: sample))\n        for i in 0..<ops.count {\n            if !m.contains(i) {\n                choices[i].remove(opcode)\n            }\n        }\n    }\n    \n    for _ in 0..<ops.count {\n        for i in 0..<ops.count {\n            if choices[i].count == 1, let opcode = choices[i].first {\n                for k in 0..<ops.count {\n                    if k != i {\n                        choices[k].remove(opcode)\n                    }\n                }\n            }\n        }\n    }\n    \n    var opcodeToIndex = Array(repeating: 0, count: ops.count)\n    var isValidAssignment = true\n    for (i, opcodes) in choices.enumerated() {\n        if opcodes.count == 1, let opcode = opcodes.first {\n            opcodeToIndex[opcode] = i\n        } else {\n            isValidAssignment = false\n        }        \n    }\n    \n    if isValidAssignment {\n        var registers = [0, 0, 0, 0]\n        for inst in program {\n            let (opcode, a, b, c) = (inst[0], inst[1], inst[2], inst[3])\n            let op = ops[opcodeToIndex[opcode]]\n            op(&registers, a, b, c)\n        }\n        print(registers[0])\n    }\n", "id": "ebw7jk6", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "Python 3\n\nRank 153 / 78.\n\n[Solution (Github)](https://github.com/alcatrazEscapee/AdventofCode/blob/master/2018/src/day16.py)\n\nThis was a fun challenge. I spent a lot of time making sure that I had all the register functions correct - after yesterday's puzzle I was going to pay attention to detail! I also managed to find all the opcode ids without any additional iteration - just by matching the opcodes that only had one solution as the tests progressed produced the full mapping. I don't know if that'd be the case for all inputs though.", "id": "ebw8e0t", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "Pattern matching (via Rust) makes the opcode evaluation code look so pretty:\n\n    fn btou(b: bool) -> usize {\n        if b {\n            1\n        } else {\n            0\n        }\n    }\n    \n    fn exec(opcode: &str, in1: usize, in2: usize, out: usize, reg: &mut [usize; 4]) {\n        reg[out] = match opcode {\n            \"addr\" => reg[in1] + reg[in2],\n            \"addi\" => reg[in1] + in2,\n            \"mulr\" => reg[in1] * reg[in2],\n            \"muli\" => reg[in1] * in2,\n            \"barr\" => reg[in1] & reg[in2],\n            \"bari\" => reg[in1] & in2,\n            \"borr\" => reg[in1] | reg[in2],\n            \"bori\" => reg[in1] | in2,\n            \"setr\" => reg[in1],\n            \"seti\" => in1,\n            \"gtir\" => btou(in1 > reg[in2]),\n            \"gtri\" => btou(reg[in1] > in2),\n            \"gtrr\" => btou(reg[in1] > reg[in2]),\n            \"eqir\" => btou(in1 == reg[in2]),\n            \"eqri\" => btou(reg[in1] == in2),\n            \"eqrr\" => btou(reg[in1] == reg[in2]),\n            _ => panic!(\"Invalid opcode: {}\", opcode),\n        }\n    }\n\nIs there a reason you're using strings for opcodes instead of an enum?  Then the last `_ => panic` wouldn't be needed and using an invalid opcode would be a compiler error...\n\nEdit: Or at least that's how it worked in my Swift solution, and AFAIK Rust and Swift's enum semantics are very similar\n\n> Rust\n\nNote that `btou(b)` is `b as usize`.\n\nIt was mostly just a matter of saving an additional layer of parsing.  I'd have to define the enum and then create a second mapping function from the strings to it.\n\nI agree that's 100% the best way to do it if this were anything serious or if the use case was more involved (for example, if instructions were linear and there were jumps or something like that) but as it is, each instruction is just getting read once.\n\nTIL! Thanks for that.\n\nWait where are you getting these strings?  The only source of enum cases I ever had were from my own program (where I just wrote them in as enum cases), since the input file only contains numbers...\n\nI create a mapping from opcode to opcode ID in part 2: https://github.com/Ameobea/advent-of-code-2018/blob/master/src/day16.rs#L125", "id": "ebw9d3w", "owner_tier": 0.5, "score": 0.3333333329629629}, {"content": "##### PowerShell, #62 / #50\n\nPart 1 went pretty well, \"now match up the op-codes\", I printed them and when I saw it, realised it would be quicker to do by hand in notepad than in code. Part 2 also well. No bugs, no trips.\n\nUntil I tried to rewrite a bit more neatly, merge both parts to post here, and do the matching up in code - then bugs all over. :|\n\nCode here [or on GitHub](https://github.com/HumanEquivalentUnit/AdventOfCode2018/blob/master/2018-12-16-PowerShell-p1-and-p2.ps1):\n\n    $opcodes = @{\n        addr = { param($A, $B, $C) $registers[$C] = $registers[$A] + $registers[$B] }\n        addi = { param($A, $B, $C) $registers[$C] = $registers[$A] + $B }\n\n        mulr = { param($A, $B, $C) $registers[$C] = $registers[$A] * $registers[$B] }\n        muli = { param($A, $B, $C) $registers[$C] = $registers[$A] * $B }\n\n        banr = { param($A, $B, $C) $registers[$C] = $registers[$A] -band $registers[$B] }\n        bani = { param($A, $B, $C) $registers[$C] = $registers[$A] -band $B }\n\n        borr = { param($A, $B, $C) $registers[$C] = $registers[$A] -bor $registers[$B] }\n        bori = { param($A, $B, $C) $registers[$C] = $registers[$A] -bor $B }\n\n        setr = { param($A, $B, $C) $registers[$C] = $registers[$A] }\n        seti = { param($A, $B, $C) $registers[$C] = $A }\n\n        gtir = { param($A, $B, $C) $registers[$C] = if ($A -gt $registers[$B]) { 1 } else { 0 } }\n        gtri = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -gt $B) { 1 } else { 0 } }\n        gtrr = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -gt $registers[$B]) { 1 } else { 0 } }\n\n        eqir = { param($A, $B, $C) $registers[$C] = if ($A -eq $registers[$B]) { 1 } else { 0 } }\n        eqri = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -eq $B) { 1 } else { 0 } }\n        eqrr = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -eq $registers[$B]) { 1 } else { 0 } }   \n    }\n\n    $blocks = (Get-Content -Path .\\data.txt -raw) -split \"`r?`n`r?`n\"\n\n    $possibles = @{}\n\n\n    # Pick out the blocks for part 1\n    $results = foreach ($block in $blocks -match 'before')\n    {\n\n\n        # Split into three lines, get the digits out for the instruction\n        $before, $instruction, $after = $block -split \"`r?`n\"\n    \n        $instruction = [int[]]@($instruction -split \"\\D+\" -ne '')\n        $afterTxt = $after.Substring(9, 10)\n    \n\n    \n        # Setup for part 2, track which op-codes this could possibly be\n        if (-not $possibles.ContainsKey($instruction[0]))\n        {\n            $possibles[$instruction[0]] = [system.collections.generic.HashSet[string]]::new()\n        }\n\n\n\n        # Evalute each instruction, count and store the ones which it could be\n        $matchingOpCount = 0\n        foreach ($op in $opcodes.Keys)\n        {\n            $registers = [int[]]@($before -split \"\\D+\" -ne '')\n\n            & $opcodes[$op] $instruction[1] $instruction[2] $instruction[3]\n\n            if (([string]::Join(', ', $registers)) -eq $afterTxt)\n            {\n                [void]$possibles[$instruction[0]].Add($op)\n                $matchingOpCount++\n            }\n        }\n        $matchingOpCount\n    }\n\n    Write-Host \"Part 1: Number of inputs which could be 3 or more opcodes: $(($results -ge 3).Count)\"\n\n\n\n    # Winnow down the availble op-code for each value\n    $opLookup = @{}\n\n    while ($possibles.Count -gt 0)\n    {\n        $known = ($possibles.getenumerator().where{$_.Value.Count -eq 1})[0]\n        $opCode = $known.Value.GetEnumerator().foreach{$_}[0]\n        $opLookup[$known.Name] = $opCode\n        $possibles.Remove($known.Name)\n        $possibles.values.foreach{ [void]$_.Remove($opCode) }\n    }\n\n\n\n    # Part 2 - execute the script\n    $registers = @(0,0,0,0)\n    foreach ($block in $blocks -notmatch 'before' -split \"`r?`n\" -ne '')\n    {\n        $parts = [int[]]@($block -split \"\\D+\" -ne '')\n    \n        & $opcodes[$opLookup[$parts[0]]] $parts[1] $parts[2] $parts[3]\n    }\n\n    Write-Host \"Part 2: Result in register 0: $($registers[0])\"\n\n\nThanks for sharing this one, you found elegant ways to solve it. I am doing AoC in powershell as well :)", "id": "ebwan1e", "owner_tier": 0.7, "score": 0.07407407370370371}, {"content": "Rank 38/111 python 2.7, spent way too much time mapping for part 2 :(\n\nThis was a really fun challenge, I had lots of fun working out the mapping for each opcode. I used the magical eval function (Don't use this unless you're 100% sure the inputs aren't malicious) to help me calculate the instructions for both part A and B, I think it's pretty neat!  \n\n```\nimport re\n\nparsed = open(\"day16.txt\").read().split(\"\\n\\n\\n\\n\")\n\npuzzleA, puzzleB = [[list(map(int, re.findall(\"\\d+\", line))) for line in part.split(\"\\n\") if line] for part in parsed]\n\ndef chronal_classification(input, inputB):\n    ambiguous = 0\n    operations = {\"ra+b\", \"ra+rb\", \"ra*b\", \"ra*rb\", \"ra&b\", \"ra&rb\", \"ra|b\", \"ra|rb\", \"ra\", \"a\", \"a>rb\", \"ra>b\", \"ra>rb\", \"a==rb\", \"ra==rb\", \"ra==b\"}\n    freq = [set() for i in range(16)]\n\n    for i in range(0, len(input), 3):\n        before, [op_id, a, b, c], after = input[i:i+3]\n\n        # Set variables for the eval\n        ra = before[a]\n        rb = before[b]\n\n        potential = set()\n        for op in operations:\n            if eval(op) == after[c]:\n                potential.add(op)\n        freq[op_id] |= potential\n        ambiguous += len(potential) >= 3\n\n    print(\"Part A: %d\" % ambiguous)\n\n    # Working out the mapping of each opcode\n    for removal in range(16):\n        for potential_ops in freq:\n            if len(potential_ops) == 1:\n                freq = [ops - potential_ops or ops for ops in freq]\n\n    return partB([min(op) for op in freq], inputB)\n\ndef partB(mapping, input):\n\n    after = [0, 0, 0, 0]\n    for op, a, b, c in input:\n        # Set variables for eval\n        ra, rb = after[a], after[b]\n        after[c] = eval(mapping[op])\n\n    return after[0]\n\nprint(\"Part B: %d\" % chronal_classification(puzzleA, puzzleB))\n```\n&#x200B;", "id": "ebwasu1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "192/353 Rust\n\nIt was fun being able to implement the whole opcode execution logic as a one-line-per-opcode match statement.\n\nAll of my other days are here btw: [https://github.com/Ameobea/advent-of-code-2018](https://github.com/Ameobea/advent-of-code-2018)  I've been working to make sure they're all neat and run quickly.\n\n    use std::collections::HashSet;\n    \n    const INPUT: &str = include_str!(\"../input/day16.txt\");\n    \n    use regex::Regex;\n    \n    lazy_static! {\n        static ref RGX: Regex = Regex::new(\".*?(\\\\d+).+?(\\\\d+).+?(\\\\d+).+?(\\\\d+).*\").unwrap();\n    }\n    \n    fn parse_line(line: &str) -> [usize; 4] {\n        let mut res = [0usize; 4];\n        let captures = RGX\n            .captures(line)\n            .expect(&format!(\"regex captures failed for {:?}\", line));\n        res[0] = captures[1].parse().unwrap();\n        res[1] = captures[2].parse().unwrap();\n        res[2] = captures[3].parse().unwrap();\n        res[3] = captures[4].parse().unwrap();\n    \n        res\n    }\n    \n    fn parse_input() -> (\n        impl Iterator<Item = ([usize; 4], [usize; 4], [usize; 4])>,\n        impl Iterator<Item = [usize; 4]>,\n    ) {\n        let lines = INPUT.lines().collect::<Vec<_>>();\n    \n        let observed_executions = lines\n            .chunks(4)\n            .take_while(|chunk| !chunk[0].is_empty())\n            .map(move |block| {\n                (\n                    parse_line(block[0]),\n                    parse_line(block[1]),\n                    parse_line(block[2]),\n                )\n            })\n            .collect::<Vec<_>>();\n    \n        let instructions = lines\n            .into_iter()\n            .skip(observed_executions.len() * 4 + 2)\n            .take_while(|l| !l.is_empty())\n            .map(parse_line);\n    \n        (observed_executions.into_iter(), instructions)\n    }\n    \n    fn btou(b: bool) -> usize {\n        if b {\n            1\n        } else {\n            0\n        }\n    }\n    \n    fn exec(opcode: &str, in1: usize, in2: usize, out: usize, reg: &mut [usize; 4]) {\n        reg[out] = match opcode {\n            \"addr\" => reg[in1] + reg[in2],\n            \"addi\" => reg[in1] + in2,\n            \"mulr\" => reg[in1] * reg[in2],\n            \"muli\" => reg[in1] * in2,\n            \"barr\" => reg[in1] & reg[in2],\n            \"bari\" => reg[in1] & in2,\n            \"borr\" => reg[in1] | reg[in2],\n            \"bori\" => reg[in1] | in2,\n            \"setr\" => reg[in1],\n            \"seti\" => in1,\n            \"gtir\" => btou(in1 > reg[in2]),\n            \"gtri\" => btou(reg[in1] > in2),\n            \"gtrr\" => btou(reg[in1] > reg[in2]),\n            \"eqir\" => btou(in1 == reg[in2]),\n            \"eqri\" => btou(reg[in1] == in2),\n            \"eqrr\" => btou(reg[in1] == reg[in2]),\n            _ => panic!(\"Invalid opcode: {}\", opcode),\n        }\n    }\n    \n    const ALL_OPCODES: &[&str] = &[\n        \"addr\", \"addi\", \"mulr\", \"muli\", \"barr\", \"bari\", \"borr\", \"bori\", \"setr\", \"seti\", \"gtir\", \"gtri\",\n        \"gtrr\", \"eqir\", \"eqri\", \"eqrr\",\n    ];\n    \n    fn part1() -> usize {\n        let mut three_or_more_valid = 0;\n        for (before, op, after) in parse_input().0 {\n            let mut count = 0;\n            for opcode in ALL_OPCODES {\n                let mut reg = before;\n                exec(opcode, op[1], op[2], op[3], &mut reg);\n                if reg == after {\n                    count += 1;\n                }\n            }\n    \n            if count >= 3 {\n                three_or_more_valid += 1;\n            }\n        }\n    \n        three_or_more_valid\n    }\n    \n    fn part2() -> usize {\n        let (observed_executions, instructions) = parse_input();\n    \n        let mut reg: [usize; 4] = [0; 4];\n        let mut valid_opcodes: Vec<Vec<HashSet<&str>>> = vec![Vec::new(); 16];\n    \n        for (before, op, after) in observed_executions {\n            let mut possible_opcodes = HashSet::new();\n            for opcode in ALL_OPCODES {\n                reg = before;\n                exec(opcode, op[1], op[2], op[3], &mut reg);\n                if after == reg {\n                    possible_opcodes.insert(opcode.clone());\n                }\n            }\n    \n            valid_opcodes[op[0]].push(possible_opcodes);\n        }\n    \n        let mut mappings: [&str; 16] = [\"\"; 16];\n        let mut found_mappings = 0;\n    \n        while found_mappings < 16 {\n            for i in 0..16 {\n                if mappings[i] != \"\" {\n                    continue;\n                }\n    \n                let mut valid_for_all = HashSet::new();\n                for opcode in &valid_opcodes[i][0] {\n                    valid_for_all.insert(opcode);\n                }\n    \n                for matched_opcode_list in &valid_opcodes[i][1..] {\n                    valid_for_all.retain(|opcode| matched_opcode_list.iter().any(|o| *o == **opcode));\n                }\n    \n                for opcode in &mappings {\n                    valid_for_all.remove(opcode);\n                }\n    \n                if valid_for_all.len() == 1 {\n                    mappings[i] = valid_for_all.drain().next().unwrap();\n                    found_mappings += 1;\n                }\n            }\n        }\n    \n        for [op, a, b, c] in instructions {\n            exec(mappings[op], a, b, c, &mut reg);\n        }\n    \n        reg[0]\n    }\n    \n    pub fn run() {\n        println!(\"Part 1: {}\", part1());\n        println!(\"Part 2: {}\", part2());\n    }\n\nIt seems like I was the only one doing this with function pointers :p It was a bit more trouble than it was worth I guess, but it was fun.", "id": "ebwbl2e", "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "This space intentionally left blank.", "id": "ebwciak", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "845/867 Python2.7 Today was the first puzzle that didn't turn into a complete disaster.  And I even like how my code turned out, pretty compact.  And yes, I'm slow.\n\n    #!/bin/env python\n    aa = '''input'''\n\n    class reg:\n       def __init__ (self):\n          self.val = None\n\n       def clear (self):\n          self.val = 0\n\n       def store (self, vv):\n          self.val = vv\n\n       __call__ = lambda self: self.val\n       __str__ = lambda self: '%s' % self.val\n       __repr__ = __str__\n\n    class regs:\n       def __init__ (self):\n          self.rr = tuple([reg() for xx in xrange(4)])\n\n       __getitem__ = lambda self, ii: self.rr[ii]\n       __call__ = lambda self: [xx() for xx in self.rr]\n       store = lambda self, vals: [xx.store(vv) for xx,vv in zip(self.rr, vals)]\n       def clear (self): [xx.clear() for xx in self.rr]\n\n    class op:\n       def __init__ (self, id_, rr, cc):\n          self.id_ = id_\n          self.rr = rr\n          self.cc = cc\n\n       def test (self, r0, opcode, r1, rv):\n          self.rr.store(r0)\n          try:\n             self.__call__(opcode)\n             if self.rr() == r1: rv.add((self.id_, opcode[0]))\n          except: pass\n\n       def __call__ (self, opcode):\n          self.rr[opcode[3]].store(self.cc(self.rr, opcode))\n\n       __str__ = lambda self: 'op::%s' % self.id_\n       __repr__ = __str__\n\n    regs_ = regs()\n    ops_ = (\n       op('addr', regs_, lambda rr, oc: rr[oc[1]]()+rr[oc[2]]()),\n       op('addi', regs_, lambda rr, oc: rr[oc[1]]()+oc[2]),\n       op('mulr', regs_, lambda rr, oc: rr[oc[1]]()*rr[oc[2]]()),\n       op('muli', regs_, lambda rr, oc: rr[oc[1]]()*oc[2]),\n       op('banr', regs_, lambda rr, oc: rr[oc[1]]()&rr[oc[2]]()),\n       op('bani', regs_, lambda rr, oc: rr[oc[1]]()&oc[2]),\n       op('borr', regs_, lambda rr, oc: rr[oc[1]]()|rr[oc[2]]()),\n       op('bori', regs_, lambda rr, oc: rr[oc[1]]()|oc[2]),\n       op('setr', regs_, lambda rr, oc: rr[oc[1]]()),\n       op('seti', regs_, lambda rr, oc: oc[1]),\n       op('gtir', regs_, lambda rr, oc: (0, 1)[oc[1]>rr[oc[2]]()]),\n       op('gtri', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()>oc[2]]),\n       op('gtrr', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()>rr[oc[2]]()]),\n       op('eqir', regs_, lambda rr, oc: (0, 1)[oc[1]==rr[oc[2]]()]),\n       op('eqri', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()==oc[2]]),\n       op('eqrr', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()==rr[oc[2]]()])\n    )\n    ops_ = dict([(xx.id_, xx) for xx in ops_])\n\n    def sortopcodes (tt, ott, oll):\n       for ii,ss in tt.items():\n          if len(ss) == 1:\n             id_ = ss.pop()\n             tt.pop(ii)\n             oll[ii] = ott.pop(id_)\n             [vv.discard(id_) for vv in tt.itervalues()]\n             return\n\n    def part1 ():\n       inp = [xx.strip() for xx in aa.splitlines()]\n       inp = [xx for xx in inp if xx]\n       count = 0\n       while len(inp):\n          bb = inp.pop(0)\n          if 'Before' in bb:\n             rv = set([])\n             r0 = eval(bb.split(':')[1])\n             opcode = eval('[%s]' % ','.join(inp.pop(0).split()))\n             r1 = eval(inp.pop(0).split(':')[1])\n             [xx.test(r0, opcode, r1, rv) for xx in ops_.itervalues()]\n             if len(rv) > 2: count+=1\n       print 'part1 count: %s' % count\n\n    def part2 ():\n       inp = [xx.strip() for xx in aa.splitlines()]\n       inp = [xx for xx in inp if xx]\n       workout = {}\n       inp2 = []\n       while len(inp):\n          bb = inp.pop(0)\n          if 'Before' in bb:\n             rv = set([])\n             r0 = eval(bb.split(':')[1])\n             opcode = eval('[%s]' % ','.join(inp.pop(0).split()))\n             r1 = eval(inp.pop(0).split(':')[1])\n             [xx.test(r0, opcode, r1, rv) for xx in ops_.itervalues()]\n             if len(rv):\n                for id_, oc in rv:\n                   workout.setdefault(oc, set([])).add(id_)\n          else:\n             inp2.append(eval('[%s]' % ','.join(bb.split())))\n\n       op2 = [None]*16\n       while len(workout):\n          sortopcodes(workout, ops_, op2)\n\n       while len(inp2):\n          oc = inp2.pop(0)\n          op2[oc[0]](oc)\n\n       print 'part2 regs: %s' % regs_()\n\n    part1()\n    part2()\n", "id": "ebwdp7l", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Python 3 (584/812) - made many mistakes along the way, so no chance on the leader board. Nevertheless, I am satisfied with the quality of my code and decided to share my results for the first time on the AoC Reddit. I hope it is of value for some.\n\nNote: I manually split today's input in 2 files (\"input\\_16\\_1\" and \"input\\_16\\_2\")\n\n\\[Card\\]  The secret technique to beat today\u2019s puzzles is a secret. \n\n    from collections import defaultdict\n    \n    def readFile(name):\n     with open(\"files/\" + name) as f:\n      content = f.readlines()\n     content = [x.strip() for x in content]\n     return content\n    \n    def addr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] + reg[ins[2]]\n     return reg\n    \n    def addi(reg, ins):\n     reg[ins[3]] = reg[ins[1]] + int(ins[2])\n     return reg\n    \n    def mulr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] * reg[ins[2]]\n     return reg\n     \n    def muli(reg, ins):\n     reg[ins[3]] = reg[ins[1]] * int(ins[2])\n     return reg\n    \n    def banr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] & reg[ins[2]]\n     return reg\n    \n    def bani(reg, ins):\n     reg[ins[3]] = reg[ins[1]] & int(ins[2])\n     return reg\n    \n    def borr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] | reg[ins[2]]\n     return reg\n    \n    def bori(reg, ins):\n     reg[ins[3]] = reg[ins[1]] | int(ins[2])\n     return reg\n    \n    def setr(reg, ins):\n     reg[ins[3]] = reg[ins[1]]\n     return reg\n    \n    def seti(reg, ins):\n     reg[ins[3]] = int(ins[1])\n     return reg\n    \n    def gtii(reg, ins):\n     if int(ins[1]) > reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n    \n    def gtri(reg, ins):\n     if reg[ins[1]] > int(ins[2]):\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n    \n    def gtrr(reg, ins):\n     if reg[ins[1]] > reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n      \n    def eqir(reg, ins):\n     if int(ins[1]) == reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0 \n     return reg\n     \n    def eqri(reg, ins):\n     if reg[ins[1]] == int(ins[2]):\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n     \n    def eqrr(reg, ins):\n     if reg[ins[1]] == reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n    \n    def call(function, reg, ins):\n     if function in allCodes: # Beware of evil elves!\n      return eval(function + \"(reg, ins)\")\n    \n    def getCodes(r, i, newRegs):\n     return [code for code in allCodes if call(code, r[:], i) == newRegs]\n    \n    def getSamples(input):\n     samples = []\n    \n     for iPoint in range(0, len(input), 4):\n      regs    = [int(x) for x in input[iPoint][9:-1].split(\", \")]\n      ins     = [int(x) for x in input[iPoint+1].split(\" \")]\n      newRegs = [int(x) for x in input[iPoint+2][9:-1].split(\", \")]\n      \n      samples.append((regs, ins, newRegs))\n     return samples\n    \n    ### Part 1\n    \n    input = readFile(\"input_16_1\")\n    \n    allCodes = [\"addr\", \"addi\", \"mulr\", \"muli\", \"banr\", \"bani\", \"borr\", \"bori\", \"setr\", \"seti\", \"gtii\", \"gtri\", \"gtrr\", \"eqir\", \"eqri\", \"eqrr\"]\n    samples  = getSamples(input)\n    result = sum([len(getCodes(regs, ins, newRegs)) >= 3 for (regs, ins, newRegs) in samples])\n    \n    print(\"Solution 1: \" + str(result))\n    \n    ### Part 2\n    \n    opCodes = defaultdict(str)\n    \n    for (regs, ins, newRegs) in samples:\n     if ins[0] not in opCodes:\n      posCodes = [code for code in getCodes(regs, ins, newRegs) if code not in opCodes.values()]\n     \n      if len(posCodes) == 1:\n       opCodes[ins[0]] = posCodes[0]\n    \n    input = readFile(\"input_16_2\")\n    registers = [0] * 4\n    \n    for line in input:\n     ins = [int(x) for x in line.split(\" \")]\n     registers = call(opCodes[ins[0]], registers, ins)\n    \n    result = registers[0]\n    \n    print(\"Solution 2: \" + str(result))\n\n&#x200B;", "id": "ebwec42", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "###(messy) Haskell\nI really enjoyed today's puzzle. Took me a bit to figure out how to map the opcodes\n\n    {-# LANGUAGE TupleSections, ViewPatterns #-}\n    \n    import Control.Lens\n    import Data.Bits\n    import Data.Foldable\n    import Data.Function\n    import Data.List\n    import Data.List.Split\n    import Data.Map (Map)\n    import qualified Data.Map.Strict as Map\n    import Data.Set (Set)\n    import qualified Data.Set as Set\n    import System.Environment\n    \n    -- TYPES\n    type Registers = [Int]\n    type Instruction = (Int, Int, Int, Int)\n    \n    data OpCode = \n      OpCode {\n        _label :: String,\n        _f :: Registers -> Int -> Int -> Int -> Registers\n      }\n    \n    instance Show OpCode where\n      show = _label\n      \n    instance Eq OpCode where\n      (==) a b = _label a == _label b\n    \n    instance Ord OpCode where\n      compare a b = _label a `compare` _label b\n    \n    -- PARSING\n    parseTest :: [String] -> (Registers, Instruction, Registers)\n    parseTest [before, line, after] =\n      let before' = read . last . splitOn \": \" $ before\n          instr   = parseInstruction line\n          after'  = read . last . splitOn \": \" $ after\n      in  (before', instr, after')\n    \n    parseInstruction :: String -> Instruction\n    parseInstruction s = \n      let [op, a, b, c] = map read . words $ s\n      in  (op, a, b, c)\n    \n    -- SOLVING  \n    main :: IO ()\n    main = do \n      contents <- readFile . head =<< getArgs\n      let input   = filter (not . null . head) . groupBy ((==) `on` null) . lines $ contents\n      let tests   = parseTest <$> init input\n      let program = parseInstruction <$> last input\n      print $ solve1 tests\n      print $ solve2 tests program\n    \n    solve1 :: [(Registers, Instruction, Registers)] -> Int\n    solve1 = length . filter (>=3) . map (Set.size . snd . testAll)\n    \n    solve2 :: [(Registers, Instruction, Registers)] -> [Instruction] -> Int\n    solve2 tests program = \n      let opCandidates = Map.fromListWith Set.intersection $ map testAll tests\n          opMap = deduceOpMap opCandidates Map.empty \n      in  head $ foldl' (call opMap) [0, 0, 0, 0] program\n      where    \n        call opMap rs (flip Map.lookup opMap -> Just op, a, b, c) = _f op rs a b c\n    \n    deduceOpMap :: Map Int (Set OpCode) -> Map Int (Set OpCode) -> Map Int OpCode\n    deduceOpMap opCandidates opMap\n      | Map.size opMap == Map.size opCandidates = \n        Map.map (head . Set.elems) opMap\n      | otherwise = \n        let opMap' = Map.union opMap \n                   . Map.filter ((==1) . length) \n                   . Map.map (`Set.difference` fold opMap) \n                   $ opCandidates\n        in  deduceOpMap opCandidates opMap' \n    \n    testAll :: (Registers, Instruction, Registers) -> (Int, Set OpCode)\n    testAll (rs, (op, a, b, c), rs') = (op,) . Set.filter (testOp rs a b c rs' . _f) $ opCodes    \n      where\n        testOp rs a b c rs' f = f rs a b c == rs'\n        opCodes = \n          Set.fromList [ OpCode \"addr\" addr, OpCode \"addi\" addi\n                       , OpCode \"mulr\" mulr, OpCode \"muli\" muli\n                       , OpCode \"banr\" banr, OpCode \"bani\" bani\n                       , OpCode \"borr\" borr, OpCode \"bori\" bori\n                       , OpCode \"gtir\" gtir, OpCode \"gtri\" gtri, OpCode \"gtrr\" gtrr\n                       , OpCode \"eqir\" eqir, OpCode \"eqri\" eqri, OpCode \"eqrr\" eqrr\n                       , OpCode \"setr\" setr, OpCode \"seti\" seti\n                       ]\n    \n    funr :: (Int -> Int -> Int) -> Registers -> Int -> Int -> Int -> Registers\n    funr f rs a b c = funi f rs a (rs !! b) c\n    \n    funi :: (Int -> Int -> Int) -> Registers -> Int -> Int -> Int -> Registers\n    funi f rs a b c = \n      let va = rs !! a \n      in  rs & ix c .~ f va b\n    \n    addr = funr (+)\n    addi = funi (+)\n    \n    mulr = funr (*)\n    muli = funi (*)\n    \n    banr = funr (.&.)\n    bani = funi (.&.)\n    \n    borr = funr (.|.)\n    bori = funi (.|.)\n    \n    gtir rs = flip (funi (\\b a -> if a > b then 1 else 0) rs)\n    gtri    =       funi (\\a b -> if a > b then 1 else 0)\n    gtrr    =       funr (\\a b -> if a > b then 1 else 0)\n    \n    eqir rs = flip (funi (\\b a -> if a == b then 1 else 0) rs)\n    eqri    =       funi (\\a b -> if a == b then 1 else 0)\n    eqrr    =       funr (\\a b -> if a == b then 1 else 0)\n    \n    setr    = funi const\n    seti rs = flip (funi (flip const) rs)", "id": "ebwegy1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "This one was another fun one, a bit tricky to write clean code for though.\n\nDid this in Golang, and the builtin `math/bits ` package proved very useful for this method.\n\n```\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/bits\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Opcode int\n\nconst (\n\taddr Opcode = iota\n\taddi\n\n\tmulr\n\tmuli\n\n\tbanr\n\tbani\n\n\tborr\n\tbori\n\n\tsetr\n\tseti\n\n\tgtir\n\tgtri\n\tgtrr\n\n\teqir\n\teqri\n\teqrr\n)\nconst NumOpcodes = 16\n\nfunc run(i Opcode, a, b int, registers [4]int) int {\n\tswitch i {\n\tcase addr:\n\t\treturn registers[a] + registers[b]\n\tcase addi:\n\t\treturn registers[a] + b\n\n\tcase mulr:\n\t\treturn registers[a] * registers[b]\n\tcase muli:\n\t\treturn registers[a] * b\n\n\tcase banr:\n\t\treturn registers[a] & registers[b]\n\tcase bani:\n\t\treturn registers[a] & b\n\n\tcase borr:\n\t\treturn registers[a] | registers[b]\n\tcase bori:\n\t\treturn registers[a] | b\n\n\tcase setr:\n\t\treturn registers[a]\n\tcase seti:\n\t\treturn a\n\n\tcase gtir:\n\t\tif a > registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase gtri:\n\t\tif registers[a] > b {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase gtrr:\n\t\tif registers[a] > registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\n\tcase eqir:\n\t\tif a == registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase eqri:\n\t\tif registers[a] == b {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase eqrr:\n\t\tif registers[a] == registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\tpanic(\"Unknown opcode\")\n}\n\nfunc main() {\n\tvar data [][4]int\n\tvar instructionMap [NumOpcodes]uint16\n\n\treader, err := os.Open(\"day16_hint.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tscanner := bufio.NewScanner(reader)\n\tfor scanner.Scan() {\n\t\tfields := strings.FieldsFunc(scanner.Text(), func(r rune) bool {\n\t\t\tswitch {\n\t\t\tcase r >= '0' && r <= '9':\n\t\t\t\treturn false\n\t\t\tdefault:\n\t\t\t\treturn true\n\t\t\t}\n\t\t})\n\t\tints := [4]int{}\n\t\tfor i := 0; i < len(fields); i++ {\n\t\t\tints[i], _ = strconv.Atoi(fields[i])\n\t\t}\n\t\tdata = append(data, ints)\n\t}\n\treader.Close()\n\n\tfor i := 0; i < NumOpcodes; i++ {\n\t\tinstructionMap[i] = 0xFFFF\n\t}\n\n\tpartA := 0\n\tfor i := 0; i < len(data); i += 4 {\n\t\tfor op := Opcode(0); op < NumOpcodes; op++ {\n\t\t\toutr := data[i+1][3]\n\t\t\tout := run(op, data[i+1][1], data[i+1][2], data[i])\n\t\t\tif data[i+2][outr] != out {\n\t\t\t\tinstructionMap[data[i+1][0]] &= ^(1 << uint(op))\n\t\t\t}\n\t\t}\n\t\tif bits.OnesCount16(instructionMap[data[i+1][0]]) >= 3 {\n\t\t\tpartA++\n\t\t}\n\t}\n\n\tfmt.Println(\"Part A:\", partA)\n\n\tunknown := uint16(0xFFFF)\n\tfor unknown > 0 {\n\t\tfor op := 0; op < NumOpcodes; op++ {\n\t\t\tif bits.OnesCount16(instructionMap[op]) == 1 {\n\t\t\t\tunknown &= ^instructionMap[op]\n\t\t\t\tfor i := 0; i < NumOpcodes; i++ {\n\t\t\t\t\tif i != op {\n\t\t\t\t\t\tinstructionMap[i] &= ^instructionMap[op]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor op := 0; op < NumOpcodes; op++ {\n\t\tinstructionMap[op] = uint16(bits.Len16(instructionMap[op]) - 1)\n\t\tfmt.Printf(\"%2d -> %2d\\n\", op, instructionMap[op])\n\t}\n\n\tdata = data[:0]\n\treader, err = os.Open(\"day16_program.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tscanner = bufio.NewScanner(reader)\n\tfor scanner.Scan() {\n\t\tfields := strings.Split(scanner.Text(), \" \")\n\t\tints := [4]int{}\n\t\tfor i := 0; i < len(fields); i++ {\n\t\t\tints[i], _ = strconv.Atoi(fields[i])\n\t\t}\n\t\tdata = append(data, ints)\n\t}\n\treader.Close()\n\n\tregisters := [4]int{0, 0, 0, 0}\n\tfor i := range data {\n\t\toutr := data[i][3]\n\t\tout := run(Opcode(instructionMap[data[i][0]]), data[i][1], data[i][2], registers)\n\t\tregisters[outr] = out\n\t}\n\tfmt.Println(\"Part B:\", registers[0])\n}\n\n```", "id": "ebwek3p", "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "Nice logical inference fun!  Part 2 was so obvious.  Wish that there was more test input for this one.  I really tried to write less repetitive code as much as possible.\n\n    import re\n\n    def execute_reg_ins(reg, operands, ins):\n        reg[operands[2]] = ins(reg[operands[0]], reg[operands[1]])\n\n    def execute_value_ins(reg, operands, ins):\n        reg[operands[2]] = ins(reg[operands[0]], operands[1])\n\n    def execute_compare_ir_ins(reg, operands, ins):\n        reg[operands[2]] = ins(operands[0], reg[operands[1]])\n\n    def execute_compare_ri_ins(reg, operands, ins):\n        execute_value_ins(reg, operands, ins)\n\n    def execute_compare_rr_ins(reg, operands, ins):\n        execute_reg_ins(reg, operands, ins)\n\n    def could_be_reg_ins(before_reg, after_reg, operands, ins):\n        return after_reg[operands[2]] == ins(before_reg[operands[0]], before_reg[operands[1]])\n\n    def could_be_value_ins(before_reg, after_reg, operands, ins):\n        return after_reg[operands[2]] == ins(before_reg[operands[0]], operands[1])\n\n    def add(a, b):\n        return a + b\n\n    def mul(a, b):\n        return a * b\n\n    def ban(a, b):\n        return a & b\n\n    def bor(a, b):\n        return a | b\n\n    def gt(a, b):\n        return 1 if a > b else 0\n\n    def eq(a, b):\n        return 1 if a == b else 0\n\n    def could_be_compare_ir(before_reg, after_reg, operands, ins):\n        return after_reg[operands[2]] == ins(operands[0], before_reg[operands[1]])\n\n    def could_be_compare_ri(before_reg, after_reg, operands, ins):\n        return could_be_value_ins(before_reg, after_reg, operands, ins)\n\n    def could_be_compare_rr(before_reg, after_reg, operands, ins):\n        return could_be_reg_ins(before_reg, after_reg, operands, ins)\n\n    simple_operations = [(add, \"add\"), (mul, \"mul\"), (ban, \"ban\"), (bor, \"bor\")]\n    compare_operations = [(gt, \"gt\"), (eq, \"eq\")]\n\n    observations = []\n    test_program = []\n\n    in_before = False\n    with open('day_16.txt', 'r') as fp:\n        before = None\n        instruction = None\n        after = None\n        for line in fp:\n            if line.startswith(\"Before:\"):\n                before = list(map(int, re.findall(r'\\d+', line)))\n                in_before = True\n            elif line.startswith(\"After:\"):\n                after = list(map(int, re.findall(r'\\d+', line)))\n                observations.append((before, after, instruction))\n                in_before = False\n            else:\n                parts = list(map(int, re.findall(r'\\d+', line)))\n                if len(parts) == 4:\n                    instruction = parts\n                    if not in_before:\n                        test_program.append(instruction)\n\n    print(len(observations))\n    print(len(test_program))\n    observation_choices = []\n    opcode_meaning = {}\n\n    for observation in observations:\n        num_could_be = 0\n        before_reg = observation[0]\n        after_reg = observation[1]\n        opcode = observation[2][0]\n        operands = observation[2][1:]\n        could_be = set()\n      \n        if after_reg[operands[2]] == operands[0]:\n            could_be.add(\"seti\")\n        if after_reg[operands[2]] == before_reg[operands[0]]:\n            could_be.add(\"setr\")\n        for ops in simple_operations:\n            if could_be_reg_ins(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"r\")\n            if could_be_value_ins(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"i\")\n        for ops in compare_operations:\n            if could_be_compare_ir(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"ir\")\n            if could_be_compare_ri(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"ri\")\n            if could_be_compare_rr(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"rr\")\n        observation_choices.append(len(could_be))\n\n        if opcode in opcode_meaning:\n            opcode_meaning[opcode] = opcode_meaning[opcode] & could_be\n        else:\n            opcode_meaning[opcode] = could_be\n\n    print(\"More Than 3: \" + str(len(list(filter(lambda x: x >= 3, observation_choices)))))\n    print(opcode_meaning)\n\n    while len(list(filter(lambda x: len(x) > 1, opcode_meaning.values()))) > 0:\n        for opcode, meaning in opcode_meaning.items():\n            if len(meaning) == 1:\n                the_meaning = list(meaning)[0]\n                print(\"Truth: \" + str(opcode) + \" means \" + the_meaning)\n                # for sure we know this one\n                for other_opcode, other_meaning in opcode_meaning.items():\n                    if opcode != other_opcode:\n                        if the_meaning in other_meaning:\n                            other_meaning.remove(the_meaning)\n        print(opcode_meaning)\n                \n    reg = [0, 0, 0, 0]\n    for ins in test_program:\n        ins_name = list(opcode_meaning[ins[0]])[0]\n        operands = ins[1:]\n        run = False\n        print(\"Run: \" + str(ins_name) + \" \" + str(operands))\n        for op in simple_operations:\n            if ins_name.startswith(op[1]):\n                if ins_name.endswith('r'):\n                    execute_reg_ins(reg, operands, op[0])\n                else:\n                    execute_value_ins(reg, operands, op[0])\n                run = True\n        if not run:\n            for op in compare_operations:\n                if ins_name.startswith(op[1]):\n                    if ins_name.endswith('ir'):\n                        execute_compare_ir_ins(reg, operands, op[0])\n                    elif ins_name.endswith('ri'):\n                        execute_compare_ri_ins(reg, operands, op[0])\n                    else:\n                        execute_compare_rr_ins(reg, operands, op[0])\n                    run = True\n        if not run:\n            if ins_name == \"seti\":\n                reg[operands[2]] = operands[0]\n            elif ins_name == \"setr\":\n                reg[operands[2]] = reg[operands[0]]\n            else:\n                print(\"FAIL!\")\n        print(\"Result: \" + str(reg))\n\n\n\n", "id": "ebwf5dg", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Clojure**\n\nFor part 2, I ran this snippet until all matching codes where found:\n\n    (def matching (map find-matching-opcodes input))  ; Run only once\n    (def matching (remove nil? (map (fn [{:keys [opcode behaves-like] :as match}]\n                                  (if (opcode->opcode-symbol opcode)\n                                    nil\n                                    (assoc match :behaves-like (remove found-opcodes behaves-like)))) matching)))\n    (set (filter #(< (count (:behaves-like %1)) 2) matching))\n\nHere's the code:\n\n    (ns aoc18.day16\n      (:require [clojure.string :as str]))\n    \n    (defn long-str [& strings]\n      (str/join \"\\n\" strings))\n    \n    (def test-input (long-str\n                      \"Before: [3, 2, 1, 1]\"\n                      \"9 2 1 2\"\n                      \"After:  [3, 2, 2, 1]\"))\n    \n    (defn parse-register-values [input]\n      (vec (map #(Integer/parseInt %1) (re-seq #\"\\d+\" input))))\n    \n    (defn parse-instruction [input]\n      (let [[opcode a b c] (str/split input #\" \")]\n        {:opcode (Integer/parseInt opcode) :a (Integer/parseInt a) :b (Integer/parseInt b) :c (Integer/parseInt c)}))\n    \n    (defn parse-input [input]\n      (let [lines (str/split-lines input)]\n        (loop [parsed []\n               [before instruction after & rest-lines :as all-lines] lines]\n          (if (empty? all-lines)\n            parsed\n            (if (str/includes? before \"Before\")\n              (recur (conj parsed {:registers-before (parse-register-values before)\n                                   :instruction      (parse-instruction instruction)\n                                   :registers-after  (parse-register-values after)})\n                     rest-lines)\n              (recur parsed (rest all-lines)))))))\n    \n    (defn initialize-cpu\n      ([] (initialize-cpu [0 0 0 0]))\n      ([registers]\n       {:registers registers}))\n    \n    (defn op-r [f]\n      (fn [{:keys [registers] :as cpu} {:keys [a b c]}]\n        (let [a-val (nth registers a)\n              b-val (nth registers b)\n              result (f a-val b-val)]\n          (assoc cpu :registers (assoc registers c result)))))\n    (defn op-i [f]\n      (fn [{:keys [registers] :as cpu} {:keys [a b c]}]\n        (let [a-val (nth registers a)\n              b-val b\n              result (f a-val b-val)]\n          (assoc cpu :registers (assoc registers c result)))))\n    \n    (defn set-r [{:keys [registers] :as cpu} {:keys [a c]}]\n      (let [a-val (nth registers a)]\n        (assoc cpu :registers (assoc registers c a-val))))\n    (defn set-i [{:keys [registers] :as cpu} {:keys [a c]}]\n      (let [a-val a]\n        (assoc cpu :registers (assoc registers c a-val))))\n    \n    (defn gtir [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val a\n            b-val (nth registers b)\n            result (if (> a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn gtri [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val b\n            result (if (> a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn gtrr [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val (nth registers b)\n            result (if (> a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    \n    (defn eqir [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val a\n            b-val (nth registers b)\n            result (if (= a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn eqri [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val b\n            result (if (= a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn eqrr [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val (nth registers b)\n            result (if (= a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    \n    (def opcode->opcode-symbol\n      {0  :eqir\n       1  :seti\n       2  :eqri\n       3  :eqrr\n       4  :addi\n       5  :setr\n       6  :gtrr\n       7  :gtri\n       8  :muli\n       9  :bori\n       10 :bani\n       11 :borr\n       12 :gtir\n       13 :banr\n       14 :addr\n       15 :mulr})\n    \n    (def found-opcodes\n      (set (map second opcode->opcode-symbol)))\n    \n    (def opcode->f\n      {:addr (op-r +)\n       :addi (op-i +)\n    \n       :mulr (op-r *)\n       :muli (op-i *)\n    \n       :banr (op-r bit-and)\n       :bani (op-i bit-and)\n    \n       :borr (op-r bit-or)\n       :bori (op-i bit-or)\n    \n       :setr set-r\n       :seti set-i\n    \n       :gtir gtir\n       :gtri gtri\n       :gtrr gtrr\n    \n       :eqir eqir\n       :eqri eqri\n       :eqrr eqrr})\n    \n    (defn find-matching-opcodes [{:keys [registers-before instruction registers-after] :as input}]\n      (let [cpu (initialize-cpu registers-before)]\n        {:opcode       (:opcode instruction)\n         :behaves-like (remove nil? (for [[opcode f] opcode->f]\n                                      (let [cpu (f cpu instruction)]\n                                        (if (= (:registers cpu) registers-after) opcode nil))))}))\n    \n    (defn load-instructions [fname]\n      (map parse-instruction (str/split-lines (slurp fname))))\n    \n    (defn run-prog [prog]\n      (let [cpu (initialize-cpu)]\n        (reduce (fn [cpu {:keys [opcode] :as instruction}]\n                  (let [opcode-symbol (opcode->opcode-symbol opcode)\n                        opcode-f (opcode->f opcode-symbol)]\n                    (opcode-f cpu instruction)))\n                cpu\n                prog)))", "id": "ebwfjuq", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Python 3.** \n\nParsing input is not my strongest skill, but otherwise I'm satisfied with the code. Overslept, so I was nowhere near the leaderboard but it took about 15 + 7 min to complete. Added comments, otherwise not cleaned up. \n\n    with open('16-1.in') as f:\n      l1 = [l.rstrip('\\n') for l in f]\n    with open('16-2.in') as f:\n      l2 = [l.rstrip('\\n') for l in f]\n    \n    def addr(a, b, c, r) :  return r[a]+r[b] \n    def addi(a, b, c, r) :  return r[a]+b\n    def mulr(a, b, c, r) :  return r[a]*r[b]\n    def muli(a, b, c, r) :  return r[a]*b\n    def banr(a, b, c, r) :  return r[a]&r[b]\n    def bani(a, b, c, r) :  return r[a]&b\n    def borr(a, b, c, r) :  return r[a]|r[b]\n    def bori(a, b, c, r) :  return r[a]|b\n    def setr(a, b, c, r) :  return r[a]\n    def seti(a, b, c, r) :  return a\n    def gtir(a, b, c, r) :  return int(a > r[b])\n    def gtri(a, b, c, r) :  return int(r[a] > b)\n    def gtrr(a, b, c, r) :  return int(r[a]>r[b])\n    def eqir(a, b, c, r) :  return int(a == r[b])\n    def eqri(a, b, c, r) :  return int(r[a] == b)\n    def eqrr(a, b, c, r) :  return int(r[a] == r[b])\n    \n    def exe(f, a, b, c, r) : \n      r[c] = f(a, b, c, r)\n      return r\n    \n    funcs = [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]\n    \n    FOP = {}                             # List of figured out operators\n    CA = {x : set() for x in range(16)}  # OP candidates \n    \n    def cfuncs(bef, aft, ins) :\n      cf = 0\n      mem = bef\n      for f in funcs : \n        bef = [x for x in mem]\n        if exe(f,ins[1],ins[2],ins[3],bef) == aft :\n          CA[ins[0]].add(f)\n          cf += 1\n      return cf\n    \n    # Part 1\n    p1ans = 0 \n    for r in range(0, len(l1), 4) :  \n      c1, c2, c3 = l1[r:r+3]\n      bef = [int(c1[x]) for x in [9,12,15,18]]\n      ins = [int(x) for x in c2.split(\" \")]\n      aft = [int(c3[x]) for x in [9,12,15,18]]\n    \n      cnt = cfuncs(bef, aft, ins) \n      p1ans += 1 if (cnt > 2) else 0 \n    \n    print(\"Part 1:\", p1ans)\n    \n    # Part 2\n    # Reduce candidate list\n    while len(FOP) < 16 :        \n      for d in range(16) :      \n        CA[d] = [c for c in CA[d] if c not in [FOP[x] for x in FOP]]\n        if len(CA[d]) == 1 :          \n          FOP[d] = CA[d][0]\n    \n    # Execute program for part 2\n    r = [0, 0, 0, 0]\n    for l in l2 : \n      ins = [int(x) for x in l.split(\" \")]\n      r = exe(FOP[ins[0]],ins[1],ins[2],ins[3], r)\n    \n    print(\"Part 2:\", r[0])\n\n&#x200B;", "id": "ebwglx8", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "C# this was a fun and hard one. I figured out which code was which function by hand by keeping track of when a function gave the correct output, wat opcode number was called, as you can see in some of my code. Not the cleanest, but this was easier for me.\n\n    private static void Day16() {\n        Console.WriteLine(\"Day 16 - Question 1:\");\n\n        string input = File.ReadAllText($\"{path}Advent of Code - Day 16 - Op Codes.txt\");\n\n        //foreach (char c in input) {\n        //    Console.WriteLine(c);\n        //}\n\n        string[] inputs = input.Split(\"\\n\\r\\n\");\n\n        int three = 0;\n\n        List<int>[] possible = new List<int>[16];\n\n        for (int i = 0; i < 16; i++)\n            possible[i] = new List<int>();\n\n        foreach (string s in inputs) {\n            string[] lines = s.Split('\\n');\n\n            int reg1, reg2, reg3, reg4;\n            reg1 = Convert.ToInt32(lines[0][9].ToString());\n            reg2 = Convert.ToInt32(lines[0][12].ToString());\n            reg3 = Convert.ToInt32(lines[0][15].ToString());\n            reg4 = Convert.ToInt32(lines[0][18].ToString());\n\n            int com1, com2, com3, com4;\n            string[] coms = lines[1].Split(' ');\n            com1 = Convert.ToInt32(coms[0]);\n            com2 = Convert.ToInt32(coms[1]);\n            com3 = Convert.ToInt32(coms[2]);\n            com4 = Convert.ToInt32(coms[3]);\n\n            int res1, res2, res3, res4;\n            res1 = Convert.ToInt32(lines[2][9].ToString());\n            res2 = Convert.ToInt32(lines[2][12].ToString());\n            res3 = Convert.ToInt32(lines[2][15].ToString());\n            res4 = Convert.ToInt32(lines[2][18].ToString());\n\n            ops[] re = new ops[16] {\n                Addr,\n                Addi,\n                Mulr,\n                Muli,\n                Banr,\n                Bani,\n                Borr,\n                Bori,\n                Setr,\n                Seti,\n                Gtir,\n                Gtri,\n                Gtrr,\n                Eqir,\n                Eqri,\n                Eqrr\n            };\n\n            int correct = 0;\n            for (int i = 0; i < re.Length; i++) {\n                int[] registry = { reg1, reg2, reg3, reg4 };\n                re[i](ref registry, com2, com3, com4);\n                if (registry[0] == res1 && registry[1] == res2 && registry[2] == res3 && registry[3] == res4) {\n                    correct++;\n                    if (!possible[i].Contains(com1))\n                        possible[i].Add(com1);\n                }\n            }\n\n            if (correct >= 3)\n                three++;\n\n            //Console.WriteLine($\"{reg1} - {reg2} - {reg3} - {reg4} --- {com1} - {com2} - {com3} - {com4} --- {res1} - {res2} - {res3} - {res4}\");\n        }\n\n        Console.WriteLine($\"Answer Q16.1: {three}\\n\");\n\n        input = File.ReadAllText($\"{path}Advent of Code - Day 16 - Op Code Program.txt\");\n        inputs = input.Split('\\n');\n\n        int[] reg = { 0, 0, 0, 0 };\n\n        ops[] commands = new ops[16] {\n                Borr,\n                Seti,\n                Mulr,\n                Eqri,\n                Banr,\n                Bori,\n                Bani,\n                Gtri,\n                Addr,\n                Muli,\n                Addi,\n                Eqrr,\n                Gtir,\n                Eqir,\n                Setr,\n                Gtrr\n            };\n\n        foreach (string s in inputs) {\n            int com1, com2, com3, com4;\n            string[] coms = s.Split(' ');\n            com1 = Convert.ToInt32(coms[0]);\n            com2 = Convert.ToInt32(coms[1]);\n            com3 = Convert.ToInt32(coms[2]);\n            com4 = Convert.ToInt32(coms[3]);\n        \n            commands[com1](ref reg, com2, com3, com4);\n        }\n\n        Console.WriteLine($\"Answer Q16.2: {reg[0]}\\n\");\n    }\n\n    private delegate void ops(ref int[] reg, int a, int b, int c);\n\n    private static void Addr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] + reg[b];\n\n    private static void Addi(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] + b;\n\n    private static void Mulr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] * reg[b];\n\n    private static void Muli(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] * b;\n\n    private static void Banr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] & reg[b];\n\n    private static void Bani(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] & b;\n\n    private static void Borr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] | reg[b];\n\n    private static void Bori(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] | b;\n\n    private static void Setr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a];\n\n    private static void Seti(ref int[] reg, int a, int b, int c) => reg[c] = a;\n\n    private static void Gtir(ref int[] reg, int a, int b, int c) => reg[c] = a > reg[b] ? 1 : 0;\n\n    private static void Gtri(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] > b ? 1 : 0;\n\n    private static void Gtrr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] > reg[b] ? 1 : 0;\n\n    private static void Eqir(ref int[] reg, int a, int b, int c) => reg[c] = a == reg[b] ? 1 : 0;\n\n    private static void Eqri(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] == b ? 1 : 0;\n\n    private static void Eqrr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] == reg[b] ? 1 : 0;", "id": "ebwh1kw", "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "Gold \\#1356. Hint for part 2: it\u2019s handy to generate a list of (name, [possible opcodes]) for the figuring-out part.\n\n    #!/usr/bin/env python3\n    import collections\n    import json\n    with open(\"input/16a.txt\") as fh:\n        file_data_A = fh.read().strip()\n    with open(\"input/16b.txt\") as fh:\n        file_data_B = fh.read().strip()\n\n\n    class CPU:\n        registers = []\n\n        def __init__(self, registers=None):\n            if registers is None:\n                self.registers = [0, 0, 0, 0]\n            else:\n                self.registers = registers\n            self.starting = self.registers.copy()\n\n        def undo(self):\n            self.registers = self.starting.copy()\n\n        def copy(self):\n            return CPU(self.registers.copy())\n\n        def __eq__(self, other):\n            if isinstance(other, CPU):\n                return self.registers == other.registers\n            return self.registers == other  # list\n\n        def addr(self, a, b, c):\n            self.registers[c] = self.registers[a] + self.registers[b]\n\n        def addi(self, a, b, c):\n            self.registers[c] = self.registers[a] + b\n\n        def mulr(self, a, b, c):\n            self.registers[c] = self.registers[a] * self.registers[b]\n\n        def muli(self, a, b, c):\n            self.registers[c] = self.registers[a] * b\n\n        def banr(self, a, b, c):\n            self.registers[c] = self.registers[a] & self.registers[b]\n\n        def bani(self, a, b, c):\n            self.registers[c] = self.registers[a] & b\n\n        def borr(self, a, b, c):\n            self.registers[c] = self.registers[a] | self.registers[b]\n\n        def bori(self, a, b, c):\n            self.registers[c] = self.registers[a] | b\n\n        def setr(self, a, _b, c):\n            self.registers[c] = self.registers[a]\n\n        def seti(self, a, _b, c):\n            self.registers[c] = a\n\n        def gtir(self, a, b, c):\n            self.registers[c] = int(a > self.registers[b])\n\n        def gtri(self, a, b, c):\n            self.registers[c] = int(self.registers[a] > b)\n\n        def gtrr(self, a, b, c):\n            self.registers[c] = int(self.registers[a] > self.registers[b])\n\n        def eqir(self, a, b, c):\n            self.registers[c] = int(a == self.registers[b])\n\n        def eqri(self, a, b, c):\n            self.registers[c] = int(self.registers[a] == b)\n\n        def eqrr(self, a, b, c):\n            self.registers[c] = int(self.registers[a] == self.registers[b])\n\n        def run(self, op, a, b, c):\n            print(self.opcodes[op], a, b, c)\n            self.opcodes[op](self, a, b, c)\n\n        def run_line(self, line):\n            self.run(*(int(i) for i in line.split()))\n\n        operations = [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]\n        opcodes = {\n            0: seti, # I\u2019m not spoiling the entire list here; it is on my GitHub though.\n        }\n\n\n    def solveA(data):\n        matches_three_or_more = 0\n        for problem in data.split('\\n\\n'):\n            before_line, op_line, after_line = problem.split('\\n')\n            before = json.loads(before_line.split(': ')[-1].strip())\n            after = json.loads(after_line.split(': ')[-1].strip())\n            op = [int(i) for i in op_line.split()]\n            opcode_num, a, b, c = op\n\n            print(op)\n            cpu = CPU(before)\n            matches = 0\n            for operation in CPU.operations:\n                operation(cpu, a, b, c)\n                if cpu == after:\n                    print(\"Matches operation\", operation)\n                    matches += 1\n                cpu.undo()\n            if matches >= 3:\n                matches_three_or_more += 1\n            print('\\n')\n\n        return matches_three_or_more\n\n\n    def prepareB(data):\n        candidates = {}\n        for opcode_num in range(16):\n            candidates[opcode_num] = collections.Counter()\n\n        for problem in data.split('\\n\\n'):\n            before_line, op_line, after_line = problem.split('\\n')\n            before = json.loads(before_line.split(': ')[-1].strip())\n            after = json.loads(after_line.split(': ')[-1].strip())\n            op = [int(i) for i in op_line.split()]\n            opcode_num, a, b, c = op\n\n            print(op)\n            cpu = CPU(before)\n            for operation in CPU.operations:\n                operation(cpu, a, b, c)\n                if cpu == after:\n                    candidates[opcode_num][operation.__name__] += 1\n                cpu.undo()\n\n        functions = {}\n        for opcode_num in range(16):\n            functions[opcode_num] = candidates[opcode_num].most_common()\n            print(opcode_num, candidates[opcode_num].most_common())\n\n        print()\n\n        for op in CPU.operations:\n            poss = []\n            for opcode_num in range(16):\n                if op.__name__ in candidates[opcode_num]:\n                    poss.append(opcode_num)\n            print(op.__name__, poss)\n\n\n    def solveB(data):\n        cpu = CPU()\n        for line in data.split('\\n'):\n            cpu.run_line(line)\n            print(cpu.registers)\n\n        return cpu.registers[0]\n\n\n    print(solveA(file_data_A))\n    prepareB(file_data_B)\n    solveB(file_data_B)\n\nHere\u2019s another script to automate part 2 preparations:\n\n    #!/usr/bin/env python3\n    # 16b1_auto: figure out opcode meaning\n    import json\n    from typing import Dict, List\n\n    input_data = \"\"\"addr [6, 12, 15]\n    addi [4, 6, 12, 15]\n    mulr [6]\n    muli [5, 6, 12, 15]\n    banr [0, 4, 5, 6, 10, 11]\n    bani [0, 5, 6, 8, 10, 11, 12]\n    borr [6, 12]\n    bori [4, 6, 10, 12]\n    setr [2, 4, 6, 10, 12]\n    seti [0, 4, 6, 12, 15]\n    gtir [0, 2, 3, 5, 6, 8, 11, 12]\n    gtri [0, 3, 4, 6, 7, 8, 9, 11, 12]\n    gtrr [0, 3, 5, 6, 7, 8, 11, 12]\n    eqir [0, 1, 3, 4, 5, 7, 8, 9, 11, 12]\n    eqri [0, 1, 3, 5, 7, 8, 11, 12, 13]\n    eqrr [0, 1, 3, 5, 8, 9, 11, 13, 14]\"\"\"\n\n    d: Dict[str, List[int]] = {}\n\n    for l in input_data.split('\\n'):\n        instruction, possibilities = l[:4], json.loads(l[5:])\n        d[instruction] = possibilities\n\n    seen = 0\n    instructions: Dict[int, str] = {i: None for i in range(16)}\n\n    while seen < 16:\n        instruction: str\n        possibilities: List[int]\n        for instruction, possibilities in d.items():\n            if len(possibilities) == 1:\n                seen += 1\n                found = possibilities[0]\n                instructions[found] = instruction\n                print(instruction, '=', found)\n                del d[instruction]\n                for poslist in d.values():\n                    if found in poslist:\n                        poslist.remove(found)\n                break\n\n    print(\"\\n{\")\n    print(\",\\n\".join(f\"    {i}: {instructions[i]}\" for i in range(16)))\n    print(\"}\")", "id": "ebwifog", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "[Day 16 in Kotlin](https://github.com/nielsutrecht/adventofcode/blob/master/src/main/kotlin/com/nibado/projects/advent/y2018/Day16.kt)", "id": "ebwis0p", "owner_tier": 0.9, "score": -3.703703681194552e-10}, {"content": "**JavaScript.** Shame on me, took me a while figuring out I had to make some deduction to get 1-to-1 opcode pairing before starting Part 2 (at first assumed the sample data was enough to determine exactly each opcode).\n\n&#x200B;\n\n[https://github.com/albertobastos/advent-of-code-2018-nodejs/blob/master/src/d16.js](https://github.com/albertobastos/advent-of-code-2018-nodejs/blob/master/src/d16.js)\n\n&#x200B;\n\nThat was fun, though.\n\nThe sample data is infact enough to programmatically deduce all opcodes. At least it was for my input, and I assume everyone's input has been chosen to do exactly that. In hindsight it definitely seems faster to do by hand though, so there's that.\n\n**Edit:** Wait but you did programmatically deduce the opcodes. I guess I misunderstood what you were saying.\n\nYep, what I tried to say is that, after the sample data, I expected to have only one \"potential instruction\" for each opcode. I even put a validation asserting that before starting Part 2, and when it triggered is when I started struggling until I realised that you had to apply deduction for instructions potentially paired with multiple opcodes.", "id": "ebwiyx4", "owner_tier": 0.1, "score": 0.11111111074074075}, {"content": "[My **Scala** solution](https://github.com/sim642/adventofcode/blob/master/src/main/scala/eu/sim642/adventofcode2018/Day16.scala).\n\nFor part 2 I initially only did the intersections per opcode number, but that didn't turn out to be enough. For a moment I thought I had a bug somewhere in the evaluation but then realized more deductions could be made.\n\nSo I added something like unit propagation, which removes exactly defined mappings from all others. I also did it early during the fitting from a single sample so it'd be useful as early as possible and make other unit propagations possible. Turns out this was enough to give a unique mapping that works. Now thinking about it, I'm not sure whether this just happens to work here or a separate solving stage would be generally needed. I suppose some especially difficult cases would be possible, where unique mapping exists but it can't be simply deduced by unit propagation and requires SAT solving.", "id": "ebwjibf", "owner_tier": 0.9, "score": -3.703703681194552e-10}, {"content": "C# today.\n\nI could only find one operation code that matched only one algorithm, and was stuck on the identifying stage until I realised I could remove any that were identified already from the check.\n\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Linq;\n    \n    namespace aoc16\n    {\n        class Program\n        {\n            static int[] reg = new int[] { 0, 0, 0, 0 };\n            static void Main(string[] args)\n            {\n                var ops = new List<Operation>();\n    \n                //addr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] + reg[b];\n                }));\n                //addi\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] + b;\n                }));\n                //mulr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] * reg[b];\n                }));\n                //muli\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] * b;\n                }));\n                //banr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] & reg[b];\n                }));\n                //bani\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] & b;\n                }));\n                //borr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] | reg[b];\n                }));\n                //bori\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] | b;\n                }));\n                //setr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a];\n                }));\n                //seti\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = a;\n                }));\n                //gtir\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = a > reg[b] ? 1 : 0;\n                }));\n                //gtri\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] > b ? 1 : 0;\n                }));\n                //gtrr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] > reg[b] ? 1 : 0;\n                }));\n                //eqir\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = a == reg[b] ? 1 : 0;\n                }));\n                //eqri\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] == b ? 1 : 0;\n                }));\n                //eqrr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] == reg[b] ? 1 : 0;\n                }));\n    \n                var input1 = File.ReadAllLines(\"input1.txt\");\n                for (int i = 0; i < input1.Length; i += 4)\n                {\n                    var bf = input1[i];\n                    var before = new int[] {\n                        int.Parse(bf.Substring(9,1)),\n                        int.Parse(bf.Substring(12,1)),\n                        int.Parse(bf.Substring(15,1)),\n                        int.Parse(bf.Substring(18,1))\n                    };\n                    var af = input1[i + 2];\n                    var after = new int[] {\n                        int.Parse(af.Substring(9,1)),\n                        int.Parse(af.Substring(12,1)),\n                        int.Parse(af.Substring(15,1)),\n                        int.Parse(af.Substring(18,1))\n                    };\n                    var p = input1[i + 1].Split(' ');\n                    var o = int.Parse(p[0]);\n                    var a = int.Parse(p[1]);\n                    var b = int.Parse(p[2]);\n                    var c = int.Parse(p[3]);\n    \n                    var matches = FindOpCodes(ops, before, a, b, c, o, after);\n                }\n                \n                reg = new int[] {0,0,0,0};\n    \n                var input2 = File.ReadAllLines(\"input2.txt\");\n                foreach (var line in input2)\n                {\n                    var inputs = line.Split(' ');\n                    var o = int.Parse(inputs[0]);\n                    var a = int.Parse(inputs[1]);\n                    var b = int.Parse(inputs[2]);\n                    var c = int.Parse(inputs[3]);\n                    var op = ops.First(x => x.OpCode == o);\n                    op.Action(a,b,c);\n                }\n    \n                Console.WriteLine(string.Join(',', reg));\n            }\n    \n            static int FindOpCodes(\n                List<Operation> ops, \n                int[] before, \n                int a, int b, int c, int opCode,\n                int[] after)\n            {\n                var count = 0;\n                Operation lastMatch = new Operation(null); \n                ops.Where(x => x.OpCode == -1).ToList().ForEach(op =>\n                {\n                    reg = (int[])before.Clone();\n                    op.Action(a, b, c);\n                    if (reg.SequenceEqual(after)) { \n                        count++;\n                        lastMatch = op;\n                    }\n                });\n                if (count == 1) {\n                    lastMatch.OpCode = opCode;\n                }\n                return count;\n            }\n        }\n    \n        public class Operation {\n            public Operation(Action<int,int,int> action) {\n                Action = action;\n            }\n            public Action<int,int,int> Action { get; set; }\n            public int OpCode { get; set; } = -1;\n        }\n    }", "id": "ebwjrv1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "I spent a lot of time trying to optimize my part1.\n\n    const LOOKUP : [u32; 64] = [38195, 38195, 38195, 38195, 4403, 13107, 54743, 48059, 5393, 39219, 21847, 39355, 37137, 47411, 21973, 39355, 4403, 13107, 22391, 48059, 46899, 46899, 46899, 46899, 5427, 47411, 22391, 48059, 37171, 47923, 22007, 48059, 5427, 13107, 22391, 39867, 5939, 14195, 55287, 48059, 38773, 38773, 38773, 38773, 38193, 47923, 21973, 39867, 37171, 47923, 22519, 48059, 45875, 47923, 57343, 48059, 38193, 47547, 22519, 48059, 46521, 46521, 46521, 46521];\n\n    pub fn solve_part1_faster(input: &str) -> usize {\n        let input = input.as_bytes();\n        let mut ret = 0;\n    \n        let mut index = 0;\n        while index < input.len() {\n            if input[index] != b'B' { break; }\n\n            let a_start = 23 + (input[index+22] != b' ') as usize;\n            let a = (input[index+a_start] & 3) as usize;\n            let b = (input[index+a_start+2] & 3) as usize;\n            let o = (input[index+a_start+4] & 3) as usize;\n            let afo = (input[a_start + 15 + (o<<1) + o] & 3) as usize;\n            let rea = (input[index + 9 + (a<<1) + a] & 3) as usize;\n            let reb = (input[index + 9 + (b<<1) + b] & 3) as usize;\n            ret += ((LOOKUP[(a<<4) | (b<<2) | rea] >> ((reb<<2) | afo)) & 0x01) as usize;\n            index += a_start + 28;\n        }\n\n        ret\n    }\n\nI got it down to 5 microseconds... but somewhat evil :)\n\n[Card] finding the secret undocumented Kaby Lake documentation", "id": "ebwk3yw", "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "A concise way to solve problem 1 in Python 3\n\n```python\nfrom re import findall\n\n\ndef optResultMatch(before, after, index, result):\n    \"\"\"Checks, whether the result of an opt code on a set of registers before\n    match the result after.\"\"\"\n    return int(before[:index] + [result] + before[(index + 1):] == after)\n\n\ndef workingOptCodes(b, a, i):\n    \"\"\"Test all of the opt-codes and return the number of those that work.\"\"\"\n    return sum([optResultMatch(b, a, i[3], ocode(b, i)) for ocode in optcodes])\n\n\n# the optcodes as lambda functions that take registers and instructions\noptcodes = [lambda reg, inst: reg[inst[1]] + reg[inst[2]],          # addr\n            lambda reg, inst: reg[inst[1]] + inst[2],               # addi\n            lambda reg, inst: reg[inst[1]] * reg[inst[2]],          # mulr\n            lambda reg, inst: reg[inst[1]] * inst[2],               # muli\n            lambda reg, inst: reg[inst[1]] & reg[inst[2]],          # banr\n            lambda reg, inst: reg[inst[1]] & inst[2],               # bani\n            lambda reg, inst: reg[inst[1]] | reg[inst[2]],          # borr\n            lambda reg, inst: reg[inst[1]] | inst[2],               # bori\n            lambda reg, inst: reg[inst[1]],                         # setr\n            lambda reg, inst: inst[1],                              # seti\n            lambda reg, inst: int(inst[1] > reg[inst[2]]),          # gtir\n            lambda reg, inst: int(reg[inst[1]] > inst[2]),          # gtri\n            lambda reg, inst: int(reg[inst[1]] > reg[inst[2]]),     # gtrr\n            lambda reg, inst: int(inst[1] == reg[inst[2]]),         # eqir\n            lambda reg, inst: int(reg[inst[1]] == inst[2]),         # eqri\n            lambda reg, inst: int(reg[inst[1]] == reg[inst[2]])]    # eqrr\n\n\ninput = open(\"16.in\", \"r\")\ndata = input.read().splitlines()\n\ni, total = 0, 0\nwhile data[i] != \"\":\n    before = [int(number) for number in findall(\"\\d+\", data[i])]\n    after = [int(number) for number in findall(\"\\d+\", data[i + 2])]\n    instruction = [int(s) for s in data[i + 1].split(\" \")]\n\n    if workingOptCodes(before, after, instruction) >= 3:\n        total += 1\n\n    i += 4\n\nprint(total)\n```", "id": "ebwl5w1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Python, 59 lines:\n\n    import itertools\n    import re\n    import random\n\n    ops = [\n        lambda r, a, b: r[a] + r[b],\n        lambda r, a, b: r[a] + b,\n        lambda r, a, b: r[a] * r[b],\n        lambda r, a, b: r[a] * b,\n        lambda r, a, b: r[a] & r[b],\n        lambda r, a, b: r[a] & b,\n        lambda r, a, b: r[a] | r[b],\n        lambda r, a, b: r[a] | b,\n        lambda r, a, b: r[a],\n        lambda r, a, b: a,\n        lambda r, a, b: int(a > r[b]),\n        lambda r, a, b: int(r[a] > b),\n        lambda r, a, b: int(r[a] > r[b]),\n        lambda r, a, b: int(a == r[b]),\n        lambda r, a, b: int(r[a] == b),\n        lambda r, a, b: int(r[a] == r[b])\n    ]\n\n    def apply(reg, op, a, b, c):\n        return reg[:c] + [op(reg, a, b)] + reg[c+1:]\n\n    part_a = 0\n    edges = [set(range(len(ops))) for _ in ops] # my number -> {possible their number}\n    for l1, l2, l3, _ in itertools.zip_longest(*[open('16_1.in')]*4):\n        reg1 = [int(v) for v in re.findall('\\d+', l1)]\n        opcode, a, b, c = [int(v) for v in re.findall('\\d+', l2)]\n        reg2 = [int(v) for v in re.findall('\\d+', l3)]\n\n        possibilities = 0\n        for i, op in enumerate(ops):\n            if apply(reg1, op, a, b, c) == reg2:\n                possibilities += 1\n            else:\n                edges[i].discard(opcode)\n\n        if possibilities >= 3:\n            part_a += 1\n    print('Part A:', part_a)\n\n    ass = [-1]*len(ops) # their number -> my number\n    def assign(v):\n        w = random.choice(list(edges[v]))\n        u, ass[w] = ass[w], v\n        if u != -1: assign(u)\n    for i in range(len(ops)):\n        assign(i)\n\n    reg = [0]*4\n    for line in open('16_2.in'):\n        opcode, a, b, c = [int(v) for v in re.findall('\\d+', line)]\n        reg[c] = ops[ass[opcode]](reg, a, b)\n\n    print('Part B:', reg)", "id": "ebwly02", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "**Red**\n\nParts 1 and 2\n\n    Red []\n    ;;;; Part 1\n    input: replace/all read %input comma \"\"\n    ops: [\n        addr [before/(C + 1): before/(A + 1) + before/(B + 1)]\n        addi [before/(C + 1): before/(A + 1) + B]\n        mulr [before/(C + 1): before/(A + 1) * before/(B + 1)]\n        muli [before/(C + 1): before/(A + 1) * B]\n        banr [before/(C + 1): before/(A + 1) and before/(B + 1)]\n        bani [before/(C + 1): before/(A + 1) and B]\n        borr [before/(C + 1): before/(A + 1) or before/(B + 1)]\n        bori [before/(C + 1): before/(A + 1) or B]\n        setr [before/(C + 1): before/(A + 1)]\n        seti [before/(C + 1): A]\n        gtir [before/(C + 1): make integer! A > before/(B + 1)]\n        gtri [before/(C + 1): make integer! before/(A + 1) > B]\n        gtrr [before/(C + 1): make integer! before/(A + 1) > before/(B + 1)]\n        eqir [before/(C + 1): make integer! A = before/(B + 1)]\n        eqri [before/(C + 1): make integer! before/(A + 1) = B]\n        eqrr [before/(C + 1): make integer! before/(A + 1) = before/(B + 1)]\n    ]\n    op-nums: repeat i 16 [append [] i - 1]\n    foreach [op _] ops [set op copy op-nums]\n\n    count0: 0\n    parse input [some [\n        copy before thru newline (do before)\n        copy instruction thru newline (set [op* A B C] load instruction)\n        copy after thru 2 newline (do after)\n        (   \n            count: 0\n            _C: before/(C + 1)\n            foreach [op code] ops [\n                do code \n                either after = before [count: count + 1][remove find get op op*]\n                before/(C + 1): _C\n            ]\n            count0: count0 + make integer! count >= 3\n        )\n    ]]\n    print [\"Part 1:\" count0]\n\n    ;;;; Part 2\n    op-list: foreach [op _] ops [append [] op]\n    forall op-list [\n        sort/compare either 1 = length? get op-list/1 [next op-list][op-list] \n            func [a b][(length? get a) < (length? get b)]\n        foreach op next op-list [remove find get op first get op-list/1]\n    ]\n    foreach op op-list [set op first get op]\n    ops: reduce ops\n    before: [0 0 0 0]\n    foreach [op A B C] load %tests [do select ops op]\n    print [\"Part 2:\" before/1]\n", "id": "ebwlzn3", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Python3, part1 in 43 lines\n\n    import operator\n    from functools import partial\n    import re\n\n    def instruction(op, A_type, B_type, A, B, C, registers):\n        if A_type == 'r':\n            A = registers[A]\n        if B_type == 'r':\n            B = registers[B]\n        registers[C] = int(op(A, B))\n\n    # Build the set of ops\n    ops = []\n    for op in [operator.add, operator.mul, operator.and_, operator.or_]:\n        ops.append(partial(instruction, op, 'r', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n    ops.append(partial(instruction, lambda a, b: a, 'r', None))\n    ops.append(partial(instruction, lambda a, b: a, 'i', None))\n    for op in [operator.gt, operator.eq]:\n        ops.append(partial(instruction, op, 'i', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n        ops.append(partial(instruction, op, 'r', 'r'))\n\n    with open('input') as f:\n        text = f.read()\n        part1, _ = text.split('\\n\\n\\n')\n        examples = part1.split('\\n\\n')\n\n    count = 0\n    for example in examples:\n        before_str, inst_str, after_str = example.splitlines()\n        registers = [int(i) for i  in re.findall('\\d+', before_str)]\n        opcode, A, B, C = [int(i) for i  in re.findall('\\d+', inst_str)]\n        target_registers = [int(i) for i  in re.findall('\\d+', after_str)]\n\n        consistent_ops = 0\n        for op in ops:\n            registers1 = registers.copy()\n            op(A, B, C, registers1)\n            consistent_ops += (registers1 == target_registers)\n        count += (consistent_ops >= 3)\n\n    print(count)", "id": "ebwn6tw", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "python3\n\nlong and i probs didn't need to use classes, but it does the job\n\nthink some of my var naming is a little awkward\n\n    #!/usr/local/bin/python3\n    \n    import time\n    from parse import parse\n    \n    input_filename = \"../../input/input_day16.txt\"\n    \n    class InsChange:\n        def __init__(self, before, ins, result):\n            self.before = before\n            self.ins = ins\n            self.result = result\n    \n    class Rule:\n        def __init__(self, a, b, c):\n            self.a = a\n            self.b = b\n            self.c = c\n    \n        def __repr__(self):\n            return f\"{type(self)}, {self.a}, {self.b}, {self.c}\"\n    \n    class Addr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a + b\n            return state\n    \n    class Addi(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a + self.b\n            return state\n    \n    class Mulr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a * b\n            return state\n    \n    class Muli(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a * self.b\n            return state\n    \n    class Banr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a & b\n            return state\n    \n    class Bani(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a & self.b\n            return state\n    \n    class Borr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a | b\n            return state\n    \n    class Bori(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a | self.b\n            return state\n    \n    class Setr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a\n            return state\n    \n    class Seti(Rule):\n        def apply_rule(self, state):\n            state[self.c] = self.a\n            return state\n    \n    class Gtir(Rule):\n        def apply_rule(self, state):\n            b = state[self.b]\n            if self.a > b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Gtri(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            if a > self.b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Gtrr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            if a > b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Eqir(Rule):\n        def apply_rule(self, state):\n            b = state[self.b]\n            if self.a == b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Eqri(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            if a == self.b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Eqrr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            if a == b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    def apply_rule(applying, part1=True):\n        ins_list = [Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori,\n                    Setr, Seti, Gtir, Gtri, Gtrr, Eqir, Eqri, Eqrr]\n        applied = [(ins, ins(*applying.ins[1:]).apply_rule(applying.before[:])) for ins in ins_list]\n        if part1:\n            return len([res for ins, res in applied if res == applying.result])\n        else:\n            return [ins for ins, res in applied if res == applying.result]\n    \n    def setup():\n        with open(input_filename) as f:\n            lines = f.read().splitlines()\n            prev_space = False\n            part1_ins = []\n            part2_ins = []\n            lines = iter(lines)\n            while True:\n                line = next(lines)\n                if line == '':\n                    if prev_space:\n                        next(lines)\n                        for line in lines:\n                            part2_ins.append(tuple(parse('{:d} {:d} {:d} {:d}', line)))\n                        return part1_ins, part2_ins\n                    prev_space = True\n                else:\n                    prev_space = False\n                    before = list(parse(\"Before: [{:d}, {:d}, {:d}, {:d}]\", line))\n                    ins = tuple(parse(\"{:d} {:d} {:d} {:d}\", next(lines)))\n                    after = list(parse(\"After:  [{:d}, {:d}, {:d}, {:d}]\", next(lines)))\n                    part1_ins.append(InsChange(before, ins, after))\n            return part1, part2\n    \n    def part1(ins_list):\n        total = 0\n        for ins in ins_list:\n            if apply_rule(ins) >= 3:\n                total += 1\n        return total\n    \n    def part2(ins_list, actual_data):\n        opcodes = {}\n        for ins in ins_list:\n            res = apply_rule(ins, False)\n            if ins.ins[0] in opcodes:\n                opcodes[ins.ins[0]] = opcodes[ins.ins[0]] & {r for r in res}\n            else:\n                opcodes[ins.ins[0]] = {r for r in res}\n    \n        actual = {}\n        while len(actual) < 16:\n            for k, v in opcodes.items():\n                if len(v) == 1:\n                    ins = v.pop()\n                    actual[k] = ins\n                    for code in opcodes:\n                        if ins in opcodes[code]:\n                            opcodes[code].remove(ins)\n    \n        opcodes = actual\n        state = [0, 0, 0, 0]\n        for ins in actual_data:\n            apply = opcodes[ins[0]](*ins[1:])\n            apply.apply_rule(state)\n        return state[0]\n    \n    def main():\n        start_setup = time.time()\n        ins1, ins2 = setup()\n        end_setup = time.time()\n    \n        start_part1 = time.time()\n        res_part1 = part1(ins1)\n        end_part1 = time.time()\n    \n        start_part2 = time.time()\n        res_part2 = part2(ins1, ins2)\n        end_part2 = time.time()\n    \n        print(f\"part 1: {res_part1}\")\n        print(f\"part 2: {res_part2}\")\n        print(f\"setup took {end_setup - start_setup} seconds\")\n        print(f\"part 1 took {end_part1 - start_part1} seconds\")\n        print(f\"part 2 took {end_part2 - start_part2} seconds\")\n        print(f\"overall took {end_part2 - start_setup} seconds\")\n    \n    if __name__ == '__main__':\n        main()\n", "id": "ebwnde4", "owner_tier": 0.7, "score": -3.703703681194552e-10}, {"content": "Haskell!\n\n[CARD] the secret technique to beating today's puzzle is -SPREADSHEETS-\n\np1- https://github.com/Benjmhart/AdventOfCode2018-haskell/blob/master/day16-1.hs\n\np2 - https://github.com/Benjmhart/AdventOfCode2018-haskell/blob/master/day16-2.hs", "id": "ebwqnp1", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "Python3, part 2 in 69 lines:\n\n    import re\n    import operator\n    from functools import partial\n\n\n    def instruction(op, A_type, B_type, A, B, C, registers):\n        if A_type == 'r':\n            A = registers[A]\n        if B_type == 'r':\n            B = registers[B]\n        registers[C] = int(op(A, B))\n\n    ops = []\n    for op in [operator.add, operator.mul, operator.and_, operator.or_]:\n        ops.append(partial(instruction, op, 'r', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n    ops.append(partial(instruction, lambda a, b: a, 'r', None))\n    ops.append(partial(instruction, lambda a, b: a, 'i', None))\n    for op in [operator.gt, operator.eq]:\n        ops.append(partial(instruction, op, 'i', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n        ops.append(partial(instruction, op, 'r', 'r'))\n\n\n    with open('input') as f:\n        text = f.read()\n    part1, part2 = text.split('\\n\\n\\n')\n    examples, program = part1.split('\\n\\n'), part2[1:]\n\n\n    # Record which ops are consistent with the behaviour observed for each opcode\n    opcode_consistent = {i: set(ops) for i in range(16)}\n    for example in examples:\n        before_str, inst_str, after_str = example.splitlines()\n        r = [int(i) for i  in re.findall('\\d+', before_str)]\n        opcode, A, B, C = [int(i) for i  in re.findall('\\d+', inst_str)]\n        target_r = [int(i) for i  in re.findall('\\d+', after_str)]\n\n        consistent = opcode_consistent[opcode]\n        for op in consistent.copy():\n            r1 = r.copy()\n            op(A, B, C, r1)\n            if r1 != target_r:\n                consistent.remove(op)\n\n\n    # Once we've gone through all the examples, any op that is only consistent\n    # with a single opcode cannot be consistent with any other opcode.\n    # Repeatedly remove such ops from other opcodes.\n    opcodes = {}\n    while True:\n        try:\n            opcode, op_set = next((opcode, ops.copy()) for opcode, ops in opcode_consistent.items() if len(ops) == 1)\n        except StopIteration:\n            break\n\n        opcodes[opcode] = next(iter(op_set))\n        for consistent in opcode_consistent.values():\n            consistent.difference_update(op_set)\n        del(opcode_consistent[opcode])\n\n\n    # Run the program\n    r = [0, 0, 0, 0]\n    for line in program.splitlines():\n        opcode, A, B, C = [int(i) for i  in re.findall('\\d+', line)]\n        opcodes[opcode](A, B, C, r)\n\n    print(r[0])", "id": "ebwsdz8", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "Haskell.\n\nCard: The secret technique to beat today's puzzles is `99 Lines of Haskell fun`.\n\n    import Data.List\n    import Data.Bits\n    \n    data State = State Int Int Int Int deriving (Show, Eq)\n    data Opcode = Addr | Addi | Mulr | Muli | Banr | Bani | Borr | Bori | Setr | Seti | Gtir | Gtri | Gtrr | Eqir | Eqri | Eqrr deriving (Show, Eq)\n    data Op = Op Int Int Int Int deriving (Show, Eq)\n    data Sample = Sample State Op State deriving (Show, Eq)\n    \n    opCodeList :: [Opcode]\n    opCodeList = [Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori, Setr, Seti, Gtir, Gtri, Gtrr, Eqir, Eqri, Eqrr]\n    \n    opList :: [State -> Op -> State]\n    opList = pure operate <*> opCodeList\n    \n    split :: String -> String -> String -> [String]\n    split str sep acc\n        | str == [] = [reverse acc]\n        | take (length sep) str == sep = (reverse acc) : (split (drop (length sep) str) sep \"\")\n        | otherwise = let (x:xs) = str in split xs sep (x : acc)\n    \n    readState :: String -> State\n    readState str =\n        let [a, b, c, d] = map (\\x -> read x :: Int) (split ((drop 9 . takeWhile (/= ']')) str) \", \" \"\")\n        in State a b c d\n    \n    readOp :: String -> Op\n    readOp str = \n        let [op, a, b, c] = map(\\x -> read x :: Int) (words str)\n        in Op op a b c\n    \n    getReg :: State -> Int -> Int\n    getReg (State a _ _ _) 0 = a\n    getReg (State _ b _ _) 1 = b\n    getReg (State _ _ c _) 2 = c\n    getReg (State _ _ _ d) 3 = d\n    \n    setReg :: State -> Int -> Int -> State\n    setReg (State _ b c d) 0 v = State v b c d\n    setReg (State a _ c d) 1 v = State a v c d\n    setReg (State a b _ d) 2 v = State a b v d\n    setReg (State a b c _) 3 v = State a b c v\n    \n    operate :: Opcode -> State -> Op -> State\n    operate Addr state (Op _ a b c) = setReg state c $ (getReg state a)  + (getReg state b)\n    operate Addi state (Op _ a b c) = setReg state c $ (getReg state a)  + b\n    operate Mulr state (Op _ a b c) = setReg state c $ (getReg state a)  * (getReg state b)\n    operate Muli state (Op _ a b c) = setReg state c $ (getReg state a)  * b\n    operate Banr state (Op _ a b c) = setReg state c $ (getReg state a) .&. (getReg state b)\n    operate Bani state (Op _ a b c) = setReg state c $ (getReg state a) .&. b\n    operate Borr state (Op _ a b c) = setReg state c $ (getReg state a) .|. (getReg state b)\n    operate Bori state (Op _ a b c) = setReg state c $ (getReg state a) .|. b\n    operate Setr state (Op _ a _ c) = setReg state c $ (getReg state a)\n    operate Seti state (Op _ a _ c) = setReg state c $ a\n    operate Gtir state (Op _ a b c) = setReg state c $ if a > (getReg state b) then 1 else 0\n    operate Gtri state (Op _ a b c) = setReg state c $ if (getReg state a) > b then 1 else 0\n    operate Gtrr state (Op _ a b c) = setReg state c $ if (getReg state a) > (getReg state b) then 1 else 0\n    operate Eqir state (Op _ a b c) = setReg state c $ if a == (getReg state b) then 1 else 0\n    operate Eqri state (Op _ a b c) = setReg state c $ if (getReg state a) == b then 1 else 0\n    operate Eqrr state (Op _ a b c) = setReg state c $ if (getReg state a) == (getReg state b) then 1 else 0\n    \n    filterOutAmbiguities :: [[Opcode]] -> [Opcode]\n    filterOutAmbiguities ops\n        | all ((==1) . length) ops = map head ops\n        | otherwise =\n            let determined = map head . filter ((==1) . length) $ ops\n            in filterOutAmbiguities . map (\\xs -> if length xs == 1 then xs else xs \\\\ determined) $ ops\n    \n    analyze :: [Sample] -> [[Opcode]] -> [State -> Op -> State]\n    analyze [] ops = map operate . filterOutAmbiguities $ ops\n    analyze ((Sample before op@(Op opcode _ _ _) after):xs) ops = analyze xs newops\n        where\n            current = ops!!opcode\n            filtered = filter (\\x -> operate x before op == after) current\n            newops = (take opcode ops) ++ filtered : (drop (opcode + 1) ops)\n    \n    execute :: [State -> Op -> State] -> [Op] -> State -> State\n    execute _ [] state = state\n    execute ops (op@(Op opcode _ _ _):xs) state = execute ops xs $ (ops!!opcode) state op\n    \n    part1 :: [Sample] -> Int\n    part1 = length . filter (\\(Sample before op after) -> (length . filter (==after) $ opList <*> pure before <*> pure op) >= 3)\n    \n    part2 :: [Sample] -> [Op] -> Int\n    part2 samples program = let (State a _ _ _) = execute (analyze samples (replicate 16 opCodeList)) program (State 0 0 0 0) in a\n    \n    main :: IO()\n    main = do\n        f <- readFile(\"16.in\")\n        let [inp1, inp2] = split f \"\\n\\n\\n\\n\" \"\"\n        let input1 = [ Sample (readState l1) (readOp l2) (readState l3) | sp <- split inp1 \"\\n\\n\" \"\", let [l1, l2, l3] = lines sp]\n        let input2 = [ readOp x | x <- lines inp2]\n        putStrLn \"Solution for part 1:\"\n        print $ part1 input1\n        putStrLn \"Solution for part 2:\"\n        print $ part2 input1 input2\n\nOk, they are actually just 95 lines.\n\n&#x200B;\n\nTo disambigue the opcodes, I just filtered them repeatedly until every ambiguity was resolved, removing the lone opcodes from the groups.\n\n\\[1,2\\] \\[1\\] -> \\[1\\] \\[2\\]", "id": "ebwvnno", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "My elixir solution: [Github link](https://github.com/acmfi/AdventCode/blob/master/2018/day16/rock/solve.ex)\n\nAnother one in Elixir :) Not as elegant as your though.\n\n[Gist](https://gist.github.com/bartlomiej-korpus/9d858ad4fcf5793018f9167ade460936)", "id": "ebwwwn4", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "Python3\n\n```python\nfrom aocd import get_data\nfrom dataclasses import dataclass, field\nfrom typing import List\nfrom collections import defaultdict\n\n\n@dataclass\nclass Sample:\n    before: List\n    instr: List\n    after: List\n    behaves_like: List = field(default_factory=list)\n    \n\nclass Solver16:\n    def __init__(self, inp):\n        self.samples = []\n        self.test = []\n        self.mapping = defaultdict(list)\n        it = iter(inp.split('\\n'))\n        \n        while True:\n            try:\n                line = next(it)\n                if not line:\n                    break  # next would be test program\n                before = list(map(int, line[9:-1].split(', ')))\n                line = next(it)\n                instr = list(map(int, line.split(' ')))\n                line = next(it)\n                after = list(map(int, line[9:-1].split(', ')))\n                self.samples.append(Sample(before=before, instr=instr, after=after))\n                next(it)  # skip blank line\n            except StopIteration:\n                break\n                \n        while True:\n            try:\n                line = next(it)\n                if not line:\n                    continue\n                instr = list(map(int, line.split(' ')))\n                self.test.append(instr)\n            except StopIteration:\n                break\n            \n    def execute(self, opcode, instr, regs):\n        if opcode is None and instr[0] in self.mapping and len(self.mapping[instr[0]]) == 1:\n            opcode = self.mapping[instr[0]][0]   \n        if opcode is None:\n            raise Exception(f'{instr[0]} ambiguous')\n\n        if opcode == 'addr' or opcode == 0:\n            regs[instr[3]] = regs[instr[1]] + regs[instr[2]]\n        if opcode == 'addi' or opcode == 1:\n            regs[instr[3]] = regs[instr[1]] + instr[2]\n        if opcode == 'mulr' or opcode == 2:\n            regs[instr[3]] = regs[instr[1]] * regs[instr[2]]\n        if opcode == 'muli' or opcode == 3:\n            regs[instr[3]] = regs[instr[1]] * instr[2]\n        if opcode == 'banr' or opcode == 4:\n            regs[instr[3]] = regs[instr[1]] & regs[instr[2]]\n        if opcode == 'bani' or opcode == 5:\n            regs[instr[3]] = regs[instr[1]] & instr[2]\n        if opcode == 'borr' or opcode == 6:\n            regs[instr[3]] = regs[instr[1]] | regs[instr[2]]\n        if opcode == 'bori' or opcode == 7:\n            regs[instr[3]] = regs[instr[1]] | instr[2]\n        if opcode == 'setr' or opcode == 8:\n            regs[instr[3]] = regs[instr[1]]\n        if opcode == 'seti' or opcode == 9:\n            regs[instr[3]] = instr[1]\n        if opcode == 'gtir' or opcode == 10:\n            regs[instr[3]] = 1 if instr[1] > regs[instr[2]] else 0\n        if opcode == 'gtri' or opcode == 11:\n            regs[instr[3]] = 1 if regs[instr[1]] > instr[2] else 0\n        if opcode == 'gtrr' or opcode == 12:\n            regs[instr[3]] = 1 if regs[instr[1]] > regs[instr[2]] else 0\n        if opcode == 'eqir' or opcode == 13:\n            regs[instr[3]] = 1 if instr[1] == regs[instr[2]] else 0\n        if opcode == 'eqri' or opcode == 14:\n            regs[instr[3]] = 1 if regs[instr[1]] == instr[2] else 0\n        if opcode == 'eqrr' or opcode == 15:\n            regs[instr[3]] = 1 if regs[instr[1]] == regs[instr[2]] else 0\n        \n    def solve(self):\n        for sample in self.samples:\n            for opcode in range(16):\n                regs = sample.before[:]\n                self.execute(opcode, sample.instr, regs)\n                if sample.after == regs:\n                    if opcode not in self.mapping[sample.instr[0]]:\n                        self.mapping[sample.instr[0]].append(opcode)\n                    sample.behaves_like.append(opcode)\n        \n        return sum([1 for x in self.samples if len(x.behaves_like) >= 3])\n    \n    def eliminate_dups(self):\n        while True:\n            changed = False\n            \n            to_remove = []\n            not_touch = []\n            for op, maps in self.mapping.items():\n                if len(maps) == 1:\n                    to_remove.append(maps[0])\n                    not_touch.append(op)\n                    \n            for remove in to_remove:\n                for op, maps in self.mapping.items():\n                    if remove in maps and op not in not_touch:\n                        maps.remove(remove)\n                        changed = True\n            \n            if not changed:\n                break\n    \n    def solve2(self):\n        self.solve()\n        self.eliminate_dups()\n\n        regs = [0] * 4\n        for test in self.test:\n            self.execute(None, test, regs)\n        \n        return regs[0]\n        \n\nsolver = Solver16(get_data(day=16, year=2018))\nprint(solver.solve())\nprint(solver.solve2())\n\n\n```", "id": "ebwzl2o", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Well, one fun today. Yesterday is still pending ... My solution is quite extense because I implemented some classes and enums for the opcodes.\n\n[https://github.com/blfuentes/AdventOfCode\\_2018/tree/master/day16](https://github.com/blfuentes/AdventOfCode_2018/tree/master/day16)\n\n**Typescript**\n\n\"happy\" with the algorithm I created to resolve the opcodes.\n\n    function operatorsToResolve(){\n    \treturn operatorDictionary.filter(_o => _o.length > 0).length > 0;\n    }\n    \n    let operatorsSolution: Array<OperatorType> = [];\n    \n    function resolveOpCodes() {\n    \tlet tmpOperator = operatorDictionary.find(_o => _o.length == 1);\n    \tlet initialOperator = -1;\n    \tlet index = -1;\n    \tif (tmpOperator != undefined) {\n    \t\tindex = operatorDictionary.indexOf(tmpOperator);\n    \t\tinitialOperator = tmpOperator[0];\n    \t\ttmpOperator.pop();\n    \t\toperatorsSolution[index] = initialOperator;\n    \t}\n    \twhile (operatorsToResolve()) {\n    \t\t// find next \n    \t\tfor (let operator of operatorDictionary) {\n    \t\t\tindex = operator.indexOf(initialOperator);\n    \t\t\tif (index != -1) {\n    \t\t\t\toperator.splice(index, 1);\n    \t\t\t}          \n    \t\t}\n    \t\ttmpOperator = operatorDictionary.find(_o => _o.length == 1);\n    \t\tif (tmpOperator != undefined) {\n    \t\t\tindex = operatorDictionary.indexOf(tmpOperator);\n    \t\t\tinitialOperator = tmpOperator[0];\n    \t\t\ttmpOperator.pop();\n    \t\t\toperatorsSolution[index] = initialOperator;\n    \t\t}\n    \t}\n    }", "id": "ebx7q86", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Ocaml**\n\nParsing was a bit annoying in Ocaml, but the rest is a breeze. Used Sets to keep track of possible values for each op-code, and set intersection/difference to remove the impossible values for each of them. Note that the input was crafted so that we didn't need any backtracking, so I\u00a0didn't bother implementing one.\n\n```\ntype instruction = {\n  code : int;\n  a : int;\n  b : int;\n  c : int;\n};;\ntype sample = {\n  before : int array;\n  after : int array;\n  instr : instruction;\n};;\n\ntype op =\n  | Mulr | Muli\n  | Addr | Addi\n  | Banr | Bani\n  | Borr | Bori\n  | Setr | Seti\n  | Gtir | Gtri | Gtrr\n  | Eqir | Eqri | Eqrr\n  | UKN;;\n\nlet execr reg i f = reg.(i.c) <- (f reg.(i.a) reg.(i.b));;\nlet execi reg i f = reg.(i.c) <- (f reg.(i.a) i.b);;\n\nlet exec_comp reg i f a b = reg.(i.c) <- (if (f a b) then 1 else 0);;\n\nlet process reg i = function\n  | Mulr -> execr reg i ( * );\n  | Muli -> execi reg i ( * );\n  | Addr -> execr reg i (+);\n  | Addi -> execi reg i (+);\n  | Banr -> execr reg i (land);\n  | Bani -> execi reg i (land);\n  | Borr -> execr reg i (lor);\n  | Bori -> execi reg i (lor);\n  | Setr -> reg.(i.c) <- reg.(i.a);\n  | Seti -> reg.(i.c) <- i.a;\n  | Gtir -> exec_comp reg i (>) i.a reg.(i.b);\n  | Gtri -> exec_comp reg i (>) reg.(i.a) i.b;\n  | Gtrr -> exec_comp reg i (>) reg.(i.a) reg.(i.b);\n  | Eqir -> exec_comp reg i (==) i.a reg.(i.b);\n  | Eqri -> exec_comp reg i (==) reg.(i.a) i.b ;\n  | Eqrr -> exec_comp reg i (==) reg.(i.a) reg.(i.b);\n  | UKN -> failwith \"unknown op code\";;\n\nlet all_ops =  Mulr :: Muli :: Addr :: Addi :: Banr :: Bani :: Borr :: Bori :: Setr :: Seti :: Gtir :: Gtri :: Gtrr :: Eqir :: Eqri :: Eqrr :: [];;\n\nlet make_instr co a b c = {code = co; a = a; b = b; c = c};;\n\nlet make_sample i1 i2 i3 i4 co a b c j1 j2 j3 j4 =\n  let before = [|i1; i2; i3; i4|] and after = [|j1; j2; j3; j4|] in\n  {before = before; after = after; instr = make_instr co a b c};;\n\n\nlet rec parse =  function () ->\ntry\n  let l1 = read_line () in\n  if l1.[0] != 'B' then failwith \"end\";\n  let l2 = read_line () and l3 = read_line () and l4 = read_line () in\n  let inp = l1 ^ \"\\n\" ^ l2 ^  \"\\n\" ^ l3 ^  \"\\n\" ^ l4 ^ \"\\n\" in\n  let s = Scanf.sscanf inp \"Before: [%d, %d, %d, %d]\\n%d %d %d %d\\nAfter:  [%d, %d, %d, %d]\\n\\n\" make_sample in\n  s :: (parse ());\nwith _ -> [] ;;\n\nlet l = parse ();;\n\nlet _ = read_line ();;\n\nlet rec parse_instr =  function () ->\ntry\n  let l = read_line () in\n  let s = Scanf.sscanf l \"%d %d %d %d\" make_instr in\n  s :: (parse_instr ());\nwith _ -> [] ;;\n\nlet all_instr = parse_instr ();;\n\nlet matches s oper =\n  let in_reg = Array.init 4 (fun i -> s.before.(i)); in\n  process in_reg s.instr oper;\n  s.after = in_reg;;\n\nlet result = List.fold_left (fun sum spl ->\n    let match_count = List.fold_left (fun sum m -> sum + (if (matches spl m) then 1 else 0)) 0 all_ops in\n    sum + (if match_count >= 3 then 1 else 0)\n  ) 0 l ;;\n\nPrintf.printf \"Part 1 = %d\\n\" result;;\n\nmodule OpSet = Set.Make(\n  struct\n    let compare = Pervasives.compare\n    type t = op\n  end );;\n\nlet possible_ops = Array.init (List.length all_ops) (fun _-> OpSet.of_list all_ops) ;;\n\n(* filter based on input *)\nList.iter (fun spl ->\n    let matching = List.filter (matches spl) all_ops in\n    let possible = OpSet.of_list matching in\n    possible_ops.(spl.instr.code) <- OpSet.inter possible_ops.(spl.instr.code) possible\n  ) l;;\n\nlet true_ops = Array.make (List.length all_ops) UKN;;\n\n(* filter based on already known operation. Note that this is greedy, in general we would need to backtrack if needed*)\nwhile (Array.exists (fun o -> match o with |UKN->true |_->false) true_ops) do\n  let affected = OpSet.of_seq (Seq.filter_map (fun ops ->\n      if OpSet.cardinal ops == 1 then Some (OpSet.choose ops) else None)\n      (Array.to_seq possible_ops)) in\n  Array.iteri (fun i ops ->\n      if (OpSet.cardinal ops) > 1 then\n        possible_ops.(i) <- OpSet.diff ops affected\n      else\n        true_ops.(i) <- OpSet.choose ops) possible_ops;\ndone;;\n\nlet reg = Array.make 4 0;;\n\n\n(* execute program *)\nList.iter (fun i -> process reg i true_ops.(i.code)) all_instr;;\n\nPrintf.printf \"Part 2 = %d\\n\" reg.(0);;\n```", "id": "ebxgwvb", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Clojure\n\n&#x200B;\n\n    (def input (clojure.string/split (slurp \"input.txt\") #\"\\r\\n\"))\n    \n    (defn read-state [line]\n      (mapv\n        read-string\n        (rest (re-matches #\"Before: \\[(\\d+), (\\d+), (\\d+), (\\d+)\\]\" line))))\n    \n    (defn read-op [line]\n      (mapv read-string (rest (re-matches #\"(\\d+) (\\d+) (\\d+) (\\d+)\" line))))\n    \n    (defn load-line [[before cmd after _]]\n     [(read-state before) (read-op cmd) (read-state after)])\n    \n    (def commands (->> input (take 3112) (partition 4) (map load-lines)))\n    \n    (def prog (->> input (drop 3114) (map read-op)))\n    \n    (defn addr [r [a b c]] (assoc r c (+ (r a) (r b))))\n    (defn addi [r [a b c]] (assoc r c (+ (r a) b)))\n    (defn mulr [r [a b c]] (assoc r c (* (r a) (r b))))\n    (defn muli [r [a b c]] (assoc r c (* (r a) b)))\n    (defn banr [r [a b c]] (assoc r c (bit-and (r a) (r b))))\n    (defn bani [r [a b c]] (assoc r c (bit-and (r a) b)))\n    (defn borr [r [a b c]] (assoc r c (bit-or (r a) (r b))))\n    (defn bori [r [a b c]] (assoc r c (bit-or (r a) b)))\n    (defn setr [r [a b c]] (assoc r c (r a)))\n    (defn seti [r [a b c]] (assoc r c a))\n    (defn gtir [r [a b c]] (assoc r c (if (> a (r b)) 1 0)))\n    (defn gtri [r [a b c]] (assoc r c (if (> (r a) b) 1 0)))\n    (defn gtrr [r [a b c]] (assoc r c (if (> (r a) (r b)) 1 0)))\n    (defn eqir [r [a b c]] (assoc r c (if (= a (r b)) 1 0)))\n    (defn eqri [r [a b c]] (assoc r c (if (= (r a) b) 1 0)))\n    (defn eqrr [r [a b c]] (assoc r c (if (= (r a) (r b)) 1 0)))\n    \n    (def ops [addi addr muli mulr bani banr bori borr\n              seti setr gtir gtri gtrr eqir eqri eqrr])\n    \n    (defn op-match [line]\n     (filter\n       (fn [op] (= (op (first line) (rest (second line))) (last line)))\n       ops))\n    \n    (defn at-least-three-ops [line]\n      (<= 3 (count (op-match line))))\n    \n    (prn (count (filter at-least-three-ops commands)))\n    \n    ;; manually determined\n    (def cmd-map {7 bori 0 muli 14 mulr 2 addi 12 addr\n                  11 borr 6 setr 1 bani 15 banr\n                  3 seti 5 eqir 13 gtrr 4 eqrr 8 gtri\n                  9 eqri 10 gtir})\n    \n    (def op-maps (map (fn [x] [(first (second x)) (op-match x)]) commands))\n    \n    (defn run-cmd [state line]\n     ((cmd-map (first line)) state (rest line)))\n    \n    (prn (reduce run-cmd [0 0 0 0] prog))", "id": "ebxijb9", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Loved the challenge! \n\nNode.js solution: [https://github.com/fhinkel/AdventOfCode2018/blob/master/day16.js](https://github.com/fhinkel/AdventOfCode2018/blob/master/day16.js)", "id": "ebxitbp", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Not as bad as day 15's. Pretty standard python code.\n\n    import re\n    from collections import defaultdict\n    from collections import Counter\n    from itertools import dropwhile\n    inplines = open('day16_input.txt').read().splitlines()\n    count = 0\n    counter = defaultdict(Counter)\n\n    pat1 = re.compile(r'(\\[.+\\])')\n    pat2= re.compile(r'(\\d+)')\n    before = []\n    opcode = []\n    after = []\n\n    for line_index, line in enumerate(inplines):    \n        if line == '':\n            count+=1\n            if count == 3:\n                line_index+=1\n                break\n            continue\n        count = 0\n\n        if 'Before' in line:\n                before.append(eval(pat1.findall(line)[0]))\n        elif 'After'in line:\n                after.append(eval(pat1.findall(line)[0]))\n        else: \n            opcode.append([int(n) for n in pat2.findall(line)])\n        \n    def addr(register, input):\n        A, B, C = input\n        register[C] = register[A] + register[B]\n        return register\n\n    def addi(register, input):\n        A, B, C = input\n        register[C] = register[A] + B\n        return register\n\n    def mulr(register, input):\n        A, B, C = input\n        register[C] = register[A] * register[B]\n        return register\n\n    def muli(register, input):\n        A, B, C = input\n        register[C] = register[A] * B\n        return register\n\n    def banr(register,input):\n        A, B, C = input\n        register[C] = register[A] & register[B]\n        return register\n\n    def bani(register, input):\n        A, B, C = input\n        register[C] = register[A] & B\n        return register\n\n    def borr(register, input):\n        A, B, C = input\n        register[C] = register[A] | register[B]\n        return register\n\n    def bori(register, input):\n        A, B, C = input\n        register[C] = register[A] | B\n        return register\n\n    def setr(register, input):\n        A, B, C = input\n        register[C] = register[A]\n        return register\n\n    def seti(register, input):\n        A, B, C = input\n        register[C] = A\n        return register\n\n    def gtir(register, input):\n        A, B, C = input\n        register[C] = int(A > register[B])\n        return register\n\n    def gtri(register, input):\n        A, B, C = input\n        register[C] = int(register[A] > B)\n        return register\n\n    def gtrr(register, input):\n        A, B, C = input\n        register[C] = int(register[A] > register[B])\n        return register\n\n    def eqir(register, input):\n        A, B, C = input\n        register[C] = int(A == register[B])\n        return register\n\n    def eqri(register, input):\n        A, B, C = input\n        register[C] = int(register[A] == B)\n        return register\n\n    def eqrr(register, input):\n        A, B, C = input\n        register[C] = int(register[A] == register[B])\n        return register\n\n    samplecounter = 0\n\n    for b, a, i in zip(before, after, opcode):\n        opcounter = 0    \n        for op in [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]:\n            r = b[:]\n            code, *input = i\n            if op(r, input) == a:\n                opcounter +=1\n                counter[op][i[0]] +=1\n        \n        if opcounter >= 3:\n            samplecounter+=1\n\n    print(samplecounter)\n\n    counters = sorted(list(counter.items()), key= lambda t: len(t[1]))\n\n    assigned = []\n    mapping = {}\n    while len(assigned)< 16:\n        for op, counter in counters[:]:\n            if len(counter) == 1:\n                for c in counter:\n                    assigned.append(c)\n                    mapping[c] = op\n                    counters.remove((op,counter))\n\n            else:\n                for k in counter.copy():\n                    if k in assigned:\n                        del counter[k]\n\n    r = [0,0,0,0]\n\n\n    for _, line in dropwhile(lambda t: t[0] < line_index, enumerate(inplines)):    \n        opid, *in_ = [int(n) for n in pat2.findall(line)]\n        mapping[opid](r,in_)\n\n    print(r)", "id": "ebxly5m", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Hello!\n\nTHANK YOU for this neat and easy puzzle. I don't know if you intended it to be \"easy\" but it really feels good to find a working solution in less than hour after yesterday's gigantic mess which ended in manually adding and substracting numbers to my output until the answer was accepted. :3\n\nSince I do actually have a working program and it has not happened in ages (smth like day 13), I submit it today: https://github.com/tut-tuuut/advent-of-code-shiny-giggle/blob/master/2018/16/part-1.php\n\nIt's written in PHP, with a few array_intersect (first time I used it this year), the usual regex-attack at the beginning to parse the input, and a little drop of sudoku logic to find which opcode has which number.\n\n[CARD] regexes (like every other day's puzzles, in fact)", "id": "ebxqdxm", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "My solution in Scala. The more I've done AoC the more I've loved what this language has to offer. \n\n    val TESTCASE_REGEX = \"\"\"^(\\w+):\\s+\\[([^]]*)\\]$\"\"\".r\n    val OPCODE_REGEX = \"\"\"^(\\d+(?:\\s+\\d+){3})$\"\"\".r\n    \n    type Regs = Vector[Int]\n    type Opcode = Vector[Int]\n    \n    case class MyOp(code: Int)\n    case class TestCase(inRegs: Regs, outRegs: Regs, opcode: Opcode)\n    \n    def operation(regs: Regs, op: MyOp, opcode: Opcode): Regs = {\n      val Seq(_, a, b, c) = opcode\n      regs.updated(c, op.code match {\n        case 0 => regs(a) + regs(b)\n        case 1 => regs(a) + b\n    \n        case 2 => regs(a) * regs(b)\n        case 3 => regs(a) * b\n    \n        case 4 => regs(a) & regs(b)\n        case 5 => regs(a) & b\n    \n        case 6 => regs(a) | regs(b)\n        case 7 => regs(a) | b\n    \n        case 8 => regs(a)\n        case 9 => a\n    \n        case 10 => if (a > regs(b)) 1 else 0\n        case 11 => if (regs(a) > b) 1 else 0\n        case 12 => if (regs(a) > regs(b)) 1 else 0\n    \n        case 13 => if (a == regs(b)) 1 else 0\n        case 14 => if (regs(a) == b) 1 else 0\n        case 15 => if (regs(a) == regs(b)) 1 else 0\n      })\n    }\n    val allOps = 0 to 15 map {MyOp(_)}\n    \n    val (testcases, instructions) = {\n      val input = scala.io.Source.fromFile(\"input\").getLines.toVector\n      val instructionPos = input.lastIndexWhere { x => TESTCASE_REGEX.findFirstMatchIn(x).isDefined } + 1\n      val (unparsedTestCases, unparsedInstructions) = input.splitAt(instructionPos)\n    \n      val testcases =\n        unparsedTestCases.sliding(3).collect {\n          case Seq(TESTCASE_REGEX(\"Before\", input),\n                   OPCODE_REGEX(v),\n                   TESTCASE_REGEX(\"After\", output)) =>\n            TestCase(inRegs = input.split(\", \").map(_.toInt).toVector,\n                     outRegs = output.split(\", \").map(_.toInt).toVector,\n                     opcode = v.split(\" \").map(_.toInt).toVector)\n        }.toVector\n      val instructions = unparsedInstructions.collect {\n        case OPCODE_REGEX(v) => v.split(\" \").map(_.toInt).toVector\n      }\n      (testcases, instructions)\n    }\n    \n    def matchingOps(tc: TestCase) = allOps.filter { op =>\n        operation(tc.inRegs, op, tc.opcode) == tc.outRegs\n      }\n    \n    @scala.annotation.tailrec\n    def removeKnownSolutions[T](curr: Map[T, Set[MyOp]], last: Map[T, Set[MyOp]] = Map.empty[T, Nothing]): Map[T, Set[MyOp]] = {\n      if (curr == last) curr\n      else {\n        val singles = curr.values.filter(_.size == 1).reduce((a, b) => a | b)\n        removeKnownSolutions(curr.mapValues { v =>\n          if (v.size == 1) v\n          else v &~ singles\n        }, curr)\n      }\n    }\n    \n    def determineOps(tcs: Seq[TestCase]) = {\n      val byOpcode = tcs.groupBy(_.opcode(0))\n      val opcodeMeanings = removeKnownSolutions(byOpcode.mapValues(_.foldLeft(allOps.toSet)((acc, tc) => acc & matchingOps(tc).toSet)))\n      assert(opcodeMeanings.values.forall(_.size == 1))\n      opcodeMeanings.mapValues(_.head)\n    }\n    \n    def part1 = testcases.filter { t => matchingOps(t).size >= 3 }.size\n    def part2 = {\n      val realOps = determineOps(testcases)\n      val finalRegs = instructions.foldLeft(Vector(0, 0, 0, 0)) { (regs, op) => operation(regs, realOps(op(0)), op) }\n      finalRegs(0)\n    }\n    \n    println(part1)\n    println(part2)\n", "id": "ebxqmbi", "owner_tier": 0.7, "score": -3.703703681194552e-10}, {"content": "Seems like I ended up doing pretty much the same thing everyone else did :)\n\n[https://github.com/kennethdmiller3/AdventOfCode2018/tree/master/16](https://github.com/kennethdmiller3/AdventOfCode2018/tree/master/16)", "id": "ebyld0b", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "The assembly problems are usually my favorite ones each year. This one was interesting! Python:\n\n    import re\n\n    samples, program = open('input.txt').read().strip().split('\\n\\n\\n\\n')\n\n    samples = [map(lambda x: tuple(map(int, re.search(r'(\\d+),? (\\d+),? (\\d+),? (\\d+)', x).groups())), s) for s in [s.split('\\n') for s in samples.split('\\n\\n')]]\n    program = [map(int, s.split(' ')) for s in program.split('\\n')]\n\n    opcodes = {\n        'addr': lambda a, b, regs: regs[a] + regs[b],\n        'addi': lambda a, b, regs: regs[a] + b,\n        'mulr': lambda a, b, regs: regs[a] * regs[b],\n        'muli': lambda a, b, regs: regs[a] * b,\n        'banr': lambda a, b, regs: regs[a] & regs[b],\n        'bani': lambda a, b, regs: regs[a] & b,\n        'borr': lambda a, b, regs: regs[a] | regs[b],\n        'bori': lambda a, b, regs: regs[a] | b,\n        'setr': lambda a, b, regs: regs[a],\n        'seti': lambda a, b, regs: a,\n        'gtir': lambda a, b, regs: int(a > regs[b]),\n        'gtri': lambda a, b, regs: int(regs[a] > b),\n        'gtrr': lambda a, b, regs: int(regs[a] > regs[b]),\n        'eqir': lambda a, b, regs: int(a == regs[b]),\n        'eqri': lambda a, b, regs: int(regs[a] == b),\n        'eqrr': lambda a, b, regs: int(regs[a] == regs[b]),\n    }\n\n    matching_samples = {}\n    possible_matches = [set(op for op in opcodes) for _ in range(16)]\n    total = 0\n\n    for before, operation, after in samples:\n        op, a, b, c = operation\n        matching_samples[(before, operation, after)] = set()\n        matches = set()\n        for instruction, opcode in opcodes.iteritems():\n            registers = list(before)\n            registers[c] = opcode(a, b, before)\n            if registers == list(after):\n                matching_samples[(before, operation, after)].add(instruction)\n                matches.add(instruction)\n        possible_matches[op] &= matches\n        if len(matching_samples[(before, operation, after)]) >= 3:\n            total += 1\n\n    print total\n\n    disambiguated = set()\n\n    while any(len(s) > 1 for s in possible_matches):\n        for s in possible_matches:\n            if len(s) == 1:\n                disambiguated |= s\n            else:\n                s -= disambiguated\n\n    possible_matches = [s.pop() for s in possible_matches]\n    registers = [0, 0, 0, 0]\n\n    for op, a, b, c in program:\n        registers[c] = opcodes[possible_matches[op]](a, b, registers)\n\n    print registers[0]", "id": "ebyt3n5", "owner_tier": 0.9, "score": -3.703703681194552e-10}, {"content": "**Rust, SweetRust**\n\nUncomment print out and sort the output -- it's pretty easy to find what virtual command (1xx, assigned by me) corresponds to what real command (0..15), and that is already included in fn exec, for execution of part 2.\n\n    use std::io::{BufRead,BufReader}; // lines() in BufRead\n    type U=usize;\n\n    fn exec( cmd:U, ops:&[U], rbf:&Vec<U> ) -> Vec<U>:\n      let mut r = rbf.clone();\n      let (a,b,c) = (ops[0],ops[1],ops[2]);\n      match cmd:\n        100|11 => /* addr ra+rb->rc */ { r[c] = r[a] + r[b]; },\n        101| 5 => /* addi ra+ b->rc */ { r[c] = r[a] +   b;  },\n        102| 1 => /* mulr ra*rb->rc */ { r[c] = r[a] * r[b]; },\n        103| 8 => /* muli ra* b->rc */ { r[c] = r[a] *   b;  },\n        104|13 => /* borr ra|rb->rc */ { r[c] = r[a] | r[b]; },\n        105| 9 => /* bori ra| b->rc */ { r[c] = r[a] |   b;  },\n        106| 4 => /* banr ra&rb->rc */ { r[c] = r[a] & r[b]; },\n        107|12 => /* bani ra& b->rc */ { r[c] = r[a] &   b;  },\n        108|10 => /* setr ra   ->rc */ { r[c] = r[a]; },\n        109| 6 => /* seti  a   ->rc */ { r[c] =   a;  },\n        110| 7 => /* gtir  a>rb->rc */ { r[c] = if   a  >  r[b] {1} else {0}; },\n        111| 2 => /* gtri ra> b->rc */ { r[c] = if r[a] >    b  {1} else {0}; },\n        112| 3 => /* gtrr ra>rb->rc */ { r[c] = if r[a] >  r[b] {1} else {0}; },\n        113|14 => /* eqir  a=rb->rc */ { r[c] = if   a  == r[b] {1} else {0}; },\n        114| 0 => /* eqri ra= b->rc */ { r[c] = if r[a] ==   b  {1} else {0}; },\n        115|15 => /* eqrr ra=rb->rc */ { r[c] = if r[a] == r[b] {1} else {0}; },\n        _ => {}\n      r\n\n    fn main():\n      let file = std::fs::File::open( \"16.dat\" ).unwrap();\n      let mut d:Vec<(String,String,String)> = vec![]; // data\n      let mut t:(String,String,String) = (String::new(),String::new(),String::new());\n      let mut b = false; // 'before' is done, command is expected\n      let mut p:Vec<String> = vec![]; // prorgam for part 2\n      for optline in BufReader::new(file).lines():\n        let line = optline.unwrap();\n        if line.starts_with(\"Before\"):\n          t.0 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          b = true;\n        else if line.starts_with(\"After\"):\n          t.2 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          d.push(t.clone());\n          b = false;\n        else if b:\n          t.1 = line[..].to_string();\n        else if line.len()>6:\n          p.push( line );\n\n      let mut o = 0;\n      for (b,c,a) in d: // (before, command, after)\n        let rbf: Vec<U> = b.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let raf: Vec<U> = a.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let mut n = 0; // how many matched the result\n        let mut good: Vec<U> = vec![];\n        for i in 100..=115: // virtual op codes\n          let res = exec( i, &cmd[1..], &rbf );\n          if raf == res:\n            good.push( i );\n            n += 1;\n        // print out and sort for analysis (yeah, by a human being, sorry)\n        // println!( \"{} -- {:?} -- ({:?}) {:?}->{:?}\", n, &good, &cmd, &rbf, &raf );\n        if n>=3:\n          o += 1;\n      println!( \"{}\", o ); // part 1\n\n      let mut r = vec![0;4];\n      for c in p:\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let res = exec( cmd[0], &cmd[1..], &r );\n        r = res;\n      println!( \"{}\", r[0] ); // part 2\n\n[My AOC2018 in J&Rust](http://zw.rf.gd/aoc2018/) | [SweetRust](http://zw.rf.gd/sweetrust/) \n\nOK, all is automatic now :)\n\n    use std::io::{BufRead,BufReader}; // lines() in BufRead\n    use std::collections::HashMap;\n    type U=usize;\n\n    fn exec( cmd:U, ops:&[U], rbf:&Vec<U> ) -> Vec<U>:\n      let mut r = rbf.clone();\n      let (a,b,c) = (ops[0],ops[1],ops[2]);\n      match cmd:\n        100 => /* addr ra+rb->rc */ { r[c] = r[a] + r[b]; },\n        101 => /* addi ra+ b->rc */ { r[c] = r[a] +   b;  },\n        102 => /* mulr ra*rb->rc */ { r[c] = r[a] * r[b]; },\n        103 => /* muli ra* b->rc */ { r[c] = r[a] *   b;  },\n        104 => /* borr ra|rb->rc */ { r[c] = r[a] | r[b]; },\n        105 => /* bori ra| b->rc */ { r[c] = r[a] |   b;  },\n        106 => /* banr ra&rb->rc */ { r[c] = r[a] & r[b]; },\n        107 => /* bani ra& b->rc */ { r[c] = r[a] &   b;  },\n        108 => /* setr ra   ->rc */ { r[c] = r[a]; },\n        109 => /* seti  a   ->rc */ { r[c] =   a;  },\n        110 => /* gtir  a>rb->rc */ { r[c] = if   a  >  r[b] {1} else {0}; },\n        111 => /* gtri ra> b->rc */ { r[c] = if r[a] >    b  {1} else {0}; },\n        112 => /* gtrr ra>rb->rc */ { r[c] = if r[a] >  r[b] {1} else {0}; },\n        113 => /* eqir  a=rb->rc */ { r[c] = if   a  == r[b] {1} else {0}; },\n        114 => /* eqri ra= b->rc */ { r[c] = if r[a] ==   b  {1} else {0}; },\n        115 => /* eqrr ra=rb->rc */ { r[c] = if r[a] == r[b] {1} else {0}; }, _ => {}\n      /* return */ r\n\n    fn main():\n      let file = std::fs::File::open( \"16.dat\" ).unwrap();\n      let mut d:Vec<(String,String,String)> = vec![]; // data\n      let mut t:(String,String,String) = (String::new(),String::new(),String::new());\n      let mut b = false; // 'before' is done, command is expected\n      let mut p:Vec<String> = vec![]; // prorgam for part 2\n      for optline in BufReader::new(file).lines():\n        let line = optline.unwrap();\n        if line.starts_with(\"Before\"):\n          t.0 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          b = true;\n        else if line.starts_with(\"After\"):\n          t.2 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          d.push(t.clone());\n          b = false;\n        else if b:\n          t.1 = line[..].to_string();\n        else if line.len()>6:\n          p.push( line );\n\n      let mut dbl: HashMap<(U,Vec<U>),U> = HashMap::new(); // n, ops -> cmd\n      let mut o = 0; // output, part 1\n      for (b,c,a) in d: // (before, command, after)\n        let rbf: Vec<U> = b.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let raf: Vec<U> = a.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let mut n = 0; // how many matched the result\n        let mut cand: Vec<U> = vec![]; // candidates\n        for i in 100..=115: // virtual op codes\n          let res = exec( i, &cmd[1..], &rbf );\n          if raf == res:\n            cand.push( i );\n            n += 1;\n        let key=(n,cand);\n        if dbl.contains_key( &key ):\n          if *dbl.get( &key ).unwrap() != cmd[0] { panic!(\"not ready for that\"); }\n        else:\n          dbl.insert( key, cmd[0] );\n        if n>=3:\n          o += 1;\n      println!( \"{}\", o ); // part 1\n\n      // analyse - build a map of real ops to virtual ops\n      let mut op2vop = vec![0;16]; // maps op --> virtual op; will be the result of analysis\n      let mut dd: Vec<(U,Vec<U>,U)> = dbl.iter().map( |(k,v)| (k.0,k.1.clone(),*v) ).collect();\n      while dd.len()>0:\n        dd.sort();\n        let (n,vops,op) = dd.remove(0);\n        if n!=1 { panic!(\"not ready for that\"); }\n        let vop = vops[0];\n        op2vop[ op ] = vop;\n        while let Some(p) = dd.iter().position( |x| x.2==op ):\n          dd.remove( p );\n        for i in 0..dd.len():\n          if let Some(p) = dd[i].1.iter().position( |&x| x==vop ):\n            dd[i].0 -= 1;\n            dd[i].1.remove( p );\n      // execute\n      let mut r = vec![0;4];\n      for c in p:\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let res = exec( op2vop[cmd[0]], &cmd[1..], &r );\n        r = res;\n      println!( \"{}\", r[0] ); // part 2\n", "id": "ebyv8ag", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "My rust solution(after several refactor):\n\nI split the input into two files.\n\n    #[macro_use]\n    extern crate lazy_static;\n    extern crate regex;\n    \n    use regex::Regex;\n    use std::collections::HashSet;\n    use std::fs::File;\n    use std::io::{BufRead, BufReader};\n    \n    #[derive(Debug)]\n    struct Assertion {\n        before: [usize; 4],\n        cmd: [usize; 4],\n        after: [usize; 4],\n    }\n    \n    impl Assertion {\n        fn try_assert(&self, index: usize) -> bool {\n            self.after == execute(&self.before, &self.cmd, index)\n        }\n    }\n    \n    fn parse_line_num(line: &str) -> [usize; 4] {\n        lazy_static! {\n            static ref RE: Regex = Regex::new(r\"(\\d+)[,\\s]+(\\d+)[,\\s]+(\\d+)[,\\s]+(\\d+)\").unwrap();\n        }\n        let caps = RE.captures(line).unwrap();\n        let u1 = caps.get(1).unwrap().as_str().parse::<usize>().unwrap();\n        let u2 = caps.get(2).unwrap().as_str().parse::<usize>().unwrap();\n        let u3 = caps.get(3).unwrap().as_str().parse::<usize>().unwrap();\n        let u4 = caps.get(4).unwrap().as_str().parse::<usize>().unwrap();\n        [u1, u2, u3, u4]\n    }\n    \n    fn execute(before: &[usize; 4], cmd: &[usize; 4], index: usize) -> [usize; 4] {\n        let mut after: [usize; 4] = Default::default();\n        after.copy_from_slice(before);\n        match index {\n            0 => after[cmd[3]] = before[cmd[1]] + before[cmd[2]],\n            1 => after[cmd[3]] = before[cmd[1]] + cmd[2],\n            2 => after[cmd[3]] = before[cmd[1]] * before[cmd[2]],\n            3 => after[cmd[3]] = before[cmd[1]] * cmd[2],\n            4 => after[cmd[3]] = before[cmd[1]] & before[cmd[2]],\n            5 => after[cmd[3]] = before[cmd[1]] & cmd[2],\n            6 => after[cmd[3]] = before[cmd[1]] | before[cmd[2]],\n            7 => after[cmd[3]] = before[cmd[1]] | cmd[2],\n            8 => after[cmd[3]] = before[cmd[1]],\n            9 => after[cmd[3]] = cmd[1],\n            10 => after[cmd[3]] = if cmd[1] > before[cmd[2]] { 1 } else { 0 },\n            11 => after[cmd[3]] = if before[cmd[1]] > cmd[2] { 1 } else { 0 },\n            12 => after[cmd[3]] = if before[cmd[1]] > before[cmd[2]] { 1 } else { 0 },\n            13 => after[cmd[3]] = if cmd[1] == before[cmd[2]] { 1 } else { 0 },\n            14 => after[cmd[3]] = if before[cmd[1]] == cmd[2] { 1 } else { 0 },\n            15 => after[cmd[3]] = if before[cmd[1]] == before[cmd[2]] { 1 } else { 0 },\n            _ => {}\n        };\n        after\n    }\n    \n    fn main() {\n        let path = format!(\"./input/{}\", \"day16_q1.txt\");\n        let vec: Vec<String> = BufReader::new(File::open(path).unwrap())\n            .lines()\n            .map(|l| l.expect(\"Could not parse line\"))\n            .collect();\n    \n        let asserts: Vec<Assertion> = vec\n            .chunks(4)\n            .map(|s| Assertion {\n                before: parse_line_num(&s[0]),\n                cmd: parse_line_num(&s[1]),\n                after: parse_line_num(&s[2]),\n            })\n            .collect();\n    \n        let q1 = asserts\n            .iter()\n            .filter(|ass| (0..=15).map(|id| ass.try_assert(id)).filter(|&b| b).count() >= 3)\n            .count();\n        println!(\"result of q01 is {}\", q1);\n    \n        // gen opcode->Set(indexes) mapping\n        let mut opcode_mapping: Vec<HashSet<usize>> = vec![HashSet::new(); 16];\n    \n        asserts.iter().for_each(|ref ass| {\n            let opcode = ass.cmd[0];\n            let mut index_set: HashSet<usize> = HashSet::new();\n            (0..=15usize).for_each(|idx| {\n                if ass.try_assert(idx) {\n                    index_set.insert(idx);\n                }\n            });\n            let un_init = opcode_mapping[opcode].is_empty();\n            if un_init {\n                opcode_mapping[opcode] = index_set;\n            } else {\n                opcode_mapping[opcode] = opcode_mapping[opcode]\n                    .intersection(&index_set)\n                    .map(|&x| x)\n                    .collect::<HashSet<usize>>();\n            }\n        });\n        println!(\"DEBUG before deduction {:?}\", opcode_mapping);\n    \n        // repeat deduction until every Set.len() == 1\n        let mut handled: HashSet<usize> = HashSet::new();\n        while opcode_mapping.iter().any(|set| set.len() != 1) {\n            for set in opcode_mapping.iter_mut() {\n                if set.len() > 1 {\n                    handled.iter().for_each(|num| {\n                        set.remove(&num);\n                    })\n                } else {\n                    handled.insert(*set.iter().next().unwrap());\n                }\n            }\n        }\n        // deduction & normalize\n        let opcode_mapping = opcode_mapping\n            .into_iter()\n            .map(|set| set.into_iter().next().unwrap())\n            .collect::<Vec<usize>>();\n        println!(\"DEBUG after deduction {:?}\", opcode_mapping);\n    \n        // parsing q2 input\n        let path = format!(\"./input/{}\", \"day16_q2.txt\");\n        let instructions: Vec<[usize; 4]> = BufReader::new(File::open(path).unwrap())\n            .lines()\n            .map(|l| l.expect(\"Could not parse line\"))\n            .map(|line| parse_line_num(&line))\n            .collect();\n    \n        let register = instructions.iter().fold([0; 4], |acc, ins| {\n            execute(&acc, ins, opcode_mapping[ins[0]])\n        });\n        println!(\"result of q02 is {}\", register[0]);\n    }\n\n&#x200B;", "id": "ebyzgbi", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Here is my Kotlin solution:\n\n[https://github.com/davidaayers/advent-of-code-2018/blob/master/src/day16/day16.kt](https://github.com/davidaayers/advent-of-code-2018/blob/master/src/day16/day16.kt)", "id": "ec010k3", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Rexx** 133/175\n\nWell I came nowhere but I'll share this because Rexx is a very neglected language.  Unfortunately it also lacks direct and/or on decimal numbers, so we have to convert to binary and back.  I used separate programs to do part 1 and part 2, but this is both of them merged together.\n\n    signal on notready\n    ans=0\n    ops.='addr addi mulr muli banr bani borr bori setr seti gtir gtri gtrr eqir eqri eqrr'\n    do forever\n        parse pull . '[' r0.0 ', ' r0.1 ', ' r0.2 ', ' r0.3 ']'\n        parse pull op opa opb opc\n        parse pull . '[' r1.0 ', ' r1.1 ', ' r1.2 ', ' r1.3 ']'\n        pull .\n        if r0.0 == '' then leave\n        t=0\n        if (r1.0=r0.0)+(r1.1=r0.1)+(r1.2=r0.2)+(r1.3=r0.3) >=3 then do\n            if r1.opc \\= r0.opa+r0.opb then call eliminate op,'addr'\n            else t=t+1\n            if r1.opc \\= r0.opa+opb then call eliminate op,'addi'\n            else t=t+1\n            if r1.opc \\= r0.opa*r0.opb then call eliminate op,'mulr'\n            else t=t+1\n            if r1.opc \\= r0.opa*opb then call eliminate op,'muli'\n            else t=t+1\n            if r1.opc \\= band(r0.opa,r0.opb) then call eliminate op,'banr'\n            else t=t+1\n            if r1.opc \\= band(r0.opa,opb) then call eliminate op,'bani'\n            else t=t+1\n            if r1.opc \\= bor(r0.opa,r0.opb) then call eliminate op,'borr'\n            else t=t+1\n            if r1.opc \\= bor(r0.opa,opb) then call eliminate op,'bori'\n            else t=t+1\n            if r1.opc \\= r0.opa then call eliminate op,'setr'\n            else t=t+1\n            if r1.opc \\= opa then call eliminate op,'seti'\n            else t=t+1\n            if r1.opc \\= (opa>r0.opb) then call eliminate op,'gtir'\n            else t=t+1\n            if r1.opc \\= (r0.opa>opb) then call eliminate op,'gtri'\n            else t=t+1\n            if r1.opc \\= (r0.opa>r0.opb) then call eliminate op,'gtrr'\n            else t=t+1\n            if r1.opc \\= (opa=r0.opb) then call eliminate op,'eqir'\n            else t=t+1\n            if r1.opc \\= (r0.opa=opb) then call eliminate op,'eqri'\n            else t=t+1\n            if r1.opc \\= (r0.opa=r0.opb) then call eliminate op,'eqrr'\n            else t=t+1\n            if t>=3 then ans=ans+1\n        end\n        else do; say \"?\" r0.0 r0.1 r0.2 r0.3 \",\" r1.0 r1.1 r1.2 r1.3; exit; end\n    end\n    notready:\n    say 'Part 1:' ans\n    do until ok\n        ok=1\n        do i=0 to 15\n            if words(ops.i)=1 then\n                do j=0 to 15\n                    if j \\= i then call eliminate j,ops.i\n                end\n            else ok=0\n        end\n    end\n    /* do i=0 to 15; say i ops.i; end */\n    \n    signal on notready name eof2\n    r.=0\n    do forever\n        parse pull op opa opb opc\n        if op='' then iterate\n        select\n            when ops.op = 'addr' then r.opc=r.opa+r.opb\n            when ops.op = 'addi' then r.opc=r.opa+opb\n            when ops.op = 'mulr' then r.opc=r.opa*r.opb\n            when ops.op = 'muli' then r.opc=r.opa*opb\n            when ops.op = 'banr' then r.opc=band(r.opa,r.opb)\n            when ops.op = 'bani' then r.opc=band(r.opa,opb)\n            when ops.op = 'borr' then r.opc=bor(r.opa,r.opb)\n            when ops.op = 'bori' then r.opc=bor(r.opa,opb)\n            when ops.op = 'setr' then r.opc=r.opa\n            when ops.op = 'seti' then r.opc=opa\n            when ops.op = 'gtir' then r.opc= (opa>r.opb)\n            when ops.op = 'gtri' then r.opc= (r.opa>opb)\n            when ops.op = 'gtrr' then r.opc= (r.opa>r.opb)\n            when ops.op = 'eqir' then r.opc= (opa=r.opb)\n            when ops.op = 'eqri' then r.opc= (r.opa=opb)\n            when ops.op = 'eqrr' then r.opc= (r.opa=r.opb)\n        end\n    end\n    eof2:\n    say 'Part 2:' r.0\n    exit\n    \n    eliminate: procedure expose ops.\n    parse arg op,word\n    p=wordpos(word,ops.op)\n    if p=0 then return\n    ops.op=strip(subword(ops.op,1,p-1) subword(ops.op,p+1))\n    return\n    \n    band:procedure\n    parse arg a,b\n    a=x2b(d2x(a))\n    b=x2b(d2x(b))\n    l=max(length(a),length(b))\n    c=bitand(right(a,l,0),right(b,l,0))\n    return x2d(b2x(c))\n    \n    bor:procedure\n    parse arg a,b\n    a=x2b(d2x(a))\n    b=x2b(d2x(b))\n    l=max(length(a),length(b))\n    c=bitor(right(a,l,0),right(b,l,0))\n    return x2d(b2x(c))\n", "id": "ec0ftts", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Belated **Perl** solution.\n\n[Card] \u201cThe secret technique to beat today's puzzles is\u201d ...\u00a0not to spend so long on the previous day's puzzle that you only get round to this one half a week later.\n\nQuite structurally similar to /u/raevnos's and /u/drbagy's solutions, but I think using sub signatures with named arguments makes the dispatch table a bit easier to read.\n\nI like that running the entire opcode program is just a one-line loop:\n\n    $reg[$4] = $op{$1}($2, $3) while !eof && <> =~ /^(\\d+) (-?\\d+) (-?\\d+) (\\d+)$/;\n\nThe op codes and numbers both end up as keys in the same hash: `$op{addr}` and `$op{3}`, for instance, both point to the calculation sub for that operation; the codes and numbers don't clash, so there's no need to have another layer of indirection converting one to the other.\n\n    use v5.20; use warnings; use experimental qw<signatures>; use List::AllUtils qw<pairfirst>;\n\n    my @reg;\n    my %op = (\n      addr => sub($idxA, $idxB) { $reg[$idxA] +  $reg[$idxB]      },\n      addi => sub($idxA, $valB) { $reg[$idxA] +  $valB            },\n      mulr => sub($idxA, $idxB) { $reg[$idxA] *  $reg[$idxB]      },\n      muli => sub($idxA, $valB) { $reg[$idxA] *  $valB            },\n      banr => sub($idxA, $idxB) { $reg[$idxA] &  $reg[$idxB]      },\n      bani => sub($idxA, $valB) { $reg[$idxA] &  $valB            },\n      borr => sub($idxA, $idxB) { $reg[$idxA] |  $reg[$idxB]      },\n      bori => sub($idxA, $valB) { $reg[$idxA] |  $valB            },\n      setr => sub($idxA, $    ) { $reg[$idxA]                     },\n      seti => sub($valA, $    ) { $valA                           },\n      gtir => sub($valA, $idxB) { $valA       >  $reg[$idxB] || 0 },\n      gtri => sub($idxA, $valB) { $reg[$idxA] >  $valB       || 0 },\n      gtrr => sub($idxA, $idxB) { $reg[$idxA] >  $reg[$idxB] || 0 },\n      eqir => sub($valA, $idxB) { $valA       == $reg[$idxB] || 0 },\n      eqri => sub($idxA, $valB) { $reg[$idxA] == $valB       || 0 },\n      eqrr => sub($idxA, $idxB) { $reg[$idxA] == $reg[$idxB] || 0 },\n    );\n\n    {\n      local $/ = \"\\n\\n\";\n      my $samples_matching_3;\n      my %maybe_op_num = map { $_ => {map { $_ => 1 } 0 .. (keys %op) - 1} } keys %op;\n      while (<>) {\n        last if /^\\n$/; # blank line separates samples from program\n        my ($op_num, @input, $output_idx, @after, $matches);\n        (@reg[0..3], $op_num, @input[0..1], $output_idx, @after) = /(-?\\d+)/g;\n        while (my ($op_code, $calc_sub) = each %op) {\n          if ($calc_sub->(@input) == $after[$output_idx]) {\n            $matches++;\n          }\n          else {\n            delete $maybe_op_num{$op_code}{$op_num}; # This num can't be this op.\n          }\n        }\n        $samples_matching_3++ if $matches >= 3;\n      }\n      say \"Samples matching at least 3 opcode behaviours: $samples_matching_3\";\n\n      # While there are opcodes that haven't been assigned numbers, grab the first\n      # one that only has one possible number remaining, and assign that:\n      while (%maybe_op_num) {\n        my ($code, $num) = pairfirst { keys %$b == 1 } %maybe_op_num;\n        ($num) = keys %$num; # Extract the only number for this code.\n        $op{$num} = $op{$code};\n        delete $maybe_op_num{$code}; # Stop trying to match this code.\n        delete @{$_}{$num} foreach values %maybe_op_num; # A found number can't be other codes'.\n      }\n    }\n\n    @reg = (0) x 4;\n    $reg[$4] = $op{$1}($2, $3) while !eof && <> =~ /^(\\d+) (-?\\d+) (-?\\d+) (\\d+)$/;\n    say \"final value of register 0: $reg[0]\";\n", "id": "ec7j4ps", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "When you stop thinking in English and start thinking in python\n\n    from re import findall\n    \n    to_ints = lambda x: (map(int, findall('-?\\d+', i)) for i in x.split('\\n') if i)\n    with open('../input/16.txt') as f:\n        test, program = map(to_ints, f.read().split('\\n\\n\\n\\n'))\n    \n    commands = { 'name': lambda r, A, B: r[A] + B } # all of them\n    \n    ambiguities = 0\n    translate = {}\n    for before, (number, A, B, C), after in zip(*[test]*3):\n        potential = set()\n        for opcode in commands:\n            if commands[opcode](before, A, B) == after[C]:\n                potential.add(opcode)\n    \n        if len(potential) >= 3:\n            ambiguities += 1\n            \n        potential = potential.difference(set(translate.values()))\n        if len(potential) == 1:\n            translate[number] = potential.pop()\n    \n    r = [0, 0, 0, 0]\n    for number, A, B, C in program:\n        r[C] = commands[translate[number]](r, A, B)\n    \n    print ambiguities\n    print r[0]\n\nMight be possible that mapping numbers to opcodes won't work without cycling through the (before, code, after) many times, for my input works to do it just once.", "id": "ed1d0is", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "This was so refreshing after day 15. I did it in C, browsing solutions I didn't see a solution yet that would store the opcodes as \\[actual function, function to lookup a, function to lookup b,\\] and then an apply function that uses those.\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nconst bool DEBUG = false;\nconst int OPCODES_COUNT = 16;\n\nint regs[4] = { 0 };\n\nstruct opcode {\n  char* name;\n  int (*fn)(int a, int b);\n  int (*a)(int arg);\n  int (*b)(int arg);\n};\n\nint add(int a, int b) {\n  return a + b;\n}\n\nint mul(int a, int b) {\n  return a * b;\n}\n\nint ban(int a, int b) {\n  return a & b;\n}\n\nint bor(int a, int b) {\n  return a | b;\n}\n\nint set(int a, int _b) {\n  return a;\n}\n\nint gt(int a, int b) {\n  return a > b ? 1 : 0;\n}\n\nint eq(int a, int b) {\n  return a == b ? 1 : 0;\n}\n\nint r(int reg) {\n  return regs[reg];\n}\n\nint i(int immediate) {\n  return immediate;\n}\n\nstruct opcode opcodes[OPCODES_COUNT] =\n  {\n   {.name = \"addr\", .a=r, .b=r, .fn=add},\n   {.name = \"addi\", .a=r, .b=i, .fn=add},\n   {.name = \"mulr\", .a=r, .b=r, .fn=mul},\n   {.name = \"muli\", .a=r, .b=i, .fn=mul},\n   {.name = \"banr\", .a=r, .b=r, .fn=ban},\n   {.name = \"bani\", .a=r, .b=i, .fn=ban},\n   {.name = \"borr\", .a=r, .b=r, .fn=bor},\n   {.name = \"bori\", .a=r, .b=i, .fn=bor},\n   {.name = \"setr\", .a=r, .b=r, .fn=set},\n   {.name = \"seti\", .a=i, .b=i, .fn=set},\n   {.name = \"gtir\", .a=i, .b=r, .fn=gt},\n   {.name = \"gtri\", .a=r, .b=i, .fn=gt},\n   {.name = \"gtrr\", .a=r, .b=r, .fn=gt},\n   {.name = \"eqir\", .a=i, .b=r, .fn=eq},\n   {.name = \"eqri\", .a=r, .b=i, .fn=eq},\n   {.name = \"eqrr\", .a=r, .b=r, .fn=eq}\n  };\n\nvoid apply(const struct opcode* op, int a, int b, int c) {\n  regs[c] = op->fn(op->a(a), op->b(b));\n}\n\nvoid print_regs(int* arg_regs) {\n  if (arg_regs == NULL) arg_regs = regs;\n\n  int i = 0;\n  while (i < 3) printf(\"%3d, \", arg_regs[i++]);\n  printf(\"%3d\", arg_regs[i]);\n}\n\nint main(void) {\n  int oregs[4] = { 0 };\n  int eregs[4] = { 0 };\n\n  int matching3 = 0;\n  int total = 0;\n\n  int defs[16][16] = { { 0 } };\n  int map[16];\n  for (int i = 0; i < 16; i++) map[i] = -1;\n\n  while (true) {\n    int o, a, b, c;\n    int res = scanf(\" Before: [%d, %d, %d, %d]\",\n          &oregs[0], &oregs[1],\n          &oregs[2], &oregs[3]);\n    if (res != 4) break;\n\n    int rres = scanf(\" %d %d %d %d\", &o, &a, &b, &c);\n    int eres = scanf(\" After: [%d, %d, %d, %d]\",\n          &eregs[0], &eregs[1],\n          &eregs[2], &eregs[3]);\n\n    total++;\n    int matching = 0;\n    for (int i = 0; i < OPCODES_COUNT; i++) {\n      memcpy(regs, oregs, 4 * sizeof(int));\n      if (DEBUG) {\n        printf(\"`%s %d %d %d`:  \", opcodes[i].name, a, b, c);\n        print_regs(regs);\n        printf(\" -> \");\n      }\n\n      apply(&opcodes[i], a, b, c);\n\n      int comp = memcmp(regs, eregs, 4 * sizeof(int));\n\n      if (DEBUG) {\n        print_regs(regs); printf(\" =? \");\n        print_regs(eregs);\n        printf(\" -- %d\\n\", comp);\n      }\n\n      if (comp == 0) matching++;\n      else defs[o][i]++;\n    }\n\n    if (matching >= 3) matching3++;\n  }\n  printf(\"Matching 3+ opcodes: %d/%d\\n\\n\", matching3, total);\n\n  int unmapped = OPCODES_COUNT;\n  int iterations = 0;\n  while (unmapped > 0 && iterations++ < 1000) {\n    for (int i = 0; i < OPCODES_COUNT; i++) {\n      if (map[i] != -1) continue;\n\n      int last_option = -1;\n      int options = 0;\n      for (int j = 0; j < OPCODES_COUNT; j++) {\n        if (defs[i][j] == 0) {\n          options++;\n          last_option = j;\n        }\n      }\n\n      if (options == 1) {\n        map[i] = last_option;\n        for (int j = 0; j < OPCODES_COUNT; j++) {\n          defs[j][last_option]++;\n        }\n        unmapped--;\n      }\n    }\n  }\n\n  printf(\"Opcode mapping:\\n\");\n  for (int i = 0; i < OPCODES_COUNT; i++) {\n    printf(\"%d = %s\\n\", i, opcodes[map[i]].name);\n  }\n  printf(\"\\n\");\n\n  memset(regs, 0, sizeof(regs));\n  while (true) {\n    int o, a, b, c;\n    if (scanf(\" %d %d %d %d\", &o, &a, &b, &c) != 4)\n      break;\n\n    if (DEBUG) {\n      print_regs(NULL);\n      printf(\" | %2d %2d %2d %2d == %s %2d %2d %2d | \",\n             o, a, b, c,\n             opcodes[map[o]].name, a, b, c);\n    }\n\n    apply(&opcodes[map[o]], a, b, c);\n\n    if (DEBUG) {\n      print_regs(NULL);\n      printf(\"\\n\");\n    }\n  }\n\n  printf(\"\\nThe final value in register 0 is %d\\n\", regs[0]);\n\n  return 0;\n}\n```", "id": "edcgdqq", "owner_tier": 0.1, "score": -3.703703681194552e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/a6mf8a/2018_day_16_solutions/", "question": {"content": "#--- Day 16: Chronal Classification ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Advent of Code: The Party Game!\n\n[Click here for rules](/r/adventofcode/w/aoctpg)\n\nPlease prefix your card submission with something like [Card] to make scanning the megathread easier.  THANK YOU!\n\n#### [Card prompt: Day 16](https://i.imgur.com/5ZQn6nGm.jpg)\n\nTranscript:\n> The secret technique to beat today's puzzles is ___.\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n###*edit:* Leaderboard capped, thread unlocked at 00:39:03!", "id": "a6mf8a", "title": "-\ud83c\udf84- 2018 Day 16 Solutions -\ud83c\udf84-", "traffic_rate": 38.33703939008895}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "We're aware of some issues during unlock today; we'll let you know when we have more information.", "id": "gesvzui", "owner_tier": 0.5, "score": -1.0869565151331837e-10}, {"content": "ruby 1/1 woo\n\n    p read.split(\"\\n\\n\").map{|x|x.split.join.chars.uniq.size}.sum\n    p read.split(\"\\n\\n\").map{|x|x.lines.map{|x|x.chomp.chars}.reduce(:&).size}.sum\n\nThat is just... amazing timing and amazing code. Kudos!\n\nAny reason you use `split` in the first one but `lines` in the second one?\n\nno lol, the first time my brain was like \"ok how do i kill all the whitespace\" and it spit out `.split.join` as a unit, then for part 2 i deleted everything in the braces to start again and the first thing that came to mind to transform the lines was `.lines.map`", "id": "ges7bz7", "owner_tier": 0.1, "score": 0.7826086955434783}, {"content": "# [Python](https://github.com/arknave/advent-of-code-2020/blob/main/day06/day06.py) / [C](https://raw.githubusercontent.com/arknave/advent-of-code-2020/main/day06/day06.c)\n\nLost a bit of time because of site issues and an off by one error, but I doubt I'm ever going to leaderboard on a string parsing problem when people are so fast these days.\n\nFirst time I've done the art the night of instead of the next day! I'm starting to learn the tiny ones are the hardest to tinker with because there's just no wiggle room.\n\n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    // AOC DAY NUMBER //\n    int main(int c,char*\n    *v){int       t,p,q;\n    char           b[66]\n    ,h[    66],*k   ,*l=\n    b,*   e=h+26;for(p=q\n    =0   ;l;   ){for(k=h\n    ;k            <e;++k\n    )*    k=0;for   (t=0\n    ;(   l=gets(b   ))&&\n    *l   ;++t)for(  k=l;\n    *k;   ++k)++h   [-97\n    +*k];          for(k\n    =h;k<e;     ++k){p+=\n    *k>0;q+=*k==t;}}--c;\n    printf(\"%d\",c?q:p);}\n\n>`blocks = fin.read().split(\"\\n\\n\")`\n\nI've been writing a really awkward for loop that appended each line manually if it wasn't empty lol. Definitely going to use this method in the future :)", "id": "gesc8cy", "owner_tier": 0.1, "score": 0.33695652163043477}, {"content": "38/27, Python. https://github.com/sophiebits/adventofcode/blob/main/2020/day06.py\n\nServer problems during unlock again today? I had to refresh several times to get each page to load.\n\nI got 504 and couldn't see the page for more than 2 minutes.\n\nSame-- by the time my page loaded, 18 people had already finished part 1, judging from leaderboard times.\n\n(115/38-- at least part 2 loaded right away!)\n\nTook me a full five minutes before I could grab the inputs; 504s all along the way, and a bunch of people on IRC (names redacted) had trouble. Guess scores won't count today.\n\n\\[06:00:17\\] <> Down again?\n\n\\[06:00:22\\] <> rip\n\n\\[06:00:29\\] <> yep for me.\n\n\\[06:00:31\\] <> yeah just wondering if anyone else was having issues\n\n\\[06:01:15\\] <> cmon\n\n\\[06:01:35\\] <> lol\n\n\\[06:01:51\\] <> NOw I know what day 1 felt like for everyone else.\n\nEdit: Asked around the private leaderboards (North Europe); looks like \\~4 minutes to get the site to load was normal.\n\nI lost around a minute or so waiting for part 2 to load.\n\nI loaded the page fine for Part 1, but then I had to try several times (and got some 504s and page-hangs) to submit the answer. It was slow for Part 2 but a bit better.\n\nThe server wouldn't serve me either. I think the leaderboard for part 1 was done before the problem even loaded for me :(\n\n(I also wasted a minute due to using `s.splitlines()` instead of `s.split('\\n\\n')` to break my input into groups, but that one's on me.)\n\nI submitted my answer for Part 1 at 12:03, but it took several minutes to go through. My official time under stats is 7:12.\n\nOh; I wasn't the only one having issues! I was only held up for about ten seconds though, so I'm not particularly annoyed.\n\nyeah it was weird, my input changed for some reason too which threw me off\n\nYeah. I lost over a minute on both parts because of that", "id": "ges6ld4", "owner_tier": 0.1, "score": 0.9999999998913044}, {"content": "[Haskell](https://github.com/SimonBaars/AdventOfCode-Haskell/blob/master/2020/Day6.hs)\n\nHaskell has proven to be insane yet again. It's so short! Part 1:\n\n    sum $ map (length . foldr1 union) input\n\nPart 2:\n\n    sum $ map (length . foldr1 intersect) input\n\nthat's so insanely short! I'm not even using any exotic imports (nothing except Data.List).\n\nYou can even (naturally) golf this a tad further!  The Monoid for Set (how to get one from two) is union.  So <> would be union, and mconcat is the <> of all items in a foldable container.  So part 1 can be:\n\n    sum . map (size . mconcat)\n\nthis is pretty crazy\n\nAhhh, foldr1 intersect is a much nicer solution than mine (which involved sorting, grouping, and then filtering out the grouped characters that were shorter than the total number of people in a boarding group), thanks for sharing! I'm gonna remember union and intersect next time\n\nBut how did you parse the input into the nice input list? I used so much time work that out", "id": "gesc59h", "owner_tier": 0.1, "score": 0.3804347825}, {"content": "Python; would have made some work of the leaderboards today if the servers didn't crash again, and it took five minutes to get past all the 504s (and all of a sudden being logged out).\n\n    groups = data.split('\\n\\n')\n\n    # Part one\n    sum(len(set.union(*map(set, g.split('\\n')))) for g in groups)\n\n    # Part two\n    sum(len(set.intersection(*map(set, g.split('\\n')))) for g in groups)\n\ngoddamn.\nthat's incredibly tiny", "id": "ges8u7n", "owner_tier": 0.5, "score": 0.13043478249999998}, {"content": "**Raku**\n\n    my @answers = 'input'.IO.slurp.split(\"\\n\\n\");\n\n    put [+] @answers.map: { .words.join.comb.Set }\n    put [+] @answers.map: { [\u2229] .words.map(*.comb.Set) }\n\nPart 1 could have been written `[+] @answers.map: { .comb(/\\S/).Set }` but I have a habit of avoiding RegEx unless necessary.\n\nAlso, doing the plus reduction `[+]` is the same number of characters as `sum`... I guess I just felt a little _reductionist_ today.\n\n*desire to learn Raku intensifies...*\n\nI imagine if you're quick at figuring out how to solve a puzzle, the ease at which Raku lets you concisely express it might give you a speed advantage.\n\nFor most problems in general, I just find it easier to figure out a solution in Raku than any other language.", "id": "gesb5jw", "owner_tier": 0.3, "score": 0.1521739129347826}, {"content": "Ruby 9/31\n\nMy input downloader failed so I had to manually open the input text in browser to copy into file lmao\n\n\n    a=$<.read.split(\"\\n\\n\")\n    p a.sum{|x|\n    # x.split.join.chars.uniq.size <- part 1\n    x.lines.map{|x|x.chomp.chars}.reduce{|x,y|x&y}.size\n    }", "id": "ges6nvc", "owner_tier": 0.3, "score": 0.08695652163043478}, {"content": "J, both parts\n\n    echo ((1 #. #@~.@;;._2) , (1 #. ([: #@; ([-.-.)&.>/);._2)) <;._2 d\n\nhttp://urstoron.com/4COP\n\n[deleted]\n\n`[-.-.` is interesting for intersection! the one i came up with is `e.#[` (nb `]` would give length error in insert. edit: now that i actually think about why, for obvious reasons lol)\n\n`e.#[` is nice.  I can't take credit for `[-.-.` \\-- that's actually a [standard J idiom](https://code.jsoftware.com/wiki/Vocabulary/minusdot#dyadic).", "id": "gesb3z0", "owner_tier": 0.1, "score": 0.1739130433695652}, {"content": "**Raku, Parts 1 & 2**\n\nTrying to do all my solutions in functional Raku. I like the middle ground here between readability and conciseness.\n\n    sub part-one($group) {\n        (set $group.subst(\"\\n\", '', :g).comb).elems;\n    }\n    \n    sub part-two($group) {\n        [\u2229] $group.split(\"\\n\").map(-> $entry { set $entry.comb });\n    }\n    \n    sub MAIN($file, Bool :$p2 = False) {\n        say [+] $file.IO.lines(:nl-in(\"\\n\\n\")).map($p2 ?? &part-two !! &part-one);\n    }\n\nNice use of `:nl-in`, I'd never have thought of that.\n\nYou can make `part-two` even more concise like this:\n\n        [\u2229] $group.lines.map(*.comb.Set);\n\nThanks! [Saw it suggested](https://reddit.com/r/rakulang/comments/k6xhrm/does_raku_have_a_paragraphatatime_mode/) on /r/rakulang yesterday and it fit in nicely with today\u2019s challenge\n\nThanks for the tip! I didn\u2019t know about `.lines` on a string, but that makes sense. That\u2019s much more readable overall too!", "id": "getqcuj", "owner_tier": 0.1, "score": 0.1521739129347826}, {"content": "**Vim keystokes** \u2014 the first line, combining the paragraphs, is [copied from day 4](https://www.reddit.com/r/adventofcode/comments/k6e8sw/2020_day_04_solutions/geklpot/?utm_source=reddit&utm_medium=web2x&context=3) but with an added `!` at the end:\n\n    :g/^/ ,/\\v^$|%$/j!\u27e8Enter\u27e9\n    :%s/\\v(.)(.*\\1)@=//g\u27e8Enter\u27e9\n    :%j!\u27e8Enter\u27e9\n    g\u27e8Ctrl+G\u27e9\n\nYour part\u00a01 answer is displayed as \u2018Col 1 of <num>\u2019.\n\nHaving got each group on to a single line, the `:%s///` removes any character which also appears later in the line, so we have each question letter just once per group of passengers.\n\nThen the total we want is the number of letters remaining in the file. `:%j!` joins them all into a single line, and `g\u27e8Ctrl+G\u27e9` tells us (among other things) how many columns are in that line.\n\nYes, there are ways of getting that count into the buffer, but it spoils the simplicity of this and I didn't see the need \u2014 we have the answer on the screen, available for typing it into the website.", "id": "gesu64i", "owner_tier": 0.3, "score": 0.06521739119565217}, {"content": "Raku\n\n    sub rv (&code) { 'input'.IO.slurp.split(\"\\n\\n\", :skip-empty).map(&code).sum }\n    say \"One: \" ~ rv { .comb(/\\S/).Set.elems };\n    say \"Two: \" ~ rv { .lines.map({ .comb(/\\S/).Set }).reduce(&infix:<\u2229>).elems };\n\n>cggoebel\n\nThe [blog post](https://ergoletterbag.blogspot.com/2020/12/raku-advent-of-code-2020-day-6.html) which details my original solution and how I refactored it into this three line solution. FWIW: I'm using Advent of Code to learn Raku. The [Raku AoC Repo](https://github.com/codesections/advent-of-raku-2020) has been a tremendous help in providing examples of code and style.", "id": "geubpsp", "owner_tier": 0.1, "score": 0.09782608684782608}, {"content": "Placed 112/69. Python. Video of me solving at [https://youtu.be/e\\_66g1QcVlE](https://youtu.be/e_66g1QcVlE). [Code](https://topaz.github.io/paste/#XQAAAQB2AwAAAAAAAAA0m0pnuFI8c9WAoVc3IiG2khdS9RZHDy1KRQQmBUCL0xNYUHRS0RIX9qrRq01NX2n+Fwtz65btvRqlGNXvpLApfwKi0UaioHt1qJsc6HZDwlPbNt0y24RrXT4uaOTwfNM7PfP3TvD+7GNnTxP9mporexjG40EYBSJO60heY+wL90h2nC0DAQJKnmlDg1Da9XeZkO2CINCGkEQzEpraC7kxDO22iSKi7uPG5zsRzsM/tf+3lsQvqY2BeueWkS3ZNFVcPug999J3O8usKriiT0qiXiVC8UFXmXHJ3ifDEpflUWZu0fFSJRsjSQRbwUaGTQrpk20PGf0r+UCjemyin8VMjKS2MAThhnS6Vemo+AhM3uO4WqSzcRJhJID0nesHKtKazbV7eLE/DJZtfTM6Y4mncX8n405H+plbwCPsVcZxcCAkKbaxFMd+ezSq01ctXqck/jLL7A3u3VHURdVkPCWCILkx6idvFdbeGqqsgDj/+p7KbA==)\n\nThat deep exhale when you finally finished is my mood for 2020.\n\nGreat job, and I love the videos. Thanks for putting them up for others to watch.", "id": "ges7hl5", "owner_tier": 0.3, "score": 0.07608695641304349}, {"content": "#[Go/Golang](https://github.com/mnml/aoc/blob/master/2020/06/2.go) 990/1589\nI love maps.\n\n**1225/495** with [the same code less a loop](https://github.com/kindermoumoute/adventofcode/blob/master/2020/day6/main.go)\n\nEDIT: feel free to join the golang leaderboard ==> 235071-2acde629\n\nEDIT2: oh nvm you are already on it, hi mnml :-)\n\nNice!\n\n>less a loop\n\nNice! I feel silly for missing that.\n\n>feel free to join the golang leaderboard :-) ==> 235071-2acde629\n\nIs that reusing-code's leaderboard? If so, I've been on it since last year as mnml (currently first place!)\n\nIm joining the go lang leaderboard. I mean, someone needs to be in the bottom rank.", "id": "ges8oht", "owner_tier": 0.1, "score": 0.18478260858695653}, {"content": "**Python**\n\nExact same function for both parts, just changing union to intersection!\n\n    data = [list(map(set, group.splitlines())) for group in raw.split('\\n\\n')]\n    \n    def combine_with(func):\n        return sum(len(reduce(func, group)) for group in data)  # functools.reduce\n    \n    def part_one():\n        return combine_with(set.union)\n    \n    def part_two():\n        return combine_with(set.intersection)\n\nI love the purity / power of your parsing !\n\nMaybe you already know this, but TIL \\`set.union\\` and \\`set.intersection\\` can take multiple arguments, so you don't even need \\`functools.reduce\\` and can just use \\`func(\\*group)\\` in your \\`combine\\_with\\`", "id": "gesqren", "owner_tier": 0.3, "score": 0.10869565206521738}, {"content": "I love how easy **Raku** makes this:\n\n    sub MAIN(IO() $inputfile where *.f = 'aoc06.input', Bool :v(:$verbose) = False)\n    {\n        my @groups = $inputfile.slurp.split(/\\n\\s*\\n/);\n    \n        my $totalCount = @groups.map(*.comb(/<[a..z]>/).unique.elems).sum;\n        say $verbose ?? 'Part one: the sum of the counts is: ' !! '',\n            $totalCount;\n    \n        my $totalCount2 = @groups.map(-> $g { $g.comb(/<[a..z]>/).Bag.grep(*.value == $g.lines).elems }).sum;\n        say $verbose ?? 'Part two: the sum of the counts is: ' !! '',\n            $totalCount2;\n    }\n\n[https://github.com/mscha/aoc/blob/master/aoc2020/aoc06](https://github.com/mscha/aoc/blob/master/aoc2020/aoc06)", "id": "getcuvx", "owner_tier": 0.1, "score": 0.07608695641304349}, {"content": "# Python\n\nAnother horrible (lovely) set of one line solutions  \n\n\n    # Part 1\n    total = sum([len(set(\"\".join(group.split(\"\\n\")))) for group in open(\"input.txt\").read().split(\"\\n\\n\")])\n    print(f\"[P1] Sum of counts: {total}\")\n    \n    \n    # Part 2\n    total = sum([len(set.intersection(*[set(sub) for sub in group.split(\"\\n\")])) for group in open(\"input.txt\").read().split(\"\\n\\n\")])\n    print(f\"[P2] Sum of counts: {total}\")\n\nTIL set.intersection() \n\nConsider using group.replace('\\n', '') instead of the join/split combo.", "id": "getqxwh", "owner_tier": 0.3, "score": 0.08695652163043478}, {"content": "My answer for both in Python:\n\n    text = open(\"/Users/ieaston/advent6_input.txt\", \"r\").read().strip()\n    sets = [[set(member) for member in group.split('\\n')] for group in text.split('\\n\\n')]\n    print(sum([len(set.union(*l)) for l in sets]))\n    print(sum([len(set.intersection(*l)) for l in sets]))", "id": "getwy36", "owner_tier": 0.1, "score": 0.043478260760869566}, {"content": "**Python 3** short oneliners\n\nPart 1:\n\n    with open(\"input6.txt\") as f:\n        l = f.read().split(\"\\n\\n\")\n    sum(len(set.union(*(set(x) for x in group.splitlines()))) for group in l)\n\nPart 2:\n\n    sum(len(set.intersection(*(set(x) for x in group.splitlines()))) for group in l)", "id": "geuwhh9", "owner_tier": 0.5, "score": 0.05434782597826087}], "link": "https://www.reddit.com/r/adventofcode/comments/k7ndux/2020_day_06_solutions/", "question": {"content": "## NEW AND NOTEWORTHY\n\n* /u/jeroenheijmans is back with the [Unofficial AoC 2020 Participant Survey](/k76nux)!\n* /u/maus80 is back with an [interactive scatterplot](/k6nb8b) of the global leaderboard!\n\n***\n\n## Advent of Code 2020: Gettin' Crafty With It\n\n+ **UNLOCKED!**  Go forth and create, you beautiful people!\n+ Full details and rules are in the [Submissions Megathread](/k4emxn)\n+ Make sure you use one of the two templates!\n * Or in the words of AoC 2016: USING A TEMPLATE IS MANDATORY\n\n***\n\n#--- Day 06: Custom Customs ---\n\n***\n\nPost your solution in this megathread.  Include what language(s) your solution uses!  If you need a refresher, the full posting rules are detailed in the wiki under [How Do The Daily Megathreads Work?](/r/adventofcode/wiki/index#wiki_how_do_the_daily_megathreads_work.3F).\n\n**Reminder:** Top-level posts in Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the global leaderboard with gold stars for today's puzzle.~~\n###*EDIT:* Global leaderboard gold cap reached at 00:04:35, megathread unlocked!", "id": "k7ndux", "title": "-\ud83c\udf84- 2020 Day 06 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "It's my birthday :) \n\n6th/5th in Python.\n\nhttps://www.youtube.com/watch?v=_nI5uCcBTcs\n\nHAPPY BIRTHDAY! :D\n\nMan, I don't get how you can read the problem that fast. It takes me a good 2 minutes just to read through the problem and understand the puzzle. Congrats, I got 145/111, also with python\n\nThanks for sharing the video. It's very interesting to see other folks work.\n\nHappy Birthday!\n\nYour video makes it look so leisurely and relaxed.\n\n(Happy Birthday!)\n\nThanks for the video!!! i feel like i learned quite a bit even though we basically ended up with the same code in the end. I like the video because i can see your thought process. it also makes me feel better about what i am doing. i just need practice to get faster.\n\nWhy did you have graph[b].append(a)?  It seems to me like all that line did was make the lists double length.\n\nAs if you did this:    \n\n    for a in graph:\n        graph[a]=graph[a]*2\n\nThank you!\n\nSame here. I did it in C++, but I have all the parsing already done ahead of time. I just need to put in what characters I want to discard. Not sure what I did with that 8 minutes. This problem was extremely easy. I've done this kind of thing a million times before.\n\nedit: I tried it again from scratch knowing how to do it and it still took me 6 minutes. I gotta figure out what I'm doing wrong.\n\nedit2: Tried it again. Down to 4 minutes. Found that using iterators is super slow to type out. Checking if an item is in a container is again slow to type. Converting string to number is slow to type. I've added some macros for this and it greatly helped. We'll see next time.\n\nmy guess (not OP) was that it wasn't super clear that the input would list the return pipe. moving as fast as he did, probably read the part that they are bi-directional and this would ensure that those were set up.\n\nPython strikes a perfect balance between providing a concise way of writing code without allowing for too many options or ways of shooting yourself in the foot (e.g. Perl). It's exceedingly well suited for these kind of problems unless your solution is time constrained.\n\nThe added time (for me) comes from dealing with the type system of Rust. While it often aids me in refactoring for part 2, it's also something you need to work around. E.g. I spent ~15 seconds writing this:\n\n    let right: Vec<u64> = it.next()\n        .expect(\"right side\")\n        .trim()\n        .split(\", \")\n        .map(|s| s.parse::<u64>().unwrap())\n        .collect()?\n\nWhich is <5 seconds of this in Python:\n\n```\nmap(int, parts[1].split(','))\n```", "id": "dr4ft3r", "owner_tier": 0.1, "score": 0.999999999864865}, {"content": "2/1 today! [NetworkX](https://networkx.github.io/) makes this kind of problem very quick if you know what you're looking for. Today's question was asking about something called a [connected component](https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29), and NetworkX provides some [nice functions](https://networkx.github.io/documentation/stable/reference/algorithms/component.html) for dealing with them.\n\n**Python 3** solution:\n\n    import networkx as nx\n\n    # Create a graph of programs\n    graph = nx.Graph()\n\n    for line in LINES:\n        # Parse the line\n        node, neighbors = line.split(' <-> ')\n\n        # Add edges defined by this line\n        graph.add_edges_from((node, neighbor) for neighbor in neighbors.split(', '))\n\n    print('Part 1:', len(nx.node_connected_component(graph, '0')))\n    print('Part 2:', nx.number_connected_components(graph))\n\n\n[Relevant xkcd.](https://xkcd.com/353/)\n\n**Connected component (graph theory)**\n\nIn graph theory, a connected component (or just component) of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. For example, the graph shown in the illustration has three connected components. A vertex with no incident edges is itself a connected component. A graph that is itself connected has exactly one connected component, consisting of the whole graph.\n\n***\n\n^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&message=Excludeme&subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/adventofcode/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate)   ^]\n^Downvote ^to ^remove ^| ^v0.28\n\nI just spent 2 hours on part 1, 28 lines including a recursive function.\nI could not figure out how to do part 2 so I came here for hints. Seeing your solution.. What am I doing with my life.\n\nWow, that's super clean and concise!\n\nNetworkX is fantastic.\n\nIt made this one quick even if you don't know what you're looking for in the NetworkX API.  I had to google the NetworkX docs to find the connected_components() method and still made leaderboard.\n\nThese are the union-find connected component videos from famed algorithms professor Robert Sedgewick\n\nhttps://www.youtube.com/watch?v=8mYfZeHtdNc&list=PLe-ggMe31CTexoNYnMhbHaWhQ0dvcy43t\n\nthat didn't give me the right answer.\n\nedit: never mind o_O\n\nman i need to learn it\n\nTo get started, the basics are:\n\n    import networkx as nx\n    g = nx.Graph()\n    g.add_node(\"foo\")\n    g.add_node(\"bar\")\n    g.add_edge(\"foo\", \"bar\")\n\nThen you can use methods like `connected_components()` and some other nifty stuff, like shortest path.\n\n(Use DiGraph for directed graphs.)", "id": "dr4fxul", "owner_tier": 0.1, "score": 0.7162162160810811}, {"content": "Perl regex.\n\n    #! /usr/bin/env perl\n    \n    use strict;\n    use warnings;\n    \n    undef $/;\n    $_ = <> . \"\\n\"; # Add a newline in case it's missing\n    \n    s/[^\\d\\n ]//sg;\n    while (s/^[^x]*\\K\\b(\\d+)\\b([^\\n]*)\\n((?:.*?\\n)?)([^\\n]*\\b\\1\\b[^\\n]*\\n)/$1 x $2 $4$3/s) { }\n    s/\\b(\\S+)\\b(?=.*?\\b\\1\\b)//sg;\n    \n    printf \"Part 1: %d\\n\", scalar(() = (m/^(.*\\b0\\b.*)$/m)[0] =~ m/\\d+/g);\n    printf \"Part 2: %d\\n\", scalar(() = m/^.*?\\d/gm);\n\n\nThis space intentionally left blank.\n\nImpressive! I had fun working out what this does. (I don't think you need the first `s///` to get rid of the punctuation though; the rest of it seems to work fine with the punctuation left in.)\n\nI tried translating it to **Vim**. A literal transliteration of the regex syntax was far too slow, but using the same basic idea I came up with:\n\n    :set nows\u27e8Enter\u27e9\n    >G:%s/[^ 0-9]//g\u27e8Enter\u27e9\n    qa:s/\\v<(\\d+)>(.*<\\1>)@=//g\u27e8Enter\u27e9\n    qg&{qb0/\\v<(\\d+)>%(\\_.{-}<\\1>)@=\u27e8Enter\u27e9\n    *dd\u27e8Ctrl+O\u27e9pkJ@aq\n\nThat merges one group into the top one. Type `@b` for the next merge (or `10@b` to see a few). Run it to the end with:\n\n    qcqqc@b@cq@c\n\n(Took 2\u20133 minutes for me.) That leaves you with each group on a separate line. Tidy it up and count things:\n\n    :%s/\\v  +/ /g\u27e8Enter\u27e9\n    {:s/ /#/g|s/\\d//g\u27e8Enter\u27e9\n    g\u27e8Ctrl+G\u27e9\n\nThe number of columns on the first line is the answer to part 1, and the number of lines the answer to part 2. (Press `u` to restore the top line to listing its group numbers instead of a row of hashes.)\n\n*Edit:* Typo fix, spotted by /u/askalski. Sorry.\n\nVery nice.  By the way, the `:%s/\\v  +/ /\u27e8Enter\u27e9` needs a `/g` modifier to squeeze out all the whitespace on each line.\n\nYou're right that the `s/[^\\d\\n ]//sg;` in my Perl code is unnecessary.  I put it in there to speed things up slightly (less text to scan each pass.)  On my input, it runs about 20% faster as a result.\n\n\nThanks, for both the explanation and for telling me about the typo (and indeed for reading the code carefully enough to spot it.) Cheers.", "id": "dr4kojx", "owner_tier": 0.3, "score": 0.2432432431081081}, {"content": "When you only care about connected components, union find is faster to code than BFS: https://gist.github.com/anonymous/02de56ccaa4c22b2388c927f00091588\n\n[removed]\n\nI use no prewritten Python code - I only have prewritten Java code for algorithms that would be difficult to implement on-the-fly - that's my fallback in case some tough algorithms problems show up in later days.\n\nI don't think it could be easier\n\n    #include <iostream>\n    #include <set>\n    \n    const int s = 2000;\n    \n    int parent[s];\n    \n    int find(int a) {\n    \tif(parent[a] == a) return a;\n    \treturn parent[a] = find(parent[a]);\n    }\n    void unite(int a, int b) {\n    \tparent[find(a)] = find(b);\n    }\n    \n    int main() {\n    \tfor(int i = 0;i < s;++ i) parent[i] = i;\n    \tfor(int i = 0;i < s;++ i) {\n    \t\tint a;\n    \t\tstd::cin >> a;\n    \t\twhile(true) {\n    \t\t\tint b;\n    \t\t\tstd::cin >> b;\n    \t\t\tif(b == -1) break;\n    \t\t\tunite(b, a);\n    \t\t}\n    \t}\n    \n    \tstd::set<int> groups;\n    \tfor(int i = 0;i < s;++ i) {\n    \t\tgroups.insert(find(i));\n    \t}\n    \tstd::cout << groups.size() << std::endl;\n        return 0;\n    }\n    \n", "id": "dr4gdze", "owner_tier": 0.1, "score": 0.16216216202702702}, {"content": "Missed the leaderboard by a few because of a typo. Grr.\n\nUsed a perl script to turn input into a graphviz dot file, and then...\n\n    perl day12.pl < day12.txt | ccomps -X 0 | gc -n\n    perl day12.pl < day12.txt | gc -c\n\nday12.pl:\n\n    #!/usr/bin/perl\n    print \"graph day12 {\\n\";\n    while (<>) {\n        s/<->/--/;\n        s/,/ -- /g;\n        print;\n    }\n    print \"}\\n\";\n\n\nThe graph as a [rather large image](https://imgur.com/o1T9Enz).\n\nThis space intentionally left blank.\n\nFrom the manpage:\n\n> If it is a directed graph, indicated by digraph, then the edgeop must be \"->\". If it is an undirected graph then the edgeop must be \"--\".\n\n>  n0 edgeop n1 edgeop ... edgeop nn [name0=val0,name1=val1,...];\n\n> Creates edges between nodes n0, n1, ..., nn and sets their attributes according to the optional list.  Creates nodes as necessary.\n\nNo commas as edge separators. Thus, the turning them into `--`. I suppose I could have split it up into a bunch of single connections, but then it wouldn't be a 8 line toy script and I would have actually had to do work.\n\nThis space intentionally left blank.\n\nAgain, according to the documentation of the dot format, it doesn't. See `man dot`\n\nThis space intentionally left blank.\n\nInteresting. They really should update the docs.", "id": "dr4fvrb", "owner_tier": 0.9, "score": 0.2432432431081081}, {"content": "This space intentionally left blank.\n\nThis space intentionally left blank.\n\nNice. I\u2019ve either got to get better at writing adhoc Parsers or at writing Parsec parsers, since writing the input parser seems to take me more time than writing the solution itself!\n\n(Maybe I should be looking at ViewPatterns?)\n\nYeah, the Data.Graph solution was basically `map flattenSCC . stronglyConnComp` (and then part one is finding the length of the sub-list that contained 0 and part two is the length of the entire list)\n\nAlternatively, part 1 is solvable directly with `length $ reachable graph 0`", "id": "dr4gt34", "owner_tier": 0.3, "score": 0.12162162148648648}, {"content": "F#. First try had some some mutable values. I managed to refactor to a functional solution I'm happy with.\n\n    let solveday12 (lines: string[]) =\n        let mapping = \n            lines\n            |> Array.map (fun l -> l.Replace(\" <-> \", \",\").Split(','))\n            |> Array.map (Array.map int)\n            |> Array.map (fun l -> (l.[0], l.[1..]))\n            |> Map.ofArray\n    \n        let rec explore seen root = \n            if Set.contains root seen then\n                seen\n            else\n                Array.fold explore (seen.Add root) mapping.[root]\n    \n        let countComponents (count, seen) (num, _) =\n            if Set.contains num seen then\n                (count, seen)\n            else \n                (count + 1, explore seen num)\n    \n        let ans1 = explore Set.empty 0 |> Set.count\n    \n        let ans2 = \n            mapping \n            |> Map.toSeq\n            |> Seq.fold countComponents (0, Set.empty)\n            |> fst\n    \n        (ans1, ans2)\n    \n\n\nI also used F#:\n\n    module AdventOfCode2017.Day12\n\n    open System\n\n    let parseInput (lines : string[]) : Map<int, Set<int>> =\n        lines\n        |> Array.map (\n            fun str ->\n                let l = str.Split ([| ' '; ',' |], StringSplitOptions.RemoveEmptyEntries)\n                int l.[0], l.[2..] |> Array.map int |> Set.ofArray\n        ) |> Map.ofArray\n\n    let graphCount (g : Map<int, Set<int>>) =\n        let rec visit (visited : Set<int>) (current : int)  : Set<int> =\n            if visited |> Set.contains current then\n                Set.empty\n            else\n                let visited' = visited.Add current\n                g.[current] + (g.[current] |> Set.map (visit visited') |> Set.unionMany)\n\n        let rec nbRoots (vertices : Set<int>) =\n            if Set.isEmpty vertices then 0 else 1 + nbRoots (vertices - (visit Set.empty (vertices |> Set.minElement)))\n\n        visit Set.empty 0 |> Set.count, g |> Map.toList |> List.map fst |> Set.ofList |> nbRoots\n\nmore F#, after a little help\n\nhttps://github.com/a-red-christmas/aoc2017-fs/blob/master/day12/Program.fs", "id": "dr4i1uo", "owner_tier": 0.1, "score": 0.06756756743243243}, {"content": "**Rust:** (231, 194), trying to optimize my workflow a bit more.\n\nEdit: cleaned up version here: https://github.com/udoprog/rust-advent-of-code-2017/blob/master/src/day12.rs\n\n    #![feature(generators)]\n    #![feature(generator_trait)]\n    #![feature(conservative_impl_trait)]\n    #![feature(never_type)]\n    #![feature(inclusive_range_syntax)]\n    #![feature(iterator_step_by)]\n\n    #![allow(unused)]\n    #![allow(dead_code)]\n\n    use std::io::Read;\n    use std::collections::{HashMap, HashSet, VecDeque};\n\n    fn count(children: &HashMap<u64, Vec<u64>>, current: u64) -> (u64, HashSet<u64>) {\n        let mut count = 0u64;\n        let mut seen = HashSet::new();\n\n        let mut queue = VecDeque::new();\n        queue.push_back(current);\n\n        while let Some(id) = queue.pop_front() {\n            if !seen.insert(id) {\n                count += 1;\n                continue;\n            }\n\n            if let Some(children) = children.get(&id) {\n                for child in children {\n                    queue.push_back(*child);\n                }\n            }\n        }\n\n        (count, seen)\n    }\n\n    fn run<R: Read>(mut reader: R) -> (u64, u64) {\n        let data = {\n            let mut data = String::new();\n            reader.read_to_string(&mut data);\n            data\n        };\n\n        let mut children: HashMap<u64, Vec<u64>> = HashMap::new();\n        let mut all_ids = HashSet::new();\n\n        for line in data.lines() {\n            let mut it = line.split(\" <-> \");\n\n            let left: u64 = it.next().expect(\"bad id\").parse().expect(\"bad id\");\n\n            let right: Vec<u64> = it.next()\n                .expect(\"bad ids\")\n                .split(\", \")\n                .map(|d| d.parse::<u64>())\n                .collect::<Result<Vec<_>, _>>()\n                .expect(\"bad ids\");\n\n            all_ids.insert(left);\n            all_ids.extend(right.iter().cloned());\n\n            children.insert(left, right);\n        }\n\n        let zero_group = count(&children, 0).0;\n\n        let mut groups = 0u64;\n\n        while let Some(next_id) = all_ids.iter().cloned().next() {\n            for found in count(&children, next_id).1 {\n                all_ids.remove(&found);\n            }\n\n            groups += 1;\n        }\n\n        (zero_group, groups)\n    }\n\n    #[test]\n    fn it_works_example() {\n        use std::io::Cursor;\n\n        assert_eq!(run(Cursor::new(include_str!(\"../day12.txt\"))), (113, 202));\n    }\n\n[deleted]\n\n`Read` is just my default. It permits the most flexibility in how much data should be kept in memory at a time and anything that can be 'read' implements it. Arguably this is yet to be a problem with AoC since all inputs are rather small. Strings can be adapted using io::Cursor.\n\nAs for Option, I'm not doing that (but ? is coming for it too soon!). I can walk you through it if you can tell me what you are referring to?\n\n[deleted]\n\nAh, it is indeed a `Result`: https://doc.rust-lang.org/std/primitive.str.html#method.parse\n\nAlso, here is `try_trait` which will add support for Option:\n\nhttps://github.com/rust-lang/rust/issues/42327\n\nhttps://doc.rust-lang.org/beta/unstable-book/library-features/try-trait.html", "id": "dr4g4tk", "owner_tier": 0.5, "score": 0.12162162148648648}, {"content": "**Bash** with **pipes**!\n\nPart 1 (reads from stdin):\n\n    sed -E 's/[^0-9]*([0-9]+)[^0-9]+/\\1|/g; s/[0-9]+/_&_/g' | ./find_grp.sh\n    grep -oE \"[0-9]+\" conns | sort | uniq -d | wc -l && rm -f conns match pipes\n\n\nPart 2 (reads from stdin):\n\n    sed -E 's/[^0-9]*([0-9]+)[^0-9]+/\\1|/g; s/[0-9]+/_&_/g' | ./find_grp.sh\n    arglen=-1\n    while [ $arglen -ne 0 ]\n    do cat pipes conns | sort | uniq -u > arg\n       arglen=$(cat arg | wc -l); ((i++))\n       cat arg | ./find_grp.sh\n    done\n    echo $i; rm -f arg conns match pipes\n\n`find_grp.sh`:\n\n    cat > pipes && head -1 pipes > conns\n    prev=0; rem=-1\n    while [ $rem -ne $prev ]\n    do grep -E -f conns pipes > match && cat match >> conns\n       prev=$rem; rem=$(cat pipes conns | sort | uniq -u | wc -l)\n    done\n\n\nThe solution would get even more pipeliney if I replaced\n\n    [...] | uniq -u > arg\n    [...]\n    cat arg | ./find_grp.sh\n\nwith\n\n    [...] | uniq -u | tee arg | ./find_grp.sh\n    [...]\n\nand\n\n    cat > pipes && head -1 pipes > conns\n\nwith\n\n    tee pipes | head -1 > conns\n\nbut I'm hitting some non-deterministic issue where `tee` sometimes copies only the first n*4K bytes of its input to the file. My working theory is that I'm probably using `tee` the wrong way. :-)", "id": "dr4ldcs", "owner_tier": 0.1, "score": 0.040540540405405404}, {"content": "**[Mathematica](https://github.com/HiggstonRainbird/AoC-2017)**\n----\n\nMathematica's graph theory capabilities are very useful here.  Less useful is `Import[]` - I spent far more time trying to parse the input than solving the problem itself.  199/97.\n\n**Import:**\n\n\tinput=\n\t\tToExpression[StringSplit[StringSplit[#,\" <->\"],\",\"]]&/@\n\t\tImport[FileNameJoin[{NotebookDirectory[],\"Day11Input.txt\"}],\"List\"][[;;-2]]\n\n\tg=Graph[Flatten[Thread[#[[1,1]]<->Flatten[#[[2]]]]&/@input],VertexLabels->\"Name\"]\n\n**Part 1:**\n\n\tLength@SelectFirst[ConnectedComponents[g],MemberQ[#,0]&]\n\n**Part 2:**\n\n\tLength@ConnectedComponents[g]\n\nI also used Mathematica today because I got lazy.\n\nHere's a picture of the graph\n\nhttps://imgur.com/a/6oTV7\n\n\n\nNot to nitpick, but you should do something like `Graph[DeleteDuplicatesBy[edges, Sort]]`to remove those duplicate edges, e.g. when A<->B and B<->A. Not sure why Mathematica doesn't remove those by default.\n\n^(Hi, I'm a bot for linking direct images of albums with only 1 image)\n\n**https://i.imgur.com/AxbxkYa.png**\n\n^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&subject=ignoreme&message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&subject=delet%20this&message=delet%20this%20dr4hd44) ", "id": "dr4fu9q", "owner_tier": 0.5, "score": 0.12162162148648648}, {"content": "**Rust** (235/198)\n\n    fn main() {\n        let input = include_str!(\"../input.txt\");\n        let mut ivec = Vec::new();\n        for line in input.lines() {\n            let mut parts = line.split_whitespace();\n            let program = parts.next().unwrap().parse::<usize>().unwrap();\n            parts.next();\n            let mut pipes = Vec::new();\n            for sprogram in parts {\n                let a = sprogram.split(\",\").next().unwrap().parse::<usize>().unwrap();\n                pipes.push(a);\n            }\n            ivec.push((program, pipes));\n        }\n        let mut groups = 0;\n    \n        while ivec.len() > 0 {\n            let mut connections = vec![ivec.clone().get(0).unwrap().0.clone()];\n            let mut priorconnections = Vec::new();\n            while priorconnections != connections {\n                priorconnections = connections.clone();\n                for p in ivec.clone() {\n                    if connections.contains(&p.0) {\n                        connections.append(&mut p.1.clone());\n                    }\n                }\n                connections.sort();\n                connections.dedup();\n            }\n            ivec.retain(|x| !connections.contains(&x.0));\n            groups += 1;\n        }\n        println!(\"{:?}\", groups);\n    }\n\n\nTIL about Rust's \"dedup()\" vector function. Thanks!", "id": "dr4gjdt", "owner_tier": 0.1, "score": 0.040540540405405404}, {"content": "As usual, I was less than a minute from getting on the leaderboard for both stars. Damn, this year has some fast challenges.\n\nAnyway, my solution in Python 3, written with no knowledge of existing Python graph theory modules:\n\n    pipes = {}\n    with open('day12.in') as f:\n        for line in f:\n            src, _, dsts = line.split(maxsplit=2)\n            pipes[int(src)] = set(map(int, dsts.split(', ')))\n    \n    def find_group(seed):\n        group = {seed}\n        new = {seed}\n        while new:\n            next_new = set()\n            for item in new:\n                next_new.update(pipes[item])\n            new = next_new - group\n            group.update(next_new)\n        return group\n    print('Part 1:', len(find_group(0)))\n    \n    remaining = set(pipes)\n    groups = 0\n    while remaining:\n        groups += 1\n        group = find_group(remaining.pop())\n        remaining -= group\n    print('Part 2:', groups)\n", "id": "dr4gc2e", "owner_tier": 0.5, "score": -1.3513513431385529e-10}, {"content": "PowerShell. Missed the leaderboard for part 1 by 23 seconds, partly because of a type error of mixing int and string getting it into an infinite loop.\n\nPart 1, build a hashtable of connections, recursively follow the connections but keep track of visited nodes so it doesn't go into an infinite loop:\n\n    $in = @'\n    0 <-> 199, 1774\n    1 <-> 350, 1328, 1920\n    etc.\n    '@ -split \"`r?`n\"\n\n\n    $connections = @{}\n    $in | ForEach-Object {\n\n        [int]$Left, [string]$Right = $_ -split ' <-> '\n\n        $connections[$Left] = [int[]]@($Right -split ', ')\n    }\n\n    $visited = New-Object System.Collections.ArrayList\n\n    function visit ([int]$id)\n    {\n        foreach ($node in $connections[$id])\n        {\n            if ($node -notin $visited)\n           {\n                [void]$visited.add($node)\n                visit $node\n            }\n        }\n    }\n\n    visit 0\n\n    # Part 1 answer:\n    $visited | Sort-Object -Unique | Measure-Object\n\n    # That's the right answer! You are one gold star closer to debugging the printer. You got rank 118 on this star's leaderboard. [Return to Day 12]\n\nPart 2 I mashed up, wasn't as confident with and copy-pasted my visitor, rewrote it a bit, took longer; it took all the nodes, started visiting them and removing them from the list. When that ran out, increase group count and go again, until all the nodes were visited.\n\n    [System.Collections.Generic.List[int]]$allNodes = $connections.Keys | ForEach-Object {$_}\n    $allNodes += $connections.Values | ForEach-Object {$_}\n\n    [System.Collections.Generic.List[int]]$allNodes = $allNodes | Sort-Object -Unique\n\n    function visit2 ([int]$id)\n    {\n        foreach ($node in $connections[$id])\n        {\n            if ($node -notin $visited2)\n           {\n                [void]$visited2.Add($node)\n                if ($node -in $allNodes)\n                {\n                    [void]$allNodes.remove($node)\n                    visit2 $node\n                }\n            }\n        }\n    }\n\n    $groups = 0\n    while ($allNodes)\n    {\n        $visited2 = New-Object -TypeName System.Collections.ArrayList\n\n        $node = $allNodes[0]\n        [void]$allNodes.Remove($node)\n        visit2 $node\n        $groups++\n    }\n    $groups\n\n    # 1044 wrong\n\n    # That's the right answer! You are one gold star closer to debugging the printer. You got rank 230 on this star's leaderboard.\n\n\n\nI'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:\n\n- [/r/pwsh2017aoc] [Day 12 - Travelling hashtable salesman](https://www.reddit.com/r/pwsh2017aoc/comments/7j8lnw/day_12_travelling_hashtable_salesman/)\n\n&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*\n\nyeah, my first stab at part2 was absurdly slow cause i was just going to generate the group for each node, then select distinct groups.  figuring out how to either remove or selectively start a new loop there stumbled me a bit.\n\nyours, just using $allnodes everywhere is pretty convenient :)", "id": "dr4grnp", "owner_tier": 0.7, "score": 0.027027026891891893}, {"content": "**Python 2** with a defaultdict of sets:\n\n    import time\n    from collections import defaultdict\n\n    def problem(d):    \n        dd = defaultdict(set)        \n\n        for line in d:\n            tokens = line.replace(\",\",\"\").split()\n            node, connections = int(tokens[0]), map(int,tokens[2:])\n            for item in connections:\n                dd[node].add(item)\n                dd[item].add(node)\n\n        # groupnodes starts with all nodes that need to be accounted for in a grouping\n        groupnodes = set(dd.keys())\n        \n        # now start with a node and merge adjacents\n        # any node that got accounted for in a flattening gets\n        # discarded from the groupnode set\n        def flatten(n):\n            prevl = 0\n            length = len(dd[n])\n            groupnodes.discard(n)\n            \n            # Keep merging in sets until the length stops growing from\n            # doing so\n            while length != prevl:\n                items = list(dd[n])\n                for item in items:\n                    dd[n] |= dd[item]\n                    groupnodes.discard(item)\n                prevl = length\n                length = len(dd[n])\n\n        flatten(0)\n        print \"part 1:\", len(dd[0])\n\n        # flatten all remaining nodes in the groupnodes set until every node has been processed\n        # there will be one new group per pass    \n        count = 1\n        while len(groupnodes):\n            n = groupnodes.pop()\n            flatten(n)\n            count += 1\n            \n        print \"part 2:\", count    \n\n    if __name__ == \"__main__\":\n        start = time.time()\n        problem(open(\"day12.txt\").readlines())\n        print time.time() - start,\"s\"\n\nedit: cleaned up a little and added some comments for future reference", "id": "dr4h0qj", "owner_tier": 0.3, "score": -1.3513513431385529e-10}, {"content": "\t#!/bin/bash\n\t(\twhile read a b c\n\t\tdo\tlist[a]=\"$c\"\n\t\tdone\n\t\tgroups=0\n\t\twhile :\n\t\tdo\tfound=false\n\t\t\tfor i in ${!list[@]}\n\t\t\tdo\t[[ -z ${group[i]} ]] && found=true && group[i]=1 && todo[i]=1 && break\n\t\t\tdone\n\t\t\t$found || break\n\t\t\twhile [[ ${!todo[@]} ]]\n\t\t\tdo\tfor i in ${!todo[@]}\n\t\t\t\tdo\tfor j in ${list[i]//,/}\n\t\t\t\t\tdo\t[[ -z ${group[j]} ]] && group[j]=1 && todo[j]=1\n\t\t\t\t\tdone\n\t\t\t\t\tunset todo[i]\n\t\t\t\tdone\n\t\t\tdone\n\t\t\t((groups++,groups==1)) && echo ${#group[@]}\n\t\tdone\n\t\techo $groups\n\t)<input\n", "id": "dr4hlj8", "owner_tier": 0.3, "score": -1.3513513431385529e-10}, {"content": "Went with a more obscure language today - here's my solution for part 2 in [io](http://iolanguage.org/index.html):\n\n    file := File with(\"12-input.txt\")\n    lines := file readLines\n    file close\n\n    dict := Map clone\n    lines foreach(i, v,\n        nums := v split(\" <-> \")\n        dict atPut(nums first, nums last split(\", \"))\n    )\n\n    set := Map clone\n    check := method(x,\n        dict at(x) foreach(i, v,\n            set hasKey(v) ifFalse(\n                set atPut(v)\n                check(v)\n            )\n        )\n    )\n\n    groups := 0\n    dict keys foreach(i, v,\n        set hasKey(v) ifFalse(\n            groups = groups + 1\n            set atPut(v)\n            check(v)\n        )\n    )\n\n    groups println\n", "id": "dr4j0wk", "owner_tier": 0.5, "score": -1.3513513431385529e-10}, {"content": "**Node.js/JavaScript**\n\nI'm... sorry.\n\n    const fs = require('fs')\n    let inp = fs.readFileSync(\"./day12input\").toString('utf-8').trim().split(/[\\r\\n]+/) // array of lines\n      .map((x) => x.split(\">\")[1].split(\", \").map(y => parseInt(y)))\n\n    let visited = []\n    function reach(i) {\n      if (visited.includes(i))\n        return 0\n      visited.push(i)\n      return inp[i].reduce((a,b) => a + reach(b), 1)\n    }\n\n    inp = inp.map((_, k) => reach(k))\n    console.log(\"a:\", inp[0]);\n    console.log(\"b:\", inp.filter(x => x > 0).length);\n\n\nUnit tests be damned! I like it.", "id": "dr4j2uq", "owner_tier": 0.5, "score": 0.027027026891891893}, {"content": "Ruby, silver 17 / gold 29\n\nI had the wrong answer on part 2 because I used 100.times again, which forced me to wait 1 minute :( This one was an easy incomplete BFS which assumes all groups can be found in under 100 steps.\n\n    g=[0]\n    h={}\n    $<.map{|x|a,b=x.split' <-> '\n    h[a.to_i]=b.split(', ').map &:to_i\n    }\n    l=[]\n    c=0 # part 2\n    loop{ # end part 2\n    100.times{s=[]\n    g.map{|x|s+=h[x]}\n    l+=g\n    g=s-l}\n    c+=1 if h.delete_if{|x,y|l.index x} # part 2\n    l=[]\n    break unless h.keys.any?\n    g=[h.keys.first]\n    } # end part 2\n    p l.size # part 1\n    p l.size,c # part 2\n\nYes, I messed about with 10.times, 20.times etc myself until deciding that an until loop would be more foolproof.\n\nLine 3: No need to split each line twice, just `scan` it for number-looking things:\n\n    a,*b = x.scan(/\\d+/).map(&:to_i)\n\nWhat we need is a graph library like how python has networkx :)\n\nThat is a valid and very constructive suggestion, I'm surprised I missed it. An alternative is splitting by `/\\D+/` since we don't care about non-digits:\n\n    a,*b = x.split(/\\D+/).map &:to_i\n\nIt can't stand in the shadow of NetworkX, but https://github.com/chikamichi/plexus looks like a candidate.", "id": "dr4fte4", "owner_tier": 0.3, "score": 0.06756756743243243}, {"content": "I stupidly forgot to return my hashset if I had already visited a node, which I think made me too slow for part 2 (I also slowly went through the test case instead of just bum rushing it).\nfrom collections import defaultdict\n\n    def count_connected(adj, start, seen=set()): \n        '''\n        Counts the number of nodes connected to start.\n        '''\n        if start in seen:\n            return 0\n        else:\n            seen.add(start)\n            return 1 + sum([count_connected(adj, child, seen) for child in\n                            adj[start]])\n    \n    def connected_group(adj, start, seen=set()): \n        '''\n        Returns the set of nodes connected to start.\n        '''\n        if start in seen:\n            return seen\n        else:\n            seen.add(start)\n            for child in adj[start]:\n                # This actually isn't necessary by virtue of how optional\n                # parameters work in Python, but it's better to be explicit.\n                seen = connected_group(adj, child, seen)\n            return seen \n    \n    with open('12.in') as inp:\n        # Adjacency list of the form {node: set(children)}.\n        adj = defaultdict(set)\n        for line in inp:\n            start, nodes = line.strip().split(' <-> ')\n            adj[start] = set(nodes.split(', '))\n            # This graph is bidirectional, so update the adjacency list for the\n            # children, too.\n            for node in adj[start]:\n                adj[node].add(start)\n        # Part 1.\n        print(count_connected(adj, '0')) \n        groups = set()\n        # Find the connected groups starting from each node.\n        for start in adj.keys():\n            # Sets aren't hashable, so use frozenset.\n            groups.add(frozenset(connected_group(adj, start)))\n        # Part 2.\n        print(len(groups))\n\nEdits:\n\nI also foolishly\n\n1. Didn't leverage the function I already had but instead wrote a new one for part 2 (this wasn't a big time loss, though).\n\n2. Didn't implement the bidirectionality (I only did connections one way) which I got lucky with based on how part 1 worked.\n\nEdit 2:\n\nUpdated code.\n\nBTW, it's faster to `for line in inp` than it is to `inp.readlines()`. The former is a generator that reads one line at a time, and the latter reads the entire file into memory first.\n\nMaybe in general, but since we have to fit the entire relatively small graph in memory anyway and the string representation isn't much, if any, larger than that, it doesn't matter too much for this puzzle.\n\nGiven the constraints of these puzzles, it's unlikely to matter for any of them really.  Unless topaz throws a multi-GB input at us from his poor webserver.\n\nThanks for that. It definitely looks more pythonic. I'll edit into the file once I do some more prettying up.\n\nThat's true, and it's also faster to write `for line in inp` than it is to write `for line in inp.readlines()`. Not much, but when a 5 letter variable is too long to write, so is `inp.readlines()` :P\n\nThat's true enough.", "id": "dr4g496", "owner_tier": 0.1, "score": 0.09459459445945946}, {"content": "PHP\n\nI seem to be one of the few using recursion. I don't even know why I use recursion, it came naturally to me :-/\n\nPart 1:\n\n\tfunction run_the_code($input) {\n\t\t$lines = explode(PHP_EOL, $input);\n\t\t$groups = [];\n\t\tforeach ($lines as $line) {\n\t\t\tif (preg_match('/(\\d+) <-> (.*)/', $line, $matches)) {\n\t\t\t\tlist($_, $a, $b) = $matches;\n\t\t\t\t$groups[$a] = array_map('trim', explode(',', $b));\n\t\t\t}\n\t\t}\n\t\n\t\t$nullGroup = [];\n\t\t$rec = function($root) use (&$rec, &$nullGroup, $groups) {\n\t\t\tif (!in_array($root, $nullGroup)) {\n\t\t\t\t$nullGroup[] = $root;\n\t\t\t\tforeach ($groups[$root] as $ch) {\n\t\t\t\t\t$rec($ch);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t$rec('0');\n\t\n\t\treturn count($nullGroup);\n\t}\n\nPart 2:\n\n\tfunction run_the_code($input) {\n\t\t$lines = explode(PHP_EOL, $input);\n\t\t$groups = [];\n\t\tforeach ($lines as $line) {\n\t\t\tif (preg_match('/(\\d+) <-> (.*)/', $line, $matches)) {\n\t\t\t\tlist($_, $a, $b) = $matches;\n\t\t\t\t$groups[$a] = array_map('trim', explode(',', $b));\n\t\t\t}\n\t\t}\n\t\n\t\t$subgroups = [];\n\t\t$rec = function($base, $root) use (&$rec, &$subgroups, $groups) {\n\t\t\tif (!array_key_exists($base, $subgroups)) {\n\t\t\t\t$subgroups[$base] = [];\n\t\t\t}\n\t\t\tif (!in_array($root, $subgroups[$base])) {\n\t\t\t\t$subgroups[$base][] = (int)$root;\n\t\t\t\tforeach ($groups[$root] as $ch) {\n\t\t\t\t\t$rec($base, $ch);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tforeach ($groups as $base => $root) {\n\t\t\t$rec($base, $base);\n\t\t\t// prepare for unique\n\t\t\tsort($subgroups[$base]);\n\t\t\t// array_unique does not work on multidimensional arrays, so hack it\n\t\t\t$subgroups[$base] = implode('-', $subgroups[$base]);\n\t\t}\n\t\t$simple = array_unique($subgroups);\n\t\n\t\treturn count($simple);\n\t}\n\n\nI had the same idea. I went with recursion because the problem seemed similar to Day 7.", "id": "dr4g7xs", "owner_tier": 0.1, "score": -1.3513513431385529e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/7j89tr/2017_day_12_solutions/", "question": {"content": "#--- Day 12: Digital Plumber ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Need a hint from the [Hugely^* Handy^\u2020 Haversack^\u2021 of Helpful^\u00a7 Hints^\u00a4](/r/adventofcode/w/h5)?\n\n[Spoiler](#s \"If today's puzzle is too easy, try adding: #define if(x) if ((x) && (rand() < RAND_MAX * 0.99))\")\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n\n###*edit:* Leaderboard capped, thread unlocked!", "id": "7j89tr", "title": "-\ud83c\udf84- 2017 Day 12 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "**Haskell** - single pass with `foldr`. Using foldr you work with a completely reduced tail and just adding things on to the front of that one at a time reducing as needed.\n\nhttps://github.com/glguy/advent2018/blob/master/execs/Day05.hs#L27-L31\n\n    part1 :: String -> Int\n    part1 = length . foldr step \"\"\n      where\n        step x (y:ys) | x /= y && toUpper x == toUpper y = ys\n        step x ys                                        = x : ys\n\nThat is actually pretty smart!\n\nI felt like today's challenge was really suited for Haskell, but the bruteforce algorithm I implemented (react until nothing changes) is not as elegant.\n\nWell, thanks for keep posting your solutions, I always like to learn more haskell!\n\n\n\nthis is poetry\n\nI'm so used to left folds I never remember that right folds exist.\n\nThat is a cool solution, and probably way faster than mine.\n\nEdit: Yep, waaay faster.\n\nwow this is amazing! so elegant. I spent a week hacking some recursive solution in haskell :(\n\n\n\n\nNice short solution! Did it get you onto the leaderboard?\n\nHaha! I did the same right fold in F#, but I didn't realize that the fold produced the correct solution in a single pass so I added some unneeded recursion:\n\n    let reacts a b = (abs ((int a) - (int b))) = 32 // 32 = distance between uppercase/lowercase in ASCII\n\n    let reduceOnce polymer =\n        List.foldBack (fun u polymer -> \n            match polymer with\n            | head::rest when reacts head u ->  rest\n            | _ -> u::polymer\n        ) polymer []\n\n    let rec reduce polymer =\n        let once = reduceOnce polymer\n        let twice = reduceOnce once\n        if once = twice then once\n        else reduce twice // Never actually true!\n\nAfter seeing your comment I simply removed my second function and renamed my first! \n\nThis space intentionally left blank.\n\nNice! Here was mine, which was arrived at independently.\n\n    sameType = (==) `on` toLower\n    oppositePolarity = (/=) `on` isLower\n\n    reactable x1 x2 = x1 `sameType` x2 && x1 `oppositePolarity` x2\n\n    reactTwo x1 (x2:xs) = if reactable x1 x2 then xs else x1:x2:xs\n    reactTwo x1 []      = [x1]\n\n    reactAll = foldr reactTwo \"\"\n\nLooking at yours, I think I went overboard with the function decomposition, but it's clear to see that they are using the same idea.\n\nI did this the slow way too :(.  glguy's solution is elegant and simple. \n It's a good reminder that the accumulator to fold functions needn't always grow/accrue, it can \"deaccumulate\" too", "id": "eb4dchg", "owner_tier": 0.3, "score": 0.9999999998630138}, {"content": "Missed the leaderboards because I was forgetting to trim my iinput for whitespace. Lesson learned I guess!\n\n    import sys\n    \n    line = [line for line in sys.stdin][0].strip()\n    \n    \n    def are_opp(a, b):\n        return (a.lower() == b.lower() and\n                ((a.isupper() and b.islower()) or\n                 (a.islower() and b.isupper())))\n    \n    \n    def react(line):\n        buf = []\n        for c in line:\n            if buf and are_opp(c, buf[-1]):\n                buf.pop()\n            else:\n                buf.append(c)\n        return len(buf)\n    \n    \n    agents = set([c.lower() for c in line])\n    \n    # part 1\n    print(react(line))\n    \n    # part 2\n    print(min([react(line.replace(a, '').replace(a.upper(), ''))\n               for a in agents]))\n    \n\nSame here. That pesky carriage return threw me off.\n\n>if buf and **are\\_opp(c, buf\\[-1\\])**:\n\nwhat do you think about this suggestion:\n\n*if bug and* `buf[-1] == c.swapcase():`\n\nDamn, I feel stupid. When I saw your solution, it looks so simple and ran plenty fast, where mine...\n\nWell, it is shitty reimplementation of fold with runtime measured in seconds. I am not proud for getting those gold stars.\n\nKudos on this one. It's easy to understand and much better than what I wrote.\n\nThis is really great.\n\nThanks man, that fixed my problem.\n\nI had almost the same solution, except for the condition that you have in your `are_opp`.\n\nI had `a.lower() == b or a == b.lower()`.\n\nObviously it missed some cases because I had too many chars in the end, but I don't see which ones.\n\nDo you have any idea ?\n\n[Edit] : of course I checked my output for matching pairs and there where none. I modified only the condition in my original program and I passed the puzzle.\n\nFell into this one as well.\n\nNot OP, but I think swapcase is neat! I was using \\`abs(ord(buf\\[-1\\]) - ord(c)) == 32\\` myself.", "id": "eb4ff0j", "owner_tier": 0.3, "score": 0.5342465752054795}, {"content": "Oooh, another challenge where using **Vim** seems easier than writing a program! For part\u00a01, anyway \u2014 load your input file, then make searching case-insensitive:\n\n    :set ic\u27e8Enter\u27e9\n\n and remove pairs of letters of opposite case with:\n\n    :s/\\v(\\l\\u|\\u\\l)&(.)\\2//g\u27e8Enter\u27e9\n\nThat substitution will then need repeating for newly created pairs. Do it again with `@:`, and watch as the line gets shorter on each press.\n\nIf you've had enough, you can make it loop till their are no more pairs with:\n\n    qaqqag&:redr\u27e8Enter\u27e9\n    @aq@a\n\nThen the answer is the number of columns, which is displayed with `g\u27e8Ctrl+G\u27e9`.\n\n(I have a plan for Part\u00a02, but now need to get the children breakfast. I'll try to put it in a reply to this comment later.) \n\n**Part 2 in Vim** *wasn't* easier than in a programming language ...\n\n    :set ic\u27e8Enter\u27e9\n    :s/\\v(.)\\1&(\\l\\u|\\u\\l)//g\u27e8Enter\u27e9\n    qaqqa:&&\u27e8Enter\u27e9@aq@a\n    yy26p\u27e8Ctrl+V\u27e9GI\u27e8Ctrl+V\u27e9\u27e8Ctrl+V\u27e996 \u27e8Esc\u27e9gveg\u27e8Ctrl+A\u27e9\n    qbce\u27e8Ctrl+R\u27e9-\u27e8Esc\u27e9x:s!\u27e8Ctrl+R\u27e9-!!g\u27e8Enter\u27e9\n    0Pq:+,$norm@b\u27e8Enter\u27e9\n    {qc$BC\u27e8Ctrl+R\u27e9=len(@-)\u27e8Enter\u27e9\u27e8Esc\u27e9q\u27e8Enter\u27e9\n    :s/<Up>\u27e8Enter\u27e9\n    :,$norm:redr|norm@a\u27e8Ctrl+V\u27e9\u27e8Enter\u27e9@c\u27e8Enter\u27e9\n    :2,sor n\u27e8Enter\u27e9\n\n**Update**: [Watch Vim running this](https://old.reddit.com/r/adventofcode/comments/a3i502/2018_day_5_vim_video_of_vim_solving_both_parts/).\n\nThe first 3 lines solve Part 1, pretty much as above, saving the method to macro `@a`.\n\nThen it makes 26 copies of the reacted polymer, and inserts the alphabet down the left. (*How?*). On each line, it removes that letter from the polymer (and re-inserts it at the left, so we can see which line is which). (*Why does the substitution use `s!!!` rather than the typical `s///`?*)\n\nNow we've copied the original reacted polymer, replace it with its length, saving the method to macro `@c`. And run both `@a` and `@c` on the other 26 lines (*Why is a `:norm` nested within another `:norm` there?*) \u2014 the line which gets the most units removed takes a little longer than the others.\n\nSort the alphabetical lines by the lengths. The answer to Part 1 is the unlabelled number on the top row (in orange in the video), and the answer to Part 2 is the number on the next line (in yellow, labelled with the letter of the problematic unit types).\n\nThat actually ended up being shorter, more readable, less awkward, and faster to run than I expected (*but has been edited from the original*, which was clunkier in several ways).\n\nI wrote:\n\n> Then it makes 26 copies of the reacted polymer, and inserts the alphabet down the left. (*How?*).\n\nNever mind \u2018how?\u2019, the more relevant question is \u2018why?\u2019 \u2014 and the answer is, \u2018because I didn't know about `:set nrformats+=alpha`\u2019, which enables `Ctrl+A` to work on letters, and would've been much more straightforward.", "id": "eb4iki6", "owner_tier": 0.3, "score": 0.3424657532876712}, {"content": "My initial implementation for part 1 ran fairly slowly (~10 seconds), so I assumed my part 2 was going to be horrible, but ended finishing in almost no extra time.  I eventually realized that I had used my reduced result from part 1 as the basis for part 2, which is actually a really great optimization.\n\nAccidental genius :) nice!", "id": "eb4fvko", "owner_tier": 0.1, "score": 0.1917808217808219}, {"content": "Rank 36/9. Disappointing part 1, including a wrong answer and deciding to type out the alphabet by hand. Video of me solving at: https://www.youtube.com/watch?v=VBhrueOccZ0\n\nCode (for part 2):\n\n     s = open('5.in').read().strip()\n\n     alpha = 'abcdefghijklmnopqrstuvwxyz'\n     M = {}\n     for c in alpha:\n         M[c.lower()] = c.upper()\n         M[c.upper()] = c.lower()\n\n     ans = 1e5\n     for rem in alpha:\n         s2 = [c for c in s if c!=rem.lower() and c!=rem.upper()]\n         stack = []\n         for c in s2:\n             if stack and c == M[stack[-1]]:\n                 stack.pop()\n             else:\n                 stack.append(c)\n         ans = min(ans, len(stack))\n     print ans\n\nthe key to typing out the alphabet by hand is that you didn't need to iterate through the letters in alphabetical order :)\n\n`str.swapcase` would also save you a ton of time.\n\na-ha, nice use of a stack!\n\nAwesome. I would never thought about using a stack.\n\nVery nice. I really like the trick for getting the opposites fast with a dictionary. \n\n>1e5\n\n`ans = len(polymer)`  \n**ans** can't be longer than polymer total size\n\n&#x200B;\n\n    from string import ascii_uppercase\n\n is a good one to keep in your back pocket too\n\nThis. Also, even if you need to for $REASONS:\n`alphabet = \"qwerty....cvbnm\".sort()`\n\nYeah but gotta be sure you didn't fat finger anything because it's a lot harder to check\n\nGood bye `c.lower() == c2.lower() and ((c.islower() and c2.isupper()) or (c2.islower() and c.isupper()))`", "id": "eb4cvto", "owner_tier": 0.3, "score": 0.8219178080821917}, {"content": "Absolute value between the two ASCII character codes == 32 is another way to do the letter comparison. Runs in <40ms for part 2.\n\n**JavaScript**\n\n    import { minBy } from 'lodash'\n    \n    const peek = stack => stack[stack.length - 1]\n    \n    const factorPolymer = input => {\n        const stack = []\n    \n        input.split('').forEach(char => {\n            // XOR of A and a, B and b, etc is 32\n            if (!stack.length || (peek(stack).charCodeAt() ^ char.charCodeAt()) !== 32) {\n                stack.push(char)\n            } else {\n                stack.pop()\n            }\n        })\n    \n        return stack.join('')\n    }\n    \n    export const solvePart1 = input => {\n        return factorPolymer(input).length\n    }\n    \n    export const solvePart2 = input => {\n        input = factorPolymer(input) // A first factorization pass speeds up the following passes\n    \n        const polymers = Array(26) // Indexes 0-26 represent 65-91 ASCII codes\n            .fill()\n            .map((e, i) => {\n                const re = new RegExp(String.fromCharCode(i + 65), 'gi')\n                const strippedInput = input.replace(re, '')\n                return factorPolymer(strippedInput)\n            })\n    \n        return minBy(polymers, 'length').length\n    }\n    \nEdit: Updated to use a stack instead of string concatenation and the fact that ASCII is laid out in a way that XOR of A and a is 32.\n\nDamn, that's fast! Neat! \n\nYour implementation of factorPolymer is quite neat!\n\nGreat stuff\n\n\n", "id": "eb4f2cf", "owner_tier": 0.1, "score": 0.1232876710958904}, {"content": "Python 3\n\nFun!\n\n    line = open(\"day5input.txt\").read().splitlines()[0]\n    \n    oldline = None\n    while oldline != line:\n        oldline = line\n        for i in range(0,26):\n            line = line.replace(chr(ord(\"a\") + i) + chr(ord(\"A\") + i),\"\")\n            line = line.replace(chr(ord(\"A\") + i) + chr(ord(\"a\") + i),\"\")\n    \n    print(\"Part1:\")\n    print(len(line))\n    \n    original = line\n    best = len(line)\n    for j in range(0,26):\n        line = original\n        line = line.replace(chr(ord(\"a\") + j),\"\")\n        line = line.replace(chr(ord(\"A\") + j),\"\")\n        oldline = None\n        while oldline != line:\n            oldline = line\n            for i in range(0,26):\n                line = line.replace(chr(ord(\"a\") + i) + chr(ord(\"A\") + i),\"\")\n                line = line.replace(chr(ord(\"A\") + i) + chr(ord(\"a\") + i),\"\")\n    \n        best = len(line) if len(line) < best else best\n    print(\"Part2:\")\n    print(best)\n\n    from string import *\n    \n    \n    def collapse(s):\n        p = ['.']\n        for u in s:\n            v = p[-1]\n            if v != u and v.lower() == u.lower():\n                p.pop()\n            else:\n                p.append(u)\n        return len(p) - 1\n    \n    \n    s = open('5.txt').read().strip()\n    print(collapse(s))\n    print(min(collapse(c for c in s if c.lower() != x) for x in ascii_lowercase))\n\n&#x200B;\n\nNice one!\n\nRemember, the `range` function implies starting at `0` by default, so `range(26)` are the same numbers as `range(0, 26)`.\n\nInstead of chr(ord(\"a\") + j) etc you could loop string.ascii\\_lowercase or ascii\\_uppercase.\n\nI think a regex solution is slower, but satisfying:\n\n    import re\n    import string\n\n    lower = string.ascii_lowercase\n    upper = string.ascii_uppercase\n    s = open(\"input.txt\").read().strip()\n    pat = \"|\".join(\n        a + b for a, b in list(zip(lower, upper)) + list(zip(upper, lower)))\n    ss = re.sub(pat, \"\", s)\n    while s != ss:\n        s = ss\n        ss = re.sub(pat, \"\", s)\n    print(len(s), s)\n\n(for part 1, just iterate for part 2)\n\nThis is the most efficient way to solve this problem. Great!\n\nThis is a great solution, but I'm perplexed. I have something very similar and it runs in \\~2.4 seconds, whereas yours consistently runs in \\~1.1 seconds. I'd love it if someone could point out which specific technique is faster here.\n\n    from string import ascii_lowercase\n    import re\n\n    def parse_input(filename):\n      \"\"\"Convenience method to parse a file and return a list as input\"\"\"\n      with open(filename, 'r') as input_file:\n        return input_file.readline()\n\n    def part1(input_string):\n      old_input = None\n      while old_input != input_string:\n        old_input = input_string\n        for char in ascii_lowercase:\n          input_string = input_string.replace(char.lower() + char.upper(), '')\n          input_string = input_string.replace(char.upper() + char.lower(), '')\n      return len(input_string)\n\n    def part2(input_string):\n      test_input = \"\"\n      shortest_value = len(input_string)\n      for char in ascii_lowercase:\n        test_input = input_string.replace(char, '').replace(char.upper(), '')\n        length = part1(test_input)\n        shortest_value = length if length < shortest_value else shortest_value\n      return shortest_value\n\n    if __name__ == \"__main__\":\n      INPUT = 'inputs/day05.txt'\n      TEST_INPUT = 'dabAcCaCBAcCcaDA'\n\n      assert part1(TEST_INPUT) == 10\n      print(f\"Part 1: {str(part1(parse_input(INPUT)))}\")\n\n      assert part2(TEST_INPUT) == 4\n      print(f\"Part 2: {part2(parse_input(INPUT))}\")\n\n\nI think mine is faster. I love using reduce :) \u200b\n\n    from functools import reduce\n    \n    def reactor(X, Y):    \n        if not X or not Y:\n            return X + Y\n    \n        # get ends of reaction\n        x = X[-1]\n        y = Y[0]\n    \n        if x != y and x.lower() == y.lower():\n            return X[:-1] + Y[1:] # react!\n        else:\n            return X + Y\n    \n    def react(polymer):\n        return reduce(reactor, list(polymer))\n    \n    %timeit len(react(input))\n    print(len(react(input)))\n    \n35.4 ms \u00b1 423 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)  \n9172\n\nYour version is an order of magnitude slower:\n\n548 ms \u00b1 3.16 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)  \n9172\n\nAnd Part 2:\n\n    import operator\n    def find_inhibitor(polymer):\n        types = set(polymer.lower())\n        inhibitor = {t: len(react(polymer.replace(t, '').replace(t.upper(), ''))) for t in types}\n        return min(inhibitor.items(), key=operator.itemgetter(1))\n    \n    %timeit find_inhibitor(input)\n    print(find_inhibitor(input))\n    \n873 ms \u00b1 9.74 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)  \n('x', 6550)\n\nYours:\n13.5 s \u00b1 88.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)  \n6550\n\nReally elegant! Easy to read and it's performant.          \nPorted it to Go part1: 774.41\u00b5s part2: 23.893527ms part2(concurrent): 11.518504ms     \n\nYep, this is an O(n) problem, not >O(n\\^2) as the solution above you is.\n\nThanks for sharing. I walked your code through the debugger, and once I understood the method I was able to dramatically improve the running time of my solution. Kudos!", "id": "eb4e5kl", "owner_tier": 0.3, "score": 0.6575342464383561}, {"content": "J, both parts\n\n\n    p1 =. [: # ,`(}.@])@.(32 -: |@(- {.)&(3&u:)/)/\n   \n    p2 =. [: <./ (a. {~ (,. 32 + ]) 65 + i.26) p1@-.\"1~ ]\n\n\n[Try it online!](https://tio.run/##LY7RCoIwGIXv9xSHAv1H7pdN8kIKZvYWIbRUqCgaRFeWr74GenMO34EPzj283dM/Buw57d2l7hrXHGJ27linweu441RhjexMP7attEyFgarwtaQwskyoSD6VzGUuAAhvFmXHOcgxxgmUMaK0QStRbmPf2JQSXlvFKz2hDUN3fUXGfEbMaBYMfw \"J \u2013 Try It Online\")\n\n\n\nJ will never stop to amaze me.", "id": "eb4jb1o", "owner_tier": 0.1, "score": 0.1232876710958904}, {"content": "First time I\u2019ve done it live this year (moving east was a mistake for Advent of Code purposes). 6th / 4th. Used a stack and added the characters one at a time for a O(n) solution. Similar to checking if a parenthesis string is balanced.\n\n    def run(s):\n        stk = []\n        for c in s:\n            popped = False\n            if stk:\n                bk = stk[-1]\n                if (('A' <= bk <= 'Z' and 'a' <= c <= 'z') or ('A' <= c <= 'Z' and 'a' <= bk <= 'z')) and bk.lower() == c.lower():\n                    stk.pop()\n                    popped = True\n            if not popped:\n                stk.append(c)\n        return len(stk)\n    \n    def main():\n        s = input().strip()\n        ans = 1000000\n        for k in range(26):\n            up = chr(ord('A') + k)\n            lo =  chr(ord('a') + k)\n            t = str(s)\n            t = t.replace(up, '')\n            t = t.replace(lo, '')\n            print(t)\n            ans = min(ans, run(t))\n        print(ans)\n    \n    main()\n\nAlso watch me code it and cry on youtube here: [https://youtu.be/GDx\\_rC5wXGc](https://youtu.be/GDx_rC5wXGc) (should go live at 12:30 EST).\n\nAwesome idea using a stack. I tried a link list, then had to do a doubly-linked list and eventually got it but a stack sounds way more straight-forward!", "id": "eb4cta2", "owner_tier": 0.1, "score": 0.0684931505479452}, {"content": "**Java 8**\n\nFelt really proud of the part 1 using a stack. Leetcode came in useful for once.\n\n    private int util1(String in) {\n        char[] arr = in.toCharArray();\n        Stack<Character> inStack = new Stack<>();\n        Stack<Character> q = new Stack<>();\n\n        for(char c : arr)\n            inStack.push(c);\n\n        for(char c : inStack) {\n            if(q.isEmpty())\n                q.push(c);\n            else {\n                char last = q.peek();\n\n                if(Math.abs(last-c) == 32) {\n                    q.pop();\n                } else {\n                    q.push(c);\n                }\n            }\n        }\n\n        return q.size();\n    }\n\n    // Less interesting part 2\n    public void runPart2() {\n        String in = this.getInputLines()[0];\n        int min = Integer.MAX_VALUE;\n\n        for(int i=0; i<26; i++) {\n           String temp = in.replaceAll(\"[\" + (char) (i + 'a') + (char) (i + 'A') + \"]\", \"\");\n\n           min = Math.min(min, util1(temp));\n        }\n\n        System.out.println(min);\n    }\n\nNote that the preferred abstraction for stacks in Java is `Deque`, `Stack` being an outdated one that builds upon the outdated `Vector`.\n\nI liked your solution, thanks for sharing.  I modified part 2 (rather than doing your replaceAll) but allowing to skip the letter (sorry did it in ruby)\n\n```\nrequire 'set'\n\ninput = File.read(\"input.txt\").strip\n\nstack = input.chars\n\ndef get_answer(stack, skip_letter: nil)\n  stack.each_with_object([]) do |el, final_stack|\n    next if skip_letter == el.downcase\n\n    if final_stack.empty?\n      final_stack << el\n    else\n      prev = final_stack.last\n\n      if el.swapcase == prev\n        final_stack.pop\n      else\n        final_stack << el\n      end\n    end\n  end\nend\n\n# pt 1\nputs get_answer(stack).size\n\n\n\n# pt2\nset = Set.new(stack).map(&:downcase)\n\nsizes = set.map do |letter|\n  get_answer(stack, skip_letter: letter).size\nend\n\np sizes.min\n```\n\n\nI like your solution. However, in part 1, why are you creating the \"inStack\" - you could directly iterate the chars as they come from input, e.g. [https://github.com/Meemaw/aoc-2018/blob/master/src/main/java/day5/Day5.java](https://github.com/Meemaw/aoc-2018/blob/master/src/main/java/day5/Day5.java)\n\nYour solution give me the same result of mine solution (11648) but it's not the correct answer, i'm lost. The input is https://pastebin.com/Hp0Xs9Hr\n\n```\n##### Puzzle 1 #####\nExecution : 0.001340ms\nResult: 11648\nResult BIS: 11648\n```\n\nCODE\n\n```\n\t// https://adventofcode.com/2018/day/5\n\tpublic static void main(String[] args) throws IOException {\n\t\tProgram p = new Program();\n\t\tp.puzzle1();\n\t\tp.puzzle1bis();\n\t\tp.puzzle2();\n\t}\n\t\n\tpublic Program() throws IOException {\n\t\tsuper(new File(Program.class.getResource(\"input.txt\").getPath()));\n\t}\n\t\n\t// https://www.reddit.com/r/adventofcode/comments/a3912m/2018_day_5_solutions/eb4fiod\n\tpublic void puzzle1bis()\t{\n\t\tchar[] arr = inputs.get(0).toCharArray();\n\t    Stack<Character> inStack = new Stack<>();\n\t    Stack<Character> q = new Stack<>();\n\n\t    for(char c : arr)\n\t        inStack.push(c);\n\n\t    for(char c : inStack) {\n\t        if(q.isEmpty())\n\t            q.push(c);\n\t        else {\n\t            char last = q.peek();\n\n\t            if(Math.abs(last-c) == 32) {\n\t                q.pop();\n\t            } else {\n\t                q.push(c);\n\t            }\n\t        }\n\t    }\n\n\t    System.out.println(\"Result BIS: \" + q.size());\n\t}\n\t\n\tpublic void puzzle1()\t{\n\t\t\n\t\tSystem.out.println(\"##### Puzzle 1 #####\");\n\t\tlong start = System.currentTimeMillis();\n\t\t\n\t\tint result = -1;\n\t\tString input = check(inputs.get(0));\n\t\t\n\t\tresult = input.length();\n\t\t\n\t\tlong end = System.currentTimeMillis();\n\t\t\n\t\tSystem.out.println(\"Execution : 0.00\" + (end-start) + \"ms\");\n\t\tSystem.out.println(\"Result: \" + result);\n\t}\n\n\tprivate String check(String input) {\n\t\tfor (int i = 0; i < input.length()-1; i++) {\n\t\t\t\n\t\t\tchar c1 = input.charAt(i);\n\t\t\tchar c2 = input.charAt(i+1);\n\t\t\tif (c1 != c2 && Character.toLowerCase(c1) == Character.toLowerCase(c2))\t{\n\t\t\t\tinput = input.substring(0, i) + input.substring(i+2);\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t\treturn input;\n\t}\n```\n\nIf you modify \\`util1\\` to take a lambda of \\`char->bool\\` (not sure the Java syntax), you don't need the \\`replaceAll\\` business.  If that lambda were called `exclude`, part1 is (python) `lambda c: False` and part2 is, for each letter, `lambda c: c == <lowercase> or c == <uppercase>`.\n\nand `ArrayDeque` is actually faster in most conditions.\n\nTIL, thank you for that. Always thought deque was a stack but had the extra capability of keeping a pointer to the bottom element.\n\nHappy to share. Sorry though I\u2019m not familiar with ruby, can you walk me through a little of what you did for part 2?\n\nYeah, speed-coding makes me do some questionable things at times. \n\nMake sure you don't have a newline at the end of your input - that's what got me for a bit. Assuming the inputs are always at least the same length it should be 50,000 bytes.", "id": "eb4fiod", "owner_tier": 0.5, "score": 0.2328767121917808}, {"content": "Ruby, reporting in.\n\nLeaderboard code was not nearly this clean, I copy/pasted the react code, and started out with actually just running it 100 times. That was good enough for part 1, but for part 2 I actually needed to make it run to completion. So I ate a minute penalty on part 2 for making a really far-off guess. This code is slightly less repetitive than what I submitted (I made `react` into a function) and uses the fact that `gsub` returns nil if no modifications were made.\n\n    def react(str)\n      loop {\n        break str if (?a..?z).all? { |x|\n          [\n            str.gsub!(x + x.upcase, ''),\n            str.gsub!(x.upcase + x, ''),\n          ].none?\n        }\n      }\n    end\n\n    input = (ARGV.empty? ? DATA : ARGF).read.chomp.freeze\n\n    puts (part1 = react(input.dup).freeze).size\n    puts (?a..?z).map { |tried_letter|\n      react(part1.tr(tried_letter + tried_letter.upcase, '')).size\n    }.min\n    \n    __END__\n    my input goes here\n\nIt ran on my input in about 1 second so I did not need to do anything more clever.\n\nEdit: Yeah okay, after reading others' solutions, I get it, a less wasteful way to do it would be to add letters left-to-right and therefore I know I only need to delete from the right end of the string. Let this be a lesson on there being a huge difference between what I write if I want to go as fast as possible versus what I might write if I actually have time to think about it.\n\nAs someone learning ruby for the first time, this is an excellent code snippet to study. Mind if I ask a few questions?\n\nWhat's going on with this line?\n>ARGV.empty? ? DATA : ARGF\n\nI get that there's a ternary operator here, and that you're asking if ARGV is empty, but are DATA and ARGF? Google says that DATA refers to stuff that's at the end of your program, but it doesn't look like anything's there. How does ARGF work? If you're supplying a text file as an argument (we only hit this if ARGV has something in it) why not just use ARGV[0]?\n\nWhat does \"?a\" mean in ruby? Firing up irb, it looks like it just converts that character a to a string (and can only do one character -- `?asdf` throws an error). Is there a name for this transformation?\n\nLast q: how does ruby know to execute all the code after the break statement and return str? Wouldn't loop just immediately exit when it sees \"break\"?\n\nSorry for the noob q's but this language is fascinating. \n\nI'm also solving in Ruby and I have to say that I absolutely love your solutions. They're all really smart and checking out your solution is as interesting as solving it on my own, because every day you seem to include something that I didn't even know existed in the language (like taking array slices with `[x, y]`, symbol arrays in the form of `%i()`, the safe navigation operator that you had in your refined solution for today, `Hash#to_proc`, being able to group statements in parentheses to use the modifier syntax). I really appreciate that you're publishing all your solutions so that others can learn from them. Even if I end up refactoring my solutions so that they end up looking a little bit too much like yours ;) \n\nHey there, don't hesitate to ask any more question if you have any!\n\n> but are DATA and ARGF? Google says that DATA refers to stuff that's at the end of your program, but it doesn't look like anything's there.\n\nThe fact that DATA is confusing is my fault entirely, of course. in the actual file on my computer there is an `__END__` and my input there. But I took that out before posting here because otherwise the post would become unnecessarily large.\n\nI've edited my post with the proper `__END__` and just put a placeholder for \"my input goes here\", so that would be how that works. Usually I leave ARGV empty.\n\n>  How does ARGF work? If you're supplying a text file as an argument (we only hit this if ARGV has something in it) why not just use ARGV[0]?\n\nI could, though note that the code would look slightly different because ARGV[0] would just be a string (a filename) which I can't call `read` on line I can with DATA and ARGF. I think it might be have to be something like `input = (ARGV.empty? ? DATA.read : File.read(ARGV[0])).chomp` and I preferred to have something that can just call `read` on in both cases, hence ARGF instead of ARGV[0]. Less repetition that way. Also note that ARGF enables reading from stdin really easily, if putting the filename `-` on ARGV.\n\ntherefore, I judged this DATA/ARGF combination to be the simplest way to allow for the various possible ways I might want to run the script:\n\n* Run it with no arguments. it should run on my input by default.\n* Run it with a filename on ARGV - it will run on that file\n* Run it with `-` on ARGV - it will run on stdin\n\n> What does \"?a\" mean in ruby? Firing up irb, it looks like it just converts that character a to a string (and can only do one character -- `?asdf` throws an error). Is there a name for this transformation?\n\nyou'll want to look at https://ruby-doc.org/core-2.3.0/doc/syntax/literals_rdoc.html and search for \"character literal\" . Note that it was only added to the docs in 2.3.0, but it looks like it was around for longer.  Of course reading later versions of the docs is fine too. You have of course already correctly figured out what it does.\n\n> Last q: how does ruby know to execute all the code after the break statement and return str? Wouldn't loop just immediately exit when it sees \"break\"?\n\nThat would be because of the `if` afterward. You may see this used in some pieces of code like `raise SomeError if something`. It would be \"unfortunate\" if that raised an error every time. Thus, it doesn't happen unless the condition is true. For more information you could read about \"modifier if\"\n\nThanks for writing in. Indeed one of my hopes is that I can show some interesting things that can be done in the language.\n\nOne of the things you mentioned stood out to me: the grouping with parentheses. I know you refer to the `(puts freq; break) if seen.include?(freq)` on day 1. There's also a related thing (since it also uses parentheses) which is doing an assignment in the middle of a larger expression such as `puts (part1 = react(input)).size` on day 5. I thought about it and I think these are different from most things I do in Advent of Code. Most things are things I would also do in larger projects where it's important to write maintainable code. But these two things actually stand out in this regard because these are pretty much just space-saving measures and in most other contexts I would write these out on separate lines. It may be a little too surprising otherwise, especially if other readers of the code are not watching for assignments in unexpected places like a `puts` line.\n\nJust some interesting thoughts when I consider how others might make use of my code.", "id": "eb4digq", "owner_tier": 0.1, "score": 0.10958904095890411}, {"content": "**Python** - using *functools.reduce*. Fun!\n\n    from functools import reduce\n\n    def trigger(x, y):\n        return False if not x else abs(ord(x[-1]) - ord(y)) == 32\n\n    def react(polymer):\n        return reduce((lambda x, y: x[:-1] if trigger(x, y) else x+y), polymer)\n\n    polymer = open('input.txt').read()\n    print(len(react(polymer)))\n    print(min([len(react(polymer.replace(chr(i), '').replace(chr(i-32), ''))) for i in range(ord('a'), ord('z') + 1)]))\n\nFirst off, beautiful.\n\nHere is the merge of our two codes, hope you gain something from it.\n\n    purge = lambda s: reduce(lambda x, y: x[:-1] if x and abs(ord(x[-1])-ord(y)) == 32 else x+y, s)\n    data = purge(open('../input/5.txt').read().strip())\n    \n    print len(data)\n    print min(len(purge(filter(lambda x: x.upper() != c, data))) for c in map(chr, range(65, 91)))    \n\ncheers!", "id": "eb5fy85", "owner_tier": 0.3, "score": 0.041095890273972605}, {"content": "[**APL**](https://github.com/jayfoad/aoc2018apl/blob/master/p5.dyalog) \\#47/29\n\nUsing regular expressions, the solution for part 1 boils down to `'Aa|Bb|...|aA|bB|...'\u2395R''\u2363\u2261`, i.e. keep replacing 'Aa' etc with '' until we reach a fixed point. An [alternative solution](https://github.com/jayfoad/aoc2018apl/blob/master/p5faster.dyalog) using Find (`\u2377`) instead runs a bit faster, but part 2 still takes a few seconds.\n\nUpdated [alternative solution](https://github.com/jayfoad/aoc2018apl/blob/master/p5faster.dyalog) still uses the \"fixed point operator\" `\u2363\u2261` but now does arithmetic on ASCII codepoints instead of string operations. Combined time for both parts is now about 0.02 seconds.\n\nsick! I got part 1 down to instant, part 2 basically ran part 1 26 times and took 3.2s (python)\n\nWould love to see this one unpacked - shorter *and* faster!\n\nSure. The algorithm is to remove pairs Aa etc and keep going until no more removals are possible. The clever bit is to notice that it's easy to remove many *non-overlapping* pairs in parallel, using array operations, which is how you get good performance from an interpreted array language like APL. The way we guarantee the pairs won't overlap is to first remove all occurrences of any of the pairs Aa Bb ... Zz, which can't possibly overlap, in one parallel operation; and then do the same for the other pairs aA bB ... zZ in a second parallel operation. (Note that Aa *can* overlap with aA if the input contains something like ...AaA..., and the risk is that we would end up removing those three characters, which would not be following the rules of the puzzle.)\n\n`p\u2190\u2395UCS\u2283\u2283\u2395NGET'p5.txt'1` gets the ASCII values (`\u2395UCS`) of the single line of input, sans line ending.\n\n`f\u2190{\u2375/\u2368{(\u2375,0)\u23710,\u2375}\u237a=2-/\u2375}` removes all lower-upper or upper-lower pairs from \u2375, depending on the value of \u237a. `2-/\u2375` is the pairwise difference between successive items of \u2375. `\u237a=2-/\u2375` is a mask of where this difference is equal to \u237a, which will be either +32 or -32 (the ASCII difference between 'A' and 'a'). `\u2371` is NOR, so `{(\u2375,0)\u23710,\u2375}` extends the mask with an extra 0 at the beginning, and at the end, and ORs the two together, to select *both* items of each pair, and then NOTs it to select all the items *not* part of a pair. `\u2375/\u2368` uses that to compress \u2375, i.e. keep only the selected items.\n\n`g\u2190(32\u2218f \u00af32\u2218f)\u2363\u2261` applies f twice in succession (for lower-upper *and* upper-lower pairs), and repeats that process to a fixed point. `\u2218` is used to bind (*curry*) a left argument with f, so `32\u2218f` and `\u00af32\u2218f` are both functions that take a single argument \u2375. Putting those two functions together in parentheses forms a *train*, a form of function composition that will just apply first one of the functions and then the other. `f\u2363\u2261` applies f repeatedly until two successive results Match (`\u2261`).\n\n`\u2262q\u2190g p` applies this algorithm to the puzzle input p, remembers the result as q for use in part 2, and uses Tally (`\u2262`) to return its length.\n\n`\u230a/{\u2262g q~\u2375,32+\u2375}\u00a8\u2395UCS \u2395A` applies the anonymous function {...} once for each of the ASCII codes for the upper case alphabet (`\u2395A`). The anonymous function removes that character \u2375 and its lower case counterpart \u2375+32 from q, and then applies the algorithm g to that and returns its length. `\u230a/` gives the minimum of all those results.\n\n&#x200B;", "id": "eb4efxr", "owner_tier": 0.1, "score": 0.09589041082191781}, {"content": "[Card] Staaaaars\n\nRust, first Rust I'm proud of. Never copy my input data.\n    \n    static INPUT: &str = \"data/day05\";\n    \n    fn react<'a>(input: impl Iterator<Item = &'a u8>) -> usize {\n        let mut v = Vec::new();\n        for &c in input {\n            match v.last() {\n                None => v.push(c),\n                Some(&d) => if d.to_ascii_lowercase() == c.to_ascii_lowercase() && d != c {\n                    v.pop();\n                } else {\n                    v.push(c);\n                }\n            }\n        }\n        v.len()\n    }\n    \n    fn main() {\n        let input: Vec<u8> = aoc::file::first_line(INPUT).into();\n        println!(\"  1: {}\", react(input.iter()));\n        let mut min = std::usize::MAX;\n        for i in 0u8..=26 {\n            let v = input.iter().filter(|&&c| c != b'a'+i && c != b'A'+i);\n            min = usize::min(react(v), min);\n        }\n        println!(\"  2: {}\", min);\n    }\n    \n\nI quite like this one. I was looping through the string slices and being forced to re-allocate every split. This is significantly faster and more efficient.\n\nThis is very clever. Nicely done!\n\n I am using this years AoC to learn Rust and it is wonderful to go through and see how other people tackled the problem. Such a good way to learn.\n\nThanks!\n\nCame here to post exactly the same thought: rust was really nice for this.\n\nTook roughly the same approach and ended up learning about the right way to accept iterators for input to let me reuse the reducer for both parts:\n\n    fn collapse_polymer<'_a, I>(vals: I) -> usize\n    where I: IntoIterator<Item = &'_a u8> {\n     let mut stack: Vec<u8> = Vec::new();\n     for c in vals.into_iter() {\n     let top = stack.pop();\n     match top {\n                Some(sc) if opposite(*c, sc) => {},\n                Some(sc) => {stack.push(sc); stack.push(*c);},        \n                None => {stack.push(*c);},\n            }\n        };\n        stack.len()\n    }\n    \n    pub fn part1_02(d: &str) -> i64{\n     collapse_polymer(d.trim().as_bytes()) as i64\n    }\n    \n    fn collapse_filtered<'_a, I>(vals: I, c: u8) -> usize \n    where I: IntoIterator<Item = &'_a u8> {\n     collapse_polymer(vals.into_iter().filter(|&cc| !(c==*cc || opposite(c, *cc))))\n    }\n    \n    pub fn part2_01(d: &str) -> i64 {\n        ('a' as u8 ..'z' as u8)\n        .map(|c| collapse_filtered(d.trim().as_bytes(), c))\n        .min().unwrap() as i64\n    }\n\n(the `i64` stuff is just because my wrapper expects this type for numbers)", "id": "eb4fkwu", "owner_tier": 0.1, "score": 0.0821917806849315}, {"content": "This space intentionally left blank.\n\n> [CARD]\n> \n> On the fifth day of AoC / My true love sent to me / Five golden HDMI cables\n\nI see your true love is a fan of Monster-branded cables.  >_>\n\nI got pretty much the same. This challenge was so easy and well fit for Haskell.\n\n    react :: [Char] -> [Char] -> [Char]\n    react stack []      = stack\n    react [] (c:cs)     = react [c] cs\n    react (x:xs) (c:cs)\n      | toLower x == toLower c && x /= c = react xs cs\n      | otherwise = react (c:x:xs) cs\n    \n    part1 :: Input -> Int\n    part1 input = length $ react [] input\n    \n    part2 :: Input -> Int\n    part2 input = minimum $ map (\\c -> length $ react \"\" $ filter ((/=c) . toLower) input) ['a'..'z']", "id": "eb4drzq", "owner_tier": 0.3, "score": 0.027397260136986304}, {"content": "[Card] FIVE GOLDEN STARS OK ONLY 2\n\nJava - easy one. You can test for lowercase/uppercase being the same letter using XOR 32.\n\n    package Advent2018;\n    \n    import util.AdventOfCode;\n    \n    import java.util.List;\n    \n    public class Day5 extends AdventOfCode {\n    \n        public Day5(List<String> input) {\n            super(input);\n        }\n    \n        private int remove(StringBuilder in) {\n            boolean removed = true;\n    \n            while (removed) {\n                for (int i = 0; i < in.length() - 1; i++) {\n                    if ( (in.charAt(i) ^ in.charAt(i + 1)) == 32) {\n                        in.delete(i, i + 2);\n                        removed = true;\n                        break;\n                    }\n                    removed = false;\n                }\n            }\n            return in.length();\n        }\n    \n        @Override\n        public Object part1() {\n            StringBuilder chain = new StringBuilder(input.get(0));\n            return remove(chain);\n        }\n    \n        @Override\n        public Object part2() {\n            int min = Integer.MAX_VALUE;\n    \n            String[] patterns = new String[26];\n            for (int i = 0; i < 26; i++) {\n                patterns[i] = \"[\" + (Character.toString((char)(i + 'a'))) +\n                        (Character.toString((char)(i + 'A'))) + \"]\";\n                //System.out.println(patterns[i]);\n            }\n    \n            for (int i = 0; i < 26; i++) {\n                String chain = input.get(0);\n                chain = chain.replaceAll(patterns[i], \"\");\n                int result = remove(new StringBuilder(chain));\n                System.out.println(result);\n                if (result < min) min = result;\n            }\n            return min;\n        }\n    \n        @Override\n        public void parse() {\n    \n        }\n    \n    }\n\n> You can test for lowercase/uppercase being the same letter using XOR 32.\n\nHuh, that's a neat way to check for that. Should've probably thought of it. Good to know for future challenges... Good job!\n\nNice!  My first version of part 1 took 85 minutes to complete.  I knew I couldn't use that for part 2, so I wanted tot see how other people solved this.  As I thought (hoped!), it was all in the comparison.\n\n&#x200B;\n\nif (unit.equalsIgnoreCase(nextUnit) && ! unit.equals(nextUnit)) { // same time, opposite polarity\n\nshorterPolymer = polymer.substring(0,i) + polymer.substring(i+2);\n\n} // end if\n\nNow it's sub-second.\n\nQuestion: Why do you break when you find a hit?  Don't all subsequent hits need to be eventually removed?\n\n&#x200B;\n\nThere's a lot of cool bit hacks for ASCII! https://www.techiedelight.com/bit-hacks-part-4-playing-letters-english-alphabet/", "id": "eb4eepd", "owner_tier": 0.9, "score": 0.1232876710958904}, {"content": "Since there is no Common Lisp yet\n\n    (defun destroy? (a b)\n      (and a b (char/= a b) (char-equal a b)))\n    \n    (defun reduce-polymer (polymer)\n      (let ((stack (list (elt polymer 0))))\n        (loop :for u :across (subseq polymer 1)\n              :do\n                 (push u stack)\n                 (if (destroy? (car stack) (cadr stack))\n                     (progn\n                       (pop stack)\n                       (pop stack))))\n        stack))\n    \n    (length (reduce-polymer *polymer*)) ;; => 11476\n    \n    (defun reduce-polymer2 (polymer1 unit-to-skip)\n      (let ((polymer (remove-if (lambda (c) (char-equal c unit-to-skip)) polymer1)))\n        (reduce-polymer polymer)))\n    \n    (loop :for i :from (char-code #\\a) :to (char-code #\\z)\n          :minimizing (length (reduce-polymer2 *polymer* (code-char i)))) ;; => 5446\n    \n\nVery similar to what I did in Clojure\n\n\nNice!\n\n[My Common Lisp solution](https://gitlab.com/asciiphil/advent-of-code/blob/master/2018/05.lisp) used the \"reduce until you can't reduce any more\" approach.  Your stack is much nicer.\n\nThat stack approach is really clever.\n\n> `(remove-if (lambda (c) (char-equal c unit-to-skip)) polymer1)`\n\nThis could be `(remove unit-to-skip polymer1 :key #'char-equal)`\n\nI did the same, though I rewrote it (epiphany when I woke up and showered) to use a stack. It took my Part 2 solution from ~3 seconds down to .06 seconds.\n\nIn college that solution would've been obvious. I've been in the corporate world too long. Elegant, simple solutions are not what we use.\n\nSo I went and redid my `react` function with (more or less) a stack^(0).  Similar to your experience, my runtime dropped from 1.7 seconds to 0.02 seconds.\n\n    (defun react (polymer)\n      (labels ((react-r (head tail)\n                 (cond\n                   ((endp tail)\n                    (reverse head))\n                   ((endp head)\n                    (react-r (cons (car tail) head) (cdr tail)))\n                   ((reactive-pair-p (car head) (car tail))\n                    (react-r (cdr head) (cdr tail)))\n                   (t\n                    (react-r (cons (car tail) head) (cdr tail))))))\n        (coerce (react-r nil (coerce polymer 'list))\n                'string)))\n\n\n^(0)I think of it as more of a zipper, but the principle is the same.", "id": "eb4gqny", "owner_tier": 0.1, "score": 0.10958904095890411}, {"content": "BASH Time :)\n\nNo sed, no grep, just pure bash!\n\nPuzzle #1 (6 seconds)\n\n    #!/bin/bash\n    \n    in_file=input\n    \n    polymer=$(cat $in_file)\n    \n    # 1000 iteration is enough :)\n    for i in {1..1000}; do\n        for x in {a..z}; do\n            polymer=${polymer//$x${x^^}}\n            polymer=${polymer//${x^^}$x}\n        done\n    done\n    \n    echo ${#polymer}\n\nPuzzle #2 (330 seconds)\n\n    #!/bin/bash\n    \n    in_file=input\n    polymer=$(cat $in_file)\n    min_size=${#polymer}\n    \n    for ch in  {a..z}; do\n        test_polymer=${polymer//$ch}\n        test_polymer=${test_polymer//${ch^^}}\n    \n        # 2000 iteration is enough :)\n        for i in {1..2000}; do\n            for x in {a..z}; do\n                test_polymer=${test_polymer//$x${x^^}}\n                test_polymer=${test_polymer//${x^^}$x}\n            done\n        done\n    \n        if [ ${#test_polymer} -lt $min_size ]; then\n            min_size=${#test_polymer}\n        fi\n    done\n    \n    echo $min_size\n\n&#x200B;", "id": "eb4i010", "owner_tier": 0.1, "score": -1.3698630053733275e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/a3912m/2018_day_5_solutions/", "question": {"content": "#--- Day 5: Alchemical Reduction ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Advent of Code: The Party Game!\n\n[Click here for rules](/r/adventofcode/w/aoctpg)\n\nPlease prefix your card submission with something like [Card] to make scanning the megathread easier.  THANK YOU!\n\n#### [Card prompt: Day 5](https://i.imgur.com/Vszj61Cm.jpg)\n\nTranscript:\n> On the fifth day of AoC / My true love sent to me / Five golden ___\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n###*edit:* Leaderboard capped, thread unlocked at 0:10:20!", "id": "a3912m", "title": "-\ud83c\udf84- 2018 Day 5 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "DID SOMEBODY SAY.. EXCEL?! Day 2 [Part 1 & 2]\n\n     = max, = min\n\nhttps://github.com/thatlegoguy/AoC2017/blob/master/Day%202%20Corruption%20Checksum.xlsx\n\nI feel like this one was designed for you :)\n\nI solved part 1 in Excel too, didn't feel savage enough to divide them all manually for part 2, so coded something for that\n\nMy brain had the first part done before I even pasted the input into the sheet =D\n\nSame but how do you solve the second part of it? Afaik you need a three-dimensional sheet to do it in excel. (or copy-paste a lot of formulas)\n\nMy repo shows the savage manual way, but technically I could have made one block of formulas, in which the formula was n1/n2 for each value, where n1 is an input field and n2 is that corresponding value on the chart, and just imputed column 1-17 each time into the input section, and recorded which values didn\u2019t have decimals for each input dump \n\nThat's what I did, but for each row you would have a 2D grid of possibilities, so you get a 3D table in the end, which cannot fit in excel.\n\nSAVAGE. That was awesome, thanks for the laugh.\n\nOr you could have used index() and modulus!\n\nhttps://www.reddit.com/r/adventofcode/comments/7h0zf2/calculate_the_spreadsheets_checksum_they_said/dqnyss1/\n\nI too used black magic, but not that dark of dark magic. Please explain the code?", "id": "dqnalfd", "owner_tier": 0.3, "score": 0.9999999998}, {"content": "    import itertools\n\n    def digits(string):\n        return [int(n) for n in string.split()]\n\n    with open('p02.txt') as fp:\n        rows = [digits(line) for line in fp.read().strip().splitlines()]\n\n    print(sum(b-a for a, *_, b in map(sorted, rows)))\n    print(sum(b//a for row in rows for a, b in itertools.combinations(sorted(row), 2) if b%a==0))\n\n\nAw, man. TIL `itertools.combinations'.\n\nTIL *_\nThanks!\n\nAnd nifty combo of combinations and sorted...\n\n:) Just posted the exact same solution for answer 2 because I only saw the Python 2 solution when I quickly skimmed.\n\nNice trick with the unpacking in answer 1! \n\nyou can also generate combinations without `itertools` using pure list comprehensions\n\nThe last line can be rewritten like this:\n    \n    print(sum(b // a for row in rows for a in row for b in row if b > a and b % a == 0))\n\nWhat does that part do?\n\nif I wasn't using itertools I'd do\n\n`(a, b) for i, a in enumerate(row) for b in row[i+1:]` I suppose\n\nwhich allows for duplicates (not an issue in this problem)", "id": "dqn9g7j", "owner_tier": 0.7, "score": 0.7799999998}, {"content": "Dusting off the Perl golf bag\n\n    # part 1\n    perl -ane '@o=sort{$b<=>$a}@F;$s+=$o[0]-pop@o;END{print$s}' < in.txt\n    \n    # part 2\n    perl -ane 'for$l(@F){$s+=$l%$_?0:$l/$_ for grep!/$l/,@F}END{print$s}' < in.txt\n\nHow long was the original before you whittled it down? I've got barbaric multi-line perl scripts and this shames me.", "id": "dqnaxuu", "owner_tier": 0.1, "score": 0.1999999998}, {"content": "Mathematica solution; one line for each part and one for the import.  #10 for part 1...and #456 for part 2.\n\n**Import**:\n\n    input=Import[FileNameJoin[{NotebookDirectory[],\"Day2Input.txt\"}],\"Table\"][[;;-2]]\n\n**Part 1**:\n        \n    Total[Max[#]-Min[#]&/@input]\n\n**Part 2**:\n\n    Total@Flatten@Table[Select[Flatten[input[[i]]/#&/@input[[i]]],IntegerQ[#]&&#!=1&],{i,16}]\n\nLikewise for Matlab:  \n\n    load input.txt\n    checksum = @(inp) sum(max(inp') - min(inp'));\n    checksum(input);\n\nGotta love that sweet, sweet taste of functional mapping.", "id": "dqn9gd9", "owner_tier": 0.5, "score": 0.0999999998}, {"content": "2 iterators 1 loop\n\n    #! /usr/bin/env perl\n    \n    use strict;\n    use warnings;\n    \n    my ($part1, $part2) = (0, 0);\n    \n    while (<>) {\n    \tmy @a = sort { $a <=> $b } split;\n    \n    \t$part1 += $a[$#a] - $a[0];\n    \n    \tmy ($i, $j, $n, $trial_multiple) = (-1, scalar @a, 0, 0);\n    \tfor (;;) {\n    \t\tif ($i == $#a) {\n    \t\t\tdie \"no multiple found on line $.\\n\";\n    \t\t} elsif ($j == @a) {\n    \t\t\t$j = ++$i + 1;\n    \t\t\t$n = $trial_multiple = 0;\n    \t\t} elsif ($trial_multiple < $a[$j]) {\n    \t\t\t$n++;\n    \t\t\t$trial_multiple += $a[$i];\n    \t\t} elsif ($trial_multiple > $a[$j]) {\n    \t\t\t$j++;\n    \t\t} else {\n    \t\t\t$part2 += $n;\n    \t\t\tlast;\n    \t\t}\n    \t}\n    }\n    \n    print <<\"\";\n    Part 1: $part1\n    Part 2: $part2\n\n\nStill trying to wrap my head around this... I'll let you know if I give up...", "id": "dqnbo31", "owner_tier": 0.3, "score": 0.0799999998}, {"content": "Is there a way to find the answer for each line in better than O(n^2 ) time?\n\nFor part 1, you can sort the elements first.  That would make it O(n log(n)).\n\nFor part 2, nothing immediately comes to mind.\n\nFor part 1 you just need min and max and both are O(n)\n\nI think you can even get a lower constant for the O(n) than the 2n-2 comparisons when searching for min and max separately if you search for them simultaneously, it was something like 3/2*n or so. Can't remember exactly, but you can sort of exploit that the max will never increase when the min just decreased while scanning the input, etc. Of course, it remains in O(n) still. \n\nA peculiar little optimization when you ever need both min and max at the same time. \n\nI did some visualisations of my iterations, and the best idea I could think of was \n\n        if(lines[line][i] > max){\n          max = lines[line][i];\n          maxId = i;\n        }else if(lines[line][i] < min){\n          min = lines[line][i];\n          minId = i;\n        }\n        //minId and maxId are for highlighting number\n\nEdit:\n\nI guess that makes an (iteration * (2 ifs + 1 assignment)) in worst case\n\nI tried that too, but as you said it's not optimal. I think the 3/2n solution involves iterating over the list in pairs of 2 elements and then given the current min, max and 2 items x1, x2 you can deduce the new min and max in just 3 comparisons from those 4 elements, so that gives the whole 3/2 thing.", "id": "dqndamd", "owner_tier": 0.7, "score": 0.35999999979999997}, {"content": "**Haskell**\n\n    main = do\n      s <- parse . lines <$> readFile \"input.txt\"\n      print $ sum $ map part1 s\n      print $ sum $ map part2 s\n    \n    parse :: [String] -> [[Int]]\n    parse = map (map read . words)\n    \n    part1, part2 :: [Int] -> Int\n    part1 xs = maximum xs - minimum xs\n    part2 xs = head [ a `div` b | a <- xs, b <- xs, a `mod` b == 0 && a /= b]\n\nForgot the `a /= b` part on the second question and that cost me a few places.", "id": "dqn9kil", "owner_tier": 0.1, "score": 0.0199999998}, {"content": "Hit diggity dang, I got on the leaderboard! (I'm never awake at midnight EST, except for today, apparently). Spent the first five or so minutes struggling with my setup because I wasn't prepared to do AoC now.\n\nIt's the start of \"haaaaave you met `itertools`?\"\n\n\timport string\n\timport itertools\n\t\n\tlines = []\n\twith open('02.txt') as fp:\n\t\tfor line in fp:\n\t\t\tlines.append(map(int, string.split(line.strip(), '\\t')))\n\t\n\tpart1 = 0\n\tpart2 = 0\n\tfor line in lines:\n\t\tpart1 += max(line) - min(line)\n\t\n\t\tfor i in itertools.combinations(line, 2):\n\t\t\tif max(i) % min(i) == 0:\n\t\t\t\tpart2 += max(i) / min(i)\n\t\t\t\tbreak\n\t\n\tprint 'Part 1: %s' % part1\n\tprint 'Part 2: %s' % part2\n\n\nUpdate: I don't think I actually got on the leaderboard. Which makes sense. I think I was in the first *thousand*, which, still: I'll take it!\n\nGetting onto the leaderboard is tough! I think you only have around 4 minutes for this one before all the spots are taken.\n\nEven 4 mins is too much\n\n>       -------Part 1--------\n\n>Day       Time  Rank  Score\n  \n>2   00:03:49   243      0", "id": "dqn9whw", "owner_tier": 0.5, "score": 0.3199999998}, {"content": "F#\n\n    let lines = [for x in System.IO.File.ReadLines(\"input\") -> x.Split() |> Array.map int]\n    printf \"%A\\n%A\\n\"\n    <| List.sum [for xs in lines -> (Array.max xs) - (Array.min xs)]\n    <| List.sum [for xs in lines do for x in xs do for y in xs do if x <> y && x % y = 0 then yield x/y]\n\nF#\n\nThat is incredibly elegant, kudos. I went with more listy operations\n\n\n    open System.Runtime.InteropServices\n    let input = [|\"5 9 2 8\";\n    \"9 4 7 3\";\n    \"3 8 6 5\"|]\n    \n    // Day 2 1\n    input\n        |> Array.map (fun (str: string) -> \n            str.Split([| ' ' |])\n                |> Array.map int\n                |> Array.fold (fun (max, min) item ->\n                    match (max, min) with\n                        | (None, None) -> (Some(item), Some(item))\n                        | (Some(x), Some(n)) -> \n                            match item with \n                                | i when i >= x -> (Some(i), min)\n                                | i when i <= n -> (max, Some(i))\n                                | _ -> (max, min)\n                        | _ -> failwith \"cant have one some and one none\"                    \n                ) (None, None)\n                |> (fun (max, min) -> max.Value - min.Value)\n        )\n        |> Array.sum\n    \n    // day 2 2\n    input\n        |> Array.map (fun (str: string) -> \n            let row = \n                str.Split([| ' ' |]) \n                |> Array.map int\n    \n            row\n            |> Array.map (fun x -> \n                row \n                |> Array.map (fun d -> \n                    match x with\n                        | x when x = d -> 0\n                        | x when x % d = 0 -> x / d\n                        | _ -> 0\n                )  \n                |> Array.sum\n            )\n            |> Array.sum\n        )\n        |> Array.sum\n\n\n\nNice!  Pushed my understanding of F#.  I was surprised to see there wasn't a combinations function already in F#.  Your answer could have been cleaner if that already existed.  Probably a good standard function to have for AoC.  I believe:\n\n    <| List.sum [for xs in lines do for (x,y) in (combinations xs) if x % y = 0 then yield x/y]\n\nedit: permutations is what you'd want not combinations\n\nThat is awesomely compact, although I find it really hard to read being new to F#.\n\nHere's my much more verbose solution:\n\n\n    let readLines filePath = System.IO.File.ReadLines(filePath)\n    let lines = readLines \"2017\\\\02\\\\input.txt\"\n    let parseLine (s:string) = \n        s.Split() \n        |> Array.filter (fun x -> x.Length > 0)\n        |> Array.map int\n\n    let parsed = lines |> Seq.map parseLine\n\n    let greatestDifferece (items:int []) = (Array.max items) - (Array.min items)\n\n    let evenDivide (items:int []) = \n        let result = \n            items\n            |> Array.collect (fun i -> items \n                                    |> Array.map (fun x -> (i, x)) \n                                    |> Array.filter (fun (x,y) -> x<>y))\n            |> Array.tryPick (fun (i,j) -> if i % j = 0 then Some (i / j) else None)\n\n        match result with\n        | Some i -> i\n        | _ -> 0\n\n    let result1 = parsed |> Seq.sumBy(greatestDifferece)\n    let result2 = parsed |> Seq.sumBy(evenDivide)\n\n\n\nF#\nI did yesterdays challenge in a bit too un-functional way so I tried to do it a bit better today ( ping /u/scrooch ):\n    \n    // Input\n    let toInt (s : string[]) : int[] = Array.map (fun e -> int e) s\n    let input = System.IO.File.ReadAllLines \"input-day2.txt\" \n                |> Array.map (fun x -> x.Split [|'\\t'|])\n                |> Array.map toInt\n    \n    // Part 1\n    let bigDiff (arr : int[]) : int = \n        (Array.max arr) - (Array.min arr)\n    \n    printfn \"part 1: %A\" (Array.fold (fun acc elem -> acc + bigDiff elem) 0 input)\n    \n    // Part 2\n    let isDiv (x:int) (arr:int[]) : bool = \n        Array.exists (fun i -> x%i = 0 && x <> i|| i%x = 0 && x <> i) arr\n    let ifDiv i arr = \n        if (isDiv i arr) then i else 0\n    let divs (arr : int[]) : int[] = \n        Array.map (fun e -> ifDiv e arr) arr |> Array.filter (fun e -> e <> 0)\n    let divbws (arr:int[]):int = \n        if arr.[0] > arr.[1] then arr.[0]/arr.[1] else arr.[1]/arr.[0]\n        \n    printfn \"part 2: %A\" (Array.fold (fun acc elem -> acc + divbws (divs elem)) 0 input)\n\nF#\n\n    // Permutation function from SO\n    let rotate lst =\n        List.tail lst @ [List.head lst]\n    \n    let getRotations lst =\n        let rec getAll lst i = if i = 0 then [] else lst :: (getAll (rotate lst) (i - 1))\n        getAll lst (List.length lst)\n    \n    let rec getPerms n lst = \n        match n, lst with\n        | 0, _ -> seq [[]]\n        | _, [] -> seq []\n        | k, _ -> lst |> getRotations |> Seq.collect (fun r -> Seq.map ((@) [List.head r]) (getPerms (k - 1) (List.tail r)))\n    \n    // My solution\n    let input =\n        System.IO.File.ReadAllLines \"Day2/input.txt\"\n        |> Array.map ((fun (x:string) -> x.Split [|'\\t'|]) >> (Array.map int))\n    \n    input\n    |> Array.sumBy (fun x -> Array.max x - Array.min x)\n    |> printfn \"Part 1: %A\"\n    \n    let findDiv = Seq.sumBy (fun (l: int list) -> if l.[0] % l.[1] = 0 then l.[0] / l.[1] else 0)\n    \n    input\n    |> Array.sumBy (List.ofArray >> getPerms 2 >> findDiv)\n    |> printfn \"Part 2: %A\"\n\nDid some stuff to minimize the complexity and be as linear as possible:\n\n    let s = \n        input.Split('\\n') |> Array.map(fun n -> \n                                 n.Trim().Split('\\t')\n                                 |> Array.map int\n                                 |> Array.toList)\n    \n    let p1 = \n        s\n        |> Array.map(fun x -> \n               x\n               |> List.fold (fun (mx, mn) e -> max mx e, min mn e) \n                      (System.Int32.MinValue, System.Int32.MaxValue)\n               ||> (-))\n        |> Array.sum\n    \n    let p2 = \n        s\n        |> Array.map(fun x -> \n               x\n               |> Seq.unfold(function \n                      | a :: b -> Some((a, b), b)\n                      | _ -> None)\n               |> Seq.pick(fun (a, m) -> \n                      m |> List.tryPick(fun b -> \n                               match a, b with\n                               | a, b | b, a when a % b = 0 -> Some(a / b)\n                               | _ -> None)))\n        |> Array.sum\n\nAlternatively you could have used sort, a lot of you first solution is a weird way to get the min and max:\n\n    let solve1 ss =\n        Array.map Array.sort ss \n        |> Array.map (fun (x : int[]) -> (Array.last x) - x.[0]) \n        |> Array.sum\n\nCool, man!  I work at a well known software company and there are many people there that can't write functionally, it can be tough for some people.  I think there is room to clean up what you have, but good work.  Here is my solution for 2 if you want another comparison:\n\n    let combinations array =\n        let length = Array.length array\n        let mutable answer = []\n        for i in 0 .. length-1 do\n            for j in i+1 .. length-1  do\n                answer <- [array.[i]; array.[j]] :: answer\n        answer\n\n    let solve2 (ss : int[][]) = \n        Array.map combinations ss\n        |> Array.map (List.map List.sort) \n        |> Array.map (List.find (fun x -> (x.[1] % x.[0]) = 0)) \n        |> Array.map (fun x -> x.[1] / x.[0])\n        |> Array.sum\n\n\n", "id": "dqnbe0f", "owner_tier": 0.3, "score": 0.3799999998}, {"content": "**Perl 6**\n\nPart1:\n\n    say [+] \"input\".IO.lines>>.comb(/\\d+/)>>.Int.map: { given $_.list { .max - .min } }\n\nPart2:\n\n    say [+] gather \"input\".IO.lines>>.comb(/\\d+/)>>.Int.map: { for .sort.combinations(2) { if .[1] %% .[0] { take .[1] div .[0]; last }}}\n\nNice use of gather/take!\n\nGood use of given! I was trying to figure out a way to topicize the list and given completely slipped my mind.\n\nYour reduce metaoperators were nicer!  I also forgot that grep is lazy, so yours is semantically equivalent to my gather/take and for/last combo whilst being more compact as well!", "id": "dqnfnxw", "owner_tier": 0.1, "score": 0.1999999998}, {"content": "**Python 3**\n\n    import io, itertools \n    with io.StringIO(s) as f:\n        lines = [[int(n) for n in l.split()] for l in f]\n\n    ans1 = sum(max(l)-min(l) for l in lines)\n\n    ans2 = sum(b//a for l in lines for a,b in itertools.combinations(sorted(l),2) if b%a==0)\n", "id": "dqna3zn", "owner_tier": 0.1, "score": 0.0199999998}, {"content": "Has anyone done a bash solution yet?\n\n    #!/bin/bash\n\n    PARTONE=0\n    PARTTWO=0\n\n    while read -r line; do\n      IFS=' ' read -r -a array <<< \"$(echo \"${line}\" | tr '\\t' '\\n' | sort -n | paste -s -d ' ' -)\"\n      LEN=${#array[*]}\n      MIN=\"${array[0]}\"\n      MAX=\"${array[$LEN-1]}\"\n      ((PARTONE += (MAX-MIN)))\n      MED=0 # This variable will let us break out of the loops when a match is found\n      for m in `seq 0  $((LEN-2))`; do\n        for n in `seq $((m+1))  $((LEN-1))`; do\n          M=${array[$m]}\n          N=${array[$n]}\n          if [ \"$(expr $N % $M)\" = \"0\" ]; then\n            ((PARTTWO += (N / M)))\n            MED=1\n            break\n          fi\n        done\n        if [ $MED -eq 1 ]; then break; fi\n      done\n    done < your_puzzle_input\n\n    echo \"Part 1 Solution: $PARTONE\"\n    echo \"Part 2 Solution: $PARTTWO\"\n\n\nUhhh, very nice! My [solution](https://www.reddit.com/r/adventofcode/comments/7h0rnm/2017_day_2_solutions/dqswqxo/) :)", "id": "dqncebo", "owner_tier": 0.5, "score": 0.0199999998}, {"content": "My Perl 6 solution.  Couldn't figure out a good way to avoid using map. Probably need sleep.\n\n    use v6;\n\n    my @rows = $*PROGRAM.parent.child('input').IO.lines;\n\n    # Part 1\n    say [+] @rows.map({\n        my @cols = .split(\"\\t\").>>.Int;\n        @cols.max - @cols.min;\n    });\n\n    # Part 2\n    say [+] @rows.map({\n      .split(\"\\t\").>>.Int.combinations(2).grep({ max(@_) % min(@_) == 0 }).flat.reduce({ @_.max div @_.min });\n    });\n", "id": "dqncxak", "owner_tier": 0.1, "score": -1.9999999878450582e-10}, {"content": "**Perl 6** version for part a:\n\n    sub MAIN(IO() $inputfile where *.f)\n    {\n        say $inputfile.lines.map({ [R-] $_.words.map(+*).minmax.minmax }).sum;\n    }\n\nWhy twice minmax?  minmax on a list returns a range min..max.  minmax on that range returns two values, min and max.\n\nPart b:\n\n    sub evenly-divisible-quotient(@nums)\n    {\n        for ^@nums -> $i {\n            for ^$i -> $j {\n                return @nums[$i] div @nums[$j] if @nums[$i] %% @nums[$j];\n                return @nums[$j] div @nums[$i] if @nums[$j] %% @nums[$i];\n            }\n        }\n    }\n\n    sub MAIN(IO() $inputfile where *.f)\n    {\n        say $inputfile.lines.map({ $_.words.map(+*).&evenly-divisible-quotient }).sum;\n    }\n\n\nAnd here's a one-liner version of part b:\n\n    sub MAIN(IO() $inputfile where *.f)\n    {\n        say $inputfile.lines.map({ [div] $_.words.map(+*).sort.reverse.combinations(2).grep({ [%%] $_ })[0]}).sum;\n    }\n\n\nNice use of [R-]. Also nice to know about minmax, that could come in use.\n\nIt seems like all of us using Perl 6 have not been able to figure out a way to avoid using map with a code block. There has to be a way, but it would probably be way convoluted.\n\nI really love seeing the different approaches in Perl 6.\n\nNice use of minmax!  I stumbled upon that when searching the docs but I didn't realize it could be called twice to get what we needed.\n\nI didn't use map (by name):\n\nhttps://gist.github.com/bbarry/15f55d2ef879b2e853af3a76f37faa99#file-day2-pl6\n\nTotally over-engineered `grammar` solution.", "id": "dqnizty", "owner_tier": 0.1, "score": 0.23999999979999997}, {"content": "Erlang, because of course.\n\nMost of the code was input handling; the meat is this:\n\n    cksum(_, _, eof, Sum) ->\n        Sum;\n    cksum(NextLineFun, CkSumFun, List, Sum) ->\n        cksum(NextLineFun, CkSumFun, NextLineFun(), Sum + CkSumFun(List)).\n    \n    find_greatest_diff(Ints) ->\n        lists:max(Ints) - lists:min(Ints).\n    \n    find_divisible([H|T]) ->\n        case scan_tail(H, T) of\n            nope ->\n                find_divisible(T);\n            Val ->\n                Val\n        end.\n    \n    scan_tail(_V, []) ->\n        nope;\n    scan_tail(V1, [V2|_T]) when V2 rem V1 == 0 ->\n        V2 div V1;\n    scan_tail(V1, [V2|_T]) when V1 rem V2 == 0 ->\n        V1 div V2;\n    scan_tail(V1, [_V2|T]) ->\n        scan_tail(V1, T).\n\n`CkSumFun` is either `fun find_greatest_diff/1` or `fun find_divisible/1`. `NextLineFun` is a pipeline that gives me `eof` or a list of integers.\n\nLol I forgot about lists:max and lists:min for first part.\nYour solution for second part is much better than yours, here is mine ( I had list of strings ) :\n\n    secondTask([], Acc) ->\n\t    Acc;\n\n    secondTask([First | Rest], Acc) ->\n\t    [FirstNumber | RestNumbers] = string:split(First, \"\\t\", all),\n\t    {IntegerFirstNumber, _} = string:to_integer(FirstNumber),\n\t    Result = findDivision(IntegerFirstNumber, RestNumbers, RestNumbers),\n\t    secondTask(Rest, Acc + Result).\n\t\n    findDivision(_, [], [Second | Rest]) ->\n\t    {SecondNumber, _} = string:to_integer(Second),\n\t    findDivision(SecondNumber, Rest, Rest);\n\n    findDivision(FirstNumber, [Second | Rest], AllExceptFirst) ->\n\t    {SecondNumber, _} = string:to_integer(Second),\n\t    case (FirstNumber div SecondNumber) == (FirstNumber /  SecondNumber) of\n\t    \ttrue -> FirstNumber div SecondNumber;\n\t    \tfalse -> case (SecondNumber div FirstNumber) == (SecondNumber / FirstNumber) of\n\t    \t\t\t\ttrue -> SecondNumber div FirstNumber;\n\t    \t\t\t\tfalse -> findDivision(FirstNumber, Rest, AllExceptFirst)\n\t    \t\t\t end\n\t     end.\n\nEDIT: I also didn't know/forgot to google about rem operator, well, you learn something new every day.\n\nHope you don't mind if I paste my solution here, might be nice in case any other people come looking for Erlang solutions in this thread.\n    \n    % read input\n    getInput() ->\n        {ok, Bin} = file:read_file(\"input.txt\"),\n        parse(string:tokens(binary_to_list(Bin), \"\\r\\n\"), []).\n    \n    parse([], Acc) -> Acc;\n    parse([H|T], Acc) ->\n        parse(T, [[list_to_integer(X) || X <- string:tokens(H, \"\\t \")]|Acc]).\n    \n    \n    % first task\n    solve1()-> Input = getInput(),\n               solve1(Input, 0).\n    \n    solve1([], Acc) -> Acc;\n    solve1([H|T], Acc)-> solve1(T, Acc + solveline1(H)).\n    \n    solveline1(Line) -> lists:max(Line) - lists:min(Line).\n    \n    \n    % second task\n    solve2() -> Input = getInput(),\n                solve2(Input, 0).\n    \n    solve2([], Acc) -> Acc;\n    solve2([H|T], Acc) -> solve2(T, Acc + solveline2(H)).\n    \n    solveline2([H|T]) -> \n        N = round(divisible(H, T)),\n        if N > 0 -> N;\n           N == 0 -> solveline2([hd(T)|tl(T)])\n        end.\n    \n    divisible(_, []) -> 0;\n    divisible(N, [H|T]) ->\n        if N rem H == 0 -> N/H;\n           H rem N == 0 -> H/N;\n           N rem H /= 0 -> divisible(N, T)\n    end.    \n\nThank you for the hint yesterday, btw. This time I converted the input to integers right away, and that did make things easier.\n\nI will admit that my solution when I submitted my answers was much less clean than that.\n\nIt's nice to deal with integers throughout so you can use guards. If I could write every program as nothing but function heads with pattern matching and guards I'd be happy. Makes it tough to use any other language. \n\nAbsolutely. I think that may be only the second `if` statement I've seen in the wild!\n\nYeah I made preparation lib now to read input file. I've made 2 functions, one which will make list of lists of integers ( each input row is one list ) and second function makes list of lists of strings ( for future tasks ).\n\nHm, so \"case ... of\" is more idiomatic Erlang then? Interesting!\n\n`if` definitely has its use, and I think your example is a pretty good one, but yes, `case` or discrete function heads (my preference as you can see) is more common.\n\nGarrett Smith has a classic blog post that presents a very opinionated viewpoint on Erlang structure. Real world usage is all over the map, but I recommend it as a starting point; I think if you err towards his code structure, you'll find code much more readable than if you go the other direction.\n\nhttp://www.gar1t.com/blog/solving-embarrassingly-obvious-problems-in-erlang.html\n\nAnd the followup:\nhttp://www.gar1t.com/blog/more-embarrassingly-obvious-problems.html\n\nI'll give them a read. Thank you!", "id": "dqnau0p", "owner_tier": 0.3, "score": 0.1999999998}, {"content": "Perl 6.  Parts 1 and 2:\n\n\n    my $P1_checksum = 0;\n    my $P2_checksum = 0;\n    for 'input.txt'.IO.lines -> $line {\n        my @row = $line.words>>.Int.sort;\n    \n        $P1_checksum += ( @row.max() - @row.min() );\n    \n        my @combinations = @row.combinations(2);\n        for @combinations -> [$a, $b] {\n            if $b %% $a {\n                $P2_checksum += ($b / $a);\n                last;\n            }\n        }\n    }\n\n    say $P1_checksum, '|', $P2_checksum;\n\n\n    \n\nNice!\nNote that you can use `.words` instead of `.split(/\\s/)`.  And if you add a `.sort` to the end of that line, you can skip the `if $a %% $b` part, since `$a` will always be `\u2264 $b`.\n\nBoth of those were nice little optimisations to my answer:\n\n    sub evenly-divisible(@c ($l, $r)) { $r/$l if $r%%$l }\n    \n    sub part1 {$^l.max - $^l.min}\n    sub part2 {[+] $^l.sort.combinations(2).map: &evenly-divisible}\n    \n    sub process-file(Str $f where *.IO.r, Callable $c) {\n    \t$f.IO.lines\u00bb.words\u00bb.Numeric.map: $c;\n    }\n\nThere's probably a bit extra to squeeze into combinations, as I could split the test and the division but it's good enough and it was fun to do.\n\nThanks for the feedback!  I've updated my solution.\n\n\nNice.\n\nIf you're looking to shorten it at all:\n\n* Use .Int instead of .Numeric\n* Use \u00bb. insead of .map even when calling a sub rather than a method", "id": "dqnaxtm", "owner_tier": 0.7, "score": 0.2599999998}], "link": "https://www.reddit.com/r/adventofcode/comments/7h0rnm/2017_day_2_solutions/", "question": {"content": "# NOTICE\n\nPlease take notice that we have updated the Posting Guidelines in the sidebar and wiki and are now requesting that you post your solutions in the daily Solution Megathreads.  Save the `Spoiler` flair for truly distinguished posts.\n\n***\n\n#--- Day 2: Corruption Checksum ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Need a hint from the [Hugely^* Handy^\u2020 Haversack^\u2021 of Helpful^\u00a7 Hints^\u00a4](/r/adventofcode/w/h5)?\n\n[Spoiler](#s \"Have you tried adding your programming language to your phone\u2019s input options?\")\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n\n###*edit:* Leaderboard capped, thread unlocked!", "id": "7h0rnm", "title": "-\ud83c\udf84- 2017 Day 2 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "Python 2.7:\n\n    text = raw_input(\"Enter string: \").replace(\" \",\"\")\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    print \"\".join(letter for letter in text if letter not in vowels)\n    print \"\".join(letter for letter in text if letter in vowels)\n\nI like how incredibly readable this is. For the record, you can define vowels as:  \n\n    vowels = 'aeiou'  \n\nand it'll work the same way without the need for so many quotes and commas.\n\nI am still learning Python and these easy problems are still hard for me to solve on my own, but I learned about .replace, .join, and an alternate way to make a list just from reading your code and the comments. I even changed it to work with Python 3. Thank you!\n\nThis is a very pretty piece of Python code!\n\nJust a tip to save some keystrokes:\n\n    vowels = list(\"aeiou\")\n\nEven shorter:\n\ninstead of \n\n    .replace(\" \",\"\")\n\nuse\n\n    .strip(\" \")\n\nIt's incredible how close our solutions were. I hadn't read your comment, but wrote this:\n\n    sentence = 'two drums and a cymbal fall off a cliff'.strip(' ')\n    vowels = list('aeiou')\n    print ''.join([i for i in sentence if i not in vowels])\n    print ''.join([i for i in sentence if i in vowels])\n\nYeah, I realised this after posting, but I left it as is. Thanks!\n\nEven more:\n\n    vowels = \"aeiou\"\n\neven faster:\n\n    vowels='oiuea' # just slap 5 fingers on the 5 keys\n\n(jk)\n\nIf we're minimising keystrokes, why not:\n\n    t = raw_input(\"Enter string: \").replace(\" \",\"\")\n    print \"\".join(l for l in t if l not in 'aeiou')\n    print \"\".join(l for l in t if l in 'aeiou')\n\nEdit: Shorter again:\n\n    import re,sys\n    t=sys.argv[1]\n    print re.sub('[aeiou ]','',t)\n    print re.sub('[^aeiou]| ','',t)", "id": "cfng0od", "owner_tier": 0.1, "score": 0.4931506848858448}, {"content": "Please keep this sub alive, I can't overstate how helpful these challenges and most importantly the discussions are.", "id": "cfnmtzo", "owner_tier": 0.7, "score": 0.18264840178082192}, {"content": "x86 assembly for Windows (assembled with MASM32)\n\n    .386 \n    .model flat, stdcall \n    option casemap :none \n\n    include \\masm32\\include\\windows.inc \n    include \\masm32\\include\\kernel32.inc \n    include \\masm32\\include\\masm32.inc \n    includelib \\masm32\\lib\\kernel32.lib \n    includelib \\masm32\\lib\\masm32.lib \n\n    .data?\n        input           db      256 dup(?)      ;\"dup\" duplicates what is in parenthesis.\n        nonVowels       db      256 dup(?)      ;In these cases, it creates 3 uninitialized arrays of 256 bytes.\n        vowels          db      256 dup(?)        \n\n    .code\n    main:\n        invoke StdIn, addr input, 256           ;get input\n\n        xor esi, esi                            ;xoring a register with itself is a fast way of setting it to 0.\n        xor edi, edi\n        xor eax, eax                            ;eax will store the destination address for vowels\n        mov bl, input[esi]\n\n    _disemvowelerLoop:\n            cmp bl, 0\n            jz _disemvowelerEnd                 ;exit loop at end of string (null terminator character)\n\n            cmp bl, ' '                         ;ignore spaces\n            jz _disemvowelerContinue\n\n            cmp bl, 'a'                         ;check if current character is a vowel\n            jz _vowel\n            cmp bl, 'e'\n            jz _vowel\n            cmp bl, 'i'\n            jz _vowel\n            cmp bl, 'o'\n            jz _vowel\n            cmp bl, 'u'\n            jz _vowel\n\n            mov nonVowels[edi], bl              ;if it isn not a vowel, add it to nonVowels\n            inc edi\n            jmp _disemvowelerContinue\n\n        _vowel:\n            xchg eax, edi                       ;temporarily swap eax and edi so edi stores the vowel destination\n            mov vowels[edi], bl                 ;if it is a vowel, add it to vowels\n            inc edi\n            xchg eax, edi\n\n        _disemvowelerContinue:\n            inc esi                             ;increment character index\n            mov bl, input[esi]\n            jmp _disemvowelerLoop\n\n    _disemvowelerEnd:\n\n        mov nonVowels[edi], 10                  ;add newline and null terminator characters to strings\n        mov nonVowels[edi+1], 0\n        xchg eax, edi\n        mov vowels[edi], 10\n        mov vowels[edi+1], 10\n        mov vowels[edi+2], 0\n\n        invoke StdOut, addr nonVowels           ;print results\n        invoke StdOut, addr vowels\n        invoke ExitProcess, 0\n    end main\n\n\nWow.  As a newbie, I was just talking to someone last night about x86.  Crazy stuff.", "id": "cfnp10y", "owner_tier": 0.3, "score": 0.1232876711872146}, {"content": "Perl:\n\n    sub dp149 {\n    \t$_ = $_[0]; s/[aeiou ]//g; say;\n    \t$_ = $_[0]; s/[^aeiou]//g; say;\n    }\n\n\n\nwhat\n\nshorter weirder:\n\n    sub dp149 {\n    \t$_ = shift;\n    \tsay y/aeiou //dr;\n    \tsay s/[^aeiou]//gr;\n    }\n\nPERL:\n\n    SUB DP149 {\n    \t$_ = $_[0]; S/[AEIOU ]//G; SAY;\n    \t$_ = $_[0]; S/[^AEIOU]//G; SAY;\n    }\n\n\n\neven shorter...\n\n    sub dp149 {\n        shift;\n        say y/aeiou //dr;\n        say s/[^aeiou]//gr;\n    }\n\n($_ is implicit)\n\n--edit-- formatting is\n\n* hard\n\nomg i can't breathe\n\nyou actually need to declare it here\n\nonly some functions set $_, and shift is not one of them\n\n$_ = $_[0];s/[aeiou]//g;say;\n\nthis bit puts the input through a regex to remove spaces and vowels, then prints it. $_ is a default but could easily be substituted for any other variable name(with the expense of file size)\n\nbah, you're right, My mistake. I always thought it did.\n\nI should probably check that I'm not actually using this in production code...  but hey, everything is working, so I'm sure it will be fine.\n\nalthough...  perl can expand variables within a regex, why not just drop the shift altogether and just s/xyz/@_[0]/g\n\n(on my tablet atm, so can't test right now).", "id": "cfng7bb", "owner_tier": 0.3, "score": 0.9999999999543379}, {"content": "Ruby!\n\n    str = 'did you hear about the excellent farmer who was outstanding in his field'\n    puts \"#{str.delete('aeiou ')}\\n#{str.delete('^aeiou')}\"\n\nOutput: \n\n    ddyhrbtthxcllntfrmrwhwststndngnhsfld\n    ioueaaoueeeeaeoaouaiiiie\n    [Finished in 0.1s]\n\n[deleted]\n\nawesome!\n\nWow!\n\nI stumbled upon String.tr(), which also does pretty much exactly what we want:\n\n    str = \"all those who believe in psychokinesis raise my hand\"\n    p str.tr(\"aeiou \", \"\")\n    p str.tr(\"^aeiou\", \"\")\n\nI make one this\n\n    def disemvoweler(i)\n       i.gsub!(/a|e|i|o|u| /, '')\n    end\n\n    puts \"What do you whant to disvowel?\"\n \n    puts disemvoweler(gets)\n\nRuby is so much fun to write in. Try it :)\n\nHey, thanks! =)\n\nHa, thanks! I'm taking that as a compliment, whether you meant it that way or not.\n\nInteresting, but I think String#delete may be more idiomatic here. Thanks! \n\nThat's not going to meet the requirements, though -- you need to print BOTH the disemvoweled string AND the vowels from that string (in order).\n\nYou're only doing the first part. Also, using String#gsub! isn't a great idea -- if there are no vowels in the string, you'll get `nil` -- not the string. And finally, you shouldn't use alternation for single characters -- you can use Regex character classes for that. Here's a slightly better version of your implementation:\n\n    def disemvoweler(str)\n      str.gsub(/[aeiou]/,'') + \"\\n\" + str.gsub([^aeiou],'')\n    end\n    \n    puts \"What do you want to disvowel?\"\n    \n    puts disemvoweler(gets.chomp)\n\nKeep practicing! You'll get there.", "id": "cfnjewn", "owner_tier": 0.7, "score": 0.18721461182648402}, {"content": "This is exactly what the shell utility `tr` is for. Here I assume the first argument is a file containing the text. See /u/galaktos's comment for stdin instead.\n\n    tr -d aeiou[:blank:] < $1\n    tr -C -d aeiou < $1", "id": "cfnos7b", "owner_tier": 0.5, "score": 0.059360730547945204}, {"content": "Perl:\n\n    chomp($_ = <STDIN>);\n    ($a = $_) =~ s/[^aeiou]//g;\n    y/aeiou //d;\n    print \"$_\\n$a\";\n\nBonus Brainfuck devoweler (doing consonants takes way too long):\n\n    >,\n    [>>++++++\n    [>++++\n    [>+>+>++++>++++>++++>++++>++++>++++>+++++>+++++>+++++>+++++<<<<<<<<<<<<-]\n    <-]\n    >>++++++++>++++++++>+>+>+++++>\n    +++++>+++++++++>+++++++++\n    >--------->--------->--->---\n    [<]<<<\n    [>+>+>+<<<-]>[->>>>-<<<<]>>>>\n    [\n    <<<[<<+>>-]<<[->+>+<<]>[->>>>>>-<<<<<<]>>>>>>\n    [\n    <<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>-<<<<<<<<]>>>>>>>>\n    [\n    <<<<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>>>-<<<<<<<<<<]>>>>>>>>>>\n    [\n    <<<<<<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>>>>>-<<<<<<<<<<<<]>>>>>>>>>>>>\n    [\n    <<<<<<<<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>>>>>>>-<<<<<<<<<<<<<<]>>>>>>>>>>>>>>\n    [[<]>.[<]]\n    [<]\n    ]\n    [<]\n    ]\n    [<]\n    ]\n    [<]\n    ]\n    [<]\n    ]\n    >>>>>>>>>>>>>\n    >,\n    ]\n\n\ni'm glad someone tried to accomplish this...I was actually wondering if anyone would.\n\nDid you use any 'convert-to-brainfuck' tool? Are are you a fucking genius?\n\nNah, I actually really suck at programming.\n\nAll it's doing is capturing invididual character input, subtracting its ASCII value from 6 others, and printing it out if it isn't equal to any of them, though, so it's very simple if you keep track of the relative memory locations.", "id": "cfo841x", "owner_tier": 0.7, "score": 0.0730593606849315}, {"content": "JavaScript:\n\n    function disemvowel(inputStr) {\n      console.log(inputStr.match(/[^aeiou ]/g).join(\"\"));\n      console.log(inputStr.match(/[aeiou]/g).join(\"\"));\n    }\n\nThis is great. This was my solution (a slight variation): \n\n    function disemvowel(s) {\n      console.log(s.replace(/[aeiou ]/g, ''));\n      console.log(s.replace(/[^aeiou]/g, ''));\n    }\n\nnew to this--why the backslash in the parameters for the match method?\n\nwow.  Mine is much more complex.  I can't believe how simple it could be.\n\n    var input = prompt(\"Please enter a string.\").toLowerCase();\n    var slicer = 0;\n    var newString = \"\"\n    console.log(input);\n\n    var vowels = \"aeiou\";\n\n    var removed = \"\";\n\n    for(var i = 0; i < input.length; i++){\n        if((vowels.indexOf(input[i]) > 0)|| (input[i] == \" \")){\n            removed += input[i];\n        }else{\n            newString += input[i];\n        }\n        slicer ++;\n    }\n\n    console.log(newString);\n    console.log(removed);\n\nNice!\n\nHave you attempted the re-envoweler challenges yet?\n\nBy the way, that's a forward slash, not a backslash! Backslashes look like they're leaning backwards against the flow of the text -- so the top is on the left.\n\nIn JavaScript, you declare a regex with the slash character.\n\nIt's a shorter way of writing regexps. Example:\n\n    console.log(/a/.exec('abcd'));\n    console.log(new RegExp('a').exec('abcd'));", "id": "cfngbti", "owner_tier": 0.5, "score": 0.0684931506392694}, {"content": "sed:\n\n    sed 's/ //g;h;s/[aeiou]//g;p;x;s/[^aeiou]//g;'\n\nNice use of `h` and `x`! (Also, TIL about `;` in `sed` \u2013 I thought you needed multiple `-e`s...)\n\nYou might still be able to minimize it a bit further by removing the first substitution, and using `[aeiou ]` (note the space) in the second.\n\nEdit: like this:\n\n    sed 'h;s/[aeiou ]//g;p;x;s/[^aeiou]//g'", "id": "cfnoay6", "owner_tier": 0.5, "score": 0.0365296803196347}, {"content": "Quick Java.\n\n    import java.util.Scanner;//import for scanner\n    import static java.lang.System.*;//import for System.in and System.out\n\n    public class dp149E\n    {\n    \tpublic static void main(String[] args)\n    \t{\n    \t\tScanner scan = new Scanner(in);//scanner for input\n\t\t\n    \t\tString a = scan.nextLine().trim().replaceAll(\" \", \"\");//get input, trim all trailing spaces, remove all spaces\n\t\t\n    \t\tout.printf(\"%s\\n%s\\n\",a.replaceAll(\"[aeoiu]\", \"\"), a.replaceAll(\"[^aeiou]\", \"\"));//replace all vowels, then replace all non-vowels\n\t\t\n    \t\tscan.close();//manage resources\n    \t}\n    }", "id": "cfnfxjz", "owner_tier": 0.1, "score": 0.00456621}, {"content": "Haskell, code golf.\n\n    main = do\n        line <- fmap (filter (/= ' ')) getLine\n        putStr . unlines $ map (\\f -> filter (f . (`elem` \"aeiou\")) line) [not, id]\n\nI've always wanted to learn Haskell as a hobby language.\n\nIn [Data.List](http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:partition), there's a function 'partition' that makes the second part of your code easier to understand. Example usage\n\n    partition (`elem` \"aeoiu\") \"hello\"\n\nWill return (\"eo\", \"hll\").\n\nI prefer doing it with one foldr \n\n    main = do\n        (o,v) <- fmap (foldr dis ([], [])) getLine\n        putStrLn o\n        putStrLn v\n      where\n        dis e (o, v) | e `elem` \"aeiou\" = (o, e:v) \n                     | e == ' '         = (o, v) \n                     | otherwise        = (e:o, v)\n\nEven if you never you never use it in an actual job, it will probably make you a better programmer. The mathematical purity that Haskell encourages is a useful concept to use in any language. Functions without side-effects are much easier to debug. If you want to give it a shot, which I highly recommend, check out [Learn You a Haskell for Great Good!](http://learnyouahaskell.com) The author is hilarious, and nothing will tickle your brain quite like functional programming.\n\nJoin us! The Haskell community is small, friendly, and helpful! Plus, there are lots of areas to shine, unlike the bigger languages like C++ or Java \n\nIt's more clear, but not as golf-y. The last line is that same amount of characters, but I have to add the extra import line, so it takes more strokes. However, if I wasn't code-golfing, I would definitely use you partition idea.\n\n    import Data.List\n\n    main = do\n        line <- fmap (filter (/= ' ')) getLine\n        let (vs, cs) = partition (`elem` \"aeiou\") line in putStr $ unlines [vs, cs]\n\nI honestly have the PDF of that book and just never got into but now it seems I'll have to!\n\nI definitely will!", "id": "cfnhgsn", "owner_tier": 0.1, "score": 0.0867579908219178}, {"content": "Concise Ruby:\n\n    puts gets.chomp.delete(' ').each_char.partition{|c| !\"aeiou\".include?(c) }.map(&:join)\n\n`String#partition` is different. We use `partition` from `Enumerable` module, so the call to `each_char` which returns an `Enumerator`", "id": "cfnjhml", "owner_tier": 0.3, "score": -4.5662100179110915e-11}, {"content": "Learning python...\n\n    import sys\n    vowels, letters, disemvoweled = 'aeiou', '', ''\n    for param in sys.argv:\n    \tif param == sys.argv[0]:\n    \t\tcontinue\n    \tparam = param.replace(' ','')\n    \tfor char in list(param):\n    \t\tif char in vowels:\n    \t\t\tdisemvoweled += char\n    \t\telse:\n    \t\t\tletters += char\n    print letters\n    print disemvoweled\n\nyou can skip the sys.argv[0] check if you iterate over sys.argv[1:] instead. also you donl't need the list(param), you can iterate over a string a character at a time.\n\nnice work. \n\nGood work, and keep cranking away at learning. I'm a Python novice as well, and writing Pythonic code is the hardest part of it all.\n\nI've been learning for a while and haven't seen import sys yet, what does sys.argv[0] do?\n\nI'm learning Python as well. This is 3.3.    \n\n    words = str(input().replace(\" \",\"\"))\n    a = list(words)\n    vowels = ['a','e','i','o','u']\n\n    extracted_vowels = ''\n    joined = ''\n\n    for letter in a:\n        if letter in vowels:\n            extracted_vowels += letter\n            a.remove(letter)\n        joined += letter\n\n    print(joined)\n    print(extracted_vowels)\n\ngreat, thanks!\n\nKind of unrelated, but is there a simple conversion of a char to ascii in python? I know that in C when you store a char with single quotes \n\n    char b = 'b'\n    # where 'b' stored as it's ascii value of 98.\n\nyou're actually storing it's ascii value (and therefore I can do math on the ascii value, think caesar cipher). Is there a python equivalent?\n\nShort answer: sys.argv is a tuple of the command line parameters that were passed to python. sys.argv[0] is ALWAYS the script name \"something.py\" that was passed to python.\n\nhere, check this out and/or google around for descriptions of argc/argv http://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean\n\nI can't really say off the top of my head what import sys does as a whole, since I only use it to get command line arguments. That's exactly what argv is though, it's what was entered on the command line. My guess is that the sys module probably provides operating system-y stuff such as architecture and maybe like process ID, date/time, idk... look it up!\n\nSo if you invoke python on the cmd line like this:\n\n    python myscript.py param1 param2 param3\n\nThen sys.argv would be a tuple that consists of ('myscript.py', 'param1', 'param2', 'param3')\n\nIn C/C++ land argv is a pointer and you are provided with another parameter called argc which is the number of parameters pointed to by argv. It seems the python sys module doesn't provide argc, but that's probably just because you can just calculate it using len(argv).\n\nLet me know if that was confusing or you have any other questions, I just typed it up real quick off the top of my head.\n\nyes, use the built in ord() function on a character:\n\n    In [55]: ord('b')\n    Out[55]: 98\n\nhope that helps. ", "id": "cfnjqls", "owner_tier": 0.5, "score": 0.095890410913242}, {"content": "Perfectly suited to a simple partition in Haskell:\n\n    import Data.List(partition)\n    import Control.Monad(liftM)\n    \n    disemvowel = partition (`elem` \"aeiou\") . filter (/=' ')\n    \n    main = do (cs, vs) <- liftM disemvowel getLine\n              putStrLn cs >> putStrLn vs\n\nEdit: Add IO\n    \n\n\nI'm just learning Haskell, your use of function composition makes yours look much nicer!\n\n    import Data.List\n\n    disemvowel :: String -> (String, String)\n    disemvowel sentence =\n        let vowels = \"aeiou\"\n            isVowel n = n `notElem` vowels\n    in partition isVowel $ filter (/= ' ') sentence", "id": "cfnl0jt", "owner_tier": 0.5, "score": 0.009132420045662101}, {"content": "+/u/CompileBot clojure\n\n    (defn disemvowler [input]\n          (loop [letter (first input)\n                 cnsnnts []\n                 vowels []\n                 remaining (rest input)]\n            (if letter\n              (case letter\n                (\\a \\A \\e \\E \\i \\I \\o \\O \\u \\U) (recur (first remaining) cnsnnts (conj vowels letter) (rest remaining))\n                \\space (recur (first remaining) cnsnnts vowels (rest remaining))\n                (recur (first remaining) (conj cnsnnts letter) vowels (rest remaining)))\n              {:consonants cnsnnts :vowels vowels})))\n\n    (defn disemvowler2 [input]\n          {:consonants (clojure.string/join (re-seq #\"[^aeiouAEIOU ]\" input)) :vowels (clojure.string/join (re-seq #\"[aeiouAEIOU]\" input))})\n\n    (println (disemvowler \"all those who believe in psychokinesis raise my hand\"))\n    (println (disemvowler2 \"all those who believe in psychokinesis raise my hand\"))\n\nEdit: Add \"one-liner\" version; compilebot\n\nOutput:\n\n    {:consonants [l l t h s w h b l v n p s y c h k n s s r s m y h n d], :vowels [a o e o e i e e i o i e i a i e a]}\n    {:consonants llthswhblvnpsychknssrsmyhnd, :vowels aoeoeieeioieiaiea}\n    \n\n[^source](http://ideone.com/HaFQhT) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&subject=Report%20Abuse&message=--report%20http%3A//www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/cfnh3uh%20Include%20your%20reason%20for%20reporting%20here.)\n\n**EDIT:** Recompile request by cdombroski\n\nOh my god, a compile bot, this is the coolest thing I have ever seen!\n\nThe bot call is awesome. Love it!\n\nLittle late, but\n\n+/u/CompileBot clojure\n\n    (defn disemvowel [s]\n      (as-> s res\n        (filter (complement #{\\ }) res)\n        (group-by #(if (#{\\a \\e \\i \\o \\u \\A \\E \\I \\O \\U} %) :vowel :consonant) res)\n        [(:consonant res) (:vowel res)]\n        (map clojure.string/join res)))\n    (-> \"all those who believe in psychokinesis raise my hand\" disemvowel println)\n\nedit: simpler; compilebot\n\n    (defn disemvowel [s]\n      (->> s\n        (filter (complement #{\\ }))\n        (group-by #(if (#{\\a \\e \\i \\o \\u \\A \\E \\I \\O \\U} %) :vowel :consonant))\n        ((juxt :consonant :vowel))\n        (map clojure.string/join)))\n    (-> \"all those who believe in psychokinesis raise my hand\" disemvowel println)\n\nI initially saw it on Sakuya_Lv9's post. It definitely fits in perfectly here.\n\nOutput:\n\n    (llthswhblvnpsychknssrsmyhnd aoeoeieeioieiaiea)\n    \n\n[^source](http://ideone.com/MKwaJl) ^|\n[^info](http://www.reddit.com/r/CompileBot/wiki) ^|\n[^git](https://github.com/renfredxh/compilebot) ^|\n[^report](http://www.reddit.com/message/compose?to=compilebot&subject=Report%20Abuse&message=--report%20http%3A//www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/cj4j2cf%20Include%20your%20reason%20for%20reporting%20here.)\n", "id": "cfnh3uh", "owner_tier": 0.5, "score": 0.0547945205022831}, {"content": "Common Lisp, using the `disjoin` higher-order function from Alexandria.\n\n    (defun vowel-p (character)\n      (find character \"aeiou\"))\n\n    (defun consonant-p (character)\n      (not (vowel-p character)))\n\n    (defun whitespace-p (character)\n      (find character \" \t\"))\n\n    (defun disemvowel (string)\n      (values (remove-if (disjoin #'whitespace-p #'vowel-p)     string)\n              (remove-if (disjoin #'whitespace-p #'consonant-p) string)))\n\nUsage:\n\n    (disemvowel \"all those who believe in psychokinesis raise my hand\")\n    ;; => \"llthswhblvnpsychknssrsmyhnd\", \"aoeoeieeioieiaiea\"\n", "id": "cfnj13u", "owner_tier": 0.7, "score": -4.5662100179110915e-11}, {"content": "Here's Scala. Decided to try to golf this one:\n\n    val x,y=readLine.filter(_!=' ')partition(\"aeiou\"contains _)\n    print(y+\"\\n\"+x)", "id": "cfnjemj", "owner_tier": 0.5, "score": -4.5662100179110915e-11}], "link": "https://www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/", "question": {"content": "# _(Easy)_: Disemvoweler\n\nDisemvoweling means removing the vowels from text. (For this challenge, the letters a, e, i, o, and u are considered vowels, and the letter y is not.) The idea is to make text difficult but not impossible to read, for when somebody posts something so idiotic you want people who are reading it to get extra frustrated.\n\nTo make things even harder to read, we'll remove spaces too. For example, this string:\n\n    two drums and a cymbal fall off a cliff\n\ncan be disemvoweled to get:\n\n    twdrmsndcymblfllffclff\n\nWe also want to keep the vowels we removed around (in their original order), which in this case is:\n\n    ouaaaaoai\n\n# Formal Inputs & Outputs\n\n## Input description\n\nA string consisting of a series of words to disemvowel. It will be all lowercase (letters a-z) and without punctuation. The only special character you need to handle is spaces.\n\n## Output description\n\nTwo strings, one of the disemvoweled text (spaces removed), and one of all the removed vowels.\n\n# Sample Inputs & Outputs\n\n## Sample Input 1\n\n    all those who believe in psychokinesis raise my hand\n\n## Sample Output 1\n\n    llthswhblvnpsychknssrsmyhnd\n    aoeoeieeioieiaiea\n\n## Sample Input 2\n\n    did you hear about the excellent farmer who was outstanding in his field\n\n## Sample Output 2\n\n    ddyhrbtthxcllntfrmrwhwststndngnhsfld\n    ioueaaoueeeeaeoaouaiiiie\n\n# Notes\n\nThanks to /u/abecedarius for inspiring this challenge on /r/dailyprogrammer_ideas!\n\nIn principle it may be possible to reconstruct the original text from the disemvoweled text. If you want to try it, check out this week's Intermediate challenge!", "id": "1ystvb", "title": "[02/24/14] Challenge #149 [Easy] Disemvoweler", "traffic_rate": 52.622466960352426}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "Python, one line for each sub-problem.\n\n    print sum(len(s[:-1]) - len(eval(s)) for s in open('inputs/problem8-input'))\n    print sum(2+s.count('\\\\')+s.count('\"') for s in open('inputs/problem8-input'))\n\nNice and tidy, but off-by-one for Part 1 of my input: https://gist.github.com/craigotis/5f456721d46c52ad86c8\n\nYour code produces `1332`, but the answer was `1333`.\n\n(But the answer for Part 2 is correct.)\n\nBrilliant. I did part 1 exactly the same as you, but implemented a decoder for the 2nd part. Figuring out the final result is simply that counting is brilliant.\n\nHere is my first:\n\n    with open('advent_8_1.in') as f:\n        print(sum(len(_) - 1 - len(eval(_)) for _ in f))\n\nAnd here my second:\n\n    import re\n    import functools\n\n    class Decoder:\n        def __init__(self):\n            self.regexp = re.compile(r'(\\\\x\\d{2}|\"|\\\\)')\n            self.subs = functools.partial(self.regexp.sub, r'\\\\\\1')\n            self.prepend = '\"'\n            self.append = '\"'\n\n        def repr(self, s):\n            return self.prepend + self.subs(s) + self.append\n\n    def main():\n        decoder = Decoder()\n        with open('advent_8_1.in') as f:\n            print(sum(len(decoder.repr(_[:-1])) - len(_[:-1]) for _ in f))\n    \n    if __name__ == '__main__':\n        main()\n\n\nYou don't have a newline at the end of your input. This code relies on the newline in s[:-1]\n\nIn the second solution the lack of new line doesn't matter because it's removed in the difference\n\nYou're right - my Python is a little rusty. Adding the newline to the input, it spits out `1333`.", "id": "cxrad1k", "owner_tier": 0.1, "score": 0.6923076920512821}, {"content": "# NEW REQUEST FROM THE MODS\n\nWe are requesting that you hold off on posting your solution until there are a significant amount of people on the leaderboard with gold stars - say, 25 or so.\n\nWe know we can't control people posting solutions elsewhere and trying to exploit the leaderboard, but this way we can try to reduce the leaderboard gaming from the official subreddit.\n\nPlease and thank you, and much appreciated!\n\n[deleted]\n\nWhile we're at it; could we post source on github/pastebin instead of directly in this topic? Less chance to spoil yourself (I tend to write a Java implementation first and then a Scala version) and it saves a lot of wear on my scrollwheel (not to mention my tablet not liking long posts).\n\nI'll be locking tomorrow's thread until the leaderboard fills up sufficiently enough for /u/topaz2078's liking (maybe 50, maybe 100, maybe after x hour(s) has elapsed), then unlock it for solution posts.\n\nDay 8 was easy for some, hard for others.  There's 17 days left to go, and they're just going to get harder and harder.\n\nAs someone who can never be awake at the start time (5AM here), roughly how long does it take contestant 1 and contestant 100?\n\nI for one would prefer that people continue to post their code directly in the comment. There's no way I'm following 100 separate links to see people's solutions, but quickly skimming through the thread and seeing if any of them look particularly interesting is great.\n\nYou can also sticky comments now if you didn't hear.\n\nGood point.", "id": "cxr7vn6", "owner_tier": 0.7, "score": 0.9999999997435898}, {"content": "Not so elegant in Go, which doesn't have an eval function, but still pretty straightforward thanks to the `strconv` package:\n\n    func unquote(str string) string {\n    \ts, _ := strconv.Unquote(str)\n    \treturn s\n    }\n\n    func quote(str string) string {\n    \treturn strconv.Quote(str)\n    }\n    \n    func main() {\n    \t// part 1\n    \tvar total int\n    \tfor _, str := range strings.Split(input, \"\\n\") {\n    \t\ttotal += len(str) - len(unquote(str))\n    \t}\n    \tprintln(total)\n    \n    \t// part 2\n    \ttotal = 0\n    \tfor _, str := range strings.Split(input, \"\\n\") {\n    \t\ttotal += len(quote(str)) - len(str)\n    \t}\n    \tprintln(total)\n    }\n\n\nit also has %q for fmt.Sprintf and fmt.Sscanf - which uses strconv under the covers\n\nDamn. That easy, didn't know this existed. Used regexes to count occurrences of the different escapes, \nstupid me. \n\nuse `strings.Count` for counting!\n\nI didn't know `strconv.Unescape` existed either. I wrote my own decoder; I handled the hex escapes using `regexp.ReplaceAllStringFunc`.\n\nHow would you count the hex escapes with this? You can't just count \\x occurrences, as this would include \\\\x, which is not a hex escape. \n\n\\\\\\x that is", "id": "cxr85fp", "owner_tier": 0.5, "score": 0.28205128179487177}, {"content": "I did this the sleuthy way in the shell.\n\n    $ wc -l input\n    300 = 300 lines in the input, so 600 quotes on the ends to remove\n    $ wc -c input\n    6789 = total characters in the input file\n    $ sed 's/\\\\\"/@/g' input | sed 's/\\\\x[a-f0-9][a-f0-9]/~/g' | sed 's/\\\\\\\\/\\\\/g' | wc -c\n    6018 = total characters after unescaping things (which was a tad tricky)\n\nSo, 6789 - 6018 + 600 = 1371 = answer to part 1\n\nAnd to go the other way, it was easier to not stick more backslashes back in the file to trip up future sed operations (we just care about correct character counts):\n\n    $ sed 's/\"/~~/g' input | sed 's/\\\\/@@/g' | wc -c\n    8306 = total characters with new ones added\n\nAdd in the 300 lines * 2 edges = 600 extra \" characters to surround each line in quotes again, and you get 8906. Subtract the 6789 characters in the original file, and you get 2117 for part 2.\n\nI'm trying to solve this with Bash at the moment, but I struggle... I do pretty much the same as you do, except\n\n* I don't pipe the seds, but use several expression in one command using `-e` &ndash; don't think that makes a difference, though\n* I match the double slash first, you match it last\n\nIf you have input like this: `\\\\xee` you first replace the `\\xee` (3 chars difference) whereas I replace just the slash - but isn't the slash escaped and the result should be `\\xee`?\n\n_Edit:_ So, I found my problem. I saved the input file using `cat <<EOF > input08` &ndash; which doesn't preserve escapes! Using `cat <<'EOF' > input08` worked finally.\n\nThis being said, I'm now pretty sure your `sed` chain isn't correct, is it? Gives me the correct result though, now that I checked...\n\nWhat platform are you on?\n\n    strax:~ jeff$ wc -c /Users/jeff/Downloads/input-3.txt \n        6502 /Users/jeff/Downloads/input-3.txt\n\nGlad you got it. I just noodled around with the seds until I got the right number :)\n\nEvery user has its own input files, so it is not surprising.\n\nOh! Good to know!", "id": "cxr8d4z", "owner_tier": 0.9, "score": 0.3589743587179487}, {"content": "I keep thinking these are going to trick me, so I never use the proper built-ins. Here's how I did it the wrong way:\n\n**Perl**\n\n    my $total_a;\n    my $total_b;\n\n    while (<>) {\n        chomp;\n\n        my $len = length $_;\n        my ($a, $b);\n\n        $a = $b = $_;\n        $a =~ s{^\"(.*)\"$}{$1};\n        $a =~ s{\\\\\\\\}{#}g;\n        $a =~ s{\\\\\"}{#}g;\n        $a =~ s{\\\\x[a-fA-F0-9][a-fA-F0-9]}{#}g;\n\n        $b =~ s{\\\\}{\\\\\\\\}g;\n        $b =~ s{\"}{\\\\\"}g;\n\n        my $len_a = length($a);\n        my $len_b = length($b) + 2;\n\n        $total_a += $len - $len_a;\n        $total_b += $len_b - $len;\n    }\n\n    print \"$total_a\\n\";\n    print \"$total_b\\n\";\n\nand here's the simpler way:\n\n    ...\n        my ($a, $b);\n\n        eval \"\\$a = $_\";\n        $b = quotemeta($_);\n\nand here are one-liners, because Perl:\n\n    cat input.txt | perl -nE '$_ = $t += length($_) - length(eval \"\\$n = $_\") - 1; say'\n    cat input.txt | perl -nE '$_ = $t += length(quotemeta($_)) + 1 - length($_); say'\n\nEDIT: Guess who learned about the -E switch today!", "id": "cxr8r39", "owner_tier": 0.1, "score": 0.051282051025641026}, {"content": "A Perl 6 solution.\n\nWith syntax highlighting: http://pygments.org/demo/3300216/\n\n    #!/usr/bin/env perl6\n    \n    # Part 1\n    say [+] 'input'.IO.lines.map: { (m:g/ \\\\x<[a..f0..9]>**2 /.list.elems * 3) + (m:g/ \\\\(\\\"|\\\\) /.list.elems) + 2 }\n    \n    # Part 2\n    say [+] 'input'.IO.lines.map: { (m:g/ \\\\x<[a..f0..9]>**2 /.list.elems) + (m:g/ \\\\ (\\\"|\\\\) /.list.elems * 2) + 4 }\n    \nThings I learned:\n\n1. Using .IO.lines on a filename string to read line-by-line\n2. Regex modifiers go before first / now\n3. Hyper operator for doing reduce operations\n4. Using .list to get group matches\n5. Using .elems to get number of items in list/array\n    \n", "id": "cxs2exg", "owner_tier": 0.1, "score": 0.07692307666666667}, {"content": "**Haskell**\n\n    module Main where\n    import BasePrelude\n\n    decode = f\n     where f ('\\\\':'\\\\':xs)    = ('\\\\':decode xs)\n           f ('\\\\':'\"':xs)     = ('\"':decode xs)\n           f ('\\\\':'x':x:y:xs) = ('!':decode xs)\n           f (x:xs)            = (x:decode xs)\n           f []                = []\n\n    encode s = \"\\\"\" <> f s <> \"\\\"\"\n      where f ('\"':xs)  = \"\\\\\\\"\" <> f xs\n            f ('\\\\':xs) = \"\\\\\\\\\" <> f xs\n            f (x:xs)    = x:(f xs)\n            f []        = []\n\n    input    = lines <$> readFile \"<snip>\"\n    output f = ((,) <$> (sum . map length <$> input) <*> (sum . map f <$> input)) >>= print\n    main1    = output ((+ (-2)) . length . decode)\n    main2    = output (length . encode)\n\n\nhaskell pattern matching always feels so magical to me\n\nHow much experience do you have with Haskell?\n\nI feel like this would be a great challenge for seasoned programmer who is a beginner to Haskell to get started with.\n\nLast time I did any Haskell was maybe 5-6 years ago.  I was trying to learn it and as an exercise wrote a Roman Numeral -> Decimal converter.\n\nI have a similar Haskell solution, although I didn't bother actually decoding the string, opting instead to just count the tokens as they come. Plus for \"encoding\" I just used Haskell's inbuilt `show`. I originally tried to use `read` for decoding, but it actually accepts variable length hexadecimal codes, so often it would consume too many digits after the `\\x`.\n\n    module Matchsticks where\n    \n    readStr, readDiff, showDiff :: String -> Int\n    \n    readStr ['\\\"']            = 0\n    readStr ('\\\"':cs)         = readStr cs\n    readStr ('\\\\':'\\\\':cs)    = readStr cs + 1\n    readStr ('\\\\':'\\\"':cs)    = readStr cs + 1\n    readStr ('\\\\':'x':_:_:cs) = readStr cs + 1\n    readStr (_:cs)            = readStr cs + 1\n    \n    readDiff l = length l - readStr l\n    showDiff l = length (show l) - length l\n    \n    fileDiff :: (String -> Int) -> String -> Int\n    fileDiff d = sum . map d . lines\n\n\nI've been writing Haskell for a long time and I highly recommend it. The ecosystem's gotten a lot better in the last year. Even if you can't write Haskell for your day job, you get better at solving problems without side effects.", "id": "cxr82rq", "owner_tier": 0.1, "score": 0.20512820487179487}, {"content": "C# in linqpad: \n\n    void Main() {\n        var lines = File.ReadLines(@\"aoc8.txt\");\n    \n        int totalCode = lines.Sum(l => l.Length);\n        int totalCharacters = lines.Sum(CharacterCount);\n        int totalEncoded = lines.Sum(EncodedStringCount);\n    \n        Console.WriteLine(totalCode - totalCharacters);\n        Console.WriteLine(totalEncoded - totalCode);\n    }\n    \n    int CharacterCount(string arg) => Regex.Match(arg, @\"^\"\"(\\\\x..|\\\\.|.)*\"\"$\").Groups[1].Captures.Count;\n    int EncodedStringCount(string arg) => 2 + arg.Sum(CharsToEncode);\n    int CharsToEncode(char c) => c == '\\\\' || c == '\\\"' ? 2 : 1;", "id": "cxr8m29", "owner_tier": 0.7, "score": 0.025641025384615386}, {"content": "I messed up real bad on my speed solve attempt today, so instead I uploaded a video of me solving Day 8 using only my text editor (vim).\n\nhttps://www.youtube.com/watch?v=2WY-01QaIIY\n\nFor those of you who did a double take when you saw the leaderboard today, my mistake was misinterpreting double-quoted, which is something of a double entendre.  I'll have to redouble my efforts tomorrow.\n\n\nAha! I was trying to do the same thing (use vim) and watching your video I see where I went wrong - I forgot that the \\x was followed by hex numbers, not decimals. So I was only grabbing \\\\x\\d\\d instead of [0-9a-z][0-9a-z]. Dang it, I think I would have made it on the board if I hadn't screwed that up. I kept coming up with the wrong answer and after a few tries, it pushes you back to 5 minutes in between guesses instead of just 1, and I was toast.\n\nGlad to hear you are ok, though.\n\nHooray for text editor solutions! Here's a video of me doing something similar in Atom: https://www.youtube.com/watch?v=zHxxzJZsj4o\n\nedit: and here's what I wrote down for those who prefer text to videos,\n\n    Part 1\n    Text editor solution, using find and replace, multiple cursors, and a character counter.    \n\n    The untouched input has 6789 characters of code. (this includes newlines but that shouldn't matter for the purposes of our calculation.) Now use text editor trickery to remove the double quotes from the beginning and end of every line, replace \\\\ with a, \\\" with a, and \\xab with b (for any characters a and b). For a new total of 5418 characters. So a difference of 1371. Note that replacing with a non special character like a was a conscious choice, otherwise you can introduce unintended new escapes sequences.    \n\n    Part 2\n    Another text editor solution using the same tools as above.    \n\n    Again we start with 6789 characters of code. Replace each \" and \\ with aa (as each takes 2 characters to encode.) Finally add quotes to the beginning and end of every line. This leaves us with 8906 characters, for a difference of 2117.\n\nedit2: damnit. this was supposed to be an edit not a reply. :'(", "id": "cxr93zy", "owner_tier": 0.3, "score": 0.1025641023076923}, {"content": "A Python 2 solution:\n\n    def raw_char_count(s):\n        return len(s)\n\n    def escaped_char_count(s):\n        count = 0\n        i = 1\n        while i < len(s) - 1:\n            if s[i] == \"\\\\\":\n                i += 4 if s[i+1] == \"x\" else 2\n            else:\n                i += 1\n            count += 1\n        return count\n\n    def encode(s):\n        result = ''\n        for c in s:\n            if c == '\"':\n                result += \"\\\\\\\"\"\n            elif c == '\\\\':\n                result += \"\\\\\\\\\"\n            else:\n                result += c\n        return '\"' + result + '\"'\n\n    def day8_part1():\n        raw, escaped = 0, 0\n        for line in open('day8input.txt'):\n            raw += raw_char_count(line)\n            escaped += escaped_char_count(line)\n        print raw - escaped\n\n    def day8_part2():\n        enc, raw = 0, 0\n        for line in open('day8input.txt'):\n            enc += len(encode(line))\n            raw += raw_char_count(line)\n        print enc - raw", "id": "cxraj80", "owner_tier": 0.1, "score": 0.025641025384615386}, {"content": "**Q**: notice that part 2 is much simpler. For part 1 I struggled with the overlapping patterns when using the vector operators so I went with an iterative solution instead.\n\n    //Part 1\n    {sum{2+first({[n;s]$[0=count s;(n;s);s[0 1]~\"\\\\\\\\\";(n+1;2_s);s[0 1]~\"\\\\\\\"\";(n+1;2_s);s[0 1]~\"\\\\x\";(n+3;4_s);(n;1_s)]}.)/[(0;-1_1_x)]}each x}\n    //Part 2\n    {sum{2+sum x in\"\\\\\\\"\"}each x}\n\n\nSomething like this (untested, but just thowing the idea out) might be better for your part 1\n\n    {2+sum 1 1 3*sum (_[1]\\[x])[;0 1] ~/:\\:(\"\\\\\\\\\";\"\\\\\\\"\";\"\\\\x\")} each x\n\nEdit - actually that doesn't work, because of your comment about overlapping patterns!\n\nIt works if you cheat slightly using ssr:\n\n    sum {2+sum 1 1 3*sum (_[1]\\[ssr[x;\"\\\\\\\\\";\"X-\"]])[;0 1] ~/:\\:(\"X-\";\"\\\\\\\"\";\"\\\\x\")} each x\n\nIndeed ssr can be used to eliminate the iteration:\n\n    {sum{2+sum sum 1 1 3*(ssr[;\"\\\\\\\"\";\"\\001\"]ssr[;\"\\\\\\\\\";\"\\000\"][x])=/:\"\\000\\001\\\\\" }each x}\n\n> {sum{2+sum sum 1 1 3*(ssr[;\"\\\\\\\"\";\"\\001\"]ssr[;\"\\\\\\\\\";\"\\000\"][x])=/:\"\\000\\001\\\\\" }each x}\n\nUsing this it can be reduced further, ssr feels like cheating though!\n\n    600+sum/[1 1 3*(ssr[;\"\\\\\\\"\";\"\\001\"]ssr[;\"\\\\\\\\\";\"\\000\"][raze x])=/:\"\\000\\001\\\\\"]\n", "id": "cxrbxyy", "owner_tier": 0.1, "score": 0.1538461535897436}, {"content": "My shortest solution yet (using C# isn't great for that...):\n\nC#\n==\n\n    using System;\n    using System.IO;\n    using System.Linq;\n    using System.Text.RegularExpressions;\n    \n    namespace Day8\n    {\n        internal class Program\n        {\n            private static void Main()\n            {\n                var words = File.ReadAllLines(\"C:/input8.txt\");\n                Console.Out.WriteLine(words.Sum(w => w.Length - Regex.Replace(w.Trim('\"').Replace(\"\\\\\\\"\", \"A\").Replace(\"\\\\\\\\\", \"B\"), \"\\\\\\\\x[a-f0-9]{2}\", \"C\").Length));\n                Console.Out.WriteLine(words.Sum(w => w.Replace(\"\\\\\", \"AA\").Replace(\"\\\"\", \"BB\").Length + 2 - w.Length));\n            }\n        }\n    }\n\nC# isn't great for this problem anyway. If you are trying to use C# string unescaping to process the file be forewarned that in C#, hex escape sequences resolve to unicode code points and may be for example `\"\\x3ffd\"` \n\n[Regex.Escape](https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex.escape(v=vs.110\\).aspx) and [Regex.Unescape](https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex.unescape(v=vs.110\\).aspx) worked for me\n\nAfter seeing a bunch of solutions using Python's eval, I decided to make something similar for C#, emitting an assembly with input lines as static constants ... it was hilarious, but was very slow and ultimately I threw it out when I came across this issue.\n\nMy initial \"solution\" parsed an input file at compile time into a string array via T4 templates. I then compared the result of `File.ReadAllLines(\"input.txt\").Select(s=>s.Length).Sum()` to `Day8().Select(s=>s.Length).Sum()` where Day8 was the template created something like this:\n\n    partial class Program {\n        static string[] Day8() {\n            return new [] { <#= string.Join(\",\", File.ReadAllLines(\"input.txt\")) #> };\n        }\n    }\n\nThat's how I found out.", "id": "cxrf0p9", "owner_tier": 0.5, "score": 0.12820512794871794}, {"content": "PHP: Really easy day, imo, thanks to built in php functions\n\n    $one = 0;\n    $two = 0;\n    foreach (file('input.txt', FILE_IGNORE_NEW_LINES) as $line) {\n    \teval('$str = ' . $line . ';');\n    \t$one += strlen($line) - strlen($str);\n    \t$two += strlen(addslashes($line))+2-strlen($line);\n    }\n    echo \"8.1: $one\\n8.2: $two\";\n\nYup. I did pretty much the same thing, but subtracting those 2 counts (part 1), and same as you for part 2.\n\n        $totalFile += strlen($line);\n        eval(\"\\$totalMem += strlen($line);\");\n\nFor some reason, I had line-endings issues, which didn't help... I'm stealing your `FILE_IGNORE_NEW_LINES` ;)\n\nAlways cautious about using `eval()` so went for pattern matching instead\n\n    <?php foreach(file(h)as$l){preg_match_all('#(\\\\\\.)#',$l,$m);$a+=2;$b+=4;foreach($m[0]as$r){$a+=($r=='\\x')?3:1;$b+=($r=='\\x')?1:2;}}echo\"$a/$b\";\n\nHoly crap, PHP wins on this one so far for shortest (while still quite readable) implementation.", "id": "cxr7wmo", "owner_tier": 0.5, "score": 0.07692307666666667}, {"content": "Haskell\n--\n    \n    readHex :: Char -> Int\n    readHex c\n        | c >= '0' && c <= '9' = fromEnum c - fromEnum '0'\n        | c >= 'a' && c <= 'f' = fromEnum c - fromEnum 'a' + 10\n        | c >= 'A' && c <= 'F' = fromEnum c - fromEnum 'A' + 10\n    \n    \n    parse :: String -> String\n    parse [] = []\n    parse ('\\\\':'\"':xs) = '\"' : parse xs\n    parse ('\\\\':'\\\\':xs) = '\\\\' : parse xs\n    parse ('\\\\':'x':a:b:xs) = toEnum (readHex a * 16 + readHex b) : parse xs\n    parse (x:xs) = x : parse xs\n    \n    parseLine :: String -> String\n    parseLine = parse . init . tail\n    \n    part1 :: String -> Int\n    part1 input = \n        length (concat (lines input)) -\n        length (concatMap parseLine (lines input))\n    \n    part2 :: String -> Int\n    part2 input =\n        length (concatMap show (lines input)) -\n        length (concat (lines input))\n\n\nTurns out calling show on each line is all that's n eeded for the second part. `parseLine` abuses the fact that the input always has one string per line to just chop off the double quotes at the start/end.\n\n\nEdit: Thinking about it, there's really no reason for it to actually parse the hex codes. Oh well!", "id": "cxr8rch", "owner_tier": 0.3, "score": -2.5641025485193053e-10}, {"content": "Java: Used code points for Part 1 then just used StringEscape for Part 2\n\n    public static void main(String[] args) {\n        String[] input = getInput().split(\"\\n\");\n        int totalLength = 0, codeLength = 0, part2Length = 0;\n        for (String in : input) {\n            totalLength += in.length();\n            codeLength += in.length();\n            part2Length += StringEscapeUtils.escapeJava(in).length()+2;\n            int offset = 0;            \n            while (offset < in.length()) {\n                int curChar = in.codePointAt(offset);\n                offset += Character.charCount(curChar);\n                if (curChar == 34) { // if quotation\n                    codeLength--;\n                } else if (curChar == 92) {  // if slash\n                    codeLength--;\n                    curChar = in.codePointAt(offset);\n                    if (curChar == 120) { // if hex\n                        codeLength -= 2;\n                        offset += Character.charCount(curChar);\n                    } else {\n                        offset += Character.charCount(curChar);\n                    }\n                }\n            }            \n        }\n        System.out.println(\"Part 1: Total length: \" + totalLength + \" Code Length: \" + codeLength + \" Answer: \" + (totalLength - codeLength));\n        System.out.println(\"Part 2: Encoded Length: \" + part2Length + \" Total length: \" + totalLength + \" Answer: \" + (part2Length - totalLength));\n    }\n\nDeleted with [this open source script](https://greasyfork.org/en/scripts/10380-reddit-overwrite)\n\nYeah I never used it before but it was cool to play around with.", "id": "cxr9b5f", "owner_tier": 0.7, "score": 0.07692307666666667}, {"content": "I tried to replace in the strings, and I got hung up on something that looked like \"fdsa\\\\\\\\x123\" because I'd replace the escaped backslash with a single backslash, then I'd see the new escaped hex character. This was a really easy one, and I managed to bungle the heck out of it. :P\n\nIn the end, I decided to just count the number of characters I skipped. C# code:\n\n\twhile ((line = file.ReadLine()) != null)\n\t{\n\t\tcount += 2; // ignore the outer quotes\n\t\tfor (int i = 1; i < line.Length - 1; i++)\n\t\t{\n\t\t\tif (line[i] == '\\\\')\n\t\t\t{\n\t\t\t\tif (line[i + 1] == '\\\\' || line[i + 1] == '\\\"')\n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if (line[i + 1] == 'x')\n\t\t\t\t{\n\t\t\t\t\tcount += 3;\n\t\t\t\t\ti += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\nWow, my code looked almost the same except I had a foreach loop instead of a while and I forgot to do \"i++\" and \"i += 3\". The rest was literally the same.\n\nI just noticed I have \"count += 1\" right next to \"i++\" That looks kinda silly. Hope you didn't do that too. :P\n\nNope, I guess that was the third difference.", "id": "cxr9h3t", "owner_tier": 0.3, "score": 0.07692307666666667}, {"content": "Boring F# using Regex's Escape/Unescape methods (needed to account for double quotes, anyone know why they don't escape?)\n\n    open System\n    open System.Text.RegularExpressions\n    \n    [<EntryPoint>]\n    let main argv = \n        let input = IO.File.ReadLines (\"..\\..\\input.txt\")\n        let literals = input |> Seq.sumBy (fun s -> s.Length)\n    \n        literals - (input |> Seq.sumBy (fun s -> (Regex.Unescape (s.Substring (1, s.Length - 2))).Length))\n        |> printfn \"Unesecaped difference: %d\"\n        \n        (input |> Seq.sumBy (fun s -> \n            (Regex.Escape s).Length + (s |> Seq.filter (fun c -> c = '\"') |> Seq.length) + 2)) - literals\n        |> printfn \"Escaped difference:    %d\"", "id": "cxraig9", "owner_tier": 0.1, "score": -2.5641025485193053e-10}, {"content": "Scala: I just went for a FSA and traverse through each string. I could just do some regex replace magic or interpret the string, but that would be no fun.\n\n    val strings = scala.io.Source.fromFile(\"input.txt\").getLines.toList\n    \n    val stringLiteralCount = strings.map(_.length).sum\n    \n    //part 1\n    val memoryDiff = stringLiteralCount - strings.map(_.foldLeft((0, 0))((s, c) => (c, s._1) match {\n        case ('\"', 0) => (1, s._2)\n        case ('\\\\', 1) => (2, s._2)\n        case ('\"', 1) => (5, s._2)\n        case (_, 1) => (1, s._2 + 1)\n        case ('\\\\', 2) => (1, s._2 + 1)\n        case ('\"', 2) => (1, s._2 + 1)\n        case ('x', 2) => (3, s._2)\n        case (_, 3) => (4, s._2)\n        case (_, 4) => (1, s._2 + 1)\n    })).map(_._2).sum\n    \n    //part 2\n    val encodeDiff = strings.map(_.foldLeft((0, \"\"))((s, c) => (c, s._1) match {\n        case ('\"', 0) => (1, s._2 + \"\\\"\\\\\\\"\")\n        case ('\\\\', 1) => (2, s._2 + \"\\\\\\\\\")\n        case ('\"', 1) => (5, s._2 + \"\\\"\\\\\\\"\")\n        case (a, 1) => (1, s._2 + a)\n        case ('\\\\', 2) => (1, s._2 + \"\\\\\\\\\")\n        case ('\"', 2) => (1, s._2 + \"\\\\\\\"\")\n        case ('x', 2) => (3, s._2 + \"x\")\n        case (a, 3) => (4, s._2 + a)\n        case (a, 4) => (1, s._2 + a)\n    })).map(_._2.length).sum - stringLiteralCount\n\nParser combinators make this much more obvious:\n\n    object Day8 extends App with JavaTokenParsers {\n\n      val input = io.Source.fromInputStream(getClass.getClassLoader.getResourceAsStream(\"day8.txt\")).getLines.toList\n\n      // Parse each element of an input string\n      def bs = \"\\\\\"\n      def quot = \"\\\"\"\n      def escBs = bs ~ bs\n      def escQuot = bs ~ quot\n      def hex = \"[0-9a-f]\".r\n      def escChr = bs ~ \"x\" ~ hex ~ hex\n      def chr = \"[a-z]\".r\n      def char = escBs | escQuot | escChr | chr\n      def escapedLine = quot ~> (char +) <~ quot\n\n      def part1 = input.map(_.length).sum - input.map(parse(escapedLine, _).get.size).sum\n\n      // Parse each element of an input string and just output the size (doesn't depend on the input)\n      def quotLen = quot ^^^ { 2 }\n      def bsLen = bs ^^^ { 2 }\n      def escQuotLen = escQuot ^^^ { 4 }\n      def escChrLen = escChr ^^^ { 5 }\n      def charLen = oneChr ^^^ { 1 }\n      def lineLen = quotLen | escChrLen | charLen | bsLen | escQuotLen\n      def escape(line: String) = parse(lineLen +, line).get.sum + 2\n\n      def part2 = input.map(escape).sum - input.map(_.length).sum\n\n      println(s\"part1 = $part1\")\n      println(s\"part1 = $part2\")\n    }\n", "id": "cxrc88r", "owner_tier": 0.7, "score": 0.07692307666666667}, {"content": "Shortest JavaScript version:\n\n\tvar str = document.body.innerText.trim();\n\n\tvar partOne = 0;\n\tvar partTwo = 0;\n\n\tstr.split('\\n').forEach(function(s, i) {\n\t\tpartOne += s.length - eval(s).length;\n\t\tpartTwo += JSON.stringify(s).length - s.length;\n\t});\n\n\tconsole.log('Part One:', partOne);\n\tconsole.log('Part Two:', partTwo);\n\nPerhaps using eval and JSON.stringify is a little cheap though...\n\n[deleted]\n\nNice! I've been avoiding ES6 here so it still works in browser's consoles :) \n\nNice!\n\nI was thinking maybe it's possible to get the correct answer without looping. Does this work for anyone else or is it just me :\n\n    var a = document.body.textContent.trim().split('\\n');\n    var b = a.join('+');\n    var c = b.length - eval(b).length + (a.length-2) * 1.5 ;\n    console.log(c);\n\nIf it does, I guess a similar technique might be used to shorten it even more?\n:D\n\n\nthat works in firefox dev console (F12 in firefox)\n\nWow, I didn't know Firefox supported arrow functions! ", "id": "cxrdtpt", "owner_tier": 0.5, "score": 0.1538461535897436}], "link": "https://www.reddit.com/r/adventofcode/comments/3vw32y/day_8_solutions/", "question": {"content": "# NEW REQUEST FROM THE MODS\n\nWe are requesting that you hold off on posting your solution until there are a significant amount of people on the leaderboard with gold stars - say, 25 or so.\n\nWe know we can't control people posting solutions elsewhere and trying to exploit the leaderboard, but this way we can try to reduce the leaderboard gaming from the official subreddit.\n\nPlease and thank you, and much appreciated!\n\n***\n\n# --- Day 8: Matchsticks ---\n\nPost your solution as a comment. Structure your post like previous daily solution threads.", "id": "3vw32y", "title": "--- Day 8 Solutions ---", "traffic_rate": 38.3351334180432}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "\\[LANGUAGE: Python 3\\] 58/9. [Solution](https://github.com/jonathanpaulson/AdventOfCode/blob/master/2023/4.py). [Video](https://youtu.be/tXnPMSSQgCU).\n\nHad a wrong answer on part 1 because I didn't read the scoring system carefully enough. It's interesting that the part 2 answer was small enough that you could afford to simulate each card (rather than each type of card) - although that would've been more complicated to code up.\n\nVery impressed by how quickly you are able to grok the puzzle descriptions. I probably spent more time reading part 2 than you spent solving both puzzles (and even with me skipping the fluff).\n\nWow, you made the same part 1 scoring error as me and yet you got a better rank than I would have gotten had I *not* made that error? I knew you were in a league above me but still, that's crazy!\n\nAnd huh, you're right. the answer is small enough to simulate each card on its own! I hope nobody truly does that though...\n\n> I hope nobody truly does that though...\n\nI did \ud83e\udd26\u200d\u2642\ufe0f 18 seconds on my machine.\n\nI'm glad someone else did as well, I got the answer after 25 seconds. I fixed it quickly but boy was it funny. The second time I ran it, finished immediately.", "id": "kbx2cek", "owner_tier": 0.3, "score": 0.8076923075}, {"content": "[LANGUAGE: Python] 70 / 70 \n\n[Original solution](https://topaz.github.io/paste/#XQAAAQAlAgAAAAAAAAA2GkofDKPu58xc5+iCM8TfuDbYvG3mtJ9ifral3nz4Y5yYuFV53W6/9Ji7dQQOafS2+hWxZQjrWjTLFeTcMK7PhEJXzpmSLHRwVkySWTXp63xQJwFtUaQEMcC4/+yRcfDgoBawUKIR+uDREwXuziLD8Lv9zY4kKmKvXABMPOfkMPRioc/nNvl/sbzPXVG65Bz6wqtQxqvl0SMvQLttU42OYygf11ccqqCbmOKsr0nulztbfc7ptLf3dcpTttv9+4qOu2uSd7hAfIkYkcO3TBDrK8rjOGqsnu6JA/DKVpBwITPnrelYZN77vn86HoHTs+uU03b2Kmb4BRmwbve74N3WbkRyn8vHrg89XsrR3sRlSdKPLP/9UOjj)\n\n[Allez Cuisine!] golfed solution that fits in 80x5 chars\n\n    m = [len(set(l[:40].split()) & set(l[42:].split())) for l in open('input.txt')]\n    c = [1] * len(m)\n    for i, n in enumerate(m):\n        for j in range(n): c[i + j + 1] += c[i]\n    print(sum(2 ** (n - 1) for n in m if n > 0), sum(c))\n\nFirst time getting top 100 since starting 3 years ago with a few close calls :)\n\n>for line in lines:  \nx, y = map(str.split, line.split('|'))\n\nWell done on the speed!\n\n I was reviewing your solution and a potential bug (which clearly wasn't there) I found would be if the 'Card #:' was in the \"numbers you have\" section, causing an extra winning match.\n\nFor example:\n\n\\`Card **13**: 31 18 13 56 72 | 74 77 10 23 35 67 36 **13**\\`\n\nGood catch! My text editor had scrolled to the right (and cut off the first 16 columns), so I thought that the puzzle input didn't have the card number text that was present in the example input.  \n\nAnother helpful thing I noticed in the input is that the number of matches + card number never exceeds the total number of cards.\n\nActually, it's not an issue, even in your example, since str.split would result in tokens: \"Card\" and \"13:\" which doesn't match against \"13\".\n\nHaha, what luck then!\n\nI took the never exceeding for granted because of this line: \n\n[(Cards will never make you copy a card past the end of the table.)](https://adventofcode.com/2023/day/4#:~:text=(Cards%20will%20never%20make%20you%20copy%20a%20card%20past%20the%20end%20of%20the%20table.))\n\nBut I'm also slow and take time to read the full description, which I can't imagine you can do if you are getting in the top 100!", "id": "kbx2ox9", "owner_tier": 0.1, "score": 0.6346153844230769}, {"content": "\\[LANGUAGE: Vim keystrokes\\] [Allez Cuisine!]\n\nLoad your input, type the following, and your part\u00a01 answer will appear:\n\n    :%s/.*:\u27e8Enter\u27e9:%s/\\v<(\\d+)>\\ze.*\\|.*<\\1>/#/g\u27e8Enter\u27e9:%s/[^#]//g\u27e8Enter\u27e9\n    :%s/#/+1/|%s/#/*2/g\u27e8Enter\u27e9\n    GvggJ0C\u27e8Ctrl+R\u27e9=\u27e8Ctrl+R\u27e9-\u27e8Enter\u27e9\u27e8Esc\u27e9\n\nAfter removing card numbers, `/\\v<(\\d+)>\\ze.*\\|.*<\\1>/` matches any entire number which is followed by a `|` and then the same number again \u2014 so a winning number that is in the list of numbers we have. Replace it with a `#` to indicate a match. Do that for all winning numbers, then get rid of everything that isn't a `#` character.\n\nThe sample input will now look like this:\n\n    ####\n    ##\n    ##\n    #\n\n\\[plus 2 blank lines at the end\\]\n\nReplace the first `#` on each line with `+1` and any subsequent `#`s with `*2`. The sample input is now:\n\n    +1*2*2*2\n    +1*2\n    +1*2\n    +1\n\nAt which point, deploy the usual design pattern to evaluate the expression and get the answer.\n\nI'm not sure whether this counts as code golf (for \u2018Allez Cuisine!\u2019 purposes) or not? I mean, I haven't *intentionally* golfed the keystrokes; it just naturally comes out like that. \n\n**Update**: A part\u00a02 solution which loops in a fraction of a second rather than ... I dunno \u2014 hours? days? And it fits within the forum rules on code size:\n\n    :%s/.*:\u27e8Enter\u27e9:%s/\\v<(\\d+)>\\ze.*\\|.*<\\1>/#/g\u27e8Enter\u27e9:%s/[^#]//g\u27e8Enter\u27e9\n    :%s/#\\+/\\=len(submatch(0))\u27e8Enter\u27e9:%s/^/+1 \u27e8Enter\u27e9\n    {qaqqa/ \\d\u27e8Enter\u27e9lDbyiwV@-joj@0\u27e8Ctrl+A\u27e9@aq@a\n    GV{J0C\u27e8Ctrl+R\u27e9=\u27e8Ctrl+R\u27e9-\u27e8Enter\u27e9\u27e8Esc\u27e9\n\nThe first line is the same set-up as in part\u00a01: creating a histogram of matching numbers out of `#`s. Replace each string of `#`s with their length and prepend `+1` to each line, to represent initially having one of each card.\n\nConsider a line like:\n\n    +17 4\n\nThis represents 17 instances of a card with 4 matching numbers, so the cards on the next 4 lines each need their counts increasing by 17. This is what the main loop does. It finds the next match count (a number that follows a space) and deletes it with `D`, which both stops it getting in the way of future calculations and handily saves it to the `\"-` small-delete register.\n\nThen it goes back and yanks the number of cards. Yanks by default get stored in the `\"0` register, which crucially is different from `\"-`.\n\nTo increase the appropriate counts it does something like `V4joj17\u27e8Ctrl+A\u27e9`: start by visually highlighting the current line, then extend down 4 lines (or fewer if near the bottom). However, that will have highlighted *5* lines, because it includes the line we started visual mode on as well as the 4 we added. To adjust for this [fence-post error](https://en.wikipedia.org/wiki/Off-by-one_error#Fencepost_error), `o` switches control to the start of the area and `j` takes the it down a line. Then `17\u27e8Ctrl+A\u27e9` adds 17 to the first number on each highlighted line, the card count that's just after the `+`.\n\nExcept of course the `4` and `17` can't be hard-coded. Just like `@a` runs the keyboard macro of keystrokes saved in the `\"a` register, `@-` runs the keystrokes stored in `\"-`. If `\"-` contains `4` then `@-j` is like doing `4j`. Yes, this means the keyboard macro \u2018runs out\u2019 partway through a command, but try not to let that bother you; the important thing is that it works! And similarly, `@0\u27e8Ctrl+A\u27e9` prefixes the `\u27e8Ctrl+A\u27e9` operator with the number stored in `\"0`.\n\nBy the time the loop ends, all the numbers of matches will have been removed, leaving just the card counts, each preceded by a `+`. Join them together and evaluate the sum to get the answer.\n\nThis is a massive improvement on my [original solution for part\u00a02](https://topaz.github.io/paste/#XQAAAQCQAQAAAAAAAAAdCUrjWNZ9/abcThvzfkP19gZqForEVZjvEhO2UlYWMVlRFzaf7gZ3A9HYMu5bWbm7kDHxUfkMfYwMcU6A5WVoxDrb0VyxQz/HMfuBAuGs710WB+H3z1rSfGBotXHACtLthrSYuQqdCPef2Qy+DZY0400IjY8R0e3so3QVRlph+FY7RYoPvqhEEX62zdnJ+vS6Fo7JsZZokh5GVWwdXEOaJVMFVrf9DG6Gc89A//9WgDwA), which represented each instance of a card visually with `#`. This worked fine on the sample input, but on my real input ... well, since I set it off, I've eaten breakfast, showered, tidied away [last night's board game](https://boardgamegeek.com/boardgame/269207/taverns-tiefenthal), walked a child to their bus stop, implemented the faster version above, and written up this explanation of it, and it's still going. I don't *think* it's going to reach [Matt Parker-like levels](https://www.youtube.com/watch?v=c33AZBnRHks) of percentage speed-up between it and the fastest solution, but we can't be sure yet. (I'll move its original explanation to a reply for posterity.)\n\n**Update\u00a02**: I `\u27e8Ctrl+C\u27e9`ed it after 6\u00bd\u00a0hours (because we needed the fan to stop being so noisy). Vim's status line said `50%`. It was processing line 99 of 196, and the first 96\u202f593 copies of the card on that line had been processed (the `#`s already turned into `.`), with 238\u202f662 cards still to go. Line 100 already has 330\u202f651 `#`s on it. So optimistically it was about halfway through. Realistically, the lines have been getting longer so it probably had much more than half to go, and it might not have finished before the boat leaves tomorrow.\n\nMy input file is 218 lines and my answer is 7 digits long, with the highest number of copies weighing in at more than 846,000.  I'd love to hear what your vim tells you tomorrow morning (especially if it's not `core dumped` :-)\n\nThanks for sharing these; I like to tell coworkers about vim keystrokes solutions when repping AoC.\n\nThe final answer for my input is about 10 million, so I'd expect that it just takes a while.\n\nThere's almost certainly to do it that doesn't involve using a character count, but I'm not good enough at using Vim to be able to come up with anything other than making like 100 #s in a row become a different character that gets processed separately.", "id": "kbx9rnq", "owner_tier": 0.3, "score": 0.42307692288461535}, {"content": "[LANGUAGE: Dyalog APL]\n\n    p\u2190\u2283\u2395nget'04.txt'1\n    c\u2190{\u2262\u2283\u2229/\u234e\u00a81\u2193\u2375\u2286\u2368~\u2375\u220a':|'}\u00a8p\n    +/\u230a2*c-1 \u235d part 1\n    m\u21901=d\u2218.\u2378\u23681+d,\u00a8c+d\u2190\u2373\u2262c\n    +/,\u2339m-\u2368\u2218.=\u2368d \u235d part 2\n\n[Video walkthrough](https://www.youtube.com/watch?v=mxBo-G6M8eQ)\n\nApparently the infinite series sum of matrix exponentiations [converges to (\ud835\udc3c\u2212\ud835\udc34)^\u22121](https://math.stackexchange.com/questions/867768/geometric-series-of-matrices), thanks to rak1507 on the APL discord for pointing that out!\n\n/r/adventofcode moderators: \"No oversized code, please.\"\n\n/u/voidhawk42 writing Alien Programming Language: \"Hold my eggnog and watch this...\"\n\nHow long did it take you to become proficient in that language? That's some _dark art_ right there.\n\nIs this actually a language or did you make this up?\n\n[removed]\n\nThe trick is finding a card punch that will handle unicode symbols.\n\nCouple years in a remote mountain monastery, nbd\n\nApparently it worked just fine on the [IBM 1130](https://aplwiki.com/wiki/APL%5C1130)!", "id": "kbx6jey", "owner_tier": 0.1, "score": 0.9999999998076923}, {"content": "\\[LANGUAGE: python3\\]\n\n89/437\n\nFirst time getting leaderboard in my life!\n\n    f = open(\"input.txt\").readlines()\n    \n    s = 0\n    cards = [1 for _ in f]\n    \n    for index, line in enumerate(f):\n        line = line.split(\":\")[1]\n        a, b = line.split(\"|\")\n        a, b = a.split(), b.split()\n    \n        n = len(set(a) & set(b))\n    \n        if n > 0:\n            s += 2 ** (n - 1)\n    \n        for i in range(n):\n            cards[index + i + 1] += cards[index]\n    \n    print(s, sum(cards))\n\nAround 0.9ms to run :)\n\n> First time getting leaderboard in my life!\n\nGood job!", "id": "kbx6htf", "owner_tier": 0.1, "score": 0.40384615365384613}, {"content": "[LANGUAGE: Python] [Code (9 lines)](https://topaz.github.io/paste/#XQAAAQAXAQAAAAAAAAAyGEruliPhODr/frYqPjojYEeXt7yUg8aNchva8dxIoouH0VOBev9LNfRCH+gX/XFKQ/FclodPBLz2EZcZrt0fE46SPy0DEMO9XvtstH3xkuZ91+U1ml/nRtEfH+dqXTpJZQ5uFDB1ZqYgpr43YBBwqRb4B+XM/B8Fon31dfZnFH1DQNKM7MGnFqL/BcgdYk468dOwn3yzpQwJm2MrhdCEmyMgzNqyOW1vJs/bshSdrizgYLjg8NsXzFbfK7B/+nvwBf555+8=)\n\nNothing clever today, but I like this part:\n\n    win, have = map(str.split, line.split('|'))\n\n    for j in range(len(set(win) & set(have))):\n        p1[i] *= 2\n        p2[i+j+1] += p2[i]\n\nwouldn't this fail on some inputs because you don't strip the \"Card %f: \" part?\n\nNope, we do get additional winning \"numbers\" `Card` and e.g. `1:` (note the colon), but those will never match the numbers we have.", "id": "kbxb2fc", "owner_tier": 0.3, "score": 0.28846153826923077}, {"content": "[Language: Rockstar]\n\nListen to my [words](https://topaz.github.io/paste/#XQAAAQAHBgAAAAAAAAAmnkAG07by9u1AZ+DYUoAIbLHQDbn8LGmwUqfKbPMBzrMN4VovQvK33rtK5dN3vaLvRWZxXwuso85Q0FtBRvb9upvnFT3mdogVYqFpAhzr5OF6kTi1gQ6X3c2l7ffzWIuFpQ1GkfyG10Mw0sKtDU8byp9BeaXh8D42ur+LghjtpG5VQDEtOIIl2x1YKssE1YhaoHsePR+7Dk7HHhZ/TB7nWhMCFyaHrgljydmxKqqd92jG0ZtD6QnQKek9kg6o4HN/E3uq1fhApny5G3RW4bf4uKvP5zrEHfEMlHz7KkpNlz0lv0zro1AvZ7kdZMkSK4y7kkf7v9dUUp7nMglny3l1DtCv7w68nNKfUPpe7CYt6e0L91dsXC6pBmlBwFHPwPg2e/PDG+VhLRP4l7oSYC6bfN8xWXaKwQvc+thHhVIJiSjZYs4/xkPrMKRhBXVpD/oYiWGl9LZD8R6cIhzPIEwpiPDO6OJSwgblbC/+oZdC3HKNJaRnofnHHEA+T5+2xrAAnYCQRJ4TR5XF3gNocalnf9tObnI0yCHaZmz71Ovk3pOW4UjWsfm0BTW+B52yza2S/QWqxpXRMkol6vSiebwyS54ysz9l18EMCDG2NT9d38GSWwuxPluotWSdqxcL8zSCY1RfmsioZm2BTI15OsgMjZE+rKzljJxY9OwEwqjtfF+zmzVNGOkdKKZLv0E//YThYg==) for they carry knowledge of thine winnings...\n\nListen to [part 2](https://topaz.github.io/paste/#XQAAAQCiBwAAAAAAAAAmnkAG07by9u1AZ+DYUoAIbLHQDbn8LGmwUqfKbPMBzrMN4VovQvK33rtK5dN3vaLvRWZxXwuso85Q0FtBRvb9upvnFT3mdogVYqFpAhzr5OF6kTi1gQ6X3c2l7ffzWIuFpQ1GkfyG10Mw0sKtDU8byp9BeaXh8D42ur+LghjtpG5VQDEtOIIl2x1YKssE1YhaoHsePR+7Dk7HH1eoPeLI1Uz/nFyLaz1KFdd3bzCgS5sFPfGeI7o0umN1k+5LV13xDy901DyJhv463T/1mh0hoGzZFFKoARRcn3cBhoFv2D53V+HtDuMyY9qspzXeUReCto7yx512tMfxpG/x5se7mZu/nD5s52a0dVA8juRhjsOPbFyvR1bLoo0xCE8Ax8pdeTVpxHakOxLDXPykoNYDRarDHZfJ25NzyccUbD3DmatJ6UzjvC+lQ1D7ZOnqqo7kzwhNrTCgRckkBP7LdS/yjjByblr6FikDegTmX+xNLkga5grx+Q3NrgoMelFUJBgPp7HkjIRa1LATMtcY+JdCcwH7jTnaGczKQPNi57etzCW9lXKBMNHGOeYhZRdzByv7sJw+2u82rCsHTtMhd37HCuXkotiznxnte0m1NwJeTqRGm/MAMk+X1NHhbyG6AZvORV3U2+eMSd6pCmFSHgtHURRCb8d9m8kufkGHVnF1mtWMfJ+CTUubtyLF989wbkCTBiiV6CzDToGmSP7qCeimZzU/GatvFGkJg41WmtGRO9O0wt7/fc8o6+Kj9phGU3Aia6uTUHPgUWwBf4itVwmsr0MpQOB2pyduovtU1AtxyFUN7tNwxHXOzhSF1DZTwLGsPVNcaUynAi4gNZvPk3pIPwXjkp0hV0GBaETVAna8ALJGOP/2zYdX) instead, would thou wish knowledge of thine truest winnings...", "id": "kbx81lp", "owner_tier": 0.9, "score": 0.1153846151923077}, {"content": "\\[LANGUAGE: Google Sheets\\]\n\n*Assuming the input is in A:A*\n\nOne formula for both parts\n\n    =MAP({3,2},LAMBDA(i,\n      SUM(INDEX(\n        LET(crds,SEQUENCE(ROWS(A:A)),\n            REDUCE({crds,crds^0,crds^0-1},\n                   crds,\n                   LAMBDA(a,i,LET(s,SPLIT(TOCOL(SPLIT(REGEXEXTRACT(SUBSTITUTE(INDEX(A:A,i),\" \",\"x\"),\":x(.*)\"),\"|\")),\"x\"),\n                       m,SUM(COUNTIF(INDEX(s,2),INDEX(s,1))),\n                       IF(m=0,a,a+IF(COUNTIF(SEQUENCE(m)+i,INDEX(a,,1)),{0,INDEX(a,i,2),2^(m-1)/m})))))),,i))))\n\nI'm going to try this just for fun because I think it's impressive", "id": "kbx8tzd", "owner_tier": 0.3, "score": 0.15384615365384616}, {"content": "\\[LANGUAGE: x86\\_64 assembly with Linux syscalls\\]\n\nAlas, even 8086 assembly would be far too late for actual punchcards,  and I would also need at least an 80386 to get 32 bit integers, a soft requirement given the size of numbers eventually encountered in the problem.\n\n[Part 1](https://github.com/JustinHuPrime/AoC/blob/main/2023/4a.s) was parsing; this was a bit fiddly, I needed to be careful about whether I interpreted the numbers as having leading whitespace (the correct way) or trailing whitespace (incorrect, since I'd be skipping the newline at the end). The actual computation was relatively nice, involving a nonconstant shift left to do the exponentiation of the base 2 required.\n\n[Part 2](https://github.com/JustinHuPrime/AoC/blob/main/2023/4b.s) was more of a fibonacci-type problem. Re-using the parser from part 1, I had to keep two lists - one list mapping the card number to the number of wins for one card, and another counting the number of cards. The one counting the number of cards had to be zero-terminated, a fact which I forgot, since I wanted to operate on variable length data (either the example or the actual input, since my personal rules require me to write code that accepts either the example or the actual input depending on what filename is passed in as a command line argument).\n\nThe actual computation was relatively straightforward, but the debugging was not. I ended up learning about GDB's foibles - it considers global labels to be actual variables and not the pointers that they so obviously are. (Well, I suppose if you're one of the folks who uses a compiler, global labels are actually variables, but this is at odds with how they're treated in assembly.)\n\nPart 1 and part 2 run in 1 ms; part 1 is 8232 bytes long, and part 2 is 8480 bytes long. I think the shrinking size is because I moved a global from the .data section to the already-existing .bss section. Since I no longer used the .data section, this could be omitted from the generated executable, saving quite a bit of space, apparently.", "id": "kbxd3du", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "\\[Language: Python\\] one-line/single-expression solutions\n\nHad fun with this one! A short solution for part 1, using as an heuristic, that numbers on each side are distinct, and a functional-style one for part 2:  \n\n    from functools import reduce\n    from itertools import chain, repeat\n    from operator import add\n\n    #print(sum((1<<len(s)-len({*s}))//2 for s in map(str.split,open(0))))\n\n    print(reduce((lambda r,x:(c:=next(r[1])) and (r[0]+c,chain(map(add,repeat(c,x),r[1]),r[1]))), (len(s)-len({*s}) for s in map(str.split,open(0))), (0,repeat(1)))[0])\n\nhttps://github.com/kaathewise/aoc2023/blob/main/4.py", "id": "kbxrpuj", "owner_tier": 0.1, "score": 0.0576923075}, {"content": "[LANGUAGE: Haskell]\n\nReally proud of my solution today, short and efficient, with no explicit recursion c:\n\n    module Main where\n    \n    import Control.Arrow (second, (&&&))\n    import Data.List (intersect)\n    import Data.Tuple.Extra (both)\n    \n    main :: IO ()\n    main = interact $ (++ \"\\n\") . show . (part1 &&& part2) . map parse . lines\n    \n    part1 :: [([Int], [Int])] -> Int\n    part1 = sum . map ((\\n -> if n >= 1 then 2 ^ (n - 1) else 0) . countMatches)\n    \n    part2 :: [([Int], [Int])] -> Int\n    part2 = sum . foldr (\\c l -> 1 + sum (take (countMatches c) l) : l) []\n    \n    countMatches :: ([Int], [Int]) -> Int\n    countMatches = length . uncurry intersect\n    \n    parse :: String -> ([Int], [Int])\n    parse = both (map read) . second tail . span (/= \"|\") . drop 2 . words\n\n[removed]", "id": "kbylhkw", "owner_tier": 0.1, "score": 0.1153846151923077}, {"content": "\\[LANGUAGE: C/C++\\]\n\n[Part 2 in 23 lines of code](https://imgur.com/a/uitewZA)\n\n(Solved on stream in twitch channel `clbi`)\n\nRuns in about two minutes on my Commodore 64. (runtime is dominated by disk accesses)\n\nEDIT: Also benchmarked the same code on AMD Ryzen 5950X, which took about 0.00075 seconds. (making it about 160,000x times faster than the C64)\n\n[Daily journal](http://clb.confined.space/aoc2023/)", "id": "kbylkw4", "owner_tier": 0.1, "score": 0.07692307673076923}, {"content": "[LANGUAGE: Python3]\n\n10th place, 22nd place\n\n    ll = [x for x in open(\"input\").read().strip().split('\\n')]\n    p1 = 0\n    multiplier = [1 for i in ll]\n    p2 = 0\n    for i,l in enumerate(ll):\n    \twinning = set([int(x) for x in l.split(\":\")[1].split(\"|\")[0].strip().split()])\n    \thave = [int(x) for x in l.split(\"|\")[1].strip().split()]\n    \thave = [x for x in have if x in winning]\n    \tif len(have):\n    \t\tp1 += 2**(len(have)-1)\n    \tmymult = multiplier[i]\n    \tfor j in range(i+1,min(i+len(have)+1,len(ll))):\n    \t\tmultiplier[j]+=mymult\n    \tp2 += mymult\n    print(p1, p2)\n\nScreen recording: https://youtu.be/IsOIBSoY85k", "id": "kbx205p", "owner_tier": 0.3, "score": 0.01923076903846154}, {"content": "\\[LANGUAGE: Python 3\\]\n\n[Part 2](https://topaz.github.io/paste/#XQAAAQB4BAAAAAAAAAARiEJHiiMzw3cPM/1Vl+2nx/DqKkM2yi+AsNSFTsnyEq6tvQ194NdE8s9q6Leu5NmZVE5/n7GL1GFISjxyXY2GpDwJ0iaL/CLTJZCVRPPBEn7RPpzqCVVteloODLtLhqzANIlee3Fa91uFAds36UOFmUU+lImtLBkWYfuB8E2vWJPjYA3TcTsuFfR6dnebT+R/CiNwQe4GtQ+QkRKwZNxHqO5wkSk03Chuvkhj15TuoMlEqmUvZBXNVPLWKVCMXah2+pj2HwvbLKGrLUGSOmZkmb2wuW5smYGlJ/efSUMnIWIc2v/y7BnFUqDJg2EG/VA5ltsj+W17sgKxcOApcrrHsn6PjKm0wl2BPsScOTNLiodFqkjYdGvF1y8vzc3FQMdRSkcjO8aKUkAA7PjYQFLZLDvTDT1109HZDIfPusxMv+Jd1FHWn8RBo+F6g5c3s9hlqKC0VI6RSLpqUGOIdEmxFT7SRN6k7Nuj1LwI1rsi70cfrUq7SILT1w0RXsEOU5JfC9ihphmV/1HeFM+w3MjFfxjs3hzH/on1u1Y6snCMf7MGTrwWrMTU+CALmvkRGjmofAGqFVXbba8DAdkVOfdwYPqzWh0yqF2AnKBwoCKnALpISydqafFcGSGBEgQSi1stP0foTnRCS+1qAxhUkmJaQJaAvwMbUv5gh+8=)\n\nFortunately no recursion needed. Just add whatever count the current card number has to the x cards that follow.\n\nIf this were later in the month we'd be making copies of *specific* cards, such as \"multiply the Card Id \\* winning number, you get another of *that* card\". But how would it ever end?\n\nMy real job isn't Python which is why I'm lacking in the list comprehensions the cool kids use.", "id": "kbx6cn6", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "[LANGUAGE: Forth] [Allez Cuisine!]\n\nFor *Allez Cuisine!*, I minimized my part 1 to less-than-punchcard size. It even executes your input file directly as code and automatically detects the scratchcard's size! Simply download your `input` file to the same directory and call `gforth part1.fth` (or use some other Forth that supports `include`). Code below:\n\n    0 : C create 0 , ; C W C M : D depth 1- ; : R here W @ over + swap ; : | W @ 0=\n    if D W ! then R do i c! loop ; : T 0 M @ 0= if D 1- M ! then M @ 0 ?do swap pad\n    ! 0 R do i c@ pad @ = + loop - loop 1 swap lshift 2/ + ; : Card T C ;\n    include input T . bye\n\n[https://github.com/tcsullivan/advent-of-code/tree/master/day4](https://github.com/tcsullivan/advent-of-code/tree/master/day4)", "id": "kbzo1dj", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "[Language: Perl] 2958 / 3056\n\nPart 1 was super straightforward. A had to read Part 2 over a couple of times to make sure I had it straight, and then I worried that the numbers might get huge, but thankfully they don't.  (A really big winning streak would be nasty!)\n\n[paste](https://topaz.github.io/paste/#XQAAAQDRAgAAAAAAAAA6nMjJFMpQu0F8vIUYL9H7bktreB2yFuCaEtxuf6Wx5iNAuLM1BuaPqLfKCPLaBP9V88XIqYfHWVeib7mZp5H8p/3aPHjl9ODn3d2kvacsUP3ZDk5fEbMzs3CIy7GeytyU+TmxASt500I5HnlZR09ogxvgLlAsGsbVnOwhMYldPe7DFC6yAsXAhV21+dixErujF7/NB06NnEUlZQyDI74AAwQfjXqXdusxd1WwwizWtqtfSfY+oHVFchSW6dRT3E/Q+jshCBL7ce4EBpCQEi0JoedtSCqXh/5T4fH8ZX76K9f3qtT6HL3t+9cllcQkP+SP3ODovY+M8HGL8y1PiU5r+VpH0zYqk3ld1swRexgwHfNZ8gH8mom5MvIbvlSdDGCl/vkju1MRF5vvk9b6X4QAliX4ewzSM15lpeEkdQuP6i/eiWMdwBFX/fiLmvo=)", "id": "kbx4z7c", "owner_tier": 0.1, "score": 0.01923076903846154}, {"content": "\\[LANGUAGE: Perl\\]\n\nPart 2\n\n(a) No need to split the winners and picks, just find the ones that appear more than once. Perl has a cute FAQ idiom using a hash to find duplicates.\n\n(b) Recursion will kill us if we try to calculate the matches every time.  Do it one pass while reading the input.\n\n(c) There's no need to carry the lists around; it's all a function of match counts and id numbers. Sequential id numbers make great array indexes.\n\n        use v5.38;\n    \n    use List::Util qw/sum/;\n    \n    use Getopt::Long;\n    my $Verbose = 0;\n    GetOptions(\"verbose\" => \\$Verbose);\n    \n    # Find numbers that occur more than once\n    sub countMatch($n)\n    {\n        my %seen;\n        $seen{$_}++ for $n->@*;\n        return scalar grep { $seen{$_} > 1 } keys %seen;\n    }\n    \n    # Make one pass to save number of matches on each card\n    my @Match;\n    while (<>)\n    {\n        my @n = m/(\\d+)/g; # Extract all the numbers\n        my $id = shift @n; # Remove the id number\n    \n        $Match[$id] = countMatch(\\@n);\n    }\n    \n    my @Count = (0) x @Match;   # Array same size as Match\n    sub countCard($id, $indent) # Recursive\n    {\n        $Count[$id]++;\n        say \"${indent}[$id] -> $Match[$id], $Count[$id]\" if $Verbose;\n        return if $Match[$id] == 0;\n    \n        for my $next ( $id+1 .. $id + $Match[$id] )\n        {\n            countCard($next, \"  $indent\") if exists $Match[$next];\n        }\n    }\n    \n    countCard($_, \"\") for 1 .. $#Match;\n    say sum @Count;", "id": "kbyg9a1", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "\\[LANGUAGE: uiua\\]\n\n    # Parse and count\n    \u229c(\u21981\u229c\u25a1\u00ac\u220a,\":|\")\u2260@\\n.\n    \u2261(/+\u228f\u234f.\u2260\u2299\u29fb \u2297\u2299.\u2229(\u2290\u229cparse\u2260@ .) \u2283\u22a2(\u22a11))\n    .\n    # Part 1\n    /+\u230a\u207f:2-1\n    :\n    # Part 2\n    \u22990\n    :\u21af:1\u29fb.\n    ;\u2227(\u2299+:\u2299\u2b1a0+:\u21af\u2299(.\u2283\u22a2(\u21981)))", "id": "kbzu7fl", "owner_tier": 0.3, "score": 0.03846153826923077}, {"content": "[Language: Python]\n[Allez Cuisine]\n\nHow do I save more characters?\n\n    c=[len({*l[10:39].split()}&{*l[42:].split()})for l in open(\"f\")]\n    q=[1]*len(c)\n    for i,x in enumerate(c):\n     for j in range(x):q[i+j+1]+=q[i]\n    print(sum(2**x//2 for x in c),sum(q))", "id": "kc0g8ea", "owner_tier": 0.1, "score": 0.01923076903846154}, {"content": "[LANGUAGE: Common Lisp]\n\nPart 2 took my way too long because I forgot that I had to count the base tickets too, and not just the extra ones.\n\n    (defun make-ticket (line)\n      (flet ((parse (lst) (mapcar #'parse-integer  (remove-if #'str:emptyp lst))))\n        (destructuring-bind (card winning-nums ticket-nums)\n            (ppcre:split \"[|:]\" line)\n          (declare (ignorable card))\n          (list\n           (parse (ppcre:split \"\\\\s+\" winning-nums))\n           (parse (ppcre:split \"\\\\s+\" ticket-nums))))))\n    \n    (defun fold-to-score (ticket)\n      (let ((winning-nums (car ticket))\n            (ticket-nums  (cadr ticket))\n            (score        0))\n        (dolist (num ticket-nums score)\n          (when (member num winning-nums) (incf score)))))\n    \n    (defun count-tickets (tickets &key (total 0) count)\n      (if (null tickets)\n          total\n    \n          (flet ((update-count (n multi cur-count)\n                   (loop :for k :from 0 :below (max n (length cur-count))\n                         :collect\n                         (let ((cur (nth k cur-count)))\n                           (cond\n                             ((and cur (< k n)) (+ multi cur))\n                             (cur cur)\n                             ((< k n) multi))))))\n    \n            (let ((wins  (fold-to-score (car tickets)))\n                  (multi (1+ (or (car count) 0))))\n              (count-tickets\n               (cdr tickets)\n               :total (+ total multi)\n               :count (update-count wins multi (cdr count)))))))\n    \n    (defun solve-1 ()\n      (reduce\n       #'+\n       (mapcar\n        (compose\n         (lambda (score) (if (> score 0) (expt 2 (1- score)) 0))\n         #'fold-to-score\n         #'make-ticket)\n        (uiop:read-file-lines \"./input/04.txt\"))))\n    \n    (defun solve-2 ()\n      (count-tickets (mapcar #'make-ticket (uiop:read-file-lines \"./input/04.txt\"))))", "id": "kc0pg1j", "owner_tier": 0.7, "score": -1.9230769113894788e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/18actmy/2023_day_4_solutions/", "question": {"content": "## NEWS\n\n* Solutions in the megathreads have been getting longer, so we're going to start enforcing [our rules on oversized code](https://reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines#wiki_no_giant_blocks_of_code).\n    * Do not give us a reason to unleash AutoModerator hard-line enforcement that counts characters inside code blocks to verify compliance\u2026 you have been warned XD\n* Before creating a `Visualization`, please review [the guidelines for creating `Visualization`s](https://reddit.com/r/adventofcode/wiki/visualizations) as there's good advice relating to accessibility, readability, colors, timing, etc.\n* Posts containing AI-generated art *must*:\n    * Use the [standardized post title syntax](https://www.reddit.com/r/adventofcode/wiki/posts/standardized_titles)\n    * [Indicate in their titles](https://reddit.com/r/adventofcode/wiki/posts/post_flair#wiki_funny) with the tag `[AI art]`\n    * [Use the `Funny` post flair](https://reddit.com/r/adventofcode/wiki/posts/post_flair#wiki_funny)\n\n## THE USUAL REMINDERS\n\n* All of our rules, FAQs, resources, etc. are in our [community wiki](https://reddit.com/r/adventofcode/wiki/).\n* Outstanding moderator challenges:\n    * [Advent of Playing With Your 3D-Printed Toys](https://www.reddit.com/r/adventofcode/comments/188kp2w/2023_day_125_my_3d_printed_advent_of_code_calendar/kblu78n/)\n* Community fun event 2023: [ALLEZ CUISINE!](https://reddit.com/r/adventofcode/comments/1883kn1/advent_of_code_2023_allez_cuisine_submissions/)\n   * ***2 DAYS*** remaining until unlock!\n\n***\n\n## AoC Community Fun 2023: ALLEZ CUISINE!\n\nToday's theme ingredient is\u2026 \\**whips off cloth covering and gestures grandly*\\*\n\n## PUNCHCARD PERFECTION!\n\nPerhaps I should have thought yesterday's Battle Spam surfeit through a little more since we are all overstuffed and not feeling well.  Help us cleanse our palates with leaner and lighter courses today!\n\n* [Code golf](https://en.wikipedia.org/wiki/Code_golf).  Alternatively, [snow golf](https://en.wikipedia.org/wiki/Snow_golf).\n* Bonus points if your solution fits on a \"punchcard\" as defined in our wiki article on [oversized code](https://reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines#wiki_no_giant_blocks_of_code).  We *will* be counting.\n* Does anyone still program with actual punchcards?  >_>\n\n***ALLEZ CUISINE!***\n\n*Request from the mods: When you include a ~~dish~~ entry alongside your solution, please label it with `[Allez Cuisine!]` so we can find it easily!*\n\n***\n\n# --- Day 4: Scratchcards ---\n\n***\n\n## Post your code solution in this megathread.\n\n* Read the [full posting rules](https://reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines) in our community wiki before you post!\n    * State which [language(s) your solution uses](https://www.reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines#wiki_state_your_programming_language.28s.29) with `[LANGUAGE: xyz]`\n    * Format code blocks using the [four-spaces Markdown syntax](https://www.reddit.com/r/adventofcode/wiki/faqs/code_formatting/code_blocks)!\n* Quick link to [Topaz's `paste`](https://topaz.github.io/paste/) if you need it for longer code blocks\n\n\n###~~This thread will be unlocked when there are a significant number of people on the global leaderboard with gold stars for today's puzzle.~~\n\n###*EDIT:* Global leaderboard gold cap reached at 00:07:08, megathread unlocked!", "id": "18actmy", "title": "-\u2744\ufe0f- 2023 Day 4 Solutions -\u2744\ufe0f-", "traffic_rate": 38.3351334180432}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "Is golfing welcome here?  I'll delete if not.\n\nPerl:\n\n    perl -ane 'printf\"$x %+d\\n\",$.if$_=$h{$x=$F[0]}and$.=$F[1]-$_;$h{$x}=$F[1]'\n\n\nEDIT: I'll explain in case anyone's curious:\n\n     1     perl -ane           # -e means \"Here's the script on the command line\"\n     2                         # -n means \"and run this script on each line of input\"\n     3                         # -a means \"but first split each line on whitespace\n     4                         #           into an array named @F.\"\n     5 \n     6     printf \"$x %+d\\n\",  # Do a formatted print of the item name\n     7                         # we'll save in $x on line 22.\n     8                         # \"%+d\" means put a plus in front of the number\n     9                         # if it's positive.\n    10            $.           # The second argument to printf (the price change),\n    11                         # which we store in variable \"$.\" on line 28.  We use\n    12                         # $. instead of a normal variable like $d because\n    13                         # that allows us to say \"printf ...,$.if ...\", while\n    14                         # if we used a letter \"printf ...,$dif ...\" wouldn't\n    15                         # parse.\n    16 \n    17     if                  # We only print that if ...\n    18     $_ =                # (just a sec: we tuck away $h{$F[0]} in $_ to save characters...)\n    19 \n    20     $h{                 # OK, we only print that if there's something in the %h hash table\n    21                         # with our item name.\n    22         $x =            # We tuck away $F[0] (the item name) in $x to save characters\n    23         $F[0]           # This is the item name, which we're using as our hash key.\n    24     } \n    25     and                 # We use \"and\" instead of \"&&\" because it's lower precedence,\n    26                         # which allows us to do an assignment next without any parens.\n    27 \n    28     $. =                # Save the price difference for use on line 10.\n    29     $F[1]               # The new price (we didn't get this far on the old price because\n    30                         # of the if on line 17). \n    31 \n    32     - $_;               # Minus the old price, which we saved on line 18. Only print if non-zero.\n    33 \n    34     $h{$x} = $F[1]      # Now we just put the price into the hash, using the $x alias\n    35                         # for $F[0] we stored on line 22.  This is only relevant for the\n    36                         # run through the old prices.\n\n\nI think the easy problems are an excellent chance to code golf.  \n\nWhat's the minimized metric on golfing? Characters, lines, readability...? :)\n\nYou're a wizard Harry! But no, seriously, nice job. \n\nJust don't try to figure them out if you're an \"easy\" level programmer yourself :D\n\nWell, do actually.. but prepare to be saying \"WTF\" \n\nLines then characters. Readability is a moot point imo.\n\nCharacters for sure.\n\nI'm just a duffer compared to the Perl golfers of the 90s.  I've added an explanation if you're curious how it works.\n\nThanks :D", "id": "cdzmla0", "owner_tier": 0.5, "score": 0.9999999998}, {"content": "Haskell:\n\n    import Control.Monad\n    import qualified Data.Map as M\n    import Text.Printf\n    \n    main = do\n        n <- readLn\n        let toRow l = let [w1, w2] = words l in (w1, read w2)\n            readMap = fmap (M.fromList . map toRow) (replicateM n getLine)\n        xs <- readMap\n        ys <- readMap\n        let zs = M.toList (M.filter (/= 0) (M.unionWith (-) ys xs))\n        forM_ zs $ \\(key, val) -> do\n            printf \"%s %+d\\n\" (key :: String) (val :: Int)\n\n\nI've wishlisted 'Learning you a haskell for great good' for christmas. Good god I hope I get it!\n\nI've just starting reading this book just yesterday.  It's a fun change of pace from the usual curly-brace languages we're familiar with.  Back in college I had to learn Scheme and Common Lisp.  This functional language is syntactically much different than the above Lisp dialects, and seems to be much more expressive and suitable for \"real world\" programming (but I admit to being very naive still - just 1 day of experience).  I also want to have a look at Scala and Erlang some day (after I'm able to do exercises like these in Haskell).\n\nThe book is so good that it put most of the novels I read to a shame.", "id": "cdzpelq", "owner_tier": 0.7, "score": 0.3399999998}, {"content": "Python 2.7\n\n    with open('file.txt') as f:\n        n = int(f.readline())\n        data = [line.strip('\\n').split() for line in f.readlines()]\n        oldist, newlist = data[: n], data[n:]\n\n    for k1, v1 in oldist:\n        for k2, v2 in newlist:\n            if k1 == k2 and v1 != v2:\n                print \"{} {:+}\".format(k1, int(v2) - int(v1))\n\n\nI like this - my mind was locked into using a dict, but using lists like this works fine and most importantly - is very readable", "id": "ce00w1e", "owner_tier": 0.5, "score": 0.17999999979999998}, {"content": "After spending an hour and a half determined to get this done in Brainfuck, I gave up and gave it a go in bash.\n\nThere's gotta be a better way, though... anyone with better command-line-fu want to give it a go? (Also, how does `sed \"N;s/\\n/ /\"` work?)\n\n    let n=$(head -n 1 $1)\n    sed -n \"2,$ p\" $1 |\n    sed \"1,$n s/ / a /\" |\n    sed \"$(($n+1)),$ s/ / b /\" |\n    sort |\n    awk '{print $1,$3;}' |\n    uniq -u |\n    sed \"N;s/\\n/ /\" |\n    awk '{print $1, $4 - $2;}' |\n    sed \"s/ \\([0-9]\\)/ +\\1/\"\n\nUsage: ./nutsnbolts.sh [INPUTFILE]\n\nNot sure how to make it use standard input instead of having to read a file.\n\nExplanation:\n\n    # Some example input:\n        # 3\n        # Cat 20\n        # Elephant 90\n        # Dog 30\n        # Elephant 90\n        # Cat 25\n        # Dog 20\n\n    # Take everything after the first line:\n        # Cat 20\n        # Elephant 90\n        # Dog 30\n        # Elephant 90\n        # Cat 25\n        # Dog 20\n    let n=$(head -n 1 $1)\n    sed -n \"2,$ p\" $1 |\n\n    # Insert \"a\" in between item and price for the old data, and \"b\" for the new\n    # data\n        # Cat a 20\n        # Elephant a 90\n        # Dog a 30\n        # Elephant b 90\n        # Cat b 25\n        # Dog b 20\n    sed \"1,$n s/ / a /\" |\n    sed \"$(($n+1)),$ s/ / b /\" |\n\n    # Now when we sort we get the items in order, with old price first and new\n    # price second:\n        # Cat a 20\n        # Cat b 25\n        # Dog a 30\n        # Dog b 20\n        # Elephant a 90\n        # Elephant b 90\n    sort |\n\n    # Delete the added a's and b's and then keep only unique lines, so we get just\n    # the items with changes:\n        # Cat 20\n        # Cat 25\n        # Dog 30\n        # Dog 20\n    awk '{print $1,$3;}' |\n    uniq -u |\n\n    # Combine pairs of lines, perform arithmetic, and add plus signs for positive\n    # numbers\n        # Cat +5\n        # Dog -10\n    sed \"N;s/\\n/ /\" |\n    awk '{print $1, $4 - $2;}' |\n    sed \"s/ \\([0-9]\\)/ +\\1/\"\n\nI'd highly suggest if you are going to invoke awk at all...just use awk for the whole thing:\n\n    NR == 1 { next }\n    { if (v[$1] && v[$1] != $2)\n         printf \"%s %+d\\n\", $1, ($2 - v[$1])\n      else\n         v[$1] = $2\n    }\n\nOr, if you really want to be all bash, make proper use of bash's `read` functionality, and associative arrays (only available in bash > 4.2):\n\n    #!/bin/bash\n    \n    declare -A prices\n    \n    read N\n    \n    for ((i = 0; i < N; i++)); do\n    \tread item price\n    \tprices[$item]=$price\n    done\n    \n    for ((i = 0; i < N; i++)); do\n    \tread item price\n    \tif (( price != prices[$item] )); then\n    \t\tprintf '%s %+d\\n' \"$item\" \"$((price - prices[$item]))\"\n    \tfi\n    done\n\n\nNice, this problem is perfect for awk, well done!", "id": "cdzqqjc", "owner_tier": 0.7, "score": 0.15999999980000001}, {"content": "If anyone want a bigger list:\n\n    44\n    Apple 162\n    Bananas 105\n    Bed 63\n    Beef 73\n    Bottle 118\n    Bread 46\n    Brocolli 165\n    Carrots 122\n    Cat 130\n    Chicken 46\n    Chocolate 176\n    Computer 63\n    Cow 101\n    Crow 160\n    Dolphin 194\n    Dove 120\n    Drawer 125\n    Egg 13\n    Fish 16\n    Fork 110\n    Fridge 40\n    Giraffe 3\n    Hamster 145\n    Knife 104\n    Lamp 175\n    Lion 198\n    Milk 113\n    Orange 48\n    Panda 84\n    Phone 29\n    Plate 14\n    Rat 37\n    Rhino 134\n    Shark 143\n    Sheep 12\n    Sofa 83\n    Spectacles 60\n    Spoon 135\n    Squirrel 149\n    Tiger 180\n    Tomato 10\n    Turtle 187\n    Whale 140\n    Zebra 31\n    Apple 162\n    Bananas 105\n    Bed 63\n    Beef 72\n    Bottle 113\n    Bread 50\n    Brocolli 165\n    Carrots 122\n    Cat 130\n    Chicken 46\n    Chocolate 176\n    Computer 63\n    Cow 101\n    Crow 145\n    Dolphin 194\n    Dove 110\n    Drawer 125\n    Egg 13\n    Fish 16\n    Fork 110\n    Fridge 40\n    Giraffe 3\n    Hamster 145\n    Knife 104\n    Lamp 175\n    Lion 198\n    Milk 113\n    Orange 48\n    Panda 84\n    Phone 29\n    Plate 12\n    Rat 37\n    Rhino 146\n    Shark 143\n    Sheep 10\n    Sofa 83\n    Spectacles 60\n    Spoon 135\n    Squirrel 149\n    Tiger 180\n    Tomato 10\n    Turtle 179\n    Whale 140\n    Zebra 31\n\nOutput:\n\n    Beef -1\n    Bottle -5\n    Bread +4\n    Crow -15\n    Dove -10\n    Plate -2\n    Rhino +12\n    Sheep -2\n    Turtle -8", "id": "ce13t0o", "owner_tier": 0.1, "score": 0.0599999998}, {"content": "Lisp.\n\n    (defun parse-list (n)\n      (sort (loop repeat n collect (list (read) (read)))\n            #'string<\n            :key (lambda (e) (symbol-name (first e)))))\n\n    (defun inventory ()\n      (let* ((n (read))\n             (wrong (parse-list n))\n             (right (parse-list n)))\n        (loop for (item a) in wrong and (_ b) in right\n              for diff = (- b a)\n              for sign = (if (< diff 0) \"\" \"+\")\n              unless (zerop diff)\n              do (format t \"~a ~a~a~%\" item sign diff))))\n\nUnfortunately Common Lisp doesn't preserve case by default, but I\nwrote this in Elisp originally, which does preserve case.\n\n\nCan you explain the `for (item a) in wrong and (_ b) in right` bit?\n\nAlso in common lisp (don't know about elisp) you can use ~@d to force the printing of the sign.\n\n> Can you explain the for (item a) in wrong and (_ b) in right bit?\n\nThe `loop` macro supports destructuring bindings. The two lists are each in alist form, so each element in the list is a pair of values. I used `_` because I don't care about that variable, being identical to `item`, and I used an underscore as a convention for this. In Elisp there's no `(declare (ignore ...))` and instead any variable starting with an underscore tells the compiler you intend to ignore that variable.\n\n> Also in common lisp (don't know about elisp) you can use ~@d to force the printing of the sign.\n\nThanks for the tip. I've have almost no practice with the Common Lisp `format` directives so I don't know any of the tricks. Elisp only supports a printf-like `format`, and I had ported it directly from that. Now that I think about it, I could have used `%+d` in that case, too.\n", "id": "cdzktn2", "owner_tier": 0.7, "score": 0.0799999998}, {"content": "Java doesn't have to be all that long either...\n\n    import java.util.*;\n    class NutsBolts {\n    \tpublic static void main(String[] args) {\n    \t\tScanner sc = new Scanner(System.in);\n    \t\tint n = sc.nextInt();\n    \t\tHashtable<String, Integer> nTable = new Hashtable<String, Integer>();\n    \t\t\n    \t\tfor (int i = 0; i < n; i++)\n    \t\t\tnTable.put(sc.next(), sc.nextInt()); // put into hashtable\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tString item = sc.next();\n    \t\t\tint q = sc.nextInt() - nTable.get(item); // subtract item's old quantity from new\n    \t\t\tif (q != 0) System.out.println(item + \" \" + ((q > 0) ? \"+\"+q : q)); // print\n    \t\t}\n    \t}\n    }", "id": "cdzwegq", "owner_tier": 0.1, "score": 0.0799999998}, {"content": "JavaScript (using node for file I/O):\n\n    fs = require('fs');\n    \n    var priceData = fs.readFileSync(process.argv[2], 'utf8').split('\\r\\n');\n    var numItems = parseInt(priceData[0]);\n    var currPriceData = priceData.slice(1, numItems + 1);\n    var correctPriceData = priceData.slice(numItems + 1);\n    var currPrices = [];\n    \n    currPriceData.forEach(function(item) {\n        var data = item.split(' ');\n        currPrices[data[0]] = parseInt(data[1]);\n    });\n    \n    correctPriceData.forEach(function(item) {    \n        var data = item.split(' ');\n        var difference = parseInt(data[1]) - currPrices[data[0]];\n        if (Math.abs(difference) > 0) {\n            console.log(data[0] + ' ' + (difference > 0 ? '+' : '') + difference);\n        }\n    });\n    \n", "id": "cdztsmq", "owner_tier": 0.5, "score": 0.0599999998}, {"content": "Python 2.7 (as it relies on dict comprehensions):\n\n    n = int(raw_input())\n    d = {x[0]: int(x[1]) for i in xrange(n) for x in [raw_input().split()] }\n    d = {x[0]: d[x[0]]-int(x[1]) for i in xrange(n) for x in [raw_input().split()] }\n    print \"\\n\".join(k+\" \"+str(v) for k,v in d.items() if v != 0)\n\n\nassuming sanitized input the first line can just be \n\n    n = input()\n\nin 2.7 as it'll just interpret it as an int to begin with. It's dangerous to do something like that normally, but this is looking code-golfy already, so might as well.\n\ncool code!\n\n[deleted]\n\nno problem! Just remember it's not something you can normally do, as 2.7's    input() tries to interpret stdin as a well-formed python expression. If you type anything other than an int (i think) it'll just ask you what you meant as there's no variable or function named \"(whatever you typed in)\". It's weird and in fact python 3's input() is just python 2.7's raw_input() which is a lot nicer and more predictable.", "id": "cdzumjv", "owner_tier": 0.1, "score": 0.15999999980000001}, {"content": "F#\n\nStill getting used to the functional approach, but I'm loving it so far.\n\n    let parseLine (line:System.String) = \n        let parsedString = line.Split(' ')\n        ( parsedString.[0], int (parsedString.[1]) )\n\n    let printLine = function\n        | (product, price) when price > 0 -> System.Console.WriteLine(product + \" +\" + string price)\n        | (product, price) when price < 0 -> System.Console.WriteLine(product + \" \" + string price)\n        | _ -> ()\n    \n    [<EntryPoint>]\n    let main argv = \n        let number = int (System.Console.ReadLine())\n        let getLines count = \n            [for n in [1..count] -> System.Console.ReadLine()] \n                |> List.map parseLine \n        let priceMap = getLines number |> List.fold (fun acc (product, price) -> Map.add product price acc) Map.empty\n        getLines number\n            |> List.map (fun (product, price) -> (product, price - Map.find product priceMap))\n            |> List.filter (fun (product, price) -> price <> 0)\n            |> List.iter printLine\n        0\n\n\n\n\nThis is the first time I've seen an F# Entry in this sub Have an upvote \n\nThanks!\n\nI try to do all the problems in F#. I haven't gotten around to the latest ones yet (holiday season), but I have a fair few others solved in F#.", "id": "ce0xpgm", "owner_tier": 0.7, "score": 0.0999999998}, {"content": "I'm trying to teach myself PHP, so this is my first attempt at programming in PHP and doing a Daily Programmer Challenge! Any critiques welcome!\n\n    <?php\n\n    function nuts_and_bolts($filename) {\n        $filereader = fopen($filename,'r');\n        \n        # Get number of rows\n        $rows = fgets($filereader);\n        \n        # Fill out the old list\n        $old_list = array();\n        for ($i = 0; $i < $rows; $i++) {\n            $line = split(\" \", fgets($filereader));\n            $old_list[$line[0]] = $line[1];\n        }\n\n        # Scan through new list, filling out changes array\n        $changes = array();\n        for ($i = 0; $i < $rows; $i++) {\n            $line = split(\" \", fgets($filereader));\n            $change = $line[1] - $old_list[$line[0]];\n            if ($change !== 0) {\n                $changes[$line[0]] = $change;\n            }\n        }\n\n        # Print changes\n        foreach($changes as $item => $change) {\n            echo $item.\" \";\n            if ($change > 0) {\n                echo \"+\".$change.\"<br />\";\n            } else {\n                echo $change.\"<br />\";\n            }\n        }\n        \n        fclose($filereader);\n    }\n\n    ?>\n\nUsage:\n\n    <?php\n    \n    nuts_and_bolts(\"nutsandbolts_input.txt\");\n\n    ?>\n\nI think you did a good job. You even managed to support multiple price changes and only output them once, which would be nice for the person using the output :-)\n\n\nBut i think you forgot a check to output a negative change. And you might also want take a look at using [foreach](http://www.php.net/manual/en/control-structures.foreach.php). It could replace your while-loop and eliminate the usage of key, current and next functions.\n\nThanks for the response! I output the negative change in the else statement. If the change is negative, then the element of the changes array is negative, so a negative sign is automatically printed out.\n\nI looked into using `foreach` for printing out the change array, but my changes array is structured like `changes[name_of_item] = change`. If I did a `foreach`, then the syntax would be something like `foreach($changes as $change)`, right? This means that I only get access to `$change`, which is just the number. I want to also be able to print out the key of the element, since that's the name of the item. How would I do that using a `foreach`?\n\nOh yeah, forgot about php-magic that adds the minus signs :D\n\nThe foreach could look like:\n\nforeach($changes as $name => $change)\n\nThanks! Edited! :)", "id": "cdzveue", "owner_tier": 0.1, "score": 0.0799999998}, {"content": "A COBOL solution:\n\n           >>SOURCE FREE\n    IDENTIFICATION DIVISION.\n    PROGRAM-ID. nuts-and-bolts.\n    \n    DATA DIVISION.\n    WORKING-STORAGE SECTION.\n    01  num-items                           PIC 99.\n    01  items-area.\n        03  items                           OCCURS 1 TO 50 TIMES\n                                            DEPENDING ON num-items\n                                            INDEXED BY items-idx.\n            05  item-name                   PIC X(30).\n            05  old-price                   PIC 9(5).\n            05  new-price                   PIC 9(5).\n    \n    01  input-str                           PIC X(50).\n    \n    01  item-to-find                        PIC X(30).\n    01  item-to-find-price                  PIC 9(5).\n    \n    01  difference                          PIC +(5).\n    \n    PROCEDURE DIVISION.\n        ACCEPT num-items\n        PERFORM VARYING items-idx FROM 1 BY 1 UNTIL items-idx > num-items\n            ACCEPT input-str\n            UNSTRING input-str DELIMITED BY SPACES INTO item-name (items-idx),\n                old-price (items-idx)\n        END-PERFORM\n    \n        PERFORM num-items TIMES\n            ACCEPT input-str\n            UNSTRING input-str DELIMITED BY SPACES INTO item-to-find,\n                item-to-find-price\n            \n            SET items-idx TO ZERO\n            SEARCH items\n                WHEN item-name (items-idx) = item-to-find\n                    MOVE item-to-find-price TO new-price (items-idx)\n            END-SEARCH\n        END-PERFORM\n    \n        DISPLAY SPACE\n        \n        PERFORM VARYING items-idx FROM 1 BY 1 UNTIL items-idx > num-items\n            SUBTRACT new-price (items-idx) FROM old-price (items-idx)\n                GIVING difference\n            IF difference <> SPACES\n                DISPLAY FUNCTION TRIM(item-name (items-idx)) \" \"\n                    FUNCTION TRIM(difference)\n            END-IF\n        END-PERFORM\n        .\n    END PROGRAM nuts-and-bolts.\n", "id": "cdzvief", "owner_tier": 0.1, "score": -1.9999999878450582e-10}, {"content": "erlang\n\n    -module(nutsnbolts).\n    -export([main/1]).\n\n    read_prices(Count) -> \n        lists:map(\n            fun(_) -> \n                {ok, [Item, Price]} = io:fread(\"\", \"~s ~d\"),\n                {Item, Price} \n            end,\n            lists:seq(1, Count)\n        ).\n\n    show_prices(Prices) -> \n        lists:foreach(\n            fun({Item, Price}) -> \n                case Price > 0 of\n                    true -> io:fwrite(\"~s +~B\\n\", [Item, Price]);\n                    false -> io:fwrite(\"~s ~B\\n\", [Item, Price])\n                end\n            end, \n            Prices\n        ).\n\n    price_changes(Old_prices, New_prices) ->\n        [{Item, Price_change} || \n            {Item, Price_change} <- lists:zipwith(\n                fun({Item, Old_price}, {Item, New_price}) -> {Item, New_price - Old_price} end,\n                lists:sort(Old_prices),\n                lists:sort(New_prices)\n            ),\n            Price_change /= 0\n        ].\n\n    main(_) ->\n        {ok, [Count]} = io:fread(\"\", \"~d\"),\n        {Old_prices, New_prices} = {read_prices(Count), read_prices(Count)},\n        show_prices(price_changes(Old_prices, New_prices)).\n\nOn second thought it's probably more \"erlang\" to do the i/o like this:\n\n    read_prices(0) -> [];\n    read_prices(Count) -> \n            {ok, [Item, Price]} = io:fread(\"\", \"~s ~d\"),\n            [{Item, Price}] ++ read_prices(Count - 1).\n\n    show_prices([]) -> [ok];\n    show_prices([{Item, Price}|Tail]) when Price > 0 -> \n        [io:fwrite(\"~s +~B\\n\", [Item, Price])] ++ show_prices(Tail);\n    show_prices([{Item, Price}|Tail]) -> \n        [io:fwrite(\"~s ~B\\n\", [Item, Price])] ++ show_prices(Tail).", "id": "ce03atq", "owner_tier": 0.1, "score": 0.0599999998}, {"content": "D Language\n\n    import std.stdio, std.algorithm, std.range, std.conv, std.typecons;\n    \n    auto toItemAndPrice(char[] line) {\n        auto t = line.findSplit(\" \");\n        return tuple(t[0].idup, t[2].to!int());\n    }\n    void main() {\n        int[string] pricemap;\n        foreach(item, price ; stdin.byLine().drop(1).map!toItemAndPrice) {\n            auto badPrice = item in pricemap;\n            if (badPrice && *badPrice != price) {\n                writefln(\"%s %+d\", item, price - *badPrice);\n            }\n            else {\n                pricemap[item] = price;\n            }\n        }\n    }\n\nmy preferred language i c++. is D worth learning?\n\nI'd definitely say so. The language and standard library are designed in a way which makes them really enjoyable to use. Compared to C++, D does a lot of things much better; [this page](http://dlang.org/overview.html) has some comparisons.\n\nIn general, you can learn a lot from trying out a bunch of different languages and seeing how they make different ideas easy or hard to express, what trade-offs they make, etc.\n\nnoice. thanks!", "id": "cdzmccv", "owner_tier": 0.1, "score": 0.0999999998}, {"content": "C#\n\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n\n    namespace NutsAndBolts\n    {\n\n        class MainClass\n        {\n\n            public static void Main(string[] args)\n            {\n\n                var inputText = File.ReadAllLines(args[0]);\n                var nItems = Convert.ToInt32(inputText[0]);\n\n                var inventory = new Dictionary<string, string>();\n                for (var i = 1; i <= nItems; ++i)\n                {\n                    var itemStrings = inputText[i].Split(' ');\n                    inventory.Add(itemStrings[0], itemStrings[1]);\n                }\n\n                var outputText = string.Empty;\n                for (var i = 1; i <= nItems; ++i)\n                {\n\n                    var itemStrings = inputText[i + nItems].Split(' ');\n                    if (itemStrings[1] != inventory[itemStrings[0]])\n                    {\n\n                        var priceDiff = Convert.ToInt32(itemStrings[1]) \n                                           - Convert.ToInt32(inventory[itemStrings[0]]);\n                        outputText += itemStrings[0] + \" \";\n                        if (priceDiff > 0)\n                            outputText += \"+\";\n                        outputText += priceDiff.ToString() + \"\\n\";\n\n                    }\n\n                }\n\n                Console.Write(outputText);\n\n            }\n\n        }\n\n    }\n\nEdited to fix one line getting cut off due to length.\n\nC# Linq one-liner of doom:\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(string.Join(\"\\n\", Console.In.ReadToEnd().Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries).Skip(1).Select(x => x.Split()).Select(x => new { Name = x[0], Price = int.Parse(x[1]) }).ToLookup(x => x.Name).Select(x => new { x.First().Name, Diff = x.ElementAt(1).Price - x.ElementAt(0).Price }).Where(x => x.Diff != 0).Select(x => x.Name + \" \" + (x.Diff > 0 ? \"+\" : \"\") + x.Diff)));\n    }\n\n\nReadable version:\n\n    Console.WriteLine(\n        string.Join(\"\\n\",\n            Console.In.ReadToEnd()\n                .Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries)\n                .Skip(1)\n                .Select(x => x.Split())\n                .Select(x => new { Name = x[0], Price = int.Parse(x[1]) })\n                .ToLookup(x => x.Name)\n                .Select(x => new { x.First().Name, Diff = x.ElementAt(1).Price - x.ElementAt(0).Price })\n                .Where(x => x.Diff != 0)\n                .Select(x => x.Name + \" \" + (x.Diff > 0 ? \"+\" : \"\") + x.Diff)\n            ));", "id": "cdzmgrr", "owner_tier": 0.3, "score": 0.0599999998}, {"content": "Golang:  \n  \n\tpackage main\n\n\timport (\n\t\t\"fmt\"\n\t\t\"os\"\n\t)\n\n\tfunc main(){\n\t\tvar count int\n\t\tnum, err := fmt.Scanln(&count)\n\t\tif(err != nil || num != 1){\n\t\t\tfmt.Println(\"Error reading file\");\n\t\t\tos.Exit(1);\n\t\t}\n\t\titems := make(map[string]int)\n\n\t\tfor i := 0; i < count; i++ {\n\t\t\tvar cost int\n\t\t\tvar name string\n\t\t\tnum, err = fmt.Scanln(&name, &cost)\n\t\t\tif(err != nil || num != 2){\n\t\t\t\tfmt.Println(\"Error reading file\");\n\t\t\t\tos.Exit(1);\n\t\t\t}\n\t\t\titems[name] = cost\n\t\t}\n\t\t\n\t\tfor i := 0; i < count; i++ {\n\t\t\tvar cost int\n\t\t\tvar name string\n\t\t\tnum, err = fmt.Scanln(&name, &cost)\n\t\t\tif(err != nil || num != 2){\n\t\t\t\tfmt.Println(\"Error reading file\");\n\t\t\t\tos.Exit(1);\n\t\t\t}\n\n\t\t\tdifference := cost - items[name]\n\t\t\tif difference != 0 {\n\t\t\t\tvar sign string\n\t\t\t\tif (difference > 0){\n\t\t\t\t\tsign = \"+\"\n\t\t\t\t}\n\t\t\t\tfmt.Printf(\"%s %s%d\\n\", name, sign, difference)\n\t\t\t\tif(err != nil || num != 2){\n\t\t\t\t\tfmt.Println(\"Error printing result\");\n\t\t\t\t\tos.Exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n  \n\n[deleted]\n\nDid not know, many thanks.", "id": "cdzmp0q", "owner_tier": 0.5, "score": 0.1399999998}], "link": "https://www.reddit.com/r/dailyprogrammer/comments/1sob1e/121113_challenge_144_easy_nuts_bolts/", "question": {"content": "# [](#EasyIcon) *(Easy)*: Nuts & Bolts\n\nYou have just been hired at a local home improvement store to help compute the proper costs of inventory. The current prices are out of date and wrong; you have to figure out which items need to be re-labeled with the correct price.\n\nYou will be first given a list of item-names and their current price. You will then be given another list of the same item-names but with the correct price. You must then print a list of items that have changed, and by how much.\n\n# Formal Inputs & Outputs\n## Input Description\n\nThe first line of input will be an integer N, which is for the number of rows in each list. Each list has N-lines of two space-delimited strings: the first string will be the unique item name (without spaces), the second string will be the price (in whole-integer cents). The second list, following the same format, will have the same unique item-names, but with the correct price. Note that the lists may not be in the same order!\n\n## Output Description\n\nFor each item that has had its price changed, print a row with the item name and the price difference (in cents). Print the sign of the change (e.g. '+' for a growth in price, or '-' for a loss in price). Order does not matter for output.\n\n# Sample Inputs & Outputs\n## Sample Input 1\n\n    4\n    CarriageBolt 45\n    Eyebolt 50\n    Washer 120\n    Rivet 10\n    CarriageBolt 45\n    Eyebolt 45\n    Washer 140\n    Rivet 10\n\n## Sample Output 1\n\n    Eyebolt -5\n    Washer +20\n\n## Sample Input 2\n\n    3\n    2DNail 3\n    4DNail 5\n    8DNail 10\n    8DNail 11\n    4DNail 5\n    2DNail 2\n\n## Sample Output 2\n\n    2DNail -1\n    8DNail +1", "id": "1sob1e", "title": "[12/11/13] Challenge #144 [Easy] Nuts & Bolts", "traffic_rate": 52.62312775330396}, "saved_time": 1721101574, "source": "reddit", "tags": []}, {"answers": [{"content": "How about:", "id": 77447518, "owner_tier": 0.5, "score": -4.347826060532735e-12}, {"content": "or you could always get geekier with regexps", "id": 9507807, "owner_tier": 0.5, "score": 0.01695652173478261}, {"content": "Try the method rstrip() (see doc Python 2 and Python 3) Python's rstrip() method strips all kinds of trailing whitespace by default, not just one newline as Perl does with chomp. To strip only newlines: In addition to rstrip(), there are also the methods strip() and lstrip(). Here is an example with the three of them:", "id": 275025, "owner_tier": 0.9, "score": 0.9999999999956523}, {"content": "It looks like there is not a perfect analog for perl's chomp.  In particular, rstrip cannot handle multi-character newline delimiters like \\r\\n. However, splitlines does as pointed out here.\nFollowing my answer on a different question, you can combine join and splitlines to remove/replace all newlines from a string s: The following removes exactly one trailing newline (as chomp would, I believe). Passing True as the keepends argument to splitlines retain the delimiters.  Then, splitlines is called again to remove the delimiters on just the last \"line\": ", "id": 43641376, "owner_tier": 0.5, "score": 0.004347826082608695}, {"content": "There are three types of line endings that we normally encounter: \\n, \\r and \\r\\n. A rather simple regular expression in re.sub, namely r\"\\r?\\n?$\", is able to catch them all. (And we gotta catch 'em all, am I right?) With the last argument, we limit the number of occurences replaced to one, mimicking chomp to some extent. Example: ... where a == b == c is True.", "id": 40750864, "owner_tier": 0.3, "score": 0.002173913039130435}, {"content": "A catch all:", "id": 26554128, "owner_tier": 0.1, "score": -4.347826060532735e-12}, {"content": "And I would say the \"pythonic\" way to get lines without trailing newline characters is splitlines().", "id": 275659, "owner_tier": 0.5, "score": 0.08173913043043478}], "link": "https://stackoverflow.com/questions/275018/how-can-i-remove-a-trailing-newline", "question": {"content": "How can I remove the last character of a string if it is a newline?", "id": 275018, "title": "How can I remove a trailing newline?", "traffic_rate": 444}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["python", "newline", "trailing"]}, {"answers": [{"content": "gawk", "id": 1654115, "owner_tier": 0.9, "score": 0.1594202897101449}, {"content": "Here's a simple solution that uses sed.\nYour versions of sed needs to support the -z option. It can either be used in a pipe or used to edit the file in place with the -i option", "id": 72138792, "owner_tier": 0.1, "score": -1.4492753623188407e-10}, {"content": "You can do this with head from GNU coreutils, it supports arguments that are relative to the end of the file. So to leave off the last byte use: To test for an ending newline you can use tail and wc. The following example saves the result to a temporary file and subsequently overwrites the original: You could also use sponge from moreutils to do \"in-place\" editing: You can also make a general reusable function by stuffing this in your .bashrc file: As noted by KarlWilbur in the comments and used in Sorentar's answer, truncate --size=-1 can replace head -c-1 and supports in-place editing.", "id": 12579554, "owner_tier": 0.9, "score": 0.8260869563768116}, {"content": "You can take advantage of the fact that shell command substitutions remove trailing newline characters: Simple form that works in bash, ksh, zsh: Portable (POSIX-compliant) alternative (slightly less efficient): Note: A guide to the other answers: If Perl is available, go for the accepted answer - it is simple and memory-efficient (doesn't read the whole input file at once). Otherwise, consider ghostdog74's Awk answer - it's obscure, but also memory-efficient; a more readable equivalent (POSIX-compliant) is: awk 'NR > 1 { print prev } { prev=$0 } END { ORS=\"\"; print }' in.txt Printing is delayed by one line so that the final line can be handled in the END block, where it is printed without a trailing \\n due to setting the output-record separator (OFS) to an empty string. If you want a verbose, but fast and robust solution that truly edits in-place (as opposed to creating a temp. file that then replaces the original), consider jrockway's Perl script.", "id": 12148703, "owner_tier": 0.9, "score": 0.9999999998550726}, {"content": "See also Match any character (including newlines) in sed.", "id": 1654040, "owner_tier": 0.9, "score": 0.04347826072463768}, {"content": "If you want to do it right, you need something like this: We open the file for reading and appending; opening for appending means that we are already seeked to the end of the file.  We then get the numerical position of the end of the file with tell.  We use that number to seek back one character, and then we read that one character.  If it's a newline, we truncate the file to the character before that newline, otherwise, we do nothing. This runs in constant time and constant space for any input, and doesn't require any more disk space, either.", "id": 1658873, "owner_tier": 0.9, "score": 0.1014492752173913}, {"content": "The only time I've wanted to do this is for code golf, and then I've just copied my code out of the file and pasted it into an echo -n 'content'>file statement.", "id": 1656988, "owner_tier": 0.9, "score": -1.4492753623188407e-10}, {"content": "Yet another perl WTDI:", "id": 1656218, "owner_tier": 0.9, "score": 0.07246376797101449}, {"content": " Edit 2:  Here is an awk version (corrected) that doesn't accumulate a potentially huge array:     awk '{if (line) print line; line=$0} END {printf $0}' abc", "id": 1654049, "owner_tier": 0.9, "score": 0.28985507231884056}], "link": "https://stackoverflow.com/questions/1654021/how-can-i-delete-a-newline-if-it-is-the-last-character-in-a-file", "question": {"content": "I have some files that I'd like to delete the last newline if it is the last character in a file.  od -c shows me that the command I run does write the file with a trailing new line: I've tried a few tricks with sed but the best I could think of isn't doing the trick: Any ideas how to do this?", "id": 1654021, "title": "How can I delete a newline if it is the last character in a file?", "traffic_rate": 24}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["linux", "perl", "shell", "awk", "sed"]}, {"answers": [{"content": "There have been great responses so far. Here is an efficient way to do this in Python: You can use the above functions to retrieve sequences/headers from a fasta file without line breaks, manipulate them, and write back to a fasta file.", "id": 64288602, "owner_tier": 0.5, "score": 0.166666665}, {"content": "Do not reinvent the wheel. If the goal is simply removing newlines in multi-line fasta file (unwrapping fasta file), use any of the specialized bioinformatics tools, for example seqtk, like so: Example: Output: SEE ALSO: seqtk usage: To install this tool, use conda, specifically miniconda, for example: REFERENCES: seqtk: https://github.com/lh3/seqtk\nconda: https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html\nconda create: https://docs.conda.io/projects/conda/en/latest/commands/create.html", "id": 64266547, "owner_tier": 0.5, "score": 0.9999999983333333}, {"content": "Use this Perl one-liner, which does all of the common reformatting that is necessary in this and similar cases: removes newlines and whitespace in the sequence (which also unwraps the sequence), but does not change the sequence header lines. Note that unlike some of the other answers, this properly handles leading and trailing whitespace/newlines in the file: Output: The Perl one-liner uses these command line flags:\n-e : Tells Perl to look for code in-line, instead of in a file.\n-n : Loop over the input one line at a time, assigning it to $_ by default. chomp : Remove the input line separator (\\n on *NIX).\nif ( /^>/ ) : Test if the current line is a sequence header line.\n$n : This variable is undefined (false) at the beginning, and true after seeing the first sequence header, in which case we print an extra newline. This newline goes at the end of each sequence, starting from the first sequence.\nEND { print \"\\n\"; } : Print the final newline after the last sequence.\ns/\\s+//g; print; : If the current line is sequence (not header), remove all the whitespace and print without the terminal newline.", "id": 63972868, "owner_tier": 0.5, "score": -1.6666666666666667e-09}, {"content": "Another variation :-)", "id": 41263012, "owner_tier": 0.5, "score": -1.6666666666666667e-09}], "link": "https://stackoverflow.com/questions/15857088/remove-line-breaks-in-a-fasta-file", "question": {"content": "I have a fasta file where the sequences are broken up with newlines.  I'd like to remove the newlines.  Here's an example of my file: I'd like to convert it into this: I found a potential solution on this site, which looks like this: However, this places an extra line break between each entry, so file looks like this: I'm an awk noob, but I took a shot at modifying the command.  My guess was the if (p){print \"\\n\";} was the culprit...potentially print \"\\n\" is adding two line breaks.  I couldn't figure out how to add just one newline...this is probably something easy, but like I said, I'm a noob.  Here was my (unsuccessful) solution: However, this adds an empty line at the beginning of the file because it's always printing a new line before it prints the first accession number: Anyone have a solution to get my file in the correct format?  Thanks!", "id": 15857088, "title": "Remove line breaks in a FASTA file", "traffic_rate": 8}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["unix", "awk", "newline", "bioinformatics", "fasta"]}, {"answers": [{"content": "Adding this for my reference more than anything else ^_^ You can also strip a new line from the output using the bash expansion magic", "id": 68526649, "owner_tier": 0.5, "score": 0.017582417560439562}, {"content": "Using Awk: Explanation:", "id": 67596503, "owner_tier": 0.5, "score": -2.1978021844451187e-11}, {"content": "If you want to print output of anything in Bash without end of line, you echo it with the -n switch. If you have it in a variable already, then echo it with the trailing newline cropped: Or you can do it in one line, instead:", "id": 12525977, "owner_tier": 0.3, "score": 0.02637362635164835}, {"content": "If your expected output is a single line, you can simply remove all newline characters from the output. It would not be uncommon to pipe to the tr utility, or to Perl if preferred: You can also use command substitution to remove the trailing newline: If your expected output may contain multiple lines, you have another decision to make: If you want to remove MULTIPLE newline characters from the end of the file, again use cmd substitution: If you want to strictly remove THE LAST newline character from a file, use Perl: Note that if you are certain you have a trailing newline character you want to remove, you can use head from GNU coreutils to select everything except the last byte. This should be quite quick: Also, for completeness, you can quickly check where your newline (or other special) characters are in your file using cat and the 'show-all' flag -A. The dollar sign character will indicate the end of each line:", "id": 12524345, "owner_tier": 0.9, "score": 0.9999999999780219}, {"content": "One way:", "id": 12524320, "owner_tier": 0.5, "score": 0.20659340657142858}], "link": "https://stackoverflow.com/questions/12524308/bash-strip-trailing-linebreak-from-output", "question": {"content": "When I execute commands in Bash (or to be specific, wc -l < log.txt), the output contains a linebreak after it. How do I get rid of it?", "id": 12524308, "title": "Bash: Strip trailing linebreak from output", "traffic_rate": 117}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["bash", "newline", "line-breaks"]}, {"answers": [{"content": "In Python, start reading the file without writing in a loop until you get a non-empty line.", "id": 59795703, "owner_tier": 0.9, "score": 0.499999995}, {"content": "Set a flag when you find a line that's not just a newline and print when that flag is set: e.g.:", "id": 59797313, "owner_tier": 0.9, "score": -5e-09}, {"content": "This is what I came up with, I'm sure it can still be improved a bit. Here is an alternative solution, which opens the file twice.", "id": 59797001, "owner_tier": 0.5, "score": -5e-09}, {"content": "Simple filter to skip leading empty lines One liner version perl -0777 -pe 's/^\\n+//' filename", "id": 59796800, "owner_tier": 0.5, "score": -5e-09}, {"content": "The equivalent-opposite Perl code to chomp is s/^\\n//. Instead of doing it on the last line (eof), do it on the first line. Even though it will only be an empty line, removing the newline will mean that line will print nothing in the output. or in place: Since starting newlines are by definition empty lines, you can also just skip printing them by using -n instead of -p (same behavior but without printing, so you can determine which lines to print). If you want to remove potentially multiple starting newlines, you could take another approach; advance the handle yourself in the beginning until you receive a non-empty line. It's all much easier if you don't mind reading the entire file into memory at once rather than line by line: To avoid doing any excess work editing the file unless it starts with newline characters, you could condition the edit by prefixing it with another command (reads first line of the file and causes a non-zero exit status if it doesn't start with a newline):", "id": 59795559, "owner_tier": 0.5, "score": 0.999999995}], "link": "https://stackoverflow.com/questions/59795526/how-to-remove-starting-newlines-or-the-starting-new-from-a-binary-file", "question": {"content": "I see there are discussions about removing trailing newlines. How can I delete a newline if it is the last character in a file? But I don't find a discusion about removing starting newlines. Could anybody let me know what is the best way to delete starting newlines (one liner preferred)? Thanks.", "id": 59795526, "title": "How to remove starting newlines or the starting new from a binary file?", "traffic_rate": 1051}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["python", "shell", "perl", "sed", "command-line"]}, {"answers": [{"content": "To handle many newline delimiters, including character combinations like \\r\\n, use splitlines.\nCombine join and splitlines to remove/replace all newlines from a string s: To remove exactly one trailing newline, pass True as the keepends argument to retain the delimiters, removing only the delimiters on the last line: ", "id": 43641128, "owner_tier": 0.5, "score": 0.0}], "link": "https://stackoverflow.com/questions/3849509/how-to-remove-n-from-a-list-element", "question": {"content": "I'm trying to get Python to a read line from a .txt file and write the elements of the first line into a list. The elements in the file were tab- separated so I used split(\"\\t\") to separate the elements. Because the .txt file has a lot of elements I saved the data found in each line into a separate list. The problem I currently have is that it's showing each list like this: How can I remove \\n from the last element of the list and make it just '7.3'?", "id": 3849509, "title": "How to remove \\n from a list element?", "traffic_rate": 139}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["python", "list", "newline"]}, {"answers": [], "link": "https://stackoverflow.com/questions/35940583/remove-new-line-from-array-in-perl", "question": {"content": "I m trying to filtering the filenames from a text file The context of the file is like below But when i print the @filenames array its like Even though i add the chomp the new line was not removed from array elements.", "id": 35940583, "title": "remove new line from array in perl", "traffic_rate": 3668}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["arrays", "perl"]}, {"answers": [], "link": "https://stackoverflow.com/questions/6852719/templated-configuration-in-python-or-perl", "question": {"content": "I'm trying to implement a templated configuration file.\nI'd prefer python, but I'd take an answer in perl too.\nI've used perl for my example. I've searched a bit and found\n - python single configuration file\n - ConfigObj\n - python configuration file generator\n - ePerl\nbut I could not from those solve my problem. I'm trying generate a configuration file mostly in the INI format (with not even sections): and I need that generated from a template where I'm embedding a scripting language inside the text: The text in between the '<:' and ':>' would be in the scripting language (python or perl). As with a template, its stdout is captured and inserted in the resulting text. The templating used in the example is basically eperl, but I'd prefer python if available. and finally, the defined variables should be reusable: Here's the test source file that I read in: And I'm looking to get this result out of the script.\nI could not figure how to have the variables defined in the config file be part of the interpreter? Thanks for your suggestions.", "id": 6852719, "title": "templated configuration in python or perl?", "traffic_rate": 588}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["python", "perl", "templates", "configuration"]}, {"answers": [{"content": "First of all, you don't even try to change the CRLF to LF. You just print back out what you got. On a Windows system, Perl adds the :crlf layer to your file handles. That means that CRLF gets changed to LF on read, and LF gets changed to CRLF on write. That last bit is the problem. By default, Perl assumes you're create a text file, but what you're creating doesn't match the definition of a text file on Windows. As such, you need to switch your output to binmode. Solution that only works on a Windows system: Or if you want it to work on any system, Without binmode on the input, s/\\r?\\n\\z// handles all of those.", "id": 15735143, "owner_tier": 0.9, "score": 0.9999999993333333}, {"content": "if you are on Unix like command line, on the shell prompt the following with do the trick: \n\n\nperl -pe 's/^M//g' file.txt # ^M mean control-M, press control-v control-M, the CRLF character\n\n \nperl -pe 's#\\r\\n$#\\n#g' file.txt \n", "id": 15825270, "owner_tier": 0.3, "score": 0.13333333266666667}, {"content": "This works for me on a Mac (Mac OS X 10.7.5, Perl 5.16.2): Sample output: The odx program gives me a hex dump of the data file; you can see that there are 0D 0A (CRLF) line endings.  The vis -c program shows control characters (other than newline and tab) as ^M (for example).  You can see that the raw input includes the ^M (lines starting 1:) but the chomp'd lines are missing both the newline and the carriage return. The only issue will be whether the input on Windows is a text file or a binary file.  If it is a text file, the I/O system should do the CRLF mapping automatically.  If it is a binary file, it won't.  (Unix doesn't have a meaningful distinction between text and binary files.)  On Windows, you may need to investigate binmode, as discussed on the open page.", "id": 15732890, "owner_tier": 0.9, "score": 0.066666666}, {"content": "I think \\s* should work.", "id": 15733855, "owner_tier": 0.5, "score": -6.666666666666666e-10}, {"content": "That would be a one-liner in Perl... Try the following under Linux: and the following under Windows:", "id": 15732711, "owner_tier": 0.3, "score": -6.666666666666666e-10}], "link": "https://stackoverflow.com/questions/15732552/how-to-remove-cr-lf-end-of-line-in-perl", "question": {"content": "I need to remove and of the line which looks like CR LF. Coding - Windows-1250\nWindows 7 EN I have been trying to chomp, chomp, change \\R to nothing change \\r\\n etc but nothing works... Thank you in advance", "id": 15732552, "title": "How to remove CR LF end of line in Perl", "traffic_rate": 9}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "stackoverflow", "tags": ["perl"]}, {"answers": [{"content": "I've said this before: have a bunch of library functions that handle this for you. There is no point in writing the exact same code for every day. \n\nI would, but generally the data changes from day to day. It's been different enough that each type of data has only been seen once or twice:\n\n* day 1, 9: one line of characters\n* day 2: multiple lines of integers separated by whitespace\n* day 3: no input file\n* day 4: lines of words separated by whitespace\n* day 5: one integer per line\n* day 6: one line of integers separated by whitespace\n* day 7, 8: lines of mixed data\n* day 10: one line of integers separated by commas\n* day 11: one line of words separated by commas\n\n... and the idiomatic way to write this in Python is already super-concise, it would take longer to write a library function and be less readable:\n\n* `[c for c in f.readline()]`\n* `[[int(n) for n in line.split()] for line in f]`\n* ...\n* `[line.split() for line in f]`\n* `[int(line) for line in f]`\n* `[int(n) for n in f.readline().split()]`\n* ...\n* `[int(n) for n in f.readline().split(\",\")]`\n* `[w for w in f.readline().strip().split(\",\")]`\n\n> ... and the idiomatic way to write this in Python is already super-concise, it would take longer to write a library function and be less readable\n\nAs someone who wrote Python professionally: you're focussing way too much on 'conciseness'. What you want to do if have a set of well tested standard functions that you reuse. Making the same mistake again and again is a great example that you should reuse more. Code is much more readable that way too. \n\nAnd basically there's really only two types of inputs: one long string and a list of strings. You can then easily map / split those any way you want. So it's just two functions you can easily reuse. [All my solutions sofar](https://github.com/nielsutrecht/adventofcode/tree/master/src/main/kotlin/com/nibado/projects/advent/y2017) use my [resourceString](https://github.com/nielsutrecht/adventofcode/blob/master/src/main/kotlin/com/nibado/projects/advent/Util.kt#L18) or [resourceLines](https://github.com/nielsutrecht/adventofcode/blob/master/src/main/kotlin/com/nibado/projects/advent/Util.kt#L30) function. \n\nI recommend treating the input as lines of data.\n\nIf there's one line, just use that one line!\n\nIf there are many, loop over them, and process them as needed - split by character, parse with regex, whatever. \n\nThe important point is you can always count on there being a discrete, continuous chunk of data with no newlines.\n\nFWIW I just stored the input for day 3 in its own `input.txt` and treated it just as any other day.\n\nTo propose an alternative to /u/nutrecht's suggestion for this particular issue: crash early and loudly.\n\nYou're making control flow decisions based on individual tokens ('n', 'sw', 'sw\\n') at some point in your code. Maybe converting the strings to objects via a dict, maybe an if tree, maybe a switch of some sorts. See if there's an easy way of making it loudly fail in case of unexpected input.\n\nE.g. in my Scala code, I converted the tokens via a Map (throwing an exception on 'sw\\n'), or did stuff based on a switch (which would again, throw an exception on 'sw\\n').\n\nPython's conciseness is a plus here - once you've crashed due to an unexpected value, you can quickly find it (if needed) by creating a set of all the tokens.\n\n> To propose an alternative to /u/nutrecht's suggestion for this particular issue: crash early and loudly.\n\nActually; do both. I tend to use regular expressions for the non-trivial parsing stuff and I crash whenever the regex does not match. It means I made a mistake and need to correct it.\n\nSo both; have a standard function to read input and make sure that the input is what you expect. ", "id": "dr2xc8s", "owner_tier": 0.9, "score": 0.9999999995238095}, {"content": "Here's what I do:\n\nI click on the input link, CTRL+A, CTRL+C, then open an empty text file where I do CTRL+V. I'm on Windows, I never get \\n at the end of the input.\n\nBut always adding a `strip()` when you read a file is a good habit to have anyway. Very rarely are you interested in the newline at the end of the file.\n\nI generally prefer `rstrip()` when reading lines from a file because in most cases leading whitespace is meaningful. That said,`strip()` is also pretty useful. \n\nGood point!", "id": "dr2xad7", "owner_tier": 0.3, "score": 0.38095238047619046}, {"content": "Except for a few lines of code in the mid-1990s, I've never written any Python code, but doesn't\n\n    f.readline().rstrip().split(\",\")\n\ndo what you want? \n\ni just did:\n\n    commands=open(\"2017_11_input.bin\").read()\n    steps=commands.strip().split(\",\")\n\n(this lets me replace `commands` with test data easily)", "id": "dr30f3x", "owner_tier": 0.1, "score": 0.14285714238095237}, {"content": "This is part of the Perl template I start every problem with\n\n    #### INIT - load input data from file into array\n    my $testing = 0;\n    my @input;\n    my $file = $testing ? 'test.txt' : 'input.txt';\n    open( my $fh, '<', \"$file\" );\n    while (<$fh>) { chomp; s/\\r//gm; push @input, $_; }\n \nNote the `chomp; s/\\r//gm;` - this strips `\\n` and `\\r` from the input line.   \n\n\n\nI've been burnt enough times by trying to process a file with Windows line endings on a unixish system and chomp leaving the `\\r` behind that I just started using `$_ =~ s/\\s+$//;` instead. Has the bonus of stripping any trailing spaces that I usually don't want at the same time.", "id": "dr2wojv", "owner_tier": 0.7, "score": 0.14285714238095237}, {"content": "Having a readline function that strips the newline from the end is very useful. I'm a bit surprised that Python's doesn't do that.", "id": "dr2y7ho", "owner_tier": 0.9, "score": -4.761904732964423e-10}, {"content": "LOL! I'm using C++ and had written a function that I use in almost every puzzle. It parses the input into tokens and put them into a vector of vectors. Basically, the outer vector is the set of lines. And the inner vector contains each token. Simple enough. I used it for today's puzzle and got the right answer on part 1. But could not get the correct answer on part 2.\n\nAfter a LONG while, I finally notice that I'm getting \"e\" as input. There is no east. Ends up I was using a buffer of 1024 characters for each line. This puzzle has a single line of 21K characters. It was splitting up the input into multiple lines of 1024 characters each.\n\nHow I got the correct answer for part 1 is beyond me.\n", "id": "dr4334m", "owner_tier": 0.3, "score": -4.761904732964423e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/7j1f5b/2017_day_11_again_with_the_damn_newline/", "question": {"content": "I've been debugging my code for today multiple times over, still couldn't see why it was getting a wrong answer.\n\nThere is a single line of input. **IT ENDS IN A NEWLINE**. Stripping out the newline gives the right answer.\n\nPython's `f.readline().split(\",\")` gives a list where the final element is `\"sw\\n\"` (or such) rather than `\"sw\"`. I wrote no code to warn about unknown directions, so I didn't notice this.\n\nThis is exactly the same problem I encountered yesterday. You get the correct answer if you strip the newline from the input, and you get the wrong answer if you don't.\n\nI'm going to have to start remembering this.", "id": "7j1f5b", "title": "[2017 Day 11] Again with the damn newline!", "traffic_rate": 38.33703939008895}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "90/98\n\nThis was very reminiscent of the Syacor challenge. Loved it!\n\n\n    #!/usr/bin/env python3\n\n    def list_map(f, s):\n        return list(map(f, s))\n\n    def addr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] + result[b]\n        return result\n\n    def addi(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] + b\n        return result\n\n    def mulr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] * result[b]\n        return result\n\n    def muli(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] * b\n        return result\n\n    def banr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] & result[b]\n        return result\n\n    def bani(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] & b\n        return result\n\n    def borr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] | result[b]\n        return result\n\n    def bori(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a] | b\n        return result\n\n    def setr(registers, a, b, c):\n        result = registers[::]\n        result[c] = result[a]\n        return result\n\n    def seti(registers, a, b, c):\n        result = registers[::]\n        result[c] = a\n        return result\n\n    def gtir(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(a > result[b])\n        return result\n\n    def gtri(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] > b)\n        return result\n\n    def gtrr(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] > result[b])\n        return result\n\n    def eqir(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(a == result[b])\n        return result\n\n    def eqri(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] == b)\n        return result\n\n    def eqrr(registers, a, b, c):\n        result = registers[::]\n        result[c] = bool(result[a] == result[b])\n        return result\n\n    OPERATIONS = [\n        addr, addi,\n        mulr, muli,\n        banr, bani,\n        borr, bori,\n        setr, seti,\n        gtir, gtri, gtrr,\n        eqir, eqri, eqrr\n    ]\n\n    def possible_operations(instruction, before, after):\n        result = set()\n        for operation in OPERATIONS:\n            op_result = operation(before, *instruction[1:])\n            if op_result == after:\n                result.add(operation)\n        return result\n\n    def problem1(LINES):\n        i = 0\n        experiments = []\n        while LINES[i].strip():\n            before, instruction, after = LINES[i:i+3]\n            i += 4\n            experiments.append((\n                list_map(int, instruction.split(' ')),\n                eval(before[8:]),\n                eval(after[8:])\n            ))\n        return len([experiment for experiment in experiments if len(possible_operations(*experiment)) >= 3])\n\n    def problem2(LINES):\n        i = 0\n        experiments = []\n        while LINES[i].strip():\n            before, instruction, after = LINES[i:i+3]\n            i += 4\n            experiments.append((\n                list_map(int, instruction.split(' ')),\n                eval(before[8:]),\n                eval(after[8:])\n            ))\n\n        operations = {opcode : set(OPERATIONS) for opcode in range(16)}\n        for experiment in experiments:\n            opcode = experiment[0][0]\n            operations[opcode].intersection_update(possible_operations(*experiment))\n\n        while True:\n            unique_ops = {}\n            for op, ops in operations.items():\n                if len(ops) == 1:\n                    unique_ops[op] = ops\n            for op_, ops_ in unique_ops.items():\n                for op, ops in operations.items():\n                    if op != op_:\n                        ops.difference_update(ops_)\n            if len(unique_ops) == len(operations):\n                break\n\n        for op in operations:\n            operations[op] = operations[op].pop()\n        registers = [0, 0, 0, 0]\n        for line in LINES[i:]:\n            if not line.strip():\n                continue\n            opcode, a, b, c = list_map(int, line.split(' '))\n            registers = operations[opcode](registers, a, b, c)\n        return registers[0]\n\n    def parse_input_file(fname):\n        s = open(fname).read()\n        if s and s[-1] == '\\n':\n            s = s[:-1]\n        return s.splitlines()\n\n    def main():\n        l = parse_input_file('input.txt')\n        print(problem1(l))\n        print(problem2(l))\n\n    if __name__ == '__main__':\n        main()\n", "id": "ebw73yj", "owner_tier": 0.3, "score": 0.22222222185185186}, {"content": "Rank 18/43, Python. Video of me solving at https://www.youtube.com/watch?v=-AvYZufvZPQ (still uploading)\n\nNeat problem! The idea of having to figure out part of the language is great! I wish the two parts of the input had been delimited better though...\n\n    import re\n    \n    def do_cmd(fn):\n        def final(before, instr):\n            after = list(before)\n            after[instr[3]] = fn(before, instr[1], instr[2])\n            return after\n        return final\n    \n    addr = do_cmd(lambda before,x,y: before[x]+before[y])\n    addi = do_cmd(lambda before,x,y: before[x]+y)\n    mulr = do_cmd(lambda before,x,y: before[x]*before[y])\n    muli = do_cmd(lambda before,x,y: before[x]*y)\n    banr = do_cmd(lambda before,x,y: before[x] & before[y])\n    bani = do_cmd(lambda before,x,y: before[x] & y)\n    borr = do_cmd(lambda before,x,y: before[x] | before[y])\n    bori = do_cmd(lambda before,x,y: before[x] | y)\n    setr = do_cmd(lambda before,x,y: before[x])\n    seti = do_cmd(lambda before,x,y: x)\n    gtir = do_cmd(lambda before,x,y: 1 if x > before[y] else 0)\n    gtri = do_cmd(lambda before,x,y: 1 if before[x] > y else 0)\n    gtrr = do_cmd(lambda before,x,y: 1 if before[x] > before[y] else 0)\n    eqir = do_cmd(lambda before,x,y: 1 if x == before[y] else 0)\n    eqri = do_cmd(lambda before,x,y: 1 if before[x] == y else 0)\n    eqrr = do_cmd(lambda before,x,y: 1 if before[x] == before[y] else 0)\n    \n    cmds = [ addr, addi\n           , mulr, muli\n           , banr, bani\n           , borr, bori\n           , setr, seti\n           , gtir, gtri, gtrr\n           , eqir, eqri, eqrr\n           ]\n    \n    options = {}\n    for code in range(16):\n        options[code] = list(enumerate(cmds))\n    \n    lines,program = open('16.in').read().strip().split('\\n\\n\\n')\n    lines = lines.strip().split('\\n')\n    ans = 0\n    for i in range(0, len(lines), 4):\n        if 'Before' in lines[i]:\n            assert 'After:' in lines[i+2]\n            before = map(int, re.findall('-?\\d+', lines[i]))\n            instr = map(int, re.findall('-?\\d+', lines[i+1]))\n            after = map(int, re.findall('-?\\d+', lines[i+2]))\n            options[instr[0]] = [(idx,fn) for (idx,fn) in options[instr[0]] if fn(before,instr) == after]\n    \n            matches = 0\n            for idx,cmd in options[instr[0]]:\n                if cmd(before, instr) == after:\n                    matches += 1\n            if matches >= 3:\n                ans += 1\n    \n    print ans\n    for _ in range(16):\n        for code in range(16):\n            if len(options[code]) == 1:\n                for other_code in range(16):\n                    if other_code != code:\n                        options[other_code] = [(idx,fn) for (idx,fn) in options[other_code] if idx!=options[code][0][0]]\n            \n    \n    #for code in range(16):\n    #    print code, options[code]\n    \n    registers = [0,0,0,0]\n    for line in program.strip().split('\\n'):\n        instr = map(int, re.findall('-?\\d+', line))\n        old_registers = list(registers)\n        registers = options[instr[0]][0][1](registers, instr)\n    print registers[0]\n\n\nI just used the four existing consecutive line breaks as delimiter.\n\nYeah, I personally ended up adding my own delimiter rather than mucking with parsing.\n\nI guess it didn't help to get the right answer on part 1 without having mulr/muli in place...\n\nHmm, your solution is off on part 1 of my input (yours gives me 458, while the correct answer is 500).\n\nHuh. I just blanked out `before` after processing every \"After:\" line and if I encountered a line of numbers while `before` was `None`, added it to the program.\n\nYeah, I should've gone this way. I spent way too long parsing the input. Even manually copying and pasting the second part of the input into another file would've been faster.\n\nCan you pastebin your input?\n\nOf course: https://gist.github.com/tobiasvl/759ef5b2848a368305f2f9d9ba8255d7\n\nMy code is here btw: https://github.com/tobiasvl/adventofcode/blob/master/2018/16/2018_16.py\n\nCould you also help me please, my code does give 500 as answer to your code @tobiasvl and gives 577 as answer to my own input ([https://gist.github.com/arcogelderblom/7b72181bb346053315f01c308995a3ba](https://gist.github.com/arcogelderblom/7b72181bb346053315f01c308995a3ba)). But this is not correct when I input this as answer on the AoC site. My code is here: [https://github.com/arcogelderblom/AdventOfCode2018/blob/master/16thDecember2018/1stPuzzle/src/main.go](https://github.com/arcogelderblom/AdventOfCode2018/blob/master/16thDecember2018/1stPuzzle/src/main.go)\n\n>\\[2018   \n>  \n>Day 16  \n>  \n>\\] Puzzle inspiration\n\nAlready fixed it, rookie mistake, forgot that i was doing assignments instead of returning after if statement, after all if statements it was overwriting a possible 1. Fixed now! :)", "id": "ebw78eu", "owner_tier": 0.3, "score": 0.9999999996296296}, {"content": "Lua 91/38. Really doesn't help that Lua 5.1 doesn't have bitwise operations, had to implement them manually using strings.\n\n    local examples, program = {}, {}\n    local before, data;\n    for v in getinput():gmatch(\"[^\\n]+\") do\n    \tlocal numbers, index = {}, 0\n    \tfor n in v:gmatch(\"%d+\") do\n    \t\tnumbers[index] = tonumber(n)\n    \t\tindex = index + 1\n    \tend\n    \tif v:match(\"Before\") then\n    \t\tbefore = numbers\n    \telseif v:match(\"After\") then\n    \t\texamples[#examples+1] = {before = before, after = numbers, data = data}\n    \t\tbefore, data = nil\n    \telseif before then\n    \t\tdata = numbers\n    \telse\n    \t\tprogram[#program+1] = numbers\n    \tend\n    end\n    \n    function binary(n)\n    \tlocal s = \"\"\n    \trepeat\n    \t\ts = (n%2)..s\n    \t\tn = (n - n%2)/2\n    \tuntil n == 0\n    \treturn (\"0\"):rep(16-#s)..s\n    end\n    \n    function AND(a, b)\n    \ta, b = binary(a), binary(b)\n    \tlocal s = \"\"\n    \tfor i = 1, #a do\n    \t\ts = s..((a:sub(i, i) == \"1\" and b:sub(i, i) == \"1\") and \"1\" or \"0\")\n    \tend\n    \treturn tonumber(s, 2)\t\n    end\n    \n    function OR(a, b)\n    \ta, b = binary(a), binary(b)\n    \tlocal s = \"\"\n    \tfor i = 1, #a do\n    \t\ts = s..((a:sub(i, i) == \"1\" or b:sub(i, i) == \"1\") and \"1\" or \"0\")\n    \tend\n    \treturn tonumber(s, 2)\t\n    end\n    \n    local r;\n    local operations = {\n    \taddr = function(a, b) return r[a] + r[b] end;\n    \taddi = function(a, b) return r[a] + b end;\n    \tmulr = function(a, b) return r[a] * r[b] end;\n    \tmuli = function(a, b) return r[a] * b end;\n    \tbanr = function(a, b) return AND(r[a], r[b]) end;\n    \tbani = function(a, b) return AND(r[a], b) end;\n    \tborr = function(a, b) return OR(r[a], r[b]) end;\n    \tbori = function(a, b) return OR(r[a], b) end;\n    \tsetr = function(a, b) return r[a] end;\n    \tseti = function(a, b) return a end;\n    \tgtir = function(a, b) return a > r[b] and 1 or 0 end;\n    \tgtri = function(a, b) return r[a] > b and 1 or 0 end;\n    \tgtrr = function(a, b) return r[a] > r[b] and 1 or 0 end;\n    \teqir = function(a, b) return a == r[b] and 1 or 0 end;\n    \teqri = function(a, b) return r[a] == b and 1 or 0 end;\n    \teqrr = function(a, b) return r[a] == r[b] and 1 or 0 end;\n    }\n    local possible = {}\n    for _, f in pairs(operations) do\n    \tlocal t = {}\n    \tfor i = 0, 15 do t[i] = true end\n    \tpossible[f] = t\n    end\n    \n    local count = 0\n    for _, e in pairs(examples) do\n    \tlocal valid = 0\n    \tlocal n, a, b, c = unpack(e.data, 0, 3)\n    \tr = e.before\n    \tfor _, f in pairs(operations) do\n    \t\tif f(a, b) == e.after[c] then\n    \t\t\tvalid = valid + 1\n    \t\telse\n    \t\t\tpossible[f][n] = false\n    \t\tend\n    \tend\n    \tif valid >= 3 then count = count + 1 end\n    end\n    print(count)\n    \n    local opcode, list = {}, {}\n    for f, t in pairs(possible) do list[#list+1] = f end\n    for i = 1, #list do\n    \ttable.sort(list, function(a, b)\n    \t\tlocal c1, c2 = 0, 0\n    \t\tfor k, v in pairs(possible[a]) do if v then c1 = c1 + 1 end end\n    \t\tfor k, v in pairs(possible[b]) do if v then c2 = c2 + 1 end end\n    \t\treturn c1 < c2\n    \tend)\n    \tlocal f = table.remove(list, 1)\n    \tfor k, v in pairs(possible[f]) do\n    \t\tif v then\n    \t\t\topcode[k] = f\n    \t\t\tfor _, y in pairs(possible) do\n    \t\t\t\ty[k] = false\n    \t\t\tend\n    \t\t\tbreak\n    \t\tend\n    \tend\n    end\n    \n    r = {[0] = 0, 0, 0, 0}\n    for _, line in pairs(program) do\n    \tlocal n, a, b, c = unpack(line, 0, 3)\n    \tr[c] = opcode[n](a, b)\n    end\n    print(r[0])\n\n&#x200B;\n\nHonest question... Why are you using a lua version that was replaced in 2011? Lua 5.3 which has bitwise operators is almost 4 years old now.\n\nLua 5.1 is still the most popular version. I started using it in 2007. I would only ever use a different version outside the context of a platform, which is what this would be. It would probably be a good idea to start using 5.3 for these problems.\n\nCurious if/why 5.1 would be the most popular version. It does not match what I see for the linux distribution I use (only one data point, but still) where install frequency is something like\n\n|5.3|90%|\n|:-|:-|\n|5.2|80%|\n|5.1|40%|\n\nIs there breaking changes post 5.1 or is adoption just slow?\n\nI was about to assume you were using LuaJIT, since that still runs 5.1 (and probably will for the foreseeable future). I always use LuaJIT myself, when I use Lua for AoC, for the extra speed. And, of course, LuaJIT adds bitwise operators to 5.1 (the `bit` module).\n\nAnother big factor is luajit. It's one of the fastest dynamic language implementations but it's fixed on Lua 5.1 as the actual language.\n\nLuajit ships with a BitOps library though.\n\nLater versions aren't backwards compatible with certain things. 5.1 doesn't have \"integers\", so in newer versions sometimes a \".0\" is added to the end of a string when a number is coerced. Another change is function environments but that's an obscure language feature. I'm not used to any differences so I didn't take the risk of being thrown off by something subtle. Development platforms like Roblox and L\u00d6VE and CryEngine still use Lua 5.1.\n\nFair enough. I'm a python guy myself, so I get the issues with subtle bugs. What is a generator and what's not between python2 and python3 can catch you off guard. Also stupid things like `min(0,None)` being valid in 2 but not 3 is weird.\n\nDon't tell me lua is another language that chooses to have double for all numbers... I kinda hoped that was contained to the likes of js. Not a fan, although I guess it makes sense considering that lua is deliberately minimal.", "id": "ebw74ql", "owner_tier": 0.1, "score": 0.7037037033333333}, {"content": "Python. 3/19. Minimal code cleanup. Took a few minutes to realize that Part 2 would require some repeated deduction.\n\n    import advent\n    import re\n    \n    from collections import *\n    from itertools import *\n    from math import *\n    \n    def addr(R, a, b, c):\n        R[c] = R[a] + R[b]\n    \n    def addi(R, a, b, c):\n        R[c] = R[a] + b\n    \n    def mulr(R, a, b, c):\n        R[c] = R[a] * R[b]\n    \n    def muli(R, a, b, c):\n        R[c] = R[a] * b\n    \n    def banr(R, a, b, c):\n        R[c] = R[a] & R[b]\n    \n    def bani(R, a, b, c):\n        R[c] = R[a] & b\n    \n    def borr(R, a, b, c):\n        R[c] = R[a] | R[b]\n    \n    def bori(R, a, b, c):\n        R[c] = R[a] | b\n    \n    def setr(R, a, b, c):\n        R[c] = R[a]\n    \n    def seti(R, a, b, c):\n        R[c] = a\n    \n    def gtir(R, a, b, c):\n        R[c] = 1 if a > R[b] else 0\n    \n    def gtri(R, a, b, c):\n        R[c] = 1 if R[a] > b else 0\n    \n    def gtrr(R, a, b, c):\n        R[c] = 1 if R[a] > R[b] else 0\n    \n    def eqir(R, a, b, c):\n        R[c] = 1 if a == R[b] else 0\n    \n    def eqri(R, a, b, c):\n        R[c] = 1 if R[a] == b else 0\n    \n    def eqrr(R, a, b, c):\n        R[c] = 1 if R[a] == R[b] else 0\n    \n    instructions = [\n        addr, addi, mulr, muli, banr, bani, borr, bori,\n        setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr,\n    ]\n    \n    def parse(line):\n        return list(map(int, re.findall(r'\\d+', line)))\n    \n    def behaves_like(instruction, before, after):\n        count = 0\n        for f in instructions:\n            R = list(before)\n            f(R, *instruction[1:])\n            if R == after:\n                count += 1\n        return count\n    \n    def remove_candidates(candidates, instruction, before, after):\n        for f in instructions:\n            R = list(before)\n            f(R, *instruction[1:])\n            if R != after:\n                candidates[instruction[0]].discard(f)\n    \n    def main():\n        data = advent.fetch(16)\n    \n        lines = data.split('\\n')\n        lines = [x.strip() for x in lines]\n    \n        # part 1\n        count = 0\n        for line in lines:\n            if 'Before' in line:\n                before = parse(line)\n            elif 'After' in line:\n                after = parse(line)\n                if behaves_like(instr, before, after) >= 3:\n                    count += 1\n            else:\n                instr = parse(line)\n        print(count)\n    \n        # part 2\n        known = set()\n        opcodes = {}\n        while len(known) < len(instructions):\n            candidates = {}\n            for i in range(16):\n                candidates[i] = set(instructions) - set(known)\n            for line in lines:\n                if 'Before' in line:\n                    before = parse(line)\n                elif 'After' in line:\n                    after = parse(line)\n                    remove_candidates(candidates, instr, before, after)\n                else:\n                    instr = parse(line)\n            for i in range(16):\n                if len(candidates[i]) == 1:\n                    f = candidates[i].pop()\n                    opcodes[i] = f\n                    known.add(f)\n    \n        R = [0] * 4\n        for line in lines[3353:]:\n            line = line.strip()\n            if not line:\n                continue\n            o, a, b, c = parse(line)\n            f = opcodes[o]\n            f(R, a, b, c)\n        print(R[0])\n    \n    if __name__ == '__main__':\n        main()", "id": "ebw75dq", "owner_tier": 0.3, "score": 0.18518518481481483}, {"content": "A very fun logic puzzle!\n\nPart 1: Oh no, reading error... I thought the problem was asking for `== 3` instead of the actual `>= 3`, submitted multiple wrong answers, and frantically tried to figure out what was wrong for 5 minutes before rereading the problem and slapping myself on the forehead.\n\nPart 2: My thought here was \"Eric must have made this problem actually possible\". I started by printing out the possible operations corresponding w/ each opcode, seeing a specific property >!there was an opcode that had only one possibility!< that would make it possible, and so I implemented that process in code for all opcodes.\n\nRuby:\n\n    instructions = {\n      addr: ->(a, b, c, r) { r[c] = r[a] + r[b] },\n      addi: ->(a, b, c, r) { r[c] = r[a] + b },\n      mulr: ->(a, b, c, r) { r[c] = r[a] * r[b] },\n      muli: ->(a, b, c, r) { r[c] = r[a] * b },\n      banr: ->(a, b, c, r) { r[c] = r[a] & r[b] },\n      bani: ->(a, b, c, r) { r[c] = r[a] & b },\n      borr: ->(a, b, c, r) { r[c] = r[a] | r[b] },\n      bori: ->(a, b, c, r) { r[c] = r[a] | b },\n      setr: ->(a, _, c, r) { r[c] = r[a] },\n      seti: ->(a, _, c, r) { r[c] = a },\n      gtir: ->(a, b, c, r) { r[c] = a > r[b] ? 1 : 0 },\n      gtri: ->(a, b, c, r) { r[c] = r[a] > b ? 1 : 0 },\n      gtrr: ->(a, b, c, r) { r[c] = r[a] > r[b] ? 1 : 0 },\n      eqir: ->(a, b, c, r) { r[c] = a == r[b] ? 1 : 0 },\n      eqri: ->(a, b, c, r) { r[c] = r[a] == b ? 1 : 0 },\n      eqrr: ->(a, b, c, r) { r[c] = r[a] == r[b] ? 1 : 0 },\n    }.freeze\n\n    raise 'You forgot an instruction...' if instructions.size != 16\n\n    could_be = Array.new(instructions.size) { instructions.keys }\n\n    verbose = ARGV.delete('-v')\n    input = (ARGV.empty? ? DATA : ARGF).each_line.map(&:chomp)\n\n    last_after = input.rindex { |l| l.start_with?('After: ') }\n\n    puts input[0..last_after].each_slice(4).count { |before, op, after, _|\n      before = before.scan(/\\d+/).map(&:to_i).freeze\n      after = after.scan(/\\d+/).map(&:to_i).freeze\n      opcode, a, b, c = op.split.map(&:to_i)\n\n      alike = instructions.select { |_, v|\n        regs = before.dup\n        begin\n          v[a, b, c, regs]\n        rescue\n          # Actually this line isn't necessary...\n          # I did it to defend against registers >= 4\n          # but it never happens in input?\n          next false\n        end\n        regs == after\n      }\n      could_be[opcode] &= alike.keys\n\n      alike.size >= 3\n    }\n\n    could_be.each_with_index { |c, i| puts \"#{i} (#{c.size}) -> #{c}\" } if verbose\n\n    assignments = [nil] * instructions.size\n    until assignments.all?\n      only_one = could_be.index { |a| a.size == 1 }\n      raise \"I'm not smart enough to do this one: #{could_be}\" unless only_one\n\n      assigned = could_be[only_one][0]\n      puts \"Assign #{only_one} #{assigned}\" if verbose\n      assignments[only_one] = instructions[assigned]\n      could_be.each { |e| e.delete(assigned) }\n    end\n\n    regs = [0, 0, 0, 0]\n\n    input.drop(last_after + 1).drop_while(&:empty?).each { |l|\n      opcode, a, b, c = l.split.map(&:to_i)\n      assignments[opcode][a, b, c, regs]\n    }\n\n    p verbose ? regs : regs[0]\n\n    __END__\n    Before: [3, 1, 0, 1]\n    9 3 3 2\n    After:  [3, 1, 0, 1]\n\n    omitted\n\n\n> raise 'You forgot an instruction...' if instructions.size != 16\n\n\nI wish I'd written this, would have saved me a lot of time!!\n\nregarding your spoiler/hint: I just assuned that this was the case and implemented the necessary code.\n\nHahaha :( I lost so much time because i forgot to add one of the commands to the list.  ", "id": "ebw7asl", "owner_tier": 0.1, "score": 0.3333333329629629}, {"content": "**Python 3**, 26/8:\n\n    import re, collections\n\n    *samples, _, program = open('inputs/day16').read().split('\\n\\n')\n\n    ops = {\n        'addr': lambda regs, a, b: regs[a] + regs[b],\n        'addi': lambda regs, a, b: regs[a] + b,\n        'mulr': lambda regs, a, b: regs[a] * regs[b],\n        'muli': lambda regs, a, b: regs[a] * b,\n        'banr': lambda regs, a, b: regs[a] & regs[b],\n        'bani': lambda regs, a, b: regs[a] & b,\n        'borr': lambda regs, a, b: regs[a] | regs[b],\n        'bori': lambda regs, a, b: regs[a] | b,\n        'setr': lambda regs, a, b: regs[a],\n        'seti': lambda regs, a, b: a,\n        'gtir': lambda regs, a, b: 1 if a > regs[b] else 0,\n        'gtri': lambda regs, a, b: 1 if regs[a] > b else 0,\n        'gtrr': lambda regs, a, b: 1 if regs[a] > regs[b] else 0,\n        'eqir': lambda regs, a, b: 1 if a == regs[b] else 0,\n        'eqri': lambda regs, a, b: 1 if regs[a] == b else 0,\n        'eqrr': lambda regs, a, b: 1 if regs[a] == regs[b] else 0,\n    }\n\n    indeterminate = 0\n\n    possible = collections.defaultdict(lambda: set(ops.keys()))\n\n    for sample in samples:\n        before, op, after = map(lambda s: list(map(int, re.findall(r'-?\\d+', s))), sample.splitlines())\n\n        count = 0\n\n        for opcode in ops:\n            result = ops[opcode](before, op[1], op[2])\n\n            if [*before[:op[3]], result, *before[op[3]+1:]] == after:\n                count += 1\n            elif opcode in possible[op[0]]:\n                possible[op[0]].remove(opcode)\n\n        if count >= 3:\n            indeterminate += 1\n\n    print('part 1:', indeterminate)\n\n    mapping = {}\n\n    while any(possible.values()):\n        for number, opcodes in possible.items():\n            if len(opcodes) == 1:\n                mapping[number] = op = opcodes.pop()\n                for remaining in possible.values():\n                    remaining.discard(op)\n\n    regs = [0, 0, 0, 0]\n\n    for line in program.splitlines():\n        op, a, b, c = [int(x) for x in line.split()]\n        regs[c] = ops[mapping[op]](regs, a, b)\n\n    print('part 2:', regs[0])\n\n\nThank you for this nice way of splitting the input! I'm so embarrassed by my own input-reading process that I've adapted it to post my code here.", "id": "ebw74jx", "owner_tier": 0.1, "score": 0.18518518481481483}, {"content": "C++, 53/34. Pretty interesting Part 2 today. Did some pretty lazy copy-pasting from Part 1 to run the program, but hey it was plenty fast enough.\n\n    #include <bits/stdc++.h>\n\tusing namespace std;\n\n\tint main(){\n\t\tstring s;\n\t\tchar junk;\n\t\tvector<int> bef(4);\n\t\tvector<int> af(4);\n\t\tvector<int> op(4);\n\n\t\tint ans = 0;\n\n\t\tset<int> full;\n\t\tfor(int i = 0; i < 16; i++) {\n\t\t\tfull.insert(i);\n\t\t}\n\t\tvector<set<int>> poss(16, full);\n\n\t\twhile(cin >> s) {\n\t\t\t// manually added SPLIT to input between the two parts\n\t\t\tif(s == \"SPLIT\") break;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcin >> junk >> bef[i];\n\t\t\t}\n\t\t\tcin >> junk;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcin >> op[i];\n\t\t\t}\n\t\t\tcin >> s;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tcin >> junk >> af[i];\n\t\t\t}\n\t\t\tcin >> junk;\n\t\t\tint opCode = op[0];\n\t\t\tint A = op[1], B = op[2], C = op[3];\n\t\t\t// compute all expected final register states\n\t\t\tvector<vector<int>> afExpect;\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tafExpect.push_back(bef);\n\t\t\t}\n\t\t\tafExpect[0][C] = bef[A] + bef[B];\n\t\t\tafExpect[1][C] = bef[A] + B;\n\n\t\t\tafExpect[2][C] = bef[A] * bef[B];\n\t\t\tafExpect[3][C] = bef[A] * B;\n\n\t\t\tafExpect[4][C] = bef[A] & bef[B];\n\t\t\tafExpect[5][C] = bef[A] & B;\n\n\t\t\tafExpect[6][C] = bef[A] | bef[B];\n\t\t\tafExpect[7][C] = bef[A] | B;\n\n\t\t\tafExpect[8][C] = bef[A];\n\t\t\tafExpect[9][C] = A;\n\n\t\t\tafExpect[10][C] = A > bef[B];\n\t\t\tafExpect[11][C] = bef[A] > B;\n\t\t\tafExpect[12][C] = bef[A] > bef[B];\n\n\t\t\tafExpect[13][C] = A == bef[B];\n\t\t\tafExpect[14][C] = bef[A] == B;\n\t\t\tafExpect[15][C] = bef[A] == bef[B];\n\t\t\tint cnt = 0;\n\t\t\tfor(int cur = 0; cur < 16; cur++) {\n\t\t\t\tbool match = true;\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tif(afExpect[cur][i] != af[i]) match = false;\n\t\t\t\t}\n\t\t\t\t// rule out impossible number-operation combos\n\t\t\t\tif(!match) poss[opCode].erase(cur);\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\n\t\twhile(true) {\n\t\t\tint numOnes = 0;\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\t// For any opcode with only one possibility,\n\t\t\t\t// we can remove the possibility from other opcodes.\n\t\t\t\tif(poss[i].size() == 1) {\n\t\t\t\t\tnumOnes++;\n\t\t\t\t\tfor(int j = 0; j < 16; j++) {\n\t\t\t\t\t\tif(i == j) continue;\n\t\t\t\t\t\tposs[j].erase(*poss[i].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(numOnes == 16) break;\n\t\t}\n\n\t\tint opCode, A, B, C;\n\t\tvector<int> reg(4, 0);\n\t\twhile(cin >> opCode) {\n\t\t\tcin >> A >> B >> C;\n\t\t\tint op = *poss[opCode].begin();\n\n\t\t\t// Lazy copy-paste, but it's fast enough\n\t\t\tvector<vector<int>> afExpect;\n\t\t\tfor(int i = 0; i < 16; i++) {\n\t\t\t\tafExpect.push_back(reg);\n\t\t\t}\n\t\t\tafExpect[0][C] = reg[A] + reg[B];\n\t\t\tafExpect[1][C] = reg[A] + B;\n\t\t\t\n\t\t\tafExpect[2][C] = reg[A] * reg[B];\n\t\t\tafExpect[3][C] = reg[A] * B;\n\n\t\t\tafExpect[4][C] = reg[A] & reg[B];\n\t\t\tafExpect[5][C] = reg[A] & B;\n\n\t\t\tafExpect[6][C] = reg[A] | reg[B];\n\t\t\tafExpect[7][C] = reg[A] | B;\n\n\t\t\tafExpect[8][C] = reg[A];\n\t\t\tafExpect[9][C] = A;\n\n\t\t\tafExpect[10][C] = A > reg[B];\n\t\t\tafExpect[11][C] = reg[A] > B;\n\t\t\tafExpect[12][C] = reg[A] > reg[B];\n\n\t\t\tafExpect[13][C] = A == reg[B];\n\t\t\tafExpect[14][C] = reg[A] == B;\n\t\t\tafExpect[15][C] = reg[A] == reg[B];\n\n\t\t\treg = afExpect[op];\n\t\t}\n\n\t\tfor(auto cur : reg) cout << cur << \" \" ;\n\n\t\treturn 0;\n\t}", "id": "ebw74yk", "owner_tier": 0.3, "score": 0.07407407370370371}, {"content": "Javascript, 81/60. Figuring out which opcode was which was fun. I was trying it manually first.\n\n&#x200B;\n\nSuper ugly code:\n\n    #!/usr/bin/env node\n    \n    const ops = [\n      (r, a, b, c) => { r[c] = r[a] + r[b] },\n      (r, a, b, c) => { r[c] = r[a] + b },\n      (r, a, b, c) => { r[c] = r[a] * r[b] },\n      (r, a, b, c) => { r[c] = r[a] * b },\n      (r, a, b, c) => { r[c] = r[a] & r[b] },\n      (r, a, b, c) => { r[c] = r[a] & b },\n      (r, a, b, c) => { r[c] = r[a] | r[b] },\n      (r, a, b, c) => { r[c] = r[a] | b },\n      (r, a, b, c) => { r[c] = r[a] },\n      (r, a, b, c) => { r[c] = a },\n      (r, a, b, c) => { r[c] = a > r[b] ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] > b ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] > r[b] ? 1 : 0 },\n      (r, a, b, c) => { r[c] = a === r[b] ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] === b ? 1 : 0 },\n      (r, a, b, c) => { r[c] = r[a] === r[b] ? 1 : 0 }\n    ]\n    \n    let r = [0, 0, 0, 0]\n    let result = []\n    let count = 0\n    \n    let possibilities = []\n    let pos = []\n    for (let i = 0; i < 16; i++) {\n      pos.push(i)\n    }\n    for (let i = 0; i < 16; i++) {\n      possibilities.push(new Set(pos))\n    }\n    let opcode = 0\n    \n    for (const line of require('fs').readFileSync('input.txt', 'utf8').trimEnd().split('\\n')) {\n      let m = line.match(/Before: \\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/)\n      if (m) {\n        r = m.slice(1).map(n => Number(n))\n      }\n      m = line.match(/^(\\d+) (\\d+) (\\d+) (\\d+)/)\n      if (m) {\n        m = m.slice(1).map(n => Number(n))\n        opcode = m[0]\n        result = []\n        for (const op of ops) {\n          let res = [...r]\n          op(res, m[1], m[2], m[3])\n          result.push(res)\n        }\n      }\n      m = line.match(/After: *\\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/)\n      if (m) {\n        const t = m.slice(1).map(n => Number(n))\n        let c = 0\n        let i = 0\n        for (const res of result) {\n          if (res.every((cur, idx) => cur === t[idx])) {\n            c++\n          } else {\n            possibilities[opcode].delete(i)\n          }\n          i++\n        }\n        if (c >= 3) {\n          count++\n        }\n      }\n    }\n    \n    console.log(count)\n    \n    let todo = new Set()\n    for (let i = 0; i < 16; i++) {\n      todo.add(i)\n    }\n    \n    let optable = []\n    while (todo.size > 0) {\n      for (const i of todo) {\n        if (possibilities[i].size === 1) {\n          optable[i] = [...possibilities[i]][0]\n          todo.delete(i)\n          for (let j = 0; j < 16; j++) {\n            possibilities[j].delete(optable[i])\n          }\n        }\n      }\n    }\n    \n    r = [0, 0, 0, 0]\n    for (const line of require('fs').readFileSync('input.txt', 'utf8').trimEnd().split('\\n').slice(3343)) {\n      const [, op, a, b, c] = line.match(/(\\d+) (\\d+) (\\d+) (\\d+)/).map(n => Number(n, 10))\n      ops[optable[op]](r, a, b, c)\n    }\n    console.log(r)\n    \n    \n    \n\n&#x200B;\n\nI'm doing these in JS too, but getting the wrong answer for Pt2.\n\n&#x200B;\n\nPart 1 went fine (though I was missing \\`borr\\` and \\`bori\\` \ud83d\ude2c -- they didn't matter). Now my final answer is a huuuuge number, and getting marked wrong as too high.\n\n&#x200B;\n\nStepping through the logic of each op seems to be doing the right thing, so I'm not sure where this is breaking. Though now that I'm rubber ducking this all out, I wonder if I've hit JS's int limit / max safe integer.\n\nMy Output for Part 2 is less then 1000 and looking over it no single register ever gets a value above 1000.\n\nFor what it's worth: all register values during execution of part 2 for my problem were three digits or less.\n\nYea, I suspected something was broken since these problems rarely reach into such arbitrarily large territory.\n\n&#x200B;\n\nGoing to double check my ops code mapping is right.\n\nYepp, my op codes were wrong. Boo-hiss. But, much better now. Thanks for the sanity check!\n\nGlad you figured it out :)", "id": "ebw7cka", "owner_tier": 0.3, "score": 0.37037036999999995}, {"content": "Ruby, #117/127. Somehow skipped over the binary OR instructions in part 1, and had brain lag trying to figure out part 2. But overall happy with the solution!\n\n    require 'pry'\n    \n    lines = $<.readlines.map(&:strip)\n    \n    class Sample\n      attr_accessor :before, :inst, :after\n      def initialize(before, inst, after)\n        @before = before\n        @inst = inst\n        @after = after\n      end\n    end\n    \n    def addr(r, a, b, c) r[c] = r[a] + r[b] end\n    def addi(r, a, b, c) r[c] = r[a] + b end\n    def mulr(r, a, b, c) r[c] = r[a] * r[b] end\n    def muli(r, a, b, c) r[c] = r[a] * b end\n    def banr(r, a, b, c) r[c] = r[a] & r[b] end\n    def bani(r, a, b, c) r[c] = r[a] & b end\n    def borr(r, a, b, c) r[c] = r[a] | r[b] end\n    def bori(r, a, b, c) r[c] = r[a] | b end\n    def setr(r, a, b, c) r[c] = r[a] end\n    def seti(r, a, b, c) r[c] = a end\n    def gtir(r, a, b, c) r[c] = a > r[b] ? 1 : 0 end\n    def gtri(r, a, b, c) r[c] = r[a] > b ? 1 : 0 end\n    def gtrr(r, a, b, c) r[c] = r[a] > r[b] ? 1 : 0 end\n    def eqir(r, a, b, c) r[c] = a == r[b] ? 1 : 0 end\n    def eqri(r, a, b, c) r[c] = r[a] == b ? 1 : 0 end\n    def eqrr(r, a, b, c) r[c] = r[a] == r[b] ? 1 : 0 end\n    \n    opcodes = (0..15).to_a\n    named_codes = [:addr, :addi, :mulr, :muli, :banr, :bani, :borr, :bori, :setr, :seti, :gtir, :gtri, :gtrr, :eqir, :eqri, :eqrr]\n    \n    samples = []\n    program = []\n    lines.each_slice(4).map do |slice|\n      if slice[0].start_with? 'Before'\n        samples << Sample.new(*slice[0..2].map { |line| line.scan(/\\d+/).map(&:to_i) })\n      else\n        program += slice.map { |line| line.scan(/\\d+/).map(&:to_i) }\n      end\n    end\n    \n    possible = opcodes.each_with_object({}) do |code, h|\n      h[code] = named_codes\n    end\n    \n    samples.each do |sample|\n      possible[sample.inst[0]] &= named_codes.select do |code|\n        r = sample.before.dup\n        send(code, r, *sample.inst[1..-1])\n        r == sample.after\n      end\n    end\n    \n    code_map = {}\n    until code_map.size == 16\n      possible.each do |num, codes|\n        next if code_map[num]\n        codes.each do |code|\n          next if possible.any? { |num2, code2| num2 != num && code2.include?(code) }\n          possible[num] = [code]\n          code_map[num] = code\n          break\n        end\n      end\n    end\n    \n    registers = [0] * 4\n    program.each do |prog|\n      send(code_map[prog[0]], registers, *prog[1..-1])\n    end\n    \n    puts registers.first", "id": "ebw7hzj", "owner_tier": 0.7, "score": 0.07407407370370371}, {"content": "Perl, 250ish/168.\n\n    #!/usr/bin/perl -s\n    use warnings;\n    use strict;\n    use feature qw/say/;\n    use integer;\n    use English;\n    \n    our $part2;\n    \n    $RS = \"\\n\\n\";\n    \n    our @registers = (0, 0, 0, 0);\n    \n    my %opcodes = (\n        addr => sub { $registers[$_[2]] = $registers[$_[0]] + $registers[$_[1]] },\n        addi => sub { $registers[$_[2]] = $registers[$_[0]] + $_[1] },\n        mulr => sub { $registers[$_[2]] = $registers[$_[0]] * $registers[$_[1]] },\n        muli => sub { $registers[$_[2]] = $registers[$_[0]] * $_[1] },\n        banr => sub { $registers[$_[2]] = $registers[$_[0]] & $registers[$_[1]] },\n        bani => sub { $registers[$_[2]] = $registers[$_[0]] & $_[1] },\n        borr => sub { $registers[$_[2]] = $registers[$_[0]] | $registers[$_[1]] },\n        bori => sub { $registers[$_[2]] = $registers[$_[0]] | $_[1] },\n        setr => sub { $registers[$_[2]] = $registers[$_[0]] },\n        seti => sub { $registers[$_[2]] = $_[0] },\n        gtir => sub { $registers[$_[2]] = $_[0] > $registers[$_[1]] },\n        gtri => sub { $registers[$_[2]] = $registers[$_[0]] > $_[1] },\n        gtrr => sub { $registers[$_[2]] = $registers[$_[0]] > $registers[$_[1]] },\n        eqir => sub { $registers[$_[2]] = $_[0] == $registers[$_[1]] },\n        eqri => sub { $registers[$_[2]] = $registers[$_[0]] == $_[1] },\n        eqrr => sub { $registers[$_[2]] = $registers[$_[0]] == $registers[$_[1]] }\n        );\n    \n    my %opnums;\n    my $total_matches = 0;\n    while (<>) {\n        last if m/\\A\\s+\\z/;\n        if (/Before:\\s+\\[(\\d+),\\ (\\d+),\\ (\\d+),\\ (\\d+)\\]\\s+\n             (\\d+)\\ (\\d+)\\ (\\d+)\\ (\\d+)\\s+\n             After:\\s+\\[(\\d+),\\ (\\d+),\\ (\\d+),\\ (\\d+)\\]/x) {\n            my $matches = 0;  \n            my $opname = \"\";\n            while (my ($name, $op) = each %opcodes) {\n                local @registers = ($1, $2, $3, $4);\n                $op->($6, $7, $8);\n                if ($registers[0] == $9 && $registers[1] == $10\n                    && $registers[2] == $11 && $registers[3] == $12) {\n                    $matches += 1;\n                    $opname = $name;\n                }\n            }\n            if ($part2 && $matches == 1) {\n                $opnums{$5} = $opcodes{$opname};\n                delete $opcodes{$opname};\n            }\n            $total_matches += 1 if $matches >= 3;\n        }\n    }\n    \n    if (not $part2) {\n        say \"Part 1: $total_matches\";\n        exit 0;\n    }\n    \n    $RS = \"\\n\";\n    while (<>) {\n        if (/(\\d+) (\\d+) (\\d+) (\\d+)/) {\n            $opnums{$1}->($2, $3, $4);\n        } else {\n            die \"Invalid input $_\";\n        }\n    }\n    say \"Part 2: $registers[0]\";\n    ", "id": "ebw7utu", "owner_tier": 0.9, "score": 0.07407407370370371}, {"content": "**Ruby** 177/321\n\nI really thought I could do better when I read the description, as I've played around with simple VMs before (eg the [Synacor Challenge](https://challenge.synacor.com/)). Ah well, still fun.\n\nI cost myself at least 20 minutes on part 2 because I kept attempting to work out the opcode values using the initial register settings from the samples, instead of the actual instructions. :facepalm: :headdesk:\n\n\tOPCODES = {\n\t\taddr: -> regs, a, b, c { regs[c] = regs[a] + regs[b] },\n\t\taddi: -> regs, a, b, c { regs[c] = regs[a] + b },\n\t\tmulr: -> regs, a, b, c { regs[c] = regs[a] * regs[b]},\n\t\tmuli: -> regs, a, b, c { regs[c] = regs[a] * b  },\n\t\tbanr: -> regs, a, b, c { regs[c] = regs[a] & regs[b] },\n\t\tbani: -> regs, a, b, c { regs[c] = regs[a] & b },\n\t\tborr: -> regs, a, b, c { regs[c] = regs[a] | regs[b] },\n\t\tbori: -> regs, a, b, c { regs[c] = regs[a] | b },\n\t\tsetr: -> regs, a, b, c { regs[c] = regs[a] },\n\t\tseti: -> regs, a, b, c { regs[c] = a },\n\t\tgtir: -> regs, a, b, c { regs[c] = a > regs[b] ? 1 : 0 },\n\t\tgtri: -> regs, a, b, c { regs[c] = regs[a] > b ? 1 : 0 },\n\t\tgtrr: -> regs, a, b, c { regs[c] = regs[a] > regs[b] ? 1 : 0 },\n\t\teqir: -> regs, a, b, c { regs[c] = a == regs[b] ? 1 : 0 },\n\t\teqri: -> regs, a, b, c { regs[c] = regs[a] == b ? 1 : 0 },\n\t\teqrr: -> regs, a, b, c { regs[c] = regs[a] == regs[b] ? 1 : 0 },\n\t}\n\n\tdef solve\n\t\topcodes = (0...16).map{ |n| [n,nil] }.to_h\n\t\tpart1_count = 0\n\t\tsamples = 0\n\t\tsmallest_sizes = {}\n\t\tidx = 0\n\t\t@input.lines.each_slice(4) do |before,input,after,_|\n\t\t\tsamples += 1\n\t\t\tregisters = /Before:\\s+\\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/.match(before)[1..-1].map(&:to_i)\n\t\t\texpected_regs = /After:\\s+\\[(\\d+), (\\d+), (\\d+), (\\d+)\\]/.match(after)[1..-1].map(&:to_i)\n\n\t\t\top, a, b, out = /(\\d+) (\\d+) (\\d+) (\\d+)/.match(input)[1..-1].map(&:to_i)\n\n\t\t\tidx += 4\n\t\t\trs = nil\n\t\t\tpossibles = OPCODES.select do |opcode,oper|\n\t\t\t\trs = registers.dup\n\t\t\t\toper.call(rs,a,b,out)\n\t\t\t\trs == expected_regs\n\t\t\tend\n\n\t\t\tpart1_count += 1 if possibles.size >= 3\n\t\t\tif possibles.size == 1\n\t\t\t\topcodes[op] = possibles.keys.first\n\t\t\t\tsmallest_sizes[op] = 1\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif opcodes[op].nil?\n\t\t\t\t\t\topcodes[op] = possibles.keys\n\t\t\t\t\t\tsmallest_sizes[op] = possibles.keys.size\n\t\t\t\t\telsif opcodes[op].is_a?(Array)\n\t\t\t\t\t\tintersection = opcodes[op] & possibles.keys\n\t\t\t\t\t\tif smallest_sizes[op] > intersection.size\n\t\t\t\t\t\t\tsmallest_sizes[op] = intersection.size\n\t\t\t\t\t\tend\n\t\t\t\t\t\topcodes[op] = intersection\n\t\t\t\t\t\tif opcodes[op].size == 1\n\t\t\t\t\t\t\topcodes[op] = opcodes[op].first\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\trescue => e\n\t\t\t\t\tputs e\n\t\t\t\t\tputs op\n\t\t\t\t\tputs possibles.keys\n\t\t\t\t\tputs opcodes\n\t\t\t\t\tputs smallest_sizes\n\t\t\t\t\traise\n\t\t\t\tend\n\t\t\tend\n\t\trescue\n\t\t\tbreak\n\t\tend\n\n\t\tchanged = true\n\t\tuntil !changed do\n\t\t\tchanged = false\n\t\t\tknown_ops = opcodes.values.select{|op| op.is_a?(Symbol)}\n\t\t\topcodes.each do |k,v|\n\t\t\t\tnext if v.is_a?(Symbol)\n\t\t\t\tres = v - known_ops\n\t\t\t\tif res != v\n\t\t\t\t\tchanged = true\n\t\t\t\t\tif res.size == 1\n\t\t\t\t\t\topcodes[k] = res.first\n\t\t\t\t\telse\n\t\t\t\t\t\topcodes[k] = res\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tputs \"There are #{opcodes.values.uniq.size} known opcocdes\"\n\t\tputs \"There are #{part1_count} samples out of #{samples} that behave like 3 or more opcodes\"\n\n\t\tregisters = [0,0,0,0]\n\t\tinstrs = 0\n\t\t@lines[idx..-1].each do |line|\n\t\t\tnext if line.empty?\n\t\t\tinstrs += 1\n\t\t\tif instrs == 1\n\t\t\t\tputs \"The first instruction is #{line}\"\n\t\t\tend\n\t\t\top, a, b, out = /(\\d+) (\\d+) (\\d+) (\\d+)/.match(line)[1..-1].map(&:to_i)\n\t\t\tOPCODES[opcodes[op]].call(registers,a,b,out)\n\t\tend\n\n\t\tputs \"The value of register 0 after running the program is #{registers.join(\" \")} (#{instrs} instructions were run)\"\n\tend\n\n\nTabs?! In Ruby?! HERESY!", "id": "ebw8q6u", "owner_tier": 0.3, "score": 0.07407407370370371}, {"content": "Although no longer trendy - I tend to solve these in Perl - as usually it's the best language (without going to compiled languages like C) especially when this version codes really quickly... Took too long for (a) as I didn't read what answer was being looked for and solved part (b) first {I'd optimized out the checking code was valid} ... code below...  \n\n\nSteps - are set up opcode map, read in input into training set and real input (possibly the hardest bit of the code <g>, looping through all reading sets and working out which opcodes are possible...; reducing this set into the final map and then applying it to the real input...  \n\n\nExecution is very fast - wrong timezone to get on leaderboard!\n\n    my %ops = (\n      'addr' => sub { return $_[0][$_[1]] +  $_[0][$_[2]]  },\n      'addi' => sub { return $_[0][$_[1]] +        $_[2]   },\n      'mulr' => sub { return $_[0][$_[1]] *  $_[0][$_[2]]  },\n      'muli' => sub { return $_[0][$_[1]] *        $_[2]   },\n      'banr' => sub { return $_[0][$_[1]] &  $_[0][$_[2]]  },\n      'bani' => sub { return $_[0][$_[1]] &        $_[2]   },\n      'borr' => sub { return $_[0][$_[1]] |  $_[0][$_[2]]  },\n      'bori' => sub { return $_[0][$_[1]] |        $_[2]   },\n      'setr' => sub { return $_[0][$_[1]]                  },\n      'seti' => sub { return       $_[1]                   },\n      'gtir' => sub { return       $_[1]  >  $_[0][$_[2]] ? 1 : 0 },\n      'gtri' => sub { return $_[0][$_[1]] >        $_[2]  ? 1 : 0 },\n      'gtrr' => sub { return $_[0][$_[1]] >  $_[0][$_[2]] ? 1 : 0 },\n      'eqir' => sub { return       $_[1]  == $_[0][$_[2]] ? 1 : 0 },\n      'eqri' => sub { return $_[0][$_[1]] ==       $_[2]  ? 1 : 0 },\n      'eqrr' => sub { return $_[0][$_[1]] == $_[0][$_[2]] ? 1 : 0 },\n    );\n    \n    open my $fh, q(<), 'in.txt';\n    while(my $row = <$fh>) {\n      if( $row =~ m{Before:} ) {\n        push @tr, [[ $row =~ m{(\\d+)}g ],[ <$fh> =~ m{(\\d+)}g ],[ <$fh> =~ m{(\\d+)}g ]];\n      } elsif ( $row =~ m{\\d} ) {\n        push @in, [ $row =~ m{(\\d+)}g ];\n      }\n    }\n    \n    foreach my $e (@tr) {\n      my ($o,$a,$b,$c) = @{$e->[1]};\n      $poss{ $o }    ||= { map { $_=>1 } keys %ops };\n      foreach my $ro ( grep { exists $poss{$o}{$_} } keys %ops )\n        delete $poss{ $o }{ $ro } unless &{$ops{$ro}}( $e->[0], $a, $b ) == $e->[2][$c];\n      }\n    }\n    \n    while( scalar keys %poss ) {\n      my ($o)     = grep { 1 == scalar keys %{$poss{$_}} } keys %poss;\n      my ($ro)    = keys %{delete $poss{$o}};\n      $actual{$o} = $ro;\n      delete $poss{$_}{$ro} foreach grep { exists $poss{$_}{$ro} } keys %poss;\n    }\n    \n    $R[ $_->[3] ] = &{$ops{$actual{$_->[0]}}}(\\@R,$_->[1],$_->[2]) foreach @in;\n    \n    print \"$R[0]\\n\";", "id": "ebwcy13", "owner_tier": 0.1, "score": 0.07407407370370371}, {"content": "This one was way more my idea of fun than yesterday. \n\nAfter part 1, I figured out the right order for the commands by hand, then just re-ordered the enum accordingly.\n\nJava\n\nhttps://pastebin.com/hswcGrGf\n\n    public class Day16 extends AdventOfCode {\n    \n        public Day16(List<String> input) {\n            super(input);\n            title = \"Chronal Classification\";\n            part1Description = \"Samples with 3 or more valid opcodes: \";\n            part2Description = \"Value at register 0 after running test program: \";\n        }\n    \n        class Sample {\n            int[] before = new int[4];\n            int[] after = new int[4];\n            int[] codes = new int[4];\n        }\n    \n        List<Sample> samples;\n        List<int[]> program;\n    \n        class Operation {\n            int aReg;\n            int aVal;\n            int bReg;\n            int bVal;\n            int c;\n            Command cmd;\n    \n            public Operation(int aReg, int aVal, int bReg, int bVal, int c, Command cmd) {\n                this.aReg = aReg;\n                this.aVal = aVal;\n                this.bReg = bReg;\n                this.bVal = bVal;\n                this.c = c;\n                this.cmd = cmd;\n            }\n        }\n    \n    \n        enum Command {\n            EQRI(Command::eq, Command::ri),\n            BANI((x, y) -> x & y, Command::ri),\n            SETI((x, y) -> x, Command::ir),\n            BORI((x, y) -> x | y, Command::ri),\n            EQIR(Command::eq, Command::ir),\n            BANR((x, y) -> x & y, Command::rr),\n            BORR((x, y) -> x | y, Command::rr),\n            MULI((x, y) -> x * y, Command::ri),\n            SETR((x, y) -> x, Command::rr),\n            ADDR((x, y) -> x + y, Command::rr),\n            EQRR(Command::eq, Command::rr),\n            ADDI((x, y) -> x + y, Command::ri),\n            GTIR(Command::gt, Command::ir),\n            GTRR(Command::gt, Command::rr),\n            GTRI(Command::gt, Command::ri),\n            MULR((x, y) -> x * y, Command::rr);\n    \n    \n            IntBinaryOperator function;\n            ToIntFunction<Operation> opcode;\n            Command(IntBinaryOperator function, ToIntFunction<Operation> opcode) {\n                this.function = function;\n                this.opcode = opcode;\n            }\n    \n    \n            static int gt(int x, int y) {\n                return x > y ? 1 : 0;\n            }\n    \n            static int eq(int x, int y) {\n                return x == y ? 1 : 0;\n            }\n    \n            static int rr(Operation op) {\n                return op.cmd.function.applyAsInt(op.aReg, op.bReg);\n            }\n    \n            static int ri(Operation op) {\n                return op.cmd.function.applyAsInt(op.aReg, op.bVal);\n            }\n    \n            static int ir(Operation op) {\n                return op.cmd.function.applyAsInt(op.aVal, op.bReg);\n            }\n    \n        }\n    \n        void run(int[] reg, int[] codes, Command cmd) {\n            int a = codes[1];\n            int b = codes[2];\n            int c = codes[3];\n    \n            Operation op = new Operation(reg[a], a, reg[b], b, reg[c], cmd);\n            reg[codes[3]] = cmd.opcode.applyAsInt(op);\n        }\n    \n        @Override\n        public Object part1() {\n            int hasthree = 0;\n    \n            // use this to order enums for part 2\n            Map<Integer, Set<Command>> cmdmap = new HashMap<>();\n    \n            for (Sample sample : samples) {\n                int count = 0;\n                for (Command cmd : Command.values()) {\n                    int[] copy = new int[sample.before.length];\n                    System.arraycopy(sample.before, 0, copy, 0, sample.before.length);\n                    run(copy, sample.codes, cmd);;\n                    if (Arrays.equals(copy, sample.after)) {\n                        cmdmap.putIfAbsent(sample.codes[0], new HashSet<>());\n                        cmdmap.get(sample.codes[0]).add(cmd);\n                        count++;\n                    }\n                }\n                if (count > 2) hasthree++;\n            }\n            return hasthree;\n        }\n    \n        @Override\n        public Object part2() {\n            int[] register = { 0, 0, 0, 0 };\n            for (int[] line : program) {\n                run(register, line, Command.values()[line[0]]);\n            }\n            return register[0];\n        }\n    \n        @Override\n        public void parse() {\n            samples = new ArrayList<>();\n            program = new ArrayList<>();\n            boolean part2 = false;\n            Sample sample = new Sample();\n            samples.add(sample);\n            for (String line : input) {\n                if (line.equals(\"stop\")) {\n                    part2 = true;\n                    continue;\n                }\n                if (part2) {\n                    program.add(FileIO.StringArrayToInt(line.split(\" \")));\n                } else {\n                    if (line.isEmpty()) {\n                        sample = new Sample();\n                        samples.add(sample);\n                        continue;\n                    }\n                    if (line.startsWith(\"Before\")) {\n                        String[] split = line.substring(9, line.indexOf(']')).split(\", \");\n                        sample.before = FileIO.StringArrayToInt(split);\n                    } else {\n                        if (line.startsWith(\"After\")) {\n                            String[] split = line.substring(9, line.indexOf(']')).split(\", \");\n                            sample.after = FileIO.StringArrayToInt(split);\n                        } else {\n                            sample.codes = FileIO.StringArrayToInt(line.split(\" \"));\n                        }\n                    }\n                }\n    \n            }\n        }\n    \n    }\n\nCleaned up and added code to solve the command order\n\nhttps://pastebin.com/9Kbeqgd5", "id": "ebwhyxk", "owner_tier": 0.9, "score": 0.14814814777777777}, {"content": "(This taken also from my **[Daily Haskell Reflecitons](https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md#day-16)** blog!)\n\n---------------\n\nToday was fun because I got to re-use some techniques I discussed in a blog\npost I've written in the past: [Send More Money: List and\nStateT][send-more-money].  I talk about using `StateT` over `[]` to do\nimplement prolog-inspired constraint satisfaction searches while taking\nadvantage of laziness.\n\n[send-more-money]: https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html\n\nFirst of all, our types.  I'll be using the *[vector-sized][]* library with\n*[finite-typelits][]* to help us do safe indexing.  A `Vector n a` is a vector\nof `n` `a`s, and a `Finite n` is a legal index into such a vector.  For\nexample, a `Vector 4 Int` is a vector of 4 `Int`s, and `Finite 4` is 0, 1, 2,\nor 3.\n\n[vector-sized]: https://hackage.haskell.org/package/vector-sized\n[finite-typelits]: https://hackage.haskell.org/package/finite-typelits\n\n\timport           Data.Vector.Sized (Vector)\n\timport           Data.Finite       (Finite)\n\n\ttype Reg = Vector 4 Int\n\n\tdata Instr a = I { _iOp  :: a\n\t                 , _iInA :: Finite 4\n\t                 , _iInB :: Finite 4\n\t                 , _iOut :: Finite 4\n\t                 }\n\t  deriving (Show, Functor)\n\n\tdata Trial = T { _tBefore :: Reg\n\t               , _tInstr  :: Instr (Finite 16)\n\t               , _tAfter  :: Reg\n\t               }\n\t  deriving Show\n\n\tdata OpCode = OAddR | OAddI\n\t            | OMulR | OMulI\n\t            | OBanR | OBanI\n\t            | OBorR | OBorI\n\t            | OSetR | OSetI\n\t            | OGtIR | OGtRI | OGtRR\n\t            | OEqIR | OEqRI | OEqRR\n\t  deriving (Show, Eq, Ord, Enum, Bounded)\n\nWe can leave `Instr` parameterized over the opcode type so that we can use it\nwith `Finite 16` initially, and `OpCode` later.\n\nWe do need to implement the functionality of each op, which we can do by\npattern matching on an `OpCode`.  We use some lens functionality to simplify\nsome of the editing of indices, but we could also just manually modify indices.\n\n\trunOp :: Instr OpCode -> Reg -> Reg\n\trunOp I{..} = case _iOp of\n\t    OAddR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  +  r ^. V.ix _iInB\n\t    OAddI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  +  fromIntegral _iInB\n\t    OMulR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  *  r ^. V.ix _iInB\n\t    OMulI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA  *  fromIntegral _iInB\n\t    OBanR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .&. r ^. V.ix _iInB\n\t    OBanI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .&. fromIntegral _iInB\n\t    OBorR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .|. r ^. V.ix _iInB\n\t    OBorI -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA .|. fromIntegral _iInB\n\t    OSetR -> \\r -> r & V.ix _iOut .~ r ^. V.ix _iInA\n\t    OSetI -> \\r -> r & V.ix _iOut .~                     fromIntegral _iInA\n\t    OGtIR -> \\r -> r & V.ix _iOut . enum .~ (fromIntegral _iInA  > r ^. V.ix _iInB   )\n\t    OGtRI -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA     > fromIntegral _iInB)\n\t    OGtRR -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA     > r ^. V.ix _iInB   )\n\t    OEqIR -> \\r -> r & V.ix _iOut . enum .~ (fromIntegral _iInA == r ^. V.ix _iInB   )\n\t    OEqRI -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA    == fromIntegral _iInB)\n\t    OEqRR -> \\r -> r & V.ix _iOut . enum .~ (r ^. V.ix _iInA    == r ^. V.ix _iInB   )\n\nNow, from a `Trial`, we can get a set of `OpCode`s that are plausible\ncandidates if the output matches the expected output for a given `OpCode`, for\nthe given input.\n\n\tplausible :: Trial -> Set OpCode\n\tplausible T{..} = S.fromList (filter tryTrial [OAddR ..])\n\t  where\n\t    tryTrial :: OpCode -> Bool\n\t    tryTrial o = runOp (_tInstr { _iOp = o }) _tBefore == _tAfter\n\nPart 1 is, then, just counting the trials with three or more plausible\ncandidates:\n\n\tday16a :: [Trial] -> Int\n\tday16a = length . filter ((>= 3) . S.size . plausible)\n\nPart 2 is where we can implement our constraint satisfaction search.  Following\n[this blog post][send-more-money], we can write a search using `StateT (Set\nOpCode) []`.  Our state will be the `OpCode`s that we have already used.  We\nfill up a vector step-by-step, by picking only `OpCode`s that have not been\nused yet:\n\n\tfillIn :: Set OpCode -> StateT (Set OpCode) [] OpCode\n\tfillIn candidates = do\n\t    unseen <- gets (candidates `S.difference`)  -- filter only unseen candidates\n\t    pick   <- lift $ toList unseen              -- branch on all unseen candidates\n\t    modify $ S.insert pick                      -- in this branch, 'pick' is seen\n\t    pure pick                                   -- return our pick for the branch\n\nNow, if we have a map of `Finite 16` (op code numbers) to their candidates (a\n`Map (Finite 16) (Set OpCode)`), we can populate all legal\nconfigurations.  We'll use `Vector 16 OpCode` to represent our configuration:\n`0` will represent the first item, `1` will represent the second, etc.  We can\nuse `V.generate :: (Finite n -> m a) -> m (Vector n a)`, and run our `fillIn`\naction for every `Finite n`.\n\n\tfillVector\n\t    :: Map (Finite 16) (Set OpCode)\n\t    -> StateT (Set OpCode) [] (Vector 16 OpCode)\n\tfillVector candmap = V.generateM $ \\i -> do\n\t    Just cands <- pure $ M.lookup i candmap\n\t    fillIn cands\n\n\tfromClues\n\t    :: Map (Finite 16) (Set OpCode)\n\t    -> Maybe (Vector 16 OpCode)\n\tfromClues m = listToMaybe $ evalStateT (fillVector m) S.empty\n\nIf this part is confusing, the [blog post][send-more-money] explains how\n`StateT` and `[]`, together, give you this short-circuting search behavior!\n\nSo our Part 2 is using `fromClues` from all of the candidates (making sure to\ndo a set intersection if we get more than one clue for an opcode number), and a\n`foldl'` over our instruction list:\n\n\tday16b :: [Trial] -> [Instr (Finite 16)] -> Int\n\tday16b ts = V.head . foldl' step (V.replicate 0)\n\t  where\n\t    candmap    = M.fromListWith S.intersection\n\t               $ [ (_iOp (_tInstr t), plausible t)\n\t                 | t <- ts\n\t                 ]\n\t    Just opMap = fromClues candmap\n\t    step r i = runOp i' r\n\t      where\n\t        i' = (opMap `V.index`) <$> i", "id": "ebwk4w0", "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "**K**:\n\n    addr:{r[z]:r[x]+r y}\n    addi:{r[z]:r[x]+y}\n    mulr:{r[z]:r[x]*r y}\n    muli:{r[z]:r[x]*y}\n    banr:{r[z]:bd db[r x]&db r y}\n    bani:{r[z]:bd db[r x]&db y}\n    borr:{r[z]:bd db[r x]|db r y}\n    bori:{r[z]:bd db[r x]|db y}\n    setr:{r[z]:r x}\n    seti:{r[z]:x}\n    gtir:{r[z]:0+x>r y}\n    gtri:{r[z]:0+r[x]>y}\n    gttr:{r[z]:0+r[x]>r y}\n    eqir:{r[z]:0+x=r y}\n    eqri:{r[z]:0+r[x]=y}\n    eqrr:{r[z]:0+r[x]=r y}\n    instr:16#!`.\n    r:4#0\n    db:{((8-#c)#0b),c:|1_*+({x 1}{(1=x-2*d;d:div[x:x 1;2])}\\(0b;x))} /8bit binary\n    bd:{`long$+/2 xexp &|x}\n    input:.q.cut[4]3136#i:{.?[x in .Q.n;x;\" \"]}'0:`p16\n    process:{[state;cmd;instruction]r::state;`.[instruction]. 1_cmd;r}\n    handle:{[before;cmd;after]after~/:process[before;cmd;]'instr}\n    +/2<+/'handle .'3#'input\n    /part 2 - converge extract cmds that are the only match\n    lookup:()!()\n    find:{i:last@&1=+/'x;cmd:input[i;1;0];col:&x@i;\n    \tif[~^*col;lookup[cmd]:*instr col;x[;col]:0b];x}\n    find/handle .'3#'input;\n    r:4#0;{`.[lookup x 0]. 1_x}'3138_i;r 0\n\nTo decipher the instructions I looked for the commands that were the single correct option in a test run.  Somehow using the first match didn't converge but the last did. Also had to throw in a binary-to-decimal convertor as K doesn't have native bitwise operators.", "id": "ebwq9dg", "owner_tier": 0.1, "score": 0.07407407370370371}, {"content": "Python 3, 8/10. I just need to get better at input parsing.\n\n[Card] copy/paste\n\n    cases = []\n    testprog = []\n    with open('16.txt') as inp:\n        while True:\n            before = inp.readline()\n            if before == '\\n': break\n            before = eval(before[8:])\n            opc, *args = map(int,inp.readline().split())\n            after = eval(inp.readline()[8:])\n            assert inp.readline() == '\\n'\n            cases.append((before, opc, args, after))\n        inp.readline()\n        while True:\n            line = inp.readline()\n            if line == '': break\n            if line == '\\n': break\n            opc, *args = map(int,line.split())\n            testprog.append((opc,args))\n\n    def addr(regs,a,b,c):\n        regs[c]=regs[a]+regs[b]\n    def addi(regs,a,b,c):\n        regs[c]=regs[a]+b\n\n    def mulr(regs,a,b,c):\n        regs[c]=regs[a]*regs[b]\n    def muli(regs,a,b,c):\n        regs[c]=regs[a]*b\n\n    def banr(regs,a,b,c):\n        regs[c]=regs[a]&regs[b]\n    def bani(regs,a,b,c):\n        regs[c]=regs[a]&b\n\n    def borr(regs,a,b,c):\n        regs[c]=regs[a]|regs[b]\n    def bori(regs,a,b,c):\n        regs[c]=regs[a]|b\n\n    def setr(regs,a,b,c):\n        regs[c]=regs[a]\n    def seti(regs,a,b,c):\n        regs[c]=a\n\n    def gtir(regs,a,b,c):\n        regs[c]=1 if a>regs[b] else 0\n    def gtri(regs,a,b,c):\n        regs[c]=1 if regs[a]>b else 0\n    def gtrr(regs,a,b,c):\n        regs[c]=1 if regs[a]>regs[b] else 0\n\n    def eqir(regs,a,b,c):\n        regs[c]=1 if a==regs[b] else 0\n    def eqri(regs,a,b,c):\n        regs[c]=1 if regs[a]==b else 0\n    def eqrr(regs,a,b,c):\n        regs[c]=1 if regs[a]==regs[b] else 0\n\n    insns = ['addr','addi','mulr','muli','banr','bani','borr','bori','setr','seti','gtir','gtri','gtrr','eqir','eqri','eqrr']\n\n    def main():\n        op_to_insn = {}\n        cool = 0\n        done_cases = []\n        for before, opc, args, after in cases:\n            works = []\n            for insn in insns:\n                regs = list(before)\n                insn = globals()[insn]\n                insn(regs,*args)\n                if regs == after:\n                    works.append(insn)\n            #print(works)\n            done_cases.append((opc, works))\n        print(cool)\n        while True:\n            for c in done_cases:\n                op = c[0]\n                if len(c[1]) == 1:\n                    op_to_insn[op] = c[1][0]\n                    for c in done_cases:\n                        try:\n                            c[1].remove(op_to_insn[op])\n                        except ValueError: pass\n                    break\n            else:\n                break\n\n        regs = [0]*4\n        for opc, args in testprog:\n            op_to_insn[opc](regs,*args)\n        print(regs[0])\n\n        print(op_to_insn)\n\n    if __name__ == '__main__':\n        main()\n\n> [Card] copy/paste\n\nSo, StackOverflow?  >_>\n\nFor the instructions, I wrote the add one and copy pasted the rest", "id": "ebw79n8", "owner_tier": 0.3, "score": 0.22222222185185186}, {"content": "Unlike yesterday, this one was a breeze! :)\n15/21\n\n    import sys\n    from collections import defaultdict as dd, deque\n\n    R = [0]*4\n\n    # Super fun implementing all these functions...\n    def addr(a,b,c): R[c] = R[a] + R[b]\n    def addi(a,b,c): R[c] = R[a] + b\n\n    def mulr(a,b,c): R[c] = R[a] * R[b]\n    def muli(a,b,c): R[c] = R[a] * b\n\n    def banr(a,b,c): R[c] = R[a] & R[b]\n    def bani(a,b,c): R[c] = R[a] & b\n\n    def borr(a,b,c): R[c] = R[a] | R[b]\n    def bori(a,b,c): R[c] = R[a] | b\n\n    def setr(a,b,c): R[c] = R[a]\n    def seti(a,b,c): R[c] = a\n\n    def gtir(a,b,c): R[c] = int(a > R[b])\n    def gtri(a,b,c): R[c] = int(R[a] > b)\n    def gtrr(a,b,c): R[c] = int(R[a] > R[b])\n\n    def eqir(a,b,c): R[c] = int(a == R[b])\n    def eqri(a,b,c): R[c] = int(R[a] == b)\n    def eqrr(a,b,c): R[c] = int(R[a] == R[b])\n\n    L = list(sys.stdin)\n\n    ### Part 1 ###\n    ops = [addr, addi, mulr, muli,\n           banr, bani, borr, bori,\n           setr, seti, gtir, gtri,\n           gtrr, eqir, eqri, eqrr]\n\n    opcode = dd(set)\n\n    res = 0\n    i = 0\n    while i < len(L):\n        if L[i] == L[i+1] == '\\n':\n            i += 2\n            break\n\n        orig = eval(L[i].split(':')[1])\n        o,a,b,c = map(int,L[i+1].split())\n        Ra = eval(L[i+2].split(':')[1])\n        \n        count = 0\n        for op in ops:\n            R = orig[:]\n            op(a,b,c)\n            if R == Ra:\n                count += 1\n                opcode[op].add(o)\n        if count >= 3:\n            res += 1\n        i += 4\n\n    print('3+ ops:',res)\n\n    ### Part 2 ###\n    \"\"\"\n    opcode = {eqir: {0, 1, 2, 3, 5, 6, 7, 8, 12, 13, 14, 15},\n              eqrr: {2, 5, 6, 7, 8, 13, 15},\n              gtri: {0, 1, 2, 3, 5, 7, 8, 11, 15},\n              gtrr: {0, 1, 2, 3, 5, 8, 11, 13, 15},\n              eqri: {1, 2, 3, 5, 8, 12, 13, 15},\n              banr: {5, 8, 11, 12, 13, 15},\n              bani: {1, 5, 11, 12, 13, 15},\n              seti: {1, 4, 5, 9, 11},\n              gtir: {1, 2, 5, 8, 10, 11, 13, 15},\n              muli: {1, 11, 12, 13},\n              bori: {1, 11, 12},\n              setr: {1, 10, 11, 12},\n              addr: {9, 11, 4, 1},\n              addi: {9, 11, 1},\n              borr: {1, 11},\n              mulr: {11}}\n    \"\"\"\n\n    # (...manual labor...)\n\n    oplist = [gtrr, borr, gtir, eqri,\n              addr, seti, eqrr, gtri,\n              banr, addi, setr, mulr,\n              bori, muli, eqir, bani]\n\n    for line in L[i:]:\n        o,a,b,c = map(int,line.split())\n        oplist[o](a,b,c)\n\n    print('Register state:',R)\n", "id": "ebw7cc7", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "C++ -- 75/62. I followed my typical style of embedding my input into the program and formatting it with multiple cursors into a datastructure; unfortunately it took a good 30 seconds or so to compile all the static data, which probably lost me a few spots :D\n\nCleaned it up here to actually read the file.\n\n\t#include \"assert.h\"\n\n\t#include <map>\n\t#include <set>\n\t#include <list>\n\t#include <stack>\n\t#include <array>\n\t#include <deque>\n\t#include <string>\n\t#include <vector>\n\t#include <fstream>\n\t#include <functional>\n\t#include <unordered_set>\n\n\t#include \"utils.h\"\n\t#include \"tinyformat.h\"\n\n\n\tusing registers_t = std::array<int, 4>;\n\n\n\n\tregisters_t compute(const registers_t& before, int real_opcode, int a, int b, int c)\n\t{\n\t\tregisters_t out = before;\n\t\t/* addr */      if(real_opcode == 0)        out[c] = out[a] + out[b];\n\t\t/* addi */      else if(real_opcode == 1)   out[c] = out[a] + b;\n\t\t/* mulr */      else if(real_opcode == 2)   out[c] = out[a] * out[b];\n\t\t/* muli */      else if(real_opcode == 3)   out[c] = out[a] * b;\n\t\t/* andr */      else if(real_opcode == 4)   out[c] = out[a] & out[b];\n\t\t/* andi */      else if(real_opcode == 5)   out[c] = out[a] & b;\n\t\t/* orr */       else if(real_opcode == 6)   out[c] = out[a] | out[b];\n\t\t/* ori */       else if(real_opcode == 7)   out[c] = out[a] | b;\n\t\t/* setr */      else if(real_opcode == 8)   out[c] = out[a];\n\t\t/* seti */      else if(real_opcode == 9)   out[c] = a;\n\t\t/* ge (i/r) */  else if(real_opcode == 10)  (a > out[b]) ? out[c] = 1 : out[c] = 0;\n\t\t/* ge (r/i) */  else if(real_opcode == 11)  (out[a] > b) ? out[c] = 1 : out[c] = 0;\n\t\t/* ge (r/r) */  else if(real_opcode == 12)  (out[a] > out[b]) ? out[c] = 1 : out[c] = 0;\n\t\t/* eq (i/r) */  else if(real_opcode == 13)  (a == out[b]) ? out[c] = 1 : out[c] = 0;\n\t\t/* eq (r/i) */  else if(real_opcode == 14)  (out[a] == b) ? out[c] = 1 : out[c] = 0;\n\t\t/* eq (r/r) */  else if(real_opcode == 15)  (out[a] == out[b]) ? out[c] = 1 : out[c] = 0;\n\t\telse                                        assert(false);\n\n\t\treturn out;\n\t}\n\n\tstruct observation\n\t{\n\t\tobservation(const registers_t& b4, int op, int a, int b, int c, const registers_t& aft)\n\t\t\t: before(b4), opcode(op), a(a), b(b), c(c), after(aft) { }\n\n\t\tregisters_t before;\n\n\t\tint opcode;\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\n\t\tregisters_t after;\n\t};\n\n\tstruct instruction\n\t{\n\t\tinstruction(int o, int a, int b, int c) : opcode(o), a(a), b(b), c(c) { }\n\n\t\tint opcode;\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\t};\n\n\n\tint main()\n\t{\n\t\tstd::vector<instruction> program;\n\t\tstd::vector<observation> observations;\n\t\t{\n\t\t\tstd::vector<std::string> lines;\n\t\t\t{\n\t\t\t\tauto input = std::ifstream(\"day16/input.txt\", std::ios::in);\n\t\t\t\tfor(std::string line; std::getline(input, line); )\n\t\t\t\t\tlines.push_back(line);\n\t\t\t}\n\n\t\t\tfor(size_t i = 0; i < lines.size(); i++)\n\t\t\t{\n\t\t\t\tauto line = lines[i];\n\t\t\t\tif(line.find(\"Before\") == 0)\n\t\t\t\t{\n\t\t\t\t\tint br0, br1, br2, br3;\n\t\t\t\t\tsscanf(line.c_str(), \"Before: [%d, %d, %d, %d]\", &br0, &br1, &br2, &br3);\n\n\t\t\t\t\tline = lines[++i];\n\n\t\t\t\t\tint op, a, b, c;\n\t\t\t\t\tsscanf(line.c_str(), \"%d %d %d %d\", &op, &a, &b, &c);\n\n\t\t\t\t\tline = lines[++i];\n\n\t\t\t\t\tint ar0, ar1, ar2, ar3;\n\t\t\t\t\tsscanf(line.c_str(), \"After:  [%d, %d, %d, %d]\", &ar0, &ar1, &ar2, &ar3);\n\n\t\t\t\t\tobservations.push_back(observation({ br0, br1, br2, br3 }, op, a, b, c, { ar0, ar1, ar2, ar3 }));\n\n\t\t\t\t\t// empty line.\n\t\t\t\t\tline = lines[++i];\n\t\t\t\t}\n\t\t\t\telse if(line != \"\\n\")\n\t\t\t\t{\n\t\t\t\t\tint op, a, b, c;\n\t\t\t\t\tsscanf(line.c_str(), \"%d %d %d %d\", &op, &a, &b, &c);\n\n\t\t\t\t\tprogram.push_back(instruction(op, a, b, c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tstd::array<std::set<int>, 16> opcode_matches = { };\n\t\tstd::vector<int> matches;\n\n\t\tfor(const auto& obs : observations)\n\t\t{\n\t\t\tmatches.push_back(0);\n\n\t\t\tfor(int op = 0; op < 16; op++)\n\t\t\t{\n\t\t\t\tauto out = compute(obs.before, op, obs.a, obs.b, obs.c);\n\t\t\t\tif(out == obs.after)\n\t\t\t\t{\n\t\t\t\t\tmatches.back()++;\n\n\t\t\t\t\topcode_matches[op].insert(obs.opcode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto count = std::count_if(matches.begin(), matches.end(), [](int k) -> bool {\n\t\t\treturn k >= 3;\n\t\t});\n\n\t\ttfm::printfln(\"part 1: %d samples match 3 or more ops\", count);\n\n\n\t\t// maps from fake to real!\n\t\tstd::map<int, int> real_opcode_map;\n\n\n\t\twhile(real_opcode_map.size() < 16)\n\t\t{\n\t\t\tfor(int k = 0; k < 16; k++)\n\t\t\t{\n\t\t\t\tconst auto& fake_matches = opcode_matches[k];\n\n\t\t\t\tif(fake_matches.size() == 1)\n\t\t\t\t{\n\t\t\t\t\tint fake = *fake_matches.begin();\n\t\t\t\t\treal_opcode_map[fake] = k;\n\n\t\t\t\t\t// erase it from the rest.\n\t\t\t\t\tfor(int m = 0; m < 16; m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m == k) continue;\n\t\t\t\t\t\topcode_matches[m].erase(fake);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t{\n\t\t\tregisters_t state = { 0, 0, 0, 0 };\n\n\t\t\tfor(auto instr : program)\n\t\t\t{\n\t\t\t\tstate = compute(state, real_opcode_map[instr.opcode], instr.a, instr.b, instr.c);\n\t\t\t\t// tfm::printfln(\"part 2: register 0 has value %d\", state[0]);\n\t\t\t}\n\n\t\t\ttfm::printfln(\"part 2: register 0 has value %d\", state[0]);\n\t\t}\n\t}", "id": "ebw7iao", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "This space intentionally left blank.", "id": "ebw7sg5", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "**92**/290, I cannot believe I finally scored on the leaderboard! Yeah!\n\nI lost so much time because I switched keyboard from ITA layout to US layout around a week ago and I still very often type `a =+ b` instead of `a += b`... which doesn't even give a warning since is perfectly correct syntax, D'OH!\n\nGuess I'll have to post my solution now, I feel obliged. Here it is, the longest Python3 script you've ever seen:\n\n    #!/usr/bin/env python3\n\n    fin = open('inputs/2018_16.txt')\n    # print(*fin)\n\n    ##################################################\n\n    def simulate(r1, o, r2):\n        op, a, b, c = o\n        count = 0\n\n        # addr\n        if r2[c] == r1[a] + r1[b]: count += 1\n        elif 'addr' in ops[op]: ops[op].remove('addr')\n\n        # addi\n        if r2[c] == r1[a] + b: count += 1\n        elif 'addi' in ops[op]: ops[op].remove('addi')\n\n        # mulr\n        if r2[c] == r1[a] * r1[b]: count += 1\n        elif 'mulr' in ops[op]: ops[op].remove('mulr')\n\n        # muli\n        if r2[c] == r1[a] * b: count += 1\n        elif 'muli' in ops[op]: ops[op].remove('muli')\n\n        # banr\n        if r2[c] == r1[a] & r1[b]: count += 1\n        elif 'banr' in ops[op]: ops[op].remove('banr')\n\n        # bani\n        if r2[c] == r1[a] & b: count += 1\n        elif 'bani' in ops[op]: ops[op].remove('bani')\n\n        # borr\n        if r2[c] == r1[a] | r1[b]: count += 1\n        elif 'borr' in ops[op]: ops[op].remove('borr')\n\n        # bori\n        if r2[c] == r1[a] | b: count += 1\n        elif 'bori' in ops[op]: ops[op].remove('bori')\n\n        # setr\n        if r2[c] == r1[a]: count += 1\n        elif 'setr' in ops[op]: ops[op].remove('setr')\n\n        # seti\n        if r2[c] == a: count += 1\n        elif 'seti' in ops[op]: ops[op].remove('seti')\n\n        # gtir\n        t = 1 if a > r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'gtir' in ops[op]: ops[op].remove('gtir')\n\n        # gtri\n        t = 1 if r1[a] > b else 0\n        if r2[c] == t: count += 1\n        elif 'gtri' in ops[op]: ops[op].remove('gtri')\n\n        # gtrr\n        t = 1 if r1[a] > r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'gtrr' in ops[op]: ops[op].remove('gtrr')\n\n        # eqir\n        t = 1 if a == r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'eqir' in ops[op]: ops[op].remove('eqir')\n\n        # eqri\n        t = 1 if r1[a] == b else 0\n        if r2[c] == t: count += 1\n        elif 'eqri' in ops[op]: ops[op].remove('eqri')\n\n        # eqrr\n        t = 1 if r1[a] == r1[b] else 0\n        if r2[c] == t: count += 1\n        elif 'eqrr' in ops[op]: ops[op].remove('eqrr')\n\n        return count\n\n    def execute(opmap, machine_code, r1):\n        n, a, b, c = machine_code\n        mnemonic = opmap[n]\n\n        r2 = r1[:]\n\n        if   mnemonic == 'addr':\n            r2[c] = r1[a] + r1[b]\n        elif mnemonic == 'addi':\n            r2[c] = r1[a] + b\n        elif mnemonic == 'mulr':\n            r2[c] = r1[a] * r1[b]\n        elif mnemonic == 'muli':\n            r2[c] = r1[a] * b\n        elif mnemonic == 'banr':\n            r2[c] = r1[a] & r1[b]\n        elif mnemonic == 'bani':\n            r2[c] = r1[a] & b\n        elif mnemonic == 'borr':\n            r2[c] = r1[a] | r1[b]\n        elif mnemonic == 'bori':\n            r2[c] = r1[a] | b\n        elif mnemonic == 'setr':\n            r2[c] = r1[a]\n        elif mnemonic == 'seti':\n            r2[c] = a\n        elif mnemonic == 'gtir':\n            r2[c] = 1 if a > r1[b] else 0\n        elif mnemonic == 'gtri':\n            r2[c] = 1 if r1[a] > b else 0\n        elif mnemonic == 'gtrr':\n            r2[c] = 1 if r1[a] > r1[b] else 0\n        elif mnemonic == 'eqir':\n            r2[c] = 1 if a == r1[b] else 0\n        elif mnemonic == 'eqri':\n            r2[c] = 1 if r1[a] == b else 0\n        elif mnemonic == 'eqrr':\n            r2[c] = 1 if r1[a] == r1[b] else 0\n\n        return r2\n\n    def simplify(ops):\n        definitive = {}\n\n        while len(definitive) != 16:\n            added = []\n            for num, candidates in ops.items():\n                if len(candidates) == 1:\n                    assert num not in definitive\n\n                    definitive[num] = candidates.pop()\n                    added.append(num)\n\n            for k in added:\n                ops.pop(k)\n                op = definitive[k]\n\n                for kk in ops:\n                    if op in ops[kk]:\n                        ops[kk].remove(op)\n\n                        if len(ops[kk]) == 0:\n                            ops.pop(kk)\n\n        return definitive\n\n    names = ['addr','addi','mulr','muli','banr','bani','borr','bori','setr','seti','gtir','gtri','gtrr','eqir','eqri','eqrr']\n\n    ops = {}\n\n    for op in range(16):\n        ops[op] = set(names[:])\n\n    data = fin.read().split('\\n\\n\\n\\n')\n    sims = data[0].split('\\n\\n')\n\n    ans = 0\n\n    for s in sims:\n        before, op, after = s.split('\\n')\n\n        before = eval(before[before.find(':')+1:])\n        op     = list(map(int, op.split()))\n        after  = eval(after[after.find(':')+1:])\n\n        if simulate(before, op, after) >= 3:\n            ans += 1\n\n    print('Part 1:', ans)\n\n    ok = simplify(ops)\n\n    # for k, o in ok.items():\n    #     print(k, o)\n\n    program = list(map(lambda l: list(map(int, l.split())), data[1].strip().split('\\n')))\n\n    regs = [0] * 4\n\n    for instr in program:\n        regs = execute(ok, instr, regs)\n\n    ans2 = regs[0]\n\n    print('Part 2':, ans2)\n\n", "id": "ebw8fqe", "owner_tier": 0.7, "score": 0.03703703666666667}, {"content": "Python 3: Fun problem! Unlike yesterday's problem which gave me a headache (literally). \n\nPython's `eval` (This is dangerous kids; don't use it unless you are completely sure about the input) and `itertools.product` really helped in shortening the solution length and not having to code all the 16 opcode behaviour individually. 'yaml.load` helped in reading the 'Before' and 'After' register states easily.\n\n  \n    from copy import deepcopy  \n    from collections import defaultdict  \n    from itertools import product  \n    import yaml  \n      \n    test_cases = []  \n      \n    with open('Day16part1.txt') as i_stream:  \n        test_case = {}  \n        for line_count, line in enumerate(i_stream.readlines()):  \n            if line_count % 2 == 0:  \n                test_case.update(yaml.load(line))  \n            if line_count % 4 == 1:  \n                test_case['opcode'], test_case['A'], test_case['B'], test_case['C'] = map(int, line.split())  \n            if line_count % 4 == 3:  \n                test_cases.append(test_case)  \n                test_case = {}  \n      \n    overall_stats = []  \n      \n    def operation(A, B, C, registers, operation, variant):  \n        registers = deepcopy(registers)  \n        if operation in \"+*|&\":  \n            format_string = {'r': \"registers[A] {operation} registers[B]\", 'i': \"registers[A] {operation} B\"}  \n        elif operation == '=':  \n            format_string = {'r': \"registers[A]\", 'i': \"A\"}  \n        elif operation in ['>', '==']:  \n            format_string = {'rr': \"int(registers[A] {operation} registers[B])\",  \n                             'ri': \"int(registers[A] {operation} B)\",  \n                             'ir': \"int(A {operation} registers[B])\"}  \n      \n        result = eval(format_string[variant].format(operation=operation))  \n      \n        registers[C] = result  \n      \n        return registers  \n      \n    def test_all_opcodes(test):  \n        count = 0  \n        registers = test['Before']  \n        opcode = test['opcode']  \n        A, B, C = test['A'], test['B'], test['C']  \n        for oper, variant in product(\"+*|&=\", \"ri\"):  \n            result = operation(A, B, C, registers, oper, variant)  \n            if result == test['After']:  \n                count += 1  \n                overall_stats.append((opcode, oper, variant))  \n      \n        for oper, variant in product([\">\", \"==\"], [\"ri\", \"rr\", \"ir\"]):  \n            result = operation(A, B, C, registers, oper, variant)  \n            if result == test['After']:  \n                count += 1  \n                overall_stats.append((opcode, oper, variant))  \n      \n        return count  \n      \n    answer = 0  \n    for test in test_cases:  \n        result = test_all_opcodes(test)  \n        answer += int(result >= 3)  \n      \n    print('part 1:', answer)  \n      \n    opcode_to_operation_map = defaultdict(set)  \n    for opcode,oper,variant in overall_stats:  \n        opcode_to_operation_map[opcode].add((oper, variant))  \n      \n    final_map = {}  \n    finalized = set()  \n    while len(final_map) != 16:  \n        for opcode, oper in opcode_to_operation_map.items():  \n            if len(oper) == 1:  \n                final_map[opcode] = list(oper)[0]  \n                finalized.update(oper)  \n            else:  \n                for item in finalized.intersection(oper):  \n                    oper.discard(item)  \n      \n    registers = [0]*4  \n      \n    with open('Day16part2.txt') as i_stream:  \n        for line in i_stream.readlines():  \n            opcode, A, B, C = map(int, line.split())  \n            oper, variant = final_map[opcode]  \n            registers = operation(A, B, C, registers, oper, variant)  \n      \n    print('part 2:', registers[0])  \n    \n\n\nYour formatting is... off...\n\nThe idea is all fine and dandy, but I think you lost more than you gained (time writing, nerves, loc, etc.)\n\nWriting is much faster with repetitive patterns when using a powerful text editor.  \nIt actually is shorter contrary to what you claim.  \nNot to mention readability.\n\nAs for reading the input, you could've done it much simpler;  \n1. turn every line into sequence of only digits (using regex or own function)  \n2. test\\_cases, program = split input on '\\\\n\\\\n\\\\n\\\\n'  \n3. read 3 (4) by 3 (4) lines from test\\_cases\n\nThis approach makes it super readable in my opinion.\n\ncheers!\n\n[here](https://github.com/MasterMedo/aoc/blob/master/2018/day/16.py) is my solution if you're interested.\n\nThanks for pointing it out! Edited it now. \n\nAh Yes, I see your point. Your solution is neat! It's simpler to understand. I guess I over-engineered my solution. ", "id": "ebwacxb", "owner_tier": 0.3, "score": 0.18518518481481483}, {"content": "[Card] SMT Solver\n\nC++ 345/603 (I made a typo in my function/register name map, took me way too long to find)\n\nIn step 1 I outputted the possible assignments as an SMTLIB2 program, which I pushed through Z3 to obtain the assignment of registers. This needed to be copied over manually, but hey, at least I don't have to write a solver manually.\n\n[Paste as I'm unable to get Reddit code formatting to work](https://pastebin.com/mM6i6Lwe)", "id": "ebwaf85", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "**Q**:\n\n    //WTF these are still not built in in 2018?!\n    .q.bitand:{0b sv (0b vs x)and 0b vs y};\n    .q.bitor:{0b sv (0b vs x)or 0b vs y};\n\n    d16ins:()!();\n    d16ins[`addr]:{[op;reg]reg[op 3]:reg[op 1]+reg[op 2];reg};\n    d16ins[`addi]:{[op;reg]reg[op 3]:reg[op 1]+op 2;reg};\n    d16ins[`mulr]:{[op;reg]reg[op 3]:reg[op 1]*reg[op 2];reg};\n    d16ins[`muli]:{[op;reg]reg[op 3]:reg[op 1]*op 2;reg};\n    d16ins[`banr]:{[op;reg]reg[op 3]:reg[op 1] bitand reg[op 2];reg};\n    d16ins[`bani]:{[op;reg]reg[op 3]:reg[op 1] bitand op 2;reg};\n    d16ins[`borr]:{[op;reg]reg[op 3]:reg[op 1] bitor reg[op 2];reg};\n    d16ins[`bori]:{[op;reg]reg[op 3]:reg[op 1] bitor op 2;reg};\n    d16ins[`setr]:{[op;reg]reg[op 3]:reg[op 1];reg};\n    d16ins[`seti]:{[op;reg]reg[op 3]:op 1;reg};\n    d16ins[`gtir]:{[op;reg]reg[op 3]:`long$op[1]>reg[op 2];reg};\n    d16ins[`gtri]:{[op;reg]reg[op 3]:`long$reg[op 1]>op 2;reg};\n    d16ins[`gtrr]:{[op;reg]reg[op 3]:`long$reg[op 1]>reg[op 2];reg};\n    d16ins[`eqir]:{[op;reg]reg[op 3]:`long$op[1]=reg[op 2];reg};\n    d16ins[`eqri]:{[op;reg]reg[op 3]:`long$reg[op 1]=op 2;reg};\n    d16ins[`eqrr]:{[op;reg]reg[op 3]:`long$reg[op 1]=reg[op 2];reg};\n\n    d16match:{[ins;c;bf;af]\n        paf:.[;(c;bf)]each ins#d16ins;\n        where paf~\\:af};\n\n    d16filt:{[poss;cba]\n        ins:cba[0][0];\n        match:d16match[poss ins;cba 0;cba 1;cba 2];\n        poss[ins]:poss[ins]inter match;\n        if[1=count poss[ins]; poss[til[16]except ins]:poss[til[16]except ins] except\\:poss[ins][0]];\n        poss};\n\n    d16p1:{\n        split:first where 0=3 msum count each x;\n        eff:4 cut -1_split#x;\n        code:value each eff[;1];\n        before:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;0];\n        after:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;2];\n        matches:d16match[key d16ins]'[code;before;after];\n        sum 3<=count each matches\n        };\n\n    d16p2:{\n        split:first where 0=3 msum count each x;\n        eff:4 cut -1_split#x;\n        test:value each (1+split) _x;\n        code:value each eff[;1];\n        before:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;0];\n        after:\"J\"$\", \"vs/:first each \"]\"vs/:last each\"[\"vs/:eff[;2];\n        poss:til[16]!16#enlist key d16ins;\n        poss2:d16filt/[poss;(;;)'[code;before;after]];\n        insmap:first each poss2;\n        first {[insmap;r;c]d16ins[insmap c 0][c;r]}[insmap]/[0 0 0 0;test]};\n", "id": "ebwarm9", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "**Common Lisp**\n\n**Part 1** is complete and can be found [here](https://github.com/rabuf/advent-of-code/blob/master/2018.16.org).\n\nI've created one function and corresponding predicate per opcode, and then iterated over all the inputs counting how many predicates match that particular input.\n\n~~I know how I'll do part 2, but I haven't finished it yet (it'll show up in that same link once it's done). Looking at the data I've already determined several of the opcodes, now I'm just writing a program to do it for me.~~\n\n**Part 2** is complete.\n\n    (unless (find-package :cl-ppcre)\n      (ql:quickload \"cl-ppcre\"))\n    (unless (find-package :iterate)\n      (ql:quickload \"iterate\"))\n    (defpackage :aoc-2018-16\n      (:use :common-lisp\n            :iterate)\n      (:export :problem-a\n               :problem-b))\n    (in-package :aoc-2018-16)\n    \n    (defun addr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (+ (aref registers a)\n                 (aref registers b)))\n        registers))\n    (defun addrp (pre command post)\n      (equalp (addr (copy-seq pre) command) post))\n    \n    (defun addi (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (+ (aref registers a)\n                 b))\n        registers))\n    (defun addip (pre command post)\n      (equalp (addi (copy-seq pre) command) post))\n    (defun mulr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (* (aref registers a)\n                 (aref registers b)))\n        registers))\n    (defun mulrp (pre command post)\n      (equalp (mulr (copy-seq pre) command) post))\n    \n    (defun muli (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (* (aref registers a)\n                 b))\n        registers))\n    (defun mulip (pre command post)\n      (equalp (muli (copy-seq pre) command) post))\n    (defun banr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logand (aref registers a)\n                      (aref registers b)))\n        registers))\n    (defun banrp (pre command post)\n      (equalp (banr (copy-seq pre) command) post))\n    \n    (defun bani (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logand (aref registers a)\n                      b))\n        registers))\n    (defun banip (pre command post)\n      (equalp (bani (copy-seq pre) command) post))\n    (defun borr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logior (aref registers a)\n                      (aref registers b)))\n        registers))\n    (defun borrp (pre command post)\n      (equalp (borr (copy-seq pre) command) post))\n    \n    (defun bori (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (logior (aref registers a)\n                      b))\n        registers))\n    (defun borip (pre command post)\n      (equalp (bori (copy-seq pre) command) post))\n    (defun setr (registers command)\n      (let ((a (aref command 1))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (aref registers a))\n        registers))\n    (defun setrp (pre command post)\n      (equalp (setr (copy-seq pre) command) post))\n    \n    (defun seti (registers command)\n      (let ((a (aref command 1))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              a)\n        registers))\n    (defun setip (pre command post)\n      (equalp (seti (copy-seq pre) command) post))\n    (defun gtir (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (> a (aref registers b)) 1 0))\n        registers))\n    (defun gtirp (pre command post)\n      (equalp (gtir (copy-seq pre) command) post))\n    \n    (defun gtri (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (> (aref registers a) b) 1 0))\n        registers))\n    (defun gtrip (pre command post)\n      (equalp (gtri (copy-seq pre) command) post))\n    \n    (defun gtrr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (> (aref registers a) (aref registers b)) 1 0))\n        registers))\n    (defun gtrrp (pre command post)\n      (equalp (gtrr (copy-seq pre) command) post))\n    (defun eqir (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (= a (aref registers b)) 1 0))\n        registers))\n    (defun eqirp (pre command post)\n      (equalp (eqir (copy-seq pre) command) post))\n    \n    (defun eqri (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (= (aref registers a) b) 1 0))\n        registers))\n    (defun eqrip (pre command post)\n      (equalp (eqri (copy-seq pre) command) post))\n    \n    (defun eqrr (registers command)\n      (let ((a (aref command 1))\n            (b (aref command 2))\n            (c (aref command 3)))\n        (setf (aref registers c)\n              (if (= (aref registers a) (aref registers b)) 1 0))\n        registers))\n    (defun eqrrp (pre command post)\n      (equalp (eqrr (copy-seq pre) command) post))\n    (defun read-input (file)\n      (iter (for line in-file file using #'read-line)\n            (collect line)))\n    (defun parse-input (lines)\n      (let ((triples nil)\n            (instructions nil))\n        (iter (until (and (string= \"\" (car lines))\n                          (string= \"\" (cadr lines))))\n              (push (list (make-array 4 :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines))))\n                          (make-array 4 :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines))))\n                          (make-array 4 :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines)))))\n                    triples)\n              (pop lines))\n        (pop lines)\n        (pop lines)\n        (iter (while lines)\n              (push (make-array 4\n                                :initial-contents (mapcar #'parse-integer (ppcre:all-matches-as-strings \"\\\\d+\" (pop lines))))\n                    instructions))\n        (list triples (reverse instructions))))\n    (defparameter *input*\n      (parse-input (read-input \"input/16.txt\")))\n    (defun solve-a (to-test)\n      (let ((predicates (list #'addrp #'addip #'mulrp #'mulip\n                              #'banrp #'banip #'borrp #'borip\n                              #'setrp #'setip #'gtirp #'gtrip\n                              #'gtrrp #'eqirp #'eqrip #'eqrrp)))\n        (iter (for (pre command post) in to-test)\n              (count (iter (for p in predicates)\n                           (with i = 0)\n                           (when (funcall p pre command post)\n                             (incf i))\n                           (finally (return (>= i 3))))))))\n    (defun problem-a () (format t \"Problem 16 A: ~a~%\" (solve-a (car *input*))))\n    (defun tally-codes (to-test)\n      (let ((predicates (list #'addr #'addi #'mulr #'muli\n                              #'banr #'bani #'borr #'bori\n                              #'setr #'seti #'gtir #'gtri\n                              #'gtrr #'eqir #'eqri #'eqrr))\n            (mapping (make-hash-table)))\n        (iter (for p in predicates)\n              (let ((opcodes (iter (for (pre command post) in to-test)\n                                   (when (equalp (funcall p (copy-seq pre) command) post)\n                                     (collect (aref command 0))))))\n                (setf (gethash p mapping) (remove-duplicates opcodes))))\n        mapping))\n    (defun get-opcodes (to-test)\n      (let ((tally (tally-codes to-test))\n            (result (make-hash-table)))\n        (iter (until (iter (for (k v) in-hashtable tally)\n                           (always (= 1 (length v)))))\n              (iter (for (k v) in-hashtable tally)\n                    (when (= 1 (length v))\n                      (iter (for (k0 v0) in-hashtable tally)\n                            (unless (equal k k0)\n                              (setf (gethash k0 tally) (remove (car v) v0)))))))\n        (iter (for (k v) in-hashtable tally)\n              (setf (gethash (car v) result) k))\n        result))\n    (defun solve-b (to-test to-run)\n      (let ((codes (get-opcodes to-test))\n            (registers (make-array 4 :initial-element 0)))\n        (iter (for command in to-run)\n              (funcall (gethash (aref command 0) codes)\n                       registers\n                       command))\n        registers))\n    (defun problem-b () (format t \"Problem 16 B: ~a~%\" (solve-b (car *input*) (cadr *input*))))\n    (problem-a)\n    (problem-b)\n", "id": "ebwazi5", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "**C++**\n\nRather than using something like std::set. I used 16-bit integer bitmasks and reduced them all using fast bit-wise arithmetic.\n\n    #include <cstddef>\n    #include <cstdint>\n    #include <cstdio>\n    #include <algorithm>\n    #include <array>\n    \n    struct Device\n    {\n    \tusing RegisterState = std::array<std::uintmax_t,4>;\n    \tusing Instruction = RegisterState;\n    \tRegisterState Register;\n    \ttemplate< typename FunctorT , bool RegisterA = true, bool RegisterB = true>\n    \tstatic void OpRegister( RegisterState& Registers, std::size_t A, std::size_t B, std::size_t C )\n    \t{\n    \t\tFunctorT Function;\n    \t\tRegisters[C] = Function(\n    \t\t\tRegisterA ? Registers[A]:A,\n    \t\t\tRegisterB ? Registers[B]:B\n    \t\t);\n    \t}\n    \ttypedef void(*Operation)( RegisterState&,std::size_t,std::size_t,std::size_t);\n    \tconstexpr static std::array<Operation,16> Opcodes = {{\n    \t\t// addr\n    \t\tOpRegister<std::plus<std::size_t>, true, true>,\n    \t\t// addi\n    \t\tOpRegister<std::plus<std::size_t>, true, false>,\n    \t\t// mulr\n    \t\tOpRegister<std::multiplies<std::size_t>,true,true>,\n    \t\t// muli\n    \t\tOpRegister<std::multiplies<std::size_t>,true,false>,\n    \t\t// bandr\n    \t\tOpRegister<std::bit_and<std::size_t>,true,true>,\n    \t\t// bandi\n    \t\tOpRegister<std::bit_and<std::size_t>,true,false>,\n    \t\t// borr\n    \t\tOpRegister<std::bit_or<std::size_t>,true,true>,\n    \t\t// bori\n    \t\tOpRegister<std::bit_or<std::size_t>,true,false>,\n    \t\t// setr\n    \t\t[]( RegisterState& Registers, std::size_t A, std::size_t, std::size_t C ) constexpr -> void\n    \t\t{\n    \t\t\tRegisters[C] = Registers[A];\n    \t\t},\n    \t\t// seti\n    \t\t[]( RegisterState& Registers, std::size_t A, std::size_t, std::size_t C ) constexpr -> void\n    \t\t{\n    \t\t\tRegisters[C] = A;\n    \t\t},\n    \t\t// gtir\n    \t\tOpRegister<std::greater<std::size_t>,false,true>,\n    \t\t// gtri\n    \t\tOpRegister<std::greater<std::size_t>,true,false>,\n    \t\t// gtrr\n    \t\tOpRegister<std::greater<std::size_t>,true,true>,\n    \t\t// eqii\n    \t\tOpRegister<std::equal_to<std::size_t>,false,true>,\n    \t\t// eqri\n    \t\tOpRegister<std::equal_to<std::size_t>,true,false>,\n    \t\t// eqrr\n    \t\tOpRegister<std::equal_to<std::size_t>,true,true>\n    \t}};\n    };\n    \n    int main()\n    {\n    \tstd::array<std::uint16_t,16> OpcodeMapping = {0};\n    \tstd::size_t Tautology3 = 0;\n    \tDevice::RegisterState Before, After;\n    \tDevice::Instruction CurInstruction;\n    \twhile(\n    \t\tstd::fscanf(\n    \t\t\tstdin,\n    \t\t\t\"Before: [%zu , %zu, %zu, %zu]\"\n    \t\t\t\"%zu %zu %zu %zu \"\n    \t\t\t\"After: [%zu , %zu, %zu, %zu] \",\n    \t\t\t&Before[0], &Before[1], &Before[2], &Before[3],\n    \t\t\t&CurInstruction[0],&CurInstruction[1],&CurInstruction[2],&CurInstruction[3],\n    \t\t\t&After[0],  &After[1],  &After[2],  &After[3]\n    \t\t) == 12\n    \t)\n    \t{\n    \t\tstd::size_t Tautologous = 0;\n    \t\tfor(std::size_t i = 0; i < Device::Opcodes.size(); ++i )\n    \t\t{\n    \t\t\tDevice::RegisterState State(Before);\n    \t\t\tDevice::Opcodes[i](\n    \t\t\t\tState,CurInstruction[1],CurInstruction[2],CurInstruction[3]\n    \t\t\t);\n    \n    \t\t\tif(std::equal(State.begin(),State.end(),After.begin()) )\n    \t\t\t{\n    \t\t\t\tOpcodeMapping[CurInstruction[0]] |= 1 << i;\n    \t\t\t\tTautologous++;\n    \t\t\t}\n    \t\t}\n    \t\tTautology3 += Tautologous >= 3;\n    \t}\n    \tstd::printf(\"Part 1: %8zu\\n\",Tautology3);\n    \n    \t// Keep iterating until all mappings are reduced to equivalences\n    \twhile(\n    \t\tstd::any_of(\n    \t\t\tOpcodeMapping.begin(),OpcodeMapping.end(),\n    \t\t\t[](const std::uint16_t& Set) -> bool\n    \t\t\t{\n    \t\t\t\treturn __builtin_popcount(Set) != 1;\n    \t\t\t}\n    \t\t)\n    \t)\n    \t{\n    \t\tfor(std::size_t i = 0; i < OpcodeMapping.size(); ++i )\n    \t\t{\n    \t\t\t// Only 1 bit set in this set, solved\n    \t\t\tif( __builtin_popcount(OpcodeMapping[i]) == 1 )\n    \t\t\t{\n    \t\t\t\t// Remove it from all the other sets\n    \t\t\t\tfor(std::size_t j = 0; j < OpcodeMapping.size(); ++j )\n    \t\t\t\t{\n    \t\t\t\t\t// Skip itself\n    \t\t\t\t\tif( i == j )\n    \t\t\t\t\t{\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\tOpcodeMapping[j] &= ~(OpcodeMapping[i]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \n    \t// Log2 bit masks into integers\n    \tfor(std::size_t i = 0; i < OpcodeMapping.size(); ++i )\n    \t{\n    \t\tOpcodeMapping[i] = 32 - __builtin_clz(OpcodeMapping[i]) - 1;\n    \t}\n    \n    \tDevice::RegisterState Registers = {0};\n    \twhile(\n    \t\tstd::fscanf(\n    \t\t\tstdin,\n    \t\t\t\"%zu %zu %zu %zu \",\n    \t\t\t&CurInstruction[0], &CurInstruction[1], &CurInstruction[2], &CurInstruction[3]\n    \t\t) == 4\n    \t)\n    \t{\n    \t\tDevice::Opcodes[\n    \t\t\tOpcodeMapping[CurInstruction[0]]\n    \t\t](Registers,CurInstruction[1],CurInstruction[2],CurInstruction[3]);\n    \t}\n    \tstd::printf(\"Part 2: %8zu\\n\",Registers[0]);\n    \treturn EXIT_SUCCESS;\n    }", "id": "ebwg1r6", "owner_tier": 0.3, "score": 0.03703703666666667}, {"content": "**Rust**\n\nI <3 these puzzles, there's just something so satisfying with fiddling with pretend assembly for fake machines.\n\n\\[CARD\\] The secret technique to beat today's puzzles is sacrifice to the Great Old Ones.\n\n    use aoc2018::*;\n    \n    #[derive(Debug, Default, Clone, PartialEq, Eq)]\n    pub struct Device([u64; 4]);\n    \n    impl Device {\n        /// Try to decode a device.\n        /// Devices take the form `[a, b, c, d]` representing all registries.\n        pub fn decode(state: &str) -> Option<Device> {\n            let mut it = state\n                .trim_matches(|c| c == '[' || c == ']')\n                .split(\", \")\n                .flat_map(|d| str::parse(d).ok());\n    \n            Some(Device([it.next()?, it.next()?, it.next()?, it.next()?]))\n        }\n    \n        pub fn reg(&mut self, reg: u64) -> Result<&mut u64, Error> {\n            match self.0.get_mut(reg as usize) {\n                Some(reg) => Ok(reg),\n                None => bail!(\"no such register: {}\", reg),\n            }\n        }\n    }\n    \n    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n    pub enum OpCode {\n        Addr,\n        Addi,\n        Mulr,\n        Muli,\n        Banr,\n        Bani,\n        Borr,\n        Bori,\n        Setr,\n        Seti,\n        Gtir,\n        Gtri,\n        Gtrr,\n        Eqir,\n        Eqri,\n        Eqrr,\n    }\n    \n    impl OpCode {\n        /// Iterate over all variants.\n        fn variants() -> impl Iterator<Item = OpCode> {\n            use self::OpCode::*;\n    \n            vec![\n                Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori, Setr, Seti, Gtir, Gtri, Gtrr, Eqir,\n                Eqri, Eqrr,\n            ]\n            .into_iter()\n        }\n    \n        fn apply(&self, d: &mut Device, inputs: &[u64; 2], o: u64) -> Result<(), Error> {\n            use self::OpCode::*;\n    \n            let [a, b] = *inputs;\n    \n            *d.reg(o)? = match *self {\n                Addr => *d.reg(a)? + *d.reg(b)?,\n                Addi => *d.reg(a)? + b,\n                Mulr => *d.reg(a)? * *d.reg(b)?,\n                Muli => *d.reg(a)? * b,\n                Banr => *d.reg(a)? & *d.reg(b)?,\n                Bani => *d.reg(a)? & b,\n                Borr => *d.reg(a)? | *d.reg(b)?,\n                Bori => *d.reg(a)? | b,\n                Setr => *d.reg(a)?,\n                Seti => a,\n                Gtir => {\n                    if a > *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Gtri => {\n                    if *d.reg(a)? > b {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Gtrr => {\n                    if *d.reg(a)? > *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Eqir => {\n                    if a == *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Eqri => {\n                    if *d.reg(a)? == b {\n                        1\n                    } else {\n                        0\n                    }\n                }\n                Eqrr => {\n                    if *d.reg(a)? == *d.reg(b)? {\n                        1\n                    } else {\n                        0\n                    }\n                }\n            };\n    \n            Ok(())\n        }\n    }\n    \n    /// An instruction.\n    #[derive(Debug)]\n    pub struct Instruction {\n        op_code: u64,\n        inputs: [u64; 2],\n        output: u64,\n    }\n    \n    impl Instruction {\n        pub fn decode(state: &str) -> Option<Instruction> {\n            let mut it = state.split(\" \").flat_map(|d| str::parse(d).ok());\n    \n            Some(Instruction {\n                op_code: it.next()?,\n                inputs: [it.next()?, it.next()?],\n                output: it.next()?,\n            })\n        }\n    }\n    \n    #[derive(Debug, Default)]\n    struct Registry(HashMap<u64, HashSet<OpCode>>);\n    \n    impl Registry {\n        /// Try to reduce the number of definitive matches.\n        pub fn regress(&mut self) -> Vec<(u64, OpCode)> {\n            let mut known = Vec::new();\n            let mut current = 0;\n    \n            self.known(&mut known);\n    \n            while current != known.len() {\n                current = known.len();\n    \n                for (known_num, known_op) in known.iter().cloned() {\n                    for (num, values) in self.0.iter_mut() {\n                        if *num == known_num {\n                            values.clear();\n                            values.insert(known_op);\n                            continue;\n                        }\n    \n                        values.remove(&known_op);\n                    }\n                }\n    \n                known.clear();\n                self.known(&mut known);\n            }\n    \n            known\n        }\n    \n        /// Extract exactly known op-codes.\n        fn known(&self, known: &mut Vec<(u64, OpCode)>) {\n            for (key, value) in &self.0 {\n                if value.len() == 1 {\n                    if let Some(op) = value.iter().cloned().next() {\n                        known.push((*key, op));\n                    }\n                }\n            }\n        }\n    }\n    \n    struct Decoder {\n        codes: HashMap<u64, OpCode>,\n    }\n    \n    impl Decoder {\n        pub fn new(codes: impl IntoIterator<Item = (u64, OpCode)>) -> Decoder {\n            Decoder {\n                codes: codes.into_iter().collect(),\n            }\n        }\n    \n        pub fn decode(&self, code: u64) -> Result<OpCode, Error> {\n            match self.codes.get(&code).cloned() {\n                Some(op) => Ok(op),\n                None => bail!(\"no such op: {}\", code),\n            }\n        }\n    }\n    \n    fn main() -> Result<(), Error> {\n        let mut it = input_str!(\"day16.txt\").lines();\n    \n        let mut part1 = 0;\n    \n        let mut registry = Registry::default();\n    \n        // NB: all op codes are initially possible for all op numbers.\n        for c in 0..16u64 {\n            for op in OpCode::variants() {\n                registry.0.entry(c).or_default().insert(op);\n            }\n        }\n    \n        while let Some(test) = Test::decode(&mut it) {\n            let mut matches = HashSet::new();\n    \n            for op in OpCode::variants() {\n                let mut device = test.before.clone();\n                op.apply(&mut device, &test.inst.inputs, test.inst.output)?;\n    \n                if device == test.after {\n                    matches.insert(op);\n                } else {\n                    if let Some(codes) = registry.0.get_mut(&test.inst.op_code) {\n                        codes.remove(&op);\n                    }\n                }\n            }\n    \n            // definitive proof that a specific op-code is the one.\n            if matches.len() == 1 {\n                if let Some(op) = matches.iter().cloned().next() {\n                    if let Some(values) = registry.0.get_mut(&test.inst.op_code) {\n                        values.clear();\n                        values.insert(op);\n                    }\n                }\n            }\n    \n            if matches.len() >= 3 {\n                part1 += 1;\n            }\n        }\n    \n        let known = registry.regress();\n    \n        assert_eq!(known.len(), 16);\n        assert_eq!(part1, 596);\n    \n        let decoder = Decoder::new(known);\n    \n        assert_eq!(it.next(), Some(\"\"));\n    \n        let mut device = Device::default();\n    \n        for inst in it.flat_map(Instruction::decode) {\n            let op = decoder.decode(inst.op_code)?;\n            op.apply(&mut device, &inst.inputs, inst.output)?;\n        }\n    \n        assert_eq!(*device.reg(0)?, 554);\n        Ok(())\n    }\n    \n    #[derive(Debug)]\n    struct Test {\n        before: Device,\n        inst: Instruction,\n        after: Device,\n    }\n    \n    impl Test {\n        fn decode<'a>(it: &mut impl Iterator<Item = &'a str>) -> Option<Test> {\n            let before = it.next()?;\n    \n            if before == \"\" {\n                return None;\n            }\n    \n            let inst = it.next()?;\n            let after = it.next()?;\n            let blank = it.next()?;\n    \n            if !before.starts_with(\"Before: \") {\n                return None;\n            }\n    \n            if !after.starts_with(\"After: \") {\n                return None;\n            }\n    \n            if blank != \"\" {\n                return None;\n            }\n    \n            let before = Device::decode(before.split(\": \").nth(1)?.trim())?;\n            let inst = Instruction::decode(&inst)?;\n            let after = Device::decode(after.split(\": \").nth(1)?.trim())?;\n    \n            Some(Test {\n                before,\n                inst,\n                after,\n            })\n        }\n    }\n\n> [CARD] The secret technique to beat today's puzzles is sacrifice to the Great Old Ones.\n\n[A sacrifice](https://i.imgur.com/q5OdF0bm.jpg), you say?", "id": "ebwgq9u", "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "F#\n\n[Full code link](https://github.com/CameronAavik/AdventOfCode/blob/master/Challenges/2018/Day16.fs)\n\nToday's was fun to do in a functional language and figuring out how to express each of the 16 instructions in a short way. Here is an extract showing how I got that working:\n\n    let inst f v1 v2 c = set c (f v1 v2)\n    let instir f (a, b, c) regs = inst f a (get b regs) c regs\n    let instri f (a, b, c) regs = inst f (get a regs) b c regs\n    let instrr f (a, b, c) regs = inst f (get a regs) (get b regs) c regs\n    \n    let useFirst a _ = a\n    let gt a b = if a > b then 1 else 0\n    let eq a b = if a = b then 1 else 0\n    \n    // instructions\n    let addr = instrr (+)\n    let addi = instri (+)\n    let mulr = instrr (*)\n    let muli = instri (*)\n    let banr = instrr (&&&)\n    let bani = instri (&&&)\n    let borr = instrr (|||)\n    let bori = instri (|||)\n    let setr = instri useFirst\n    let seti = instir useFirst\n    let gtir = instir gt\n    let gtri = instri gt\n    let gtrr = instrr gt\n    let eqir = instir eq\n    let eqri = instri eq\n    let eqrr = instrr eq\n\nBenchmarks: Part 1 = 13.442ms, Part 2 = 7.382ms\n\nIt is interesting to see that part 2 is faster than part 1 here, but it makes sense because in part 1 we compare each sample with all 16 instructions. In part 2 we only need to compare each instruction against the samples grouped by opcode and we can terminate that comparison early if we find a sample that doesn't match.", "id": "ebwknjp", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "**FORTRAN**\n\n[Pastebin](https://pastebin.com/JeZzys9s). Decided to try out procedure pointers and figured out a way to get an array of pointers. Used the info from part 1 for which opcode/instruction combos didn't work with some simple logic to create an array mapping the opcodes to the correct elements of the procedure pointer array.", "id": "ebwugxe", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "**Perl 6** solution.  This one was fun, and a lot more straightforward than yesterday's.  I especially like how brief the instructions for part two are...\n\n    #!/usr/bin/env perl6\n    use v6.c;\n\n    $*OUT.out-buffer = False;   # Autoflush\n\n    # Advent of Code 2018 day 16 -- https://adventofcode.com/2018/day/16\n\n    enum Opcode <addr addi mulr muli banr bani borr bori setr seti gtir gtri gtrr eqir eqri eqrr>;\n\n    grammar WristDeviceInstructions\n    {\n        rule TOP { <sample>+ <test-program> }\n\n        rule sample { 'Before:' '[' <registers> ']'\n                      <input>\n                      'After:' '[' <registers> ']' }\n        rule registers { <n> ** 4 % ',' }\n        rule input { <n> ** 4 }\n\n        rule test-program { <program-line>+ }\n        rule program-line { <n> ** 4 }\n\n        token n { \\d+ }\n    }\n\n    class WristDevice\n    {\n        has @.register = 0 xx 4;\n        has @.samples;\n        has @.program;\n\n        has @.opcode-candidates = Opcode::.values.Set xx 16;\n        has @.opcode-by-id;\n\n        has Bool $.verbose = False;\n\n        # Actions for grammar WristDeviceInstructions\n        method sample($/)\n        {\n            @!samples.push: { :before($<registers>[0]<n>\u00bb.Int),\n                              :input($<input><n>\u00bb.Int),\n                              :after($<registers>[1]<n>\u00bb.Int) };\n        }\n        method program-line($/)\n        {\n            @.program.push: $<n>\u00bb.Int;\n        }\n\n        # Process an instruction\n        method process(Opcode $opcode, ($a, $b, $c))\n        {\n            given $opcode {\n                @!register[$c] = @!register[$a] + @!register[$b] when addr;\n                @!register[$c] = @!register[$a] + $b when addi;\n                @!register[$c] = @!register[$a] \u00d7 @!register[$b] when mulr;\n                @!register[$c] = @!register[$a] \u00d7 $b when muli;\n                @!register[$c] = @!register[$a] +& @!register[$b] when banr;\n                @!register[$c] = @!register[$a] +& $b when bani;\n                @!register[$c] = @!register[$a] +| @!register[$b] when borr;\n                @!register[$c] = @!register[$a] +| $b when bori;\n                @!register[$c] = @!register[$a] when setr;\n                @!register[$c] = $a when seti;\n                @!register[$c] = +($a > @!register[$b]) when gtir;\n                @!register[$c] = +(@!register[$a] > $b) when gtri;\n                @!register[$c] = +(@!register[$a] > @!register[$b]) when gtrr;\n                @!register[$c] = +($a == @!register[$b]) when eqir;\n                @!register[$c] = +(@!register[$a] == $b) when eqri;\n                @!register[$c] = +(@!register[$a] == @!register[$b]) when eqrr;\n            }\n        }\n\n        # Find any opcodes that match a sample instruction\n        method find-possible-opcodes($instr)\n        {\n            my @before = $instr<before>[];\n            my $id = $instr<input>[0];\n            my @input = $instr<input>[1..3];\n            my @after = $instr<after>[];\n            my @cand;\n\n            # For each possible opcode, set the before values of the register, perform the opcode\n            # and verify the after values.  If they match, this is a possible opcode.\n            for Opcode::.values.sort -> $opcode {\n                @!register = @before;\n                self.process($opcode, @input);\n                if @!register eqv @after {\n                    @cand.append($opcode);\n                }\n            }\n\n            # Limit the candidate opcodes for this ID to at most these candidates\n            @!opcode-candidates[$id] \u2229= @cand;\n\n            return @cand;\n        }\n\n        # Match opcode IDs to opcodes, based on the candidates found before.\n        method match-opcode-ids\n        {\n            for ^16 {\n                # Find an ID with only one possible opcode.\n                # If there isn't one, we can't complete the match.\n                my ($id, $op) = @!opcode-candidates.first(*.keys == 1, :kv);\n                die \"Unable to find opcode mapping!\\n\" unless $id.defined;\n\n                # Remember the match, and remove the matched opcode from every ID's candidates\n                my $opcode = $op.keys[0];\n                @!opcode-by-id[$id] = $opcode;\n                for @!opcode-candidates -> $op is rw {\n                    $op \u2216= $opcode;\n                }\n            }\n        }\n\n        # Execute the test program\n        method execute\n        {\n            # Reset the register\n            @!register = 0 xx 4;\n            say '  ', @!register if $!verbose;\n\n            # Process each line\n            for @!program -> @line {\n                say @!opcode-by-id[@line[0]], ' ', @line[1..3] if $!verbose;\n                self.process(@!opcode-by-id[@line[0]], @line[1..3]);\n                say '  ', @!register if $!verbose;\n            }\n        }\n    }\n\n    #| Process wrist device instructions\n    multi sub MAIN(Str $instructions, Bool :v(:$verbose)=False)\n    {\n        my $dev = WristDevice.new(:$verbose);\n        WristDeviceInstructions.parse($instructions, :actions($dev)) or die \"Invalid input\";\n\n        # Part 1\n        my $min3count = 0;\n        for $dev.samples.kv -> $i, $instr {\n            my @opcodes = $dev.find-possible-opcodes($instr);\n            say \"Sample #$i: id #{$instr<input>[0]} has possible opcodes @opcodes[]\" if $verbose;\n            $min3count++ if @opcodes \u2265 3;\n        }\n        say \"There are $min3count samples which behave like at least three opcodes\";\n\n        # Part 2\n        $dev.match-opcode-ids;\n        if $verbose {\n            say \"Opcode mapping:\";\n            for ^16 -> $id {\n                say \" - #$id: $dev.opcode-by-id()[$id]\";\n            }\n        }\n        $dev.execute;\n        say \"The contents of the register after executing the test program are: $dev.register()\";\n    }\n\n    #| Process wrist device instructions from a file (default aoc16.input)\n    multi sub MAIN(Str $inputfile where *.IO.f = ~$*PROGRAM.sibling('aoc16.input'), Bool :v(:$verbose)=False)\n    {\n        MAIN($inputfile.IO.slurp, :$verbose);\n    }\n\n[All my Perl 6 solutions in Github](https://github.com/mscha/aoc/tree/master/aoc2018)", "id": "ebxepgn", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "**Swift**\n\n    extension Sequence {\n    \tvar tuple4: (Element, Element, Element, Element)? {\n    \t\tvar iter = makeIterator()\n    \t\tguard let first  = iter.next(),\n    \t\t      let second = iter.next(),\n    \t\t      let third  = iter.next(),\n    \t\t      let fourth = iter.next()\n    \t\telse { return nil }\n    \t\treturn (first, second, third, fourth)\n    \t}\n    }\n    \n    enum Opcode {\n    \tcase addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr\n    \n    \tstatic let allCases: [Opcode] = [.addr, .addi, .mulr, .muli, .banr, .bani, .borr, .bori, .setr, .seti, .gtir, .gtri, .gtrr, .eqir, .eqri, .eqrr]\n    \n    \tfunc exec(instr: Instruction, input: [Int]) -> [Int] {\n    \t\tvar output = input\n    \t\tswitch self {\n    \t\tcase .addr: output[instr.c] = output[instr.a] + output[instr.b]\n    \t\tcase .addi: output[instr.c] = output[instr.a] + instr.b\n    \t\tcase .mulr: output[instr.c] = output[instr.a] * output[instr.b]\n    \t\tcase .muli: output[instr.c] = output[instr.a] * instr.b\n    \t\tcase .banr: output[instr.c] = output[instr.a] & output[instr.b]\n    \t\tcase .bani: output[instr.c] = output[instr.a] & instr.b\n    \t\tcase .borr: output[instr.c] = output[instr.a] | output[instr.b]\n    \t\tcase .bori: output[instr.c] = output[instr.a] | instr.b\n    \t\tcase .setr: output[instr.c] = output[instr.a]\n    \t\tcase .seti: output[instr.c] = instr.a\n    \t\tcase .gtir: output[instr.c] = instr.a > output[instr.b] ? 1 : 0\n    \t\tcase .gtri: output[instr.c] = output[instr.a] > instr.b ? 1 : 0\n    \t\tcase .gtrr: output[instr.c] = output[instr.a] > output[instr.b] ? 1 : 0\n    \t\tcase .eqir: output[instr.c] = instr.a == output[instr.b] ? 1 : 0\n    \t\tcase .eqri: output[instr.c] = output[instr.a] == instr.b ? 1 : 0\n    \t\tcase .eqrr: output[instr.c] = output[instr.a] == output[instr.b] ? 1 : 0\n    \t\t}\n    \t\treturn output\n    \t}\n    }\n    \n    struct Instruction {\n    \tvar opcode: Int\n    \tvar a: Int\n    \tvar b: Int\n    \tvar c: Int\n    \tinit?<S: Sequence>(_ seq: S) where S.Element == Int {\n    \t\tguard let tuple4 = seq.tuple4 else { return nil }\n    \t\t(opcode, a, b, c) = tuple4\n    \t}\n    }\n    \n    func aocD16a(_ input: [(from: [Int], instr: Instruction, to: [Int])]) {\n    \tprint(input.lazy.map { (from, instr, to) in\n    \t\tOpcode.allCases.lazy.filter { $0.exec(instr: instr, input: from) == to }.count\n    \t}.filter({ $0 >= 3 }).count)\n    }\n    \n    func aocD16b(_ input: [(from: [Int], instr: Instruction, to: [Int])], program: [Instruction]) {\n    \tvar possibleMappings = Array(repeating: Opcode.allCases, count: 16)\n    \tfor (from, instr, to) in input {\n    \t\tpossibleMappings[instr.opcode].removeAll(where: { $0.exec(instr: instr, input: from) != to })\n    \t}\n    \tvar finalMappings = possibleMappings.map { $0.count == 1 ? $0[0] : nil }\n    \tvar new = finalMappings.compactMap { $0 }\n    \twhile let next = new.popLast() {\n    \t\tfor index in possibleMappings.indices {\n    \t\t\tif let i = possibleMappings[index].firstIndex(of: next) {\n    \t\t\t\tpossibleMappings[index].remove(at: i)\n    \t\t\t\tif possibleMappings[index].count == 1 {\n    \t\t\t\t\tfinalMappings[index] = possibleMappings[index][0]\n    \t\t\t\t\tnew.append(possibleMappings[index][0])\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tlet mappings = finalMappings.map { $0! }\n    \tvar arr = [0, 0, 0, 0]\n    \tfor instruction in program {\n    \t\tarr = mappings[instruction.opcode].exec(instr: instruction, input: arr)\n    \t}\n    \tprint(arr)\n    }\n    \n    import Foundation\n    let str = try! String(contentsOf: URL(fileURLWithPath: CommandLine.arguments[1]))\n    \n    \n    let input = str.components(separatedBy: \"\\n\\n\").compactMap { block -> (from: [Int], instr: Instruction, to: [Int])? in\n    \tlet numbers = block.split(whereSeparator: { !\"0123456789\".contains($0) }).lazy.map { Int($0)! }\n    \tguard numbers.count == 12 else { return nil }\n    \tlet from = Array(numbers[0..<4])\n    \tlet instr = Instruction(numbers[4..<8])!\n    \tlet to = Array(numbers[8..<12])\n    \treturn (from, instr, to)\n    }\n    \n    let testProgram = str.components(separatedBy: \"\\n\\n\\n\\n\")[1].split(separator: \"\\n\").map { line in\n    \treturn Instruction(line.split(separator: \" \").lazy.map { Int($0)! })!\n    }\n    \n    aocD16a(input)\n    aocD16b(input, program: testProgram)\n\n\nAnother Swift solution:\n\n    func addr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] + rx[b]\n    }\n    \n    func addi(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] + b\n    }\n    \n    func mulr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] * rx[b]\n    }\n    \n    func muli(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] * b\n    }\n    \n    func banr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] & rx[b]\n    }\n    \n    func bani(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] & b\n    }\n    \n    func borr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] | rx[b]\n    }\n    \n    func bori(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] | b\n    }\n    \n    func setr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a]\n    }\n    \n    func seti(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = a\n    }\n    \n    func gtir(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = a > rx[b] ? 1 : 0 \n    }\n    \n    func gtri(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] > b ? 1 : 0 \n    }\n    \n    func gtrr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] > rx[b] ? 1 : 0 \n    }\n    \n    func eqir(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = a == rx[b] ? 1 : 0 \n    }\n    \n    func eqri(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] == b ? 1 : 0 \n    }\n    \n    func eqrr(rx: inout [Int], a: Int, b: Int, c: Int) {\n        rx[c] = rx[a] == rx[b] ? 1 : 0 \n    }\n    \n    let ops = [addi, addr, mulr, muli, banr, bani, borr, bori, setr, seti,\n               gtir, gtri, gtrr, eqir, eqri, eqrr]\n    \n    typealias Sample = (before: [Int], instruction: [Int], after: [Int])\n    \n    func matchingOpIndices(sample: Sample) -> [Int] {\n        let ins = sample.instruction\n        let (before, a, b, c, after) = (sample.before, ins[1], ins[2], ins[3], sample.after)\n        return ops.enumerated().filter({ _, op in\n            var registers = before\n            op(&registers, a, b, c)\n            return registers == after\n        }).map({ $0.0 })\n    }\n    \n    func parseInts(_ line: String?) -> [Int]? {\n        let digits = \"0123456789\"\n        return line?.split(whereSeparator: { !digits.contains($0) }).compactMap({ Int($0) })\n    }\n    \n    var samples = [Sample]()\n    while let line = readLine(), line.hasPrefix(\"Before:\") {\n        if let before = parseInts(line), \n            let instruction = parseInts(readLine()), \n            let after = parseInts(readLine()),\n            let _ = readLine() {\n            samples.append((before, instruction, after))\n        }\n    }\n    \n    var program = [[Int]]()\n    if readLine()?.isEmpty == true {\n        while let instruction = parseInts(readLine()) {\n            program.append(instruction)\n        }\n    }\n    \n    print(samples.filter({ matchingOpIndices(sample: $0).count >= 3 }).count)\n    \n    var choices = Array(repeating: Set(0..<ops.count), count: ops.count)\n    for sample in samples {\n        let opcode = sample.instruction[0]\n        let m = Set(matchingOpIndices(sample: sample))\n        for i in 0..<ops.count {\n            if !m.contains(i) {\n                choices[i].remove(opcode)\n            }\n        }\n    }\n    \n    for _ in 0..<ops.count {\n        for i in 0..<ops.count {\n            if choices[i].count == 1, let opcode = choices[i].first {\n                for k in 0..<ops.count {\n                    if k != i {\n                        choices[k].remove(opcode)\n                    }\n                }\n            }\n        }\n    }\n    \n    var opcodeToIndex = Array(repeating: 0, count: ops.count)\n    var isValidAssignment = true\n    for (i, opcodes) in choices.enumerated() {\n        if opcodes.count == 1, let opcode = opcodes.first {\n            opcodeToIndex[opcode] = i\n        } else {\n            isValidAssignment = false\n        }        \n    }\n    \n    if isValidAssignment {\n        var registers = [0, 0, 0, 0]\n        for inst in program {\n            let (opcode, a, b, c) = (inst[0], inst[1], inst[2], inst[3])\n            let op = ops[opcodeToIndex[opcode]]\n            op(&registers, a, b, c)\n        }\n        print(registers[0])\n    }\n", "id": "ebw7jk6", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "Python 3\n\nRank 153 / 78.\n\n[Solution (Github)](https://github.com/alcatrazEscapee/AdventofCode/blob/master/2018/src/day16.py)\n\nThis was a fun challenge. I spent a lot of time making sure that I had all the register functions correct - after yesterday's puzzle I was going to pay attention to detail! I also managed to find all the opcode ids without any additional iteration - just by matching the opcodes that only had one solution as the tests progressed produced the full mapping. I don't know if that'd be the case for all inputs though.", "id": "ebw8e0t", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "Pattern matching (via Rust) makes the opcode evaluation code look so pretty:\n\n    fn btou(b: bool) -> usize {\n        if b {\n            1\n        } else {\n            0\n        }\n    }\n    \n    fn exec(opcode: &str, in1: usize, in2: usize, out: usize, reg: &mut [usize; 4]) {\n        reg[out] = match opcode {\n            \"addr\" => reg[in1] + reg[in2],\n            \"addi\" => reg[in1] + in2,\n            \"mulr\" => reg[in1] * reg[in2],\n            \"muli\" => reg[in1] * in2,\n            \"barr\" => reg[in1] & reg[in2],\n            \"bari\" => reg[in1] & in2,\n            \"borr\" => reg[in1] | reg[in2],\n            \"bori\" => reg[in1] | in2,\n            \"setr\" => reg[in1],\n            \"seti\" => in1,\n            \"gtir\" => btou(in1 > reg[in2]),\n            \"gtri\" => btou(reg[in1] > in2),\n            \"gtrr\" => btou(reg[in1] > reg[in2]),\n            \"eqir\" => btou(in1 == reg[in2]),\n            \"eqri\" => btou(reg[in1] == in2),\n            \"eqrr\" => btou(reg[in1] == reg[in2]),\n            _ => panic!(\"Invalid opcode: {}\", opcode),\n        }\n    }\n\nIs there a reason you're using strings for opcodes instead of an enum?  Then the last `_ => panic` wouldn't be needed and using an invalid opcode would be a compiler error...\n\nEdit: Or at least that's how it worked in my Swift solution, and AFAIK Rust and Swift's enum semantics are very similar\n\n> Rust\n\nNote that `btou(b)` is `b as usize`.\n\nIt was mostly just a matter of saving an additional layer of parsing.  I'd have to define the enum and then create a second mapping function from the strings to it.\n\nI agree that's 100% the best way to do it if this were anything serious or if the use case was more involved (for example, if instructions were linear and there were jumps or something like that) but as it is, each instruction is just getting read once.\n\nTIL! Thanks for that.\n\nWait where are you getting these strings?  The only source of enum cases I ever had were from my own program (where I just wrote them in as enum cases), since the input file only contains numbers...\n\nI create a mapping from opcode to opcode ID in part 2: https://github.com/Ameobea/advent-of-code-2018/blob/master/src/day16.rs#L125", "id": "ebw9d3w", "owner_tier": 0.5, "score": 0.3333333329629629}, {"content": "##### PowerShell, #62 / #50\n\nPart 1 went pretty well, \"now match up the op-codes\", I printed them and when I saw it, realised it would be quicker to do by hand in notepad than in code. Part 2 also well. No bugs, no trips.\n\nUntil I tried to rewrite a bit more neatly, merge both parts to post here, and do the matching up in code - then bugs all over. :|\n\nCode here [or on GitHub](https://github.com/HumanEquivalentUnit/AdventOfCode2018/blob/master/2018-12-16-PowerShell-p1-and-p2.ps1):\n\n    $opcodes = @{\n        addr = { param($A, $B, $C) $registers[$C] = $registers[$A] + $registers[$B] }\n        addi = { param($A, $B, $C) $registers[$C] = $registers[$A] + $B }\n\n        mulr = { param($A, $B, $C) $registers[$C] = $registers[$A] * $registers[$B] }\n        muli = { param($A, $B, $C) $registers[$C] = $registers[$A] * $B }\n\n        banr = { param($A, $B, $C) $registers[$C] = $registers[$A] -band $registers[$B] }\n        bani = { param($A, $B, $C) $registers[$C] = $registers[$A] -band $B }\n\n        borr = { param($A, $B, $C) $registers[$C] = $registers[$A] -bor $registers[$B] }\n        bori = { param($A, $B, $C) $registers[$C] = $registers[$A] -bor $B }\n\n        setr = { param($A, $B, $C) $registers[$C] = $registers[$A] }\n        seti = { param($A, $B, $C) $registers[$C] = $A }\n\n        gtir = { param($A, $B, $C) $registers[$C] = if ($A -gt $registers[$B]) { 1 } else { 0 } }\n        gtri = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -gt $B) { 1 } else { 0 } }\n        gtrr = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -gt $registers[$B]) { 1 } else { 0 } }\n\n        eqir = { param($A, $B, $C) $registers[$C] = if ($A -eq $registers[$B]) { 1 } else { 0 } }\n        eqri = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -eq $B) { 1 } else { 0 } }\n        eqrr = { param($A, $B, $C) $registers[$C] = if ($registers[$A] -eq $registers[$B]) { 1 } else { 0 } }   \n    }\n\n    $blocks = (Get-Content -Path .\\data.txt -raw) -split \"`r?`n`r?`n\"\n\n    $possibles = @{}\n\n\n    # Pick out the blocks for part 1\n    $results = foreach ($block in $blocks -match 'before')\n    {\n\n\n        # Split into three lines, get the digits out for the instruction\n        $before, $instruction, $after = $block -split \"`r?`n\"\n    \n        $instruction = [int[]]@($instruction -split \"\\D+\" -ne '')\n        $afterTxt = $after.Substring(9, 10)\n    \n\n    \n        # Setup for part 2, track which op-codes this could possibly be\n        if (-not $possibles.ContainsKey($instruction[0]))\n        {\n            $possibles[$instruction[0]] = [system.collections.generic.HashSet[string]]::new()\n        }\n\n\n\n        # Evalute each instruction, count and store the ones which it could be\n        $matchingOpCount = 0\n        foreach ($op in $opcodes.Keys)\n        {\n            $registers = [int[]]@($before -split \"\\D+\" -ne '')\n\n            & $opcodes[$op] $instruction[1] $instruction[2] $instruction[3]\n\n            if (([string]::Join(', ', $registers)) -eq $afterTxt)\n            {\n                [void]$possibles[$instruction[0]].Add($op)\n                $matchingOpCount++\n            }\n        }\n        $matchingOpCount\n    }\n\n    Write-Host \"Part 1: Number of inputs which could be 3 or more opcodes: $(($results -ge 3).Count)\"\n\n\n\n    # Winnow down the availble op-code for each value\n    $opLookup = @{}\n\n    while ($possibles.Count -gt 0)\n    {\n        $known = ($possibles.getenumerator().where{$_.Value.Count -eq 1})[0]\n        $opCode = $known.Value.GetEnumerator().foreach{$_}[0]\n        $opLookup[$known.Name] = $opCode\n        $possibles.Remove($known.Name)\n        $possibles.values.foreach{ [void]$_.Remove($opCode) }\n    }\n\n\n\n    # Part 2 - execute the script\n    $registers = @(0,0,0,0)\n    foreach ($block in $blocks -notmatch 'before' -split \"`r?`n\" -ne '')\n    {\n        $parts = [int[]]@($block -split \"\\D+\" -ne '')\n    \n        & $opcodes[$opLookup[$parts[0]]] $parts[1] $parts[2] $parts[3]\n    }\n\n    Write-Host \"Part 2: Result in register 0: $($registers[0])\"\n\n\nThanks for sharing this one, you found elegant ways to solve it. I am doing AoC in powershell as well :)", "id": "ebwan1e", "owner_tier": 0.7, "score": 0.07407407370370371}, {"content": "Rank 38/111 python 2.7, spent way too much time mapping for part 2 :(\n\nThis was a really fun challenge, I had lots of fun working out the mapping for each opcode. I used the magical eval function (Don't use this unless you're 100% sure the inputs aren't malicious) to help me calculate the instructions for both part A and B, I think it's pretty neat!  \n\n```\nimport re\n\nparsed = open(\"day16.txt\").read().split(\"\\n\\n\\n\\n\")\n\npuzzleA, puzzleB = [[list(map(int, re.findall(\"\\d+\", line))) for line in part.split(\"\\n\") if line] for part in parsed]\n\ndef chronal_classification(input, inputB):\n    ambiguous = 0\n    operations = {\"ra+b\", \"ra+rb\", \"ra*b\", \"ra*rb\", \"ra&b\", \"ra&rb\", \"ra|b\", \"ra|rb\", \"ra\", \"a\", \"a>rb\", \"ra>b\", \"ra>rb\", \"a==rb\", \"ra==rb\", \"ra==b\"}\n    freq = [set() for i in range(16)]\n\n    for i in range(0, len(input), 3):\n        before, [op_id, a, b, c], after = input[i:i+3]\n\n        # Set variables for the eval\n        ra = before[a]\n        rb = before[b]\n\n        potential = set()\n        for op in operations:\n            if eval(op) == after[c]:\n                potential.add(op)\n        freq[op_id] |= potential\n        ambiguous += len(potential) >= 3\n\n    print(\"Part A: %d\" % ambiguous)\n\n    # Working out the mapping of each opcode\n    for removal in range(16):\n        for potential_ops in freq:\n            if len(potential_ops) == 1:\n                freq = [ops - potential_ops or ops for ops in freq]\n\n    return partB([min(op) for op in freq], inputB)\n\ndef partB(mapping, input):\n\n    after = [0, 0, 0, 0]\n    for op, a, b, c in input:\n        # Set variables for eval\n        ra, rb = after[a], after[b]\n        after[c] = eval(mapping[op])\n\n    return after[0]\n\nprint(\"Part B: %d\" % chronal_classification(puzzleA, puzzleB))\n```\n&#x200B;", "id": "ebwasu1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "192/353 Rust\n\nIt was fun being able to implement the whole opcode execution logic as a one-line-per-opcode match statement.\n\nAll of my other days are here btw: [https://github.com/Ameobea/advent-of-code-2018](https://github.com/Ameobea/advent-of-code-2018)  I've been working to make sure they're all neat and run quickly.\n\n    use std::collections::HashSet;\n    \n    const INPUT: &str = include_str!(\"../input/day16.txt\");\n    \n    use regex::Regex;\n    \n    lazy_static! {\n        static ref RGX: Regex = Regex::new(\".*?(\\\\d+).+?(\\\\d+).+?(\\\\d+).+?(\\\\d+).*\").unwrap();\n    }\n    \n    fn parse_line(line: &str) -> [usize; 4] {\n        let mut res = [0usize; 4];\n        let captures = RGX\n            .captures(line)\n            .expect(&format!(\"regex captures failed for {:?}\", line));\n        res[0] = captures[1].parse().unwrap();\n        res[1] = captures[2].parse().unwrap();\n        res[2] = captures[3].parse().unwrap();\n        res[3] = captures[4].parse().unwrap();\n    \n        res\n    }\n    \n    fn parse_input() -> (\n        impl Iterator<Item = ([usize; 4], [usize; 4], [usize; 4])>,\n        impl Iterator<Item = [usize; 4]>,\n    ) {\n        let lines = INPUT.lines().collect::<Vec<_>>();\n    \n        let observed_executions = lines\n            .chunks(4)\n            .take_while(|chunk| !chunk[0].is_empty())\n            .map(move |block| {\n                (\n                    parse_line(block[0]),\n                    parse_line(block[1]),\n                    parse_line(block[2]),\n                )\n            })\n            .collect::<Vec<_>>();\n    \n        let instructions = lines\n            .into_iter()\n            .skip(observed_executions.len() * 4 + 2)\n            .take_while(|l| !l.is_empty())\n            .map(parse_line);\n    \n        (observed_executions.into_iter(), instructions)\n    }\n    \n    fn btou(b: bool) -> usize {\n        if b {\n            1\n        } else {\n            0\n        }\n    }\n    \n    fn exec(opcode: &str, in1: usize, in2: usize, out: usize, reg: &mut [usize; 4]) {\n        reg[out] = match opcode {\n            \"addr\" => reg[in1] + reg[in2],\n            \"addi\" => reg[in1] + in2,\n            \"mulr\" => reg[in1] * reg[in2],\n            \"muli\" => reg[in1] * in2,\n            \"barr\" => reg[in1] & reg[in2],\n            \"bari\" => reg[in1] & in2,\n            \"borr\" => reg[in1] | reg[in2],\n            \"bori\" => reg[in1] | in2,\n            \"setr\" => reg[in1],\n            \"seti\" => in1,\n            \"gtir\" => btou(in1 > reg[in2]),\n            \"gtri\" => btou(reg[in1] > in2),\n            \"gtrr\" => btou(reg[in1] > reg[in2]),\n            \"eqir\" => btou(in1 == reg[in2]),\n            \"eqri\" => btou(reg[in1] == in2),\n            \"eqrr\" => btou(reg[in1] == reg[in2]),\n            _ => panic!(\"Invalid opcode: {}\", opcode),\n        }\n    }\n    \n    const ALL_OPCODES: &[&str] = &[\n        \"addr\", \"addi\", \"mulr\", \"muli\", \"barr\", \"bari\", \"borr\", \"bori\", \"setr\", \"seti\", \"gtir\", \"gtri\",\n        \"gtrr\", \"eqir\", \"eqri\", \"eqrr\",\n    ];\n    \n    fn part1() -> usize {\n        let mut three_or_more_valid = 0;\n        for (before, op, after) in parse_input().0 {\n            let mut count = 0;\n            for opcode in ALL_OPCODES {\n                let mut reg = before;\n                exec(opcode, op[1], op[2], op[3], &mut reg);\n                if reg == after {\n                    count += 1;\n                }\n            }\n    \n            if count >= 3 {\n                three_or_more_valid += 1;\n            }\n        }\n    \n        three_or_more_valid\n    }\n    \n    fn part2() -> usize {\n        let (observed_executions, instructions) = parse_input();\n    \n        let mut reg: [usize; 4] = [0; 4];\n        let mut valid_opcodes: Vec<Vec<HashSet<&str>>> = vec![Vec::new(); 16];\n    \n        for (before, op, after) in observed_executions {\n            let mut possible_opcodes = HashSet::new();\n            for opcode in ALL_OPCODES {\n                reg = before;\n                exec(opcode, op[1], op[2], op[3], &mut reg);\n                if after == reg {\n                    possible_opcodes.insert(opcode.clone());\n                }\n            }\n    \n            valid_opcodes[op[0]].push(possible_opcodes);\n        }\n    \n        let mut mappings: [&str; 16] = [\"\"; 16];\n        let mut found_mappings = 0;\n    \n        while found_mappings < 16 {\n            for i in 0..16 {\n                if mappings[i] != \"\" {\n                    continue;\n                }\n    \n                let mut valid_for_all = HashSet::new();\n                for opcode in &valid_opcodes[i][0] {\n                    valid_for_all.insert(opcode);\n                }\n    \n                for matched_opcode_list in &valid_opcodes[i][1..] {\n                    valid_for_all.retain(|opcode| matched_opcode_list.iter().any(|o| *o == **opcode));\n                }\n    \n                for opcode in &mappings {\n                    valid_for_all.remove(opcode);\n                }\n    \n                if valid_for_all.len() == 1 {\n                    mappings[i] = valid_for_all.drain().next().unwrap();\n                    found_mappings += 1;\n                }\n            }\n        }\n    \n        for [op, a, b, c] in instructions {\n            exec(mappings[op], a, b, c, &mut reg);\n        }\n    \n        reg[0]\n    }\n    \n    pub fn run() {\n        println!(\"Part 1: {}\", part1());\n        println!(\"Part 2: {}\", part2());\n    }\n\nIt seems like I was the only one doing this with function pointers :p It was a bit more trouble than it was worth I guess, but it was fun.", "id": "ebwbl2e", "owner_tier": 0.5, "score": 0.07407407370370371}, {"content": "This space intentionally left blank.", "id": "ebwciak", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "845/867 Python2.7 Today was the first puzzle that didn't turn into a complete disaster.  And I even like how my code turned out, pretty compact.  And yes, I'm slow.\n\n    #!/bin/env python\n    aa = '''input'''\n\n    class reg:\n       def __init__ (self):\n          self.val = None\n\n       def clear (self):\n          self.val = 0\n\n       def store (self, vv):\n          self.val = vv\n\n       __call__ = lambda self: self.val\n       __str__ = lambda self: '%s' % self.val\n       __repr__ = __str__\n\n    class regs:\n       def __init__ (self):\n          self.rr = tuple([reg() for xx in xrange(4)])\n\n       __getitem__ = lambda self, ii: self.rr[ii]\n       __call__ = lambda self: [xx() for xx in self.rr]\n       store = lambda self, vals: [xx.store(vv) for xx,vv in zip(self.rr, vals)]\n       def clear (self): [xx.clear() for xx in self.rr]\n\n    class op:\n       def __init__ (self, id_, rr, cc):\n          self.id_ = id_\n          self.rr = rr\n          self.cc = cc\n\n       def test (self, r0, opcode, r1, rv):\n          self.rr.store(r0)\n          try:\n             self.__call__(opcode)\n             if self.rr() == r1: rv.add((self.id_, opcode[0]))\n          except: pass\n\n       def __call__ (self, opcode):\n          self.rr[opcode[3]].store(self.cc(self.rr, opcode))\n\n       __str__ = lambda self: 'op::%s' % self.id_\n       __repr__ = __str__\n\n    regs_ = regs()\n    ops_ = (\n       op('addr', regs_, lambda rr, oc: rr[oc[1]]()+rr[oc[2]]()),\n       op('addi', regs_, lambda rr, oc: rr[oc[1]]()+oc[2]),\n       op('mulr', regs_, lambda rr, oc: rr[oc[1]]()*rr[oc[2]]()),\n       op('muli', regs_, lambda rr, oc: rr[oc[1]]()*oc[2]),\n       op('banr', regs_, lambda rr, oc: rr[oc[1]]()&rr[oc[2]]()),\n       op('bani', regs_, lambda rr, oc: rr[oc[1]]()&oc[2]),\n       op('borr', regs_, lambda rr, oc: rr[oc[1]]()|rr[oc[2]]()),\n       op('bori', regs_, lambda rr, oc: rr[oc[1]]()|oc[2]),\n       op('setr', regs_, lambda rr, oc: rr[oc[1]]()),\n       op('seti', regs_, lambda rr, oc: oc[1]),\n       op('gtir', regs_, lambda rr, oc: (0, 1)[oc[1]>rr[oc[2]]()]),\n       op('gtri', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()>oc[2]]),\n       op('gtrr', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()>rr[oc[2]]()]),\n       op('eqir', regs_, lambda rr, oc: (0, 1)[oc[1]==rr[oc[2]]()]),\n       op('eqri', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()==oc[2]]),\n       op('eqrr', regs_, lambda rr, oc: (0, 1)[rr[oc[1]]()==rr[oc[2]]()])\n    )\n    ops_ = dict([(xx.id_, xx) for xx in ops_])\n\n    def sortopcodes (tt, ott, oll):\n       for ii,ss in tt.items():\n          if len(ss) == 1:\n             id_ = ss.pop()\n             tt.pop(ii)\n             oll[ii] = ott.pop(id_)\n             [vv.discard(id_) for vv in tt.itervalues()]\n             return\n\n    def part1 ():\n       inp = [xx.strip() for xx in aa.splitlines()]\n       inp = [xx for xx in inp if xx]\n       count = 0\n       while len(inp):\n          bb = inp.pop(0)\n          if 'Before' in bb:\n             rv = set([])\n             r0 = eval(bb.split(':')[1])\n             opcode = eval('[%s]' % ','.join(inp.pop(0).split()))\n             r1 = eval(inp.pop(0).split(':')[1])\n             [xx.test(r0, opcode, r1, rv) for xx in ops_.itervalues()]\n             if len(rv) > 2: count+=1\n       print 'part1 count: %s' % count\n\n    def part2 ():\n       inp = [xx.strip() for xx in aa.splitlines()]\n       inp = [xx for xx in inp if xx]\n       workout = {}\n       inp2 = []\n       while len(inp):\n          bb = inp.pop(0)\n          if 'Before' in bb:\n             rv = set([])\n             r0 = eval(bb.split(':')[1])\n             opcode = eval('[%s]' % ','.join(inp.pop(0).split()))\n             r1 = eval(inp.pop(0).split(':')[1])\n             [xx.test(r0, opcode, r1, rv) for xx in ops_.itervalues()]\n             if len(rv):\n                for id_, oc in rv:\n                   workout.setdefault(oc, set([])).add(id_)\n          else:\n             inp2.append(eval('[%s]' % ','.join(bb.split())))\n\n       op2 = [None]*16\n       while len(workout):\n          sortopcodes(workout, ops_, op2)\n\n       while len(inp2):\n          oc = inp2.pop(0)\n          op2[oc[0]](oc)\n\n       print 'part2 regs: %s' % regs_()\n\n    part1()\n    part2()\n", "id": "ebwdp7l", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Python 3 (584/812) - made many mistakes along the way, so no chance on the leader board. Nevertheless, I am satisfied with the quality of my code and decided to share my results for the first time on the AoC Reddit. I hope it is of value for some.\n\nNote: I manually split today's input in 2 files (\"input\\_16\\_1\" and \"input\\_16\\_2\")\n\n\\[Card\\]  The secret technique to beat today\u2019s puzzles is a secret. \n\n    from collections import defaultdict\n    \n    def readFile(name):\n     with open(\"files/\" + name) as f:\n      content = f.readlines()\n     content = [x.strip() for x in content]\n     return content\n    \n    def addr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] + reg[ins[2]]\n     return reg\n    \n    def addi(reg, ins):\n     reg[ins[3]] = reg[ins[1]] + int(ins[2])\n     return reg\n    \n    def mulr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] * reg[ins[2]]\n     return reg\n     \n    def muli(reg, ins):\n     reg[ins[3]] = reg[ins[1]] * int(ins[2])\n     return reg\n    \n    def banr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] & reg[ins[2]]\n     return reg\n    \n    def bani(reg, ins):\n     reg[ins[3]] = reg[ins[1]] & int(ins[2])\n     return reg\n    \n    def borr(reg, ins):\n     reg[ins[3]] = reg[ins[1]] | reg[ins[2]]\n     return reg\n    \n    def bori(reg, ins):\n     reg[ins[3]] = reg[ins[1]] | int(ins[2])\n     return reg\n    \n    def setr(reg, ins):\n     reg[ins[3]] = reg[ins[1]]\n     return reg\n    \n    def seti(reg, ins):\n     reg[ins[3]] = int(ins[1])\n     return reg\n    \n    def gtii(reg, ins):\n     if int(ins[1]) > reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n    \n    def gtri(reg, ins):\n     if reg[ins[1]] > int(ins[2]):\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n    \n    def gtrr(reg, ins):\n     if reg[ins[1]] > reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n      \n    def eqir(reg, ins):\n     if int(ins[1]) == reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0 \n     return reg\n     \n    def eqri(reg, ins):\n     if reg[ins[1]] == int(ins[2]):\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n     \n    def eqrr(reg, ins):\n     if reg[ins[1]] == reg[ins[2]]:\n      reg[ins[3]] = 1\n     else:\n      reg[ins[3]] = 0\n     return reg\n    \n    def call(function, reg, ins):\n     if function in allCodes: # Beware of evil elves!\n      return eval(function + \"(reg, ins)\")\n    \n    def getCodes(r, i, newRegs):\n     return [code for code in allCodes if call(code, r[:], i) == newRegs]\n    \n    def getSamples(input):\n     samples = []\n    \n     for iPoint in range(0, len(input), 4):\n      regs    = [int(x) for x in input[iPoint][9:-1].split(\", \")]\n      ins     = [int(x) for x in input[iPoint+1].split(\" \")]\n      newRegs = [int(x) for x in input[iPoint+2][9:-1].split(\", \")]\n      \n      samples.append((regs, ins, newRegs))\n     return samples\n    \n    ### Part 1\n    \n    input = readFile(\"input_16_1\")\n    \n    allCodes = [\"addr\", \"addi\", \"mulr\", \"muli\", \"banr\", \"bani\", \"borr\", \"bori\", \"setr\", \"seti\", \"gtii\", \"gtri\", \"gtrr\", \"eqir\", \"eqri\", \"eqrr\"]\n    samples  = getSamples(input)\n    result = sum([len(getCodes(regs, ins, newRegs)) >= 3 for (regs, ins, newRegs) in samples])\n    \n    print(\"Solution 1: \" + str(result))\n    \n    ### Part 2\n    \n    opCodes = defaultdict(str)\n    \n    for (regs, ins, newRegs) in samples:\n     if ins[0] not in opCodes:\n      posCodes = [code for code in getCodes(regs, ins, newRegs) if code not in opCodes.values()]\n     \n      if len(posCodes) == 1:\n       opCodes[ins[0]] = posCodes[0]\n    \n    input = readFile(\"input_16_2\")\n    registers = [0] * 4\n    \n    for line in input:\n     ins = [int(x) for x in line.split(\" \")]\n     registers = call(opCodes[ins[0]], registers, ins)\n    \n    result = registers[0]\n    \n    print(\"Solution 2: \" + str(result))\n\n&#x200B;", "id": "ebwec42", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "###(messy) Haskell\nI really enjoyed today's puzzle. Took me a bit to figure out how to map the opcodes\n\n    {-# LANGUAGE TupleSections, ViewPatterns #-}\n    \n    import Control.Lens\n    import Data.Bits\n    import Data.Foldable\n    import Data.Function\n    import Data.List\n    import Data.List.Split\n    import Data.Map (Map)\n    import qualified Data.Map.Strict as Map\n    import Data.Set (Set)\n    import qualified Data.Set as Set\n    import System.Environment\n    \n    -- TYPES\n    type Registers = [Int]\n    type Instruction = (Int, Int, Int, Int)\n    \n    data OpCode = \n      OpCode {\n        _label :: String,\n        _f :: Registers -> Int -> Int -> Int -> Registers\n      }\n    \n    instance Show OpCode where\n      show = _label\n      \n    instance Eq OpCode where\n      (==) a b = _label a == _label b\n    \n    instance Ord OpCode where\n      compare a b = _label a `compare` _label b\n    \n    -- PARSING\n    parseTest :: [String] -> (Registers, Instruction, Registers)\n    parseTest [before, line, after] =\n      let before' = read . last . splitOn \": \" $ before\n          instr   = parseInstruction line\n          after'  = read . last . splitOn \": \" $ after\n      in  (before', instr, after')\n    \n    parseInstruction :: String -> Instruction\n    parseInstruction s = \n      let [op, a, b, c] = map read . words $ s\n      in  (op, a, b, c)\n    \n    -- SOLVING  \n    main :: IO ()\n    main = do \n      contents <- readFile . head =<< getArgs\n      let input   = filter (not . null . head) . groupBy ((==) `on` null) . lines $ contents\n      let tests   = parseTest <$> init input\n      let program = parseInstruction <$> last input\n      print $ solve1 tests\n      print $ solve2 tests program\n    \n    solve1 :: [(Registers, Instruction, Registers)] -> Int\n    solve1 = length . filter (>=3) . map (Set.size . snd . testAll)\n    \n    solve2 :: [(Registers, Instruction, Registers)] -> [Instruction] -> Int\n    solve2 tests program = \n      let opCandidates = Map.fromListWith Set.intersection $ map testAll tests\n          opMap = deduceOpMap opCandidates Map.empty \n      in  head $ foldl' (call opMap) [0, 0, 0, 0] program\n      where    \n        call opMap rs (flip Map.lookup opMap -> Just op, a, b, c) = _f op rs a b c\n    \n    deduceOpMap :: Map Int (Set OpCode) -> Map Int (Set OpCode) -> Map Int OpCode\n    deduceOpMap opCandidates opMap\n      | Map.size opMap == Map.size opCandidates = \n        Map.map (head . Set.elems) opMap\n      | otherwise = \n        let opMap' = Map.union opMap \n                   . Map.filter ((==1) . length) \n                   . Map.map (`Set.difference` fold opMap) \n                   $ opCandidates\n        in  deduceOpMap opCandidates opMap' \n    \n    testAll :: (Registers, Instruction, Registers) -> (Int, Set OpCode)\n    testAll (rs, (op, a, b, c), rs') = (op,) . Set.filter (testOp rs a b c rs' . _f) $ opCodes    \n      where\n        testOp rs a b c rs' f = f rs a b c == rs'\n        opCodes = \n          Set.fromList [ OpCode \"addr\" addr, OpCode \"addi\" addi\n                       , OpCode \"mulr\" mulr, OpCode \"muli\" muli\n                       , OpCode \"banr\" banr, OpCode \"bani\" bani\n                       , OpCode \"borr\" borr, OpCode \"bori\" bori\n                       , OpCode \"gtir\" gtir, OpCode \"gtri\" gtri, OpCode \"gtrr\" gtrr\n                       , OpCode \"eqir\" eqir, OpCode \"eqri\" eqri, OpCode \"eqrr\" eqrr\n                       , OpCode \"setr\" setr, OpCode \"seti\" seti\n                       ]\n    \n    funr :: (Int -> Int -> Int) -> Registers -> Int -> Int -> Int -> Registers\n    funr f rs a b c = funi f rs a (rs !! b) c\n    \n    funi :: (Int -> Int -> Int) -> Registers -> Int -> Int -> Int -> Registers\n    funi f rs a b c = \n      let va = rs !! a \n      in  rs & ix c .~ f va b\n    \n    addr = funr (+)\n    addi = funi (+)\n    \n    mulr = funr (*)\n    muli = funi (*)\n    \n    banr = funr (.&.)\n    bani = funi (.&.)\n    \n    borr = funr (.|.)\n    bori = funi (.|.)\n    \n    gtir rs = flip (funi (\\b a -> if a > b then 1 else 0) rs)\n    gtri    =       funi (\\a b -> if a > b then 1 else 0)\n    gtrr    =       funr (\\a b -> if a > b then 1 else 0)\n    \n    eqir rs = flip (funi (\\b a -> if a == b then 1 else 0) rs)\n    eqri    =       funi (\\a b -> if a == b then 1 else 0)\n    eqrr    =       funr (\\a b -> if a == b then 1 else 0)\n    \n    setr    = funi const\n    seti rs = flip (funi (flip const) rs)", "id": "ebwegy1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "This one was another fun one, a bit tricky to write clean code for though.\n\nDid this in Golang, and the builtin `math/bits ` package proved very useful for this method.\n\n```\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/bits\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Opcode int\n\nconst (\n\taddr Opcode = iota\n\taddi\n\n\tmulr\n\tmuli\n\n\tbanr\n\tbani\n\n\tborr\n\tbori\n\n\tsetr\n\tseti\n\n\tgtir\n\tgtri\n\tgtrr\n\n\teqir\n\teqri\n\teqrr\n)\nconst NumOpcodes = 16\n\nfunc run(i Opcode, a, b int, registers [4]int) int {\n\tswitch i {\n\tcase addr:\n\t\treturn registers[a] + registers[b]\n\tcase addi:\n\t\treturn registers[a] + b\n\n\tcase mulr:\n\t\treturn registers[a] * registers[b]\n\tcase muli:\n\t\treturn registers[a] * b\n\n\tcase banr:\n\t\treturn registers[a] & registers[b]\n\tcase bani:\n\t\treturn registers[a] & b\n\n\tcase borr:\n\t\treturn registers[a] | registers[b]\n\tcase bori:\n\t\treturn registers[a] | b\n\n\tcase setr:\n\t\treturn registers[a]\n\tcase seti:\n\t\treturn a\n\n\tcase gtir:\n\t\tif a > registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase gtri:\n\t\tif registers[a] > b {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase gtrr:\n\t\tif registers[a] > registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\n\tcase eqir:\n\t\tif a == registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase eqri:\n\t\tif registers[a] == b {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\tcase eqrr:\n\t\tif registers[a] == registers[b] {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\tpanic(\"Unknown opcode\")\n}\n\nfunc main() {\n\tvar data [][4]int\n\tvar instructionMap [NumOpcodes]uint16\n\n\treader, err := os.Open(\"day16_hint.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tscanner := bufio.NewScanner(reader)\n\tfor scanner.Scan() {\n\t\tfields := strings.FieldsFunc(scanner.Text(), func(r rune) bool {\n\t\t\tswitch {\n\t\t\tcase r >= '0' && r <= '9':\n\t\t\t\treturn false\n\t\t\tdefault:\n\t\t\t\treturn true\n\t\t\t}\n\t\t})\n\t\tints := [4]int{}\n\t\tfor i := 0; i < len(fields); i++ {\n\t\t\tints[i], _ = strconv.Atoi(fields[i])\n\t\t}\n\t\tdata = append(data, ints)\n\t}\n\treader.Close()\n\n\tfor i := 0; i < NumOpcodes; i++ {\n\t\tinstructionMap[i] = 0xFFFF\n\t}\n\n\tpartA := 0\n\tfor i := 0; i < len(data); i += 4 {\n\t\tfor op := Opcode(0); op < NumOpcodes; op++ {\n\t\t\toutr := data[i+1][3]\n\t\t\tout := run(op, data[i+1][1], data[i+1][2], data[i])\n\t\t\tif data[i+2][outr] != out {\n\t\t\t\tinstructionMap[data[i+1][0]] &= ^(1 << uint(op))\n\t\t\t}\n\t\t}\n\t\tif bits.OnesCount16(instructionMap[data[i+1][0]]) >= 3 {\n\t\t\tpartA++\n\t\t}\n\t}\n\n\tfmt.Println(\"Part A:\", partA)\n\n\tunknown := uint16(0xFFFF)\n\tfor unknown > 0 {\n\t\tfor op := 0; op < NumOpcodes; op++ {\n\t\t\tif bits.OnesCount16(instructionMap[op]) == 1 {\n\t\t\t\tunknown &= ^instructionMap[op]\n\t\t\t\tfor i := 0; i < NumOpcodes; i++ {\n\t\t\t\t\tif i != op {\n\t\t\t\t\t\tinstructionMap[i] &= ^instructionMap[op]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor op := 0; op < NumOpcodes; op++ {\n\t\tinstructionMap[op] = uint16(bits.Len16(instructionMap[op]) - 1)\n\t\tfmt.Printf(\"%2d -> %2d\\n\", op, instructionMap[op])\n\t}\n\n\tdata = data[:0]\n\treader, err = os.Open(\"day16_program.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tscanner = bufio.NewScanner(reader)\n\tfor scanner.Scan() {\n\t\tfields := strings.Split(scanner.Text(), \" \")\n\t\tints := [4]int{}\n\t\tfor i := 0; i < len(fields); i++ {\n\t\t\tints[i], _ = strconv.Atoi(fields[i])\n\t\t}\n\t\tdata = append(data, ints)\n\t}\n\treader.Close()\n\n\tregisters := [4]int{0, 0, 0, 0}\n\tfor i := range data {\n\t\toutr := data[i][3]\n\t\tout := run(Opcode(instructionMap[data[i][0]]), data[i][1], data[i][2], registers)\n\t\tregisters[outr] = out\n\t}\n\tfmt.Println(\"Part B:\", registers[0])\n}\n\n```", "id": "ebwek3p", "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "Nice logical inference fun!  Part 2 was so obvious.  Wish that there was more test input for this one.  I really tried to write less repetitive code as much as possible.\n\n    import re\n\n    def execute_reg_ins(reg, operands, ins):\n        reg[operands[2]] = ins(reg[operands[0]], reg[operands[1]])\n\n    def execute_value_ins(reg, operands, ins):\n        reg[operands[2]] = ins(reg[operands[0]], operands[1])\n\n    def execute_compare_ir_ins(reg, operands, ins):\n        reg[operands[2]] = ins(operands[0], reg[operands[1]])\n\n    def execute_compare_ri_ins(reg, operands, ins):\n        execute_value_ins(reg, operands, ins)\n\n    def execute_compare_rr_ins(reg, operands, ins):\n        execute_reg_ins(reg, operands, ins)\n\n    def could_be_reg_ins(before_reg, after_reg, operands, ins):\n        return after_reg[operands[2]] == ins(before_reg[operands[0]], before_reg[operands[1]])\n\n    def could_be_value_ins(before_reg, after_reg, operands, ins):\n        return after_reg[operands[2]] == ins(before_reg[operands[0]], operands[1])\n\n    def add(a, b):\n        return a + b\n\n    def mul(a, b):\n        return a * b\n\n    def ban(a, b):\n        return a & b\n\n    def bor(a, b):\n        return a | b\n\n    def gt(a, b):\n        return 1 if a > b else 0\n\n    def eq(a, b):\n        return 1 if a == b else 0\n\n    def could_be_compare_ir(before_reg, after_reg, operands, ins):\n        return after_reg[operands[2]] == ins(operands[0], before_reg[operands[1]])\n\n    def could_be_compare_ri(before_reg, after_reg, operands, ins):\n        return could_be_value_ins(before_reg, after_reg, operands, ins)\n\n    def could_be_compare_rr(before_reg, after_reg, operands, ins):\n        return could_be_reg_ins(before_reg, after_reg, operands, ins)\n\n    simple_operations = [(add, \"add\"), (mul, \"mul\"), (ban, \"ban\"), (bor, \"bor\")]\n    compare_operations = [(gt, \"gt\"), (eq, \"eq\")]\n\n    observations = []\n    test_program = []\n\n    in_before = False\n    with open('day_16.txt', 'r') as fp:\n        before = None\n        instruction = None\n        after = None\n        for line in fp:\n            if line.startswith(\"Before:\"):\n                before = list(map(int, re.findall(r'\\d+', line)))\n                in_before = True\n            elif line.startswith(\"After:\"):\n                after = list(map(int, re.findall(r'\\d+', line)))\n                observations.append((before, after, instruction))\n                in_before = False\n            else:\n                parts = list(map(int, re.findall(r'\\d+', line)))\n                if len(parts) == 4:\n                    instruction = parts\n                    if not in_before:\n                        test_program.append(instruction)\n\n    print(len(observations))\n    print(len(test_program))\n    observation_choices = []\n    opcode_meaning = {}\n\n    for observation in observations:\n        num_could_be = 0\n        before_reg = observation[0]\n        after_reg = observation[1]\n        opcode = observation[2][0]\n        operands = observation[2][1:]\n        could_be = set()\n      \n        if after_reg[operands[2]] == operands[0]:\n            could_be.add(\"seti\")\n        if after_reg[operands[2]] == before_reg[operands[0]]:\n            could_be.add(\"setr\")\n        for ops in simple_operations:\n            if could_be_reg_ins(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"r\")\n            if could_be_value_ins(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"i\")\n        for ops in compare_operations:\n            if could_be_compare_ir(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"ir\")\n            if could_be_compare_ri(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"ri\")\n            if could_be_compare_rr(before_reg, after_reg, operands, ops[0]):\n                could_be.add(ops[1] + \"rr\")\n        observation_choices.append(len(could_be))\n\n        if opcode in opcode_meaning:\n            opcode_meaning[opcode] = opcode_meaning[opcode] & could_be\n        else:\n            opcode_meaning[opcode] = could_be\n\n    print(\"More Than 3: \" + str(len(list(filter(lambda x: x >= 3, observation_choices)))))\n    print(opcode_meaning)\n\n    while len(list(filter(lambda x: len(x) > 1, opcode_meaning.values()))) > 0:\n        for opcode, meaning in opcode_meaning.items():\n            if len(meaning) == 1:\n                the_meaning = list(meaning)[0]\n                print(\"Truth: \" + str(opcode) + \" means \" + the_meaning)\n                # for sure we know this one\n                for other_opcode, other_meaning in opcode_meaning.items():\n                    if opcode != other_opcode:\n                        if the_meaning in other_meaning:\n                            other_meaning.remove(the_meaning)\n        print(opcode_meaning)\n                \n    reg = [0, 0, 0, 0]\n    for ins in test_program:\n        ins_name = list(opcode_meaning[ins[0]])[0]\n        operands = ins[1:]\n        run = False\n        print(\"Run: \" + str(ins_name) + \" \" + str(operands))\n        for op in simple_operations:\n            if ins_name.startswith(op[1]):\n                if ins_name.endswith('r'):\n                    execute_reg_ins(reg, operands, op[0])\n                else:\n                    execute_value_ins(reg, operands, op[0])\n                run = True\n        if not run:\n            for op in compare_operations:\n                if ins_name.startswith(op[1]):\n                    if ins_name.endswith('ir'):\n                        execute_compare_ir_ins(reg, operands, op[0])\n                    elif ins_name.endswith('ri'):\n                        execute_compare_ri_ins(reg, operands, op[0])\n                    else:\n                        execute_compare_rr_ins(reg, operands, op[0])\n                    run = True\n        if not run:\n            if ins_name == \"seti\":\n                reg[operands[2]] = operands[0]\n            elif ins_name == \"setr\":\n                reg[operands[2]] = reg[operands[0]]\n            else:\n                print(\"FAIL!\")\n        print(\"Result: \" + str(reg))\n\n\n\n", "id": "ebwf5dg", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Clojure**\n\nFor part 2, I ran this snippet until all matching codes where found:\n\n    (def matching (map find-matching-opcodes input))  ; Run only once\n    (def matching (remove nil? (map (fn [{:keys [opcode behaves-like] :as match}]\n                                  (if (opcode->opcode-symbol opcode)\n                                    nil\n                                    (assoc match :behaves-like (remove found-opcodes behaves-like)))) matching)))\n    (set (filter #(< (count (:behaves-like %1)) 2) matching))\n\nHere's the code:\n\n    (ns aoc18.day16\n      (:require [clojure.string :as str]))\n    \n    (defn long-str [& strings]\n      (str/join \"\\n\" strings))\n    \n    (def test-input (long-str\n                      \"Before: [3, 2, 1, 1]\"\n                      \"9 2 1 2\"\n                      \"After:  [3, 2, 2, 1]\"))\n    \n    (defn parse-register-values [input]\n      (vec (map #(Integer/parseInt %1) (re-seq #\"\\d+\" input))))\n    \n    (defn parse-instruction [input]\n      (let [[opcode a b c] (str/split input #\" \")]\n        {:opcode (Integer/parseInt opcode) :a (Integer/parseInt a) :b (Integer/parseInt b) :c (Integer/parseInt c)}))\n    \n    (defn parse-input [input]\n      (let [lines (str/split-lines input)]\n        (loop [parsed []\n               [before instruction after & rest-lines :as all-lines] lines]\n          (if (empty? all-lines)\n            parsed\n            (if (str/includes? before \"Before\")\n              (recur (conj parsed {:registers-before (parse-register-values before)\n                                   :instruction      (parse-instruction instruction)\n                                   :registers-after  (parse-register-values after)})\n                     rest-lines)\n              (recur parsed (rest all-lines)))))))\n    \n    (defn initialize-cpu\n      ([] (initialize-cpu [0 0 0 0]))\n      ([registers]\n       {:registers registers}))\n    \n    (defn op-r [f]\n      (fn [{:keys [registers] :as cpu} {:keys [a b c]}]\n        (let [a-val (nth registers a)\n              b-val (nth registers b)\n              result (f a-val b-val)]\n          (assoc cpu :registers (assoc registers c result)))))\n    (defn op-i [f]\n      (fn [{:keys [registers] :as cpu} {:keys [a b c]}]\n        (let [a-val (nth registers a)\n              b-val b\n              result (f a-val b-val)]\n          (assoc cpu :registers (assoc registers c result)))))\n    \n    (defn set-r [{:keys [registers] :as cpu} {:keys [a c]}]\n      (let [a-val (nth registers a)]\n        (assoc cpu :registers (assoc registers c a-val))))\n    (defn set-i [{:keys [registers] :as cpu} {:keys [a c]}]\n      (let [a-val a]\n        (assoc cpu :registers (assoc registers c a-val))))\n    \n    (defn gtir [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val a\n            b-val (nth registers b)\n            result (if (> a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn gtri [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val b\n            result (if (> a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn gtrr [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val (nth registers b)\n            result (if (> a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    \n    (defn eqir [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val a\n            b-val (nth registers b)\n            result (if (= a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn eqri [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val b\n            result (if (= a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    (defn eqrr [{:keys [registers] :as cpu} {:keys [a b c]}]\n      (let [a-val (nth registers a)\n            b-val (nth registers b)\n            result (if (= a-val b-val) 1 0)]\n        (assoc cpu :registers (assoc registers c result))))\n    \n    (def opcode->opcode-symbol\n      {0  :eqir\n       1  :seti\n       2  :eqri\n       3  :eqrr\n       4  :addi\n       5  :setr\n       6  :gtrr\n       7  :gtri\n       8  :muli\n       9  :bori\n       10 :bani\n       11 :borr\n       12 :gtir\n       13 :banr\n       14 :addr\n       15 :mulr})\n    \n    (def found-opcodes\n      (set (map second opcode->opcode-symbol)))\n    \n    (def opcode->f\n      {:addr (op-r +)\n       :addi (op-i +)\n    \n       :mulr (op-r *)\n       :muli (op-i *)\n    \n       :banr (op-r bit-and)\n       :bani (op-i bit-and)\n    \n       :borr (op-r bit-or)\n       :bori (op-i bit-or)\n    \n       :setr set-r\n       :seti set-i\n    \n       :gtir gtir\n       :gtri gtri\n       :gtrr gtrr\n    \n       :eqir eqir\n       :eqri eqri\n       :eqrr eqrr})\n    \n    (defn find-matching-opcodes [{:keys [registers-before instruction registers-after] :as input}]\n      (let [cpu (initialize-cpu registers-before)]\n        {:opcode       (:opcode instruction)\n         :behaves-like (remove nil? (for [[opcode f] opcode->f]\n                                      (let [cpu (f cpu instruction)]\n                                        (if (= (:registers cpu) registers-after) opcode nil))))}))\n    \n    (defn load-instructions [fname]\n      (map parse-instruction (str/split-lines (slurp fname))))\n    \n    (defn run-prog [prog]\n      (let [cpu (initialize-cpu)]\n        (reduce (fn [cpu {:keys [opcode] :as instruction}]\n                  (let [opcode-symbol (opcode->opcode-symbol opcode)\n                        opcode-f (opcode->f opcode-symbol)]\n                    (opcode-f cpu instruction)))\n                cpu\n                prog)))", "id": "ebwfjuq", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Python 3.** \n\nParsing input is not my strongest skill, but otherwise I'm satisfied with the code. Overslept, so I was nowhere near the leaderboard but it took about 15 + 7 min to complete. Added comments, otherwise not cleaned up. \n\n    with open('16-1.in') as f:\n      l1 = [l.rstrip('\\n') for l in f]\n    with open('16-2.in') as f:\n      l2 = [l.rstrip('\\n') for l in f]\n    \n    def addr(a, b, c, r) :  return r[a]+r[b] \n    def addi(a, b, c, r) :  return r[a]+b\n    def mulr(a, b, c, r) :  return r[a]*r[b]\n    def muli(a, b, c, r) :  return r[a]*b\n    def banr(a, b, c, r) :  return r[a]&r[b]\n    def bani(a, b, c, r) :  return r[a]&b\n    def borr(a, b, c, r) :  return r[a]|r[b]\n    def bori(a, b, c, r) :  return r[a]|b\n    def setr(a, b, c, r) :  return r[a]\n    def seti(a, b, c, r) :  return a\n    def gtir(a, b, c, r) :  return int(a > r[b])\n    def gtri(a, b, c, r) :  return int(r[a] > b)\n    def gtrr(a, b, c, r) :  return int(r[a]>r[b])\n    def eqir(a, b, c, r) :  return int(a == r[b])\n    def eqri(a, b, c, r) :  return int(r[a] == b)\n    def eqrr(a, b, c, r) :  return int(r[a] == r[b])\n    \n    def exe(f, a, b, c, r) : \n      r[c] = f(a, b, c, r)\n      return r\n    \n    funcs = [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]\n    \n    FOP = {}                             # List of figured out operators\n    CA = {x : set() for x in range(16)}  # OP candidates \n    \n    def cfuncs(bef, aft, ins) :\n      cf = 0\n      mem = bef\n      for f in funcs : \n        bef = [x for x in mem]\n        if exe(f,ins[1],ins[2],ins[3],bef) == aft :\n          CA[ins[0]].add(f)\n          cf += 1\n      return cf\n    \n    # Part 1\n    p1ans = 0 \n    for r in range(0, len(l1), 4) :  \n      c1, c2, c3 = l1[r:r+3]\n      bef = [int(c1[x]) for x in [9,12,15,18]]\n      ins = [int(x) for x in c2.split(\" \")]\n      aft = [int(c3[x]) for x in [9,12,15,18]]\n    \n      cnt = cfuncs(bef, aft, ins) \n      p1ans += 1 if (cnt > 2) else 0 \n    \n    print(\"Part 1:\", p1ans)\n    \n    # Part 2\n    # Reduce candidate list\n    while len(FOP) < 16 :        \n      for d in range(16) :      \n        CA[d] = [c for c in CA[d] if c not in [FOP[x] for x in FOP]]\n        if len(CA[d]) == 1 :          \n          FOP[d] = CA[d][0]\n    \n    # Execute program for part 2\n    r = [0, 0, 0, 0]\n    for l in l2 : \n      ins = [int(x) for x in l.split(\" \")]\n      r = exe(FOP[ins[0]],ins[1],ins[2],ins[3], r)\n    \n    print(\"Part 2:\", r[0])\n\n&#x200B;", "id": "ebwglx8", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "C# this was a fun and hard one. I figured out which code was which function by hand by keeping track of when a function gave the correct output, wat opcode number was called, as you can see in some of my code. Not the cleanest, but this was easier for me.\n\n    private static void Day16() {\n        Console.WriteLine(\"Day 16 - Question 1:\");\n\n        string input = File.ReadAllText($\"{path}Advent of Code - Day 16 - Op Codes.txt\");\n\n        //foreach (char c in input) {\n        //    Console.WriteLine(c);\n        //}\n\n        string[] inputs = input.Split(\"\\n\\r\\n\");\n\n        int three = 0;\n\n        List<int>[] possible = new List<int>[16];\n\n        for (int i = 0; i < 16; i++)\n            possible[i] = new List<int>();\n\n        foreach (string s in inputs) {\n            string[] lines = s.Split('\\n');\n\n            int reg1, reg2, reg3, reg4;\n            reg1 = Convert.ToInt32(lines[0][9].ToString());\n            reg2 = Convert.ToInt32(lines[0][12].ToString());\n            reg3 = Convert.ToInt32(lines[0][15].ToString());\n            reg4 = Convert.ToInt32(lines[0][18].ToString());\n\n            int com1, com2, com3, com4;\n            string[] coms = lines[1].Split(' ');\n            com1 = Convert.ToInt32(coms[0]);\n            com2 = Convert.ToInt32(coms[1]);\n            com3 = Convert.ToInt32(coms[2]);\n            com4 = Convert.ToInt32(coms[3]);\n\n            int res1, res2, res3, res4;\n            res1 = Convert.ToInt32(lines[2][9].ToString());\n            res2 = Convert.ToInt32(lines[2][12].ToString());\n            res3 = Convert.ToInt32(lines[2][15].ToString());\n            res4 = Convert.ToInt32(lines[2][18].ToString());\n\n            ops[] re = new ops[16] {\n                Addr,\n                Addi,\n                Mulr,\n                Muli,\n                Banr,\n                Bani,\n                Borr,\n                Bori,\n                Setr,\n                Seti,\n                Gtir,\n                Gtri,\n                Gtrr,\n                Eqir,\n                Eqri,\n                Eqrr\n            };\n\n            int correct = 0;\n            for (int i = 0; i < re.Length; i++) {\n                int[] registry = { reg1, reg2, reg3, reg4 };\n                re[i](ref registry, com2, com3, com4);\n                if (registry[0] == res1 && registry[1] == res2 && registry[2] == res3 && registry[3] == res4) {\n                    correct++;\n                    if (!possible[i].Contains(com1))\n                        possible[i].Add(com1);\n                }\n            }\n\n            if (correct >= 3)\n                three++;\n\n            //Console.WriteLine($\"{reg1} - {reg2} - {reg3} - {reg4} --- {com1} - {com2} - {com3} - {com4} --- {res1} - {res2} - {res3} - {res4}\");\n        }\n\n        Console.WriteLine($\"Answer Q16.1: {three}\\n\");\n\n        input = File.ReadAllText($\"{path}Advent of Code - Day 16 - Op Code Program.txt\");\n        inputs = input.Split('\\n');\n\n        int[] reg = { 0, 0, 0, 0 };\n\n        ops[] commands = new ops[16] {\n                Borr,\n                Seti,\n                Mulr,\n                Eqri,\n                Banr,\n                Bori,\n                Bani,\n                Gtri,\n                Addr,\n                Muli,\n                Addi,\n                Eqrr,\n                Gtir,\n                Eqir,\n                Setr,\n                Gtrr\n            };\n\n        foreach (string s in inputs) {\n            int com1, com2, com3, com4;\n            string[] coms = s.Split(' ');\n            com1 = Convert.ToInt32(coms[0]);\n            com2 = Convert.ToInt32(coms[1]);\n            com3 = Convert.ToInt32(coms[2]);\n            com4 = Convert.ToInt32(coms[3]);\n        \n            commands[com1](ref reg, com2, com3, com4);\n        }\n\n        Console.WriteLine($\"Answer Q16.2: {reg[0]}\\n\");\n    }\n\n    private delegate void ops(ref int[] reg, int a, int b, int c);\n\n    private static void Addr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] + reg[b];\n\n    private static void Addi(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] + b;\n\n    private static void Mulr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] * reg[b];\n\n    private static void Muli(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] * b;\n\n    private static void Banr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] & reg[b];\n\n    private static void Bani(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] & b;\n\n    private static void Borr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] | reg[b];\n\n    private static void Bori(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] | b;\n\n    private static void Setr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a];\n\n    private static void Seti(ref int[] reg, int a, int b, int c) => reg[c] = a;\n\n    private static void Gtir(ref int[] reg, int a, int b, int c) => reg[c] = a > reg[b] ? 1 : 0;\n\n    private static void Gtri(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] > b ? 1 : 0;\n\n    private static void Gtrr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] > reg[b] ? 1 : 0;\n\n    private static void Eqir(ref int[] reg, int a, int b, int c) => reg[c] = a == reg[b] ? 1 : 0;\n\n    private static void Eqri(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] == b ? 1 : 0;\n\n    private static void Eqrr(ref int[] reg, int a, int b, int c) => reg[c] = reg[a] == reg[b] ? 1 : 0;", "id": "ebwh1kw", "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "Gold \\#1356. Hint for part 2: it\u2019s handy to generate a list of (name, [possible opcodes]) for the figuring-out part.\n\n    #!/usr/bin/env python3\n    import collections\n    import json\n    with open(\"input/16a.txt\") as fh:\n        file_data_A = fh.read().strip()\n    with open(\"input/16b.txt\") as fh:\n        file_data_B = fh.read().strip()\n\n\n    class CPU:\n        registers = []\n\n        def __init__(self, registers=None):\n            if registers is None:\n                self.registers = [0, 0, 0, 0]\n            else:\n                self.registers = registers\n            self.starting = self.registers.copy()\n\n        def undo(self):\n            self.registers = self.starting.copy()\n\n        def copy(self):\n            return CPU(self.registers.copy())\n\n        def __eq__(self, other):\n            if isinstance(other, CPU):\n                return self.registers == other.registers\n            return self.registers == other  # list\n\n        def addr(self, a, b, c):\n            self.registers[c] = self.registers[a] + self.registers[b]\n\n        def addi(self, a, b, c):\n            self.registers[c] = self.registers[a] + b\n\n        def mulr(self, a, b, c):\n            self.registers[c] = self.registers[a] * self.registers[b]\n\n        def muli(self, a, b, c):\n            self.registers[c] = self.registers[a] * b\n\n        def banr(self, a, b, c):\n            self.registers[c] = self.registers[a] & self.registers[b]\n\n        def bani(self, a, b, c):\n            self.registers[c] = self.registers[a] & b\n\n        def borr(self, a, b, c):\n            self.registers[c] = self.registers[a] | self.registers[b]\n\n        def bori(self, a, b, c):\n            self.registers[c] = self.registers[a] | b\n\n        def setr(self, a, _b, c):\n            self.registers[c] = self.registers[a]\n\n        def seti(self, a, _b, c):\n            self.registers[c] = a\n\n        def gtir(self, a, b, c):\n            self.registers[c] = int(a > self.registers[b])\n\n        def gtri(self, a, b, c):\n            self.registers[c] = int(self.registers[a] > b)\n\n        def gtrr(self, a, b, c):\n            self.registers[c] = int(self.registers[a] > self.registers[b])\n\n        def eqir(self, a, b, c):\n            self.registers[c] = int(a == self.registers[b])\n\n        def eqri(self, a, b, c):\n            self.registers[c] = int(self.registers[a] == b)\n\n        def eqrr(self, a, b, c):\n            self.registers[c] = int(self.registers[a] == self.registers[b])\n\n        def run(self, op, a, b, c):\n            print(self.opcodes[op], a, b, c)\n            self.opcodes[op](self, a, b, c)\n\n        def run_line(self, line):\n            self.run(*(int(i) for i in line.split()))\n\n        operations = [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]\n        opcodes = {\n            0: seti, # I\u2019m not spoiling the entire list here; it is on my GitHub though.\n        }\n\n\n    def solveA(data):\n        matches_three_or_more = 0\n        for problem in data.split('\\n\\n'):\n            before_line, op_line, after_line = problem.split('\\n')\n            before = json.loads(before_line.split(': ')[-1].strip())\n            after = json.loads(after_line.split(': ')[-1].strip())\n            op = [int(i) for i in op_line.split()]\n            opcode_num, a, b, c = op\n\n            print(op)\n            cpu = CPU(before)\n            matches = 0\n            for operation in CPU.operations:\n                operation(cpu, a, b, c)\n                if cpu == after:\n                    print(\"Matches operation\", operation)\n                    matches += 1\n                cpu.undo()\n            if matches >= 3:\n                matches_three_or_more += 1\n            print('\\n')\n\n        return matches_three_or_more\n\n\n    def prepareB(data):\n        candidates = {}\n        for opcode_num in range(16):\n            candidates[opcode_num] = collections.Counter()\n\n        for problem in data.split('\\n\\n'):\n            before_line, op_line, after_line = problem.split('\\n')\n            before = json.loads(before_line.split(': ')[-1].strip())\n            after = json.loads(after_line.split(': ')[-1].strip())\n            op = [int(i) for i in op_line.split()]\n            opcode_num, a, b, c = op\n\n            print(op)\n            cpu = CPU(before)\n            for operation in CPU.operations:\n                operation(cpu, a, b, c)\n                if cpu == after:\n                    candidates[opcode_num][operation.__name__] += 1\n                cpu.undo()\n\n        functions = {}\n        for opcode_num in range(16):\n            functions[opcode_num] = candidates[opcode_num].most_common()\n            print(opcode_num, candidates[opcode_num].most_common())\n\n        print()\n\n        for op in CPU.operations:\n            poss = []\n            for opcode_num in range(16):\n                if op.__name__ in candidates[opcode_num]:\n                    poss.append(opcode_num)\n            print(op.__name__, poss)\n\n\n    def solveB(data):\n        cpu = CPU()\n        for line in data.split('\\n'):\n            cpu.run_line(line)\n            print(cpu.registers)\n\n        return cpu.registers[0]\n\n\n    print(solveA(file_data_A))\n    prepareB(file_data_B)\n    solveB(file_data_B)\n\nHere\u2019s another script to automate part 2 preparations:\n\n    #!/usr/bin/env python3\n    # 16b1_auto: figure out opcode meaning\n    import json\n    from typing import Dict, List\n\n    input_data = \"\"\"addr [6, 12, 15]\n    addi [4, 6, 12, 15]\n    mulr [6]\n    muli [5, 6, 12, 15]\n    banr [0, 4, 5, 6, 10, 11]\n    bani [0, 5, 6, 8, 10, 11, 12]\n    borr [6, 12]\n    bori [4, 6, 10, 12]\n    setr [2, 4, 6, 10, 12]\n    seti [0, 4, 6, 12, 15]\n    gtir [0, 2, 3, 5, 6, 8, 11, 12]\n    gtri [0, 3, 4, 6, 7, 8, 9, 11, 12]\n    gtrr [0, 3, 5, 6, 7, 8, 11, 12]\n    eqir [0, 1, 3, 4, 5, 7, 8, 9, 11, 12]\n    eqri [0, 1, 3, 5, 7, 8, 11, 12, 13]\n    eqrr [0, 1, 3, 5, 8, 9, 11, 13, 14]\"\"\"\n\n    d: Dict[str, List[int]] = {}\n\n    for l in input_data.split('\\n'):\n        instruction, possibilities = l[:4], json.loads(l[5:])\n        d[instruction] = possibilities\n\n    seen = 0\n    instructions: Dict[int, str] = {i: None for i in range(16)}\n\n    while seen < 16:\n        instruction: str\n        possibilities: List[int]\n        for instruction, possibilities in d.items():\n            if len(possibilities) == 1:\n                seen += 1\n                found = possibilities[0]\n                instructions[found] = instruction\n                print(instruction, '=', found)\n                del d[instruction]\n                for poslist in d.values():\n                    if found in poslist:\n                        poslist.remove(found)\n                break\n\n    print(\"\\n{\")\n    print(\",\\n\".join(f\"    {i}: {instructions[i]}\" for i in range(16)))\n    print(\"}\")", "id": "ebwifog", "owner_tier": 0.5, "score": 0.03703703666666667}, {"content": "[Day 16 in Kotlin](https://github.com/nielsutrecht/adventofcode/blob/master/src/main/kotlin/com/nibado/projects/advent/y2018/Day16.kt)", "id": "ebwis0p", "owner_tier": 0.9, "score": -3.703703681194552e-10}, {"content": "**JavaScript.** Shame on me, took me a while figuring out I had to make some deduction to get 1-to-1 opcode pairing before starting Part 2 (at first assumed the sample data was enough to determine exactly each opcode).\n\n&#x200B;\n\n[https://github.com/albertobastos/advent-of-code-2018-nodejs/blob/master/src/d16.js](https://github.com/albertobastos/advent-of-code-2018-nodejs/blob/master/src/d16.js)\n\n&#x200B;\n\nThat was fun, though.\n\nThe sample data is infact enough to programmatically deduce all opcodes. At least it was for my input, and I assume everyone's input has been chosen to do exactly that. In hindsight it definitely seems faster to do by hand though, so there's that.\n\n**Edit:** Wait but you did programmatically deduce the opcodes. I guess I misunderstood what you were saying.\n\nYep, what I tried to say is that, after the sample data, I expected to have only one \"potential instruction\" for each opcode. I even put a validation asserting that before starting Part 2, and when it triggered is when I started struggling until I realised that you had to apply deduction for instructions potentially paired with multiple opcodes.", "id": "ebwiyx4", "owner_tier": 0.1, "score": 0.11111111074074075}, {"content": "[My **Scala** solution](https://github.com/sim642/adventofcode/blob/master/src/main/scala/eu/sim642/adventofcode2018/Day16.scala).\n\nFor part 2 I initially only did the intersections per opcode number, but that didn't turn out to be enough. For a moment I thought I had a bug somewhere in the evaluation but then realized more deductions could be made.\n\nSo I added something like unit propagation, which removes exactly defined mappings from all others. I also did it early during the fitting from a single sample so it'd be useful as early as possible and make other unit propagations possible. Turns out this was enough to give a unique mapping that works. Now thinking about it, I'm not sure whether this just happens to work here or a separate solving stage would be generally needed. I suppose some especially difficult cases would be possible, where unique mapping exists but it can't be simply deduced by unit propagation and requires SAT solving.", "id": "ebwjibf", "owner_tier": 0.9, "score": -3.703703681194552e-10}, {"content": "C# today.\n\nI could only find one operation code that matched only one algorithm, and was stuck on the identifying stage until I realised I could remove any that were identified already from the check.\n\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Linq;\n    \n    namespace aoc16\n    {\n        class Program\n        {\n            static int[] reg = new int[] { 0, 0, 0, 0 };\n            static void Main(string[] args)\n            {\n                var ops = new List<Operation>();\n    \n                //addr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] + reg[b];\n                }));\n                //addi\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] + b;\n                }));\n                //mulr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] * reg[b];\n                }));\n                //muli\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] * b;\n                }));\n                //banr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] & reg[b];\n                }));\n                //bani\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] & b;\n                }));\n                //borr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] | reg[b];\n                }));\n                //bori\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] | b;\n                }));\n                //setr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a];\n                }));\n                //seti\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = a;\n                }));\n                //gtir\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = a > reg[b] ? 1 : 0;\n                }));\n                //gtri\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] > b ? 1 : 0;\n                }));\n                //gtrr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] > reg[b] ? 1 : 0;\n                }));\n                //eqir\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = a == reg[b] ? 1 : 0;\n                }));\n                //eqri\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] == b ? 1 : 0;\n                }));\n                //eqrr\n                ops.Add(new Operation((a, b, c) =>\n                {\n                    reg[c] = reg[a] == reg[b] ? 1 : 0;\n                }));\n    \n                var input1 = File.ReadAllLines(\"input1.txt\");\n                for (int i = 0; i < input1.Length; i += 4)\n                {\n                    var bf = input1[i];\n                    var before = new int[] {\n                        int.Parse(bf.Substring(9,1)),\n                        int.Parse(bf.Substring(12,1)),\n                        int.Parse(bf.Substring(15,1)),\n                        int.Parse(bf.Substring(18,1))\n                    };\n                    var af = input1[i + 2];\n                    var after = new int[] {\n                        int.Parse(af.Substring(9,1)),\n                        int.Parse(af.Substring(12,1)),\n                        int.Parse(af.Substring(15,1)),\n                        int.Parse(af.Substring(18,1))\n                    };\n                    var p = input1[i + 1].Split(' ');\n                    var o = int.Parse(p[0]);\n                    var a = int.Parse(p[1]);\n                    var b = int.Parse(p[2]);\n                    var c = int.Parse(p[3]);\n    \n                    var matches = FindOpCodes(ops, before, a, b, c, o, after);\n                }\n                \n                reg = new int[] {0,0,0,0};\n    \n                var input2 = File.ReadAllLines(\"input2.txt\");\n                foreach (var line in input2)\n                {\n                    var inputs = line.Split(' ');\n                    var o = int.Parse(inputs[0]);\n                    var a = int.Parse(inputs[1]);\n                    var b = int.Parse(inputs[2]);\n                    var c = int.Parse(inputs[3]);\n                    var op = ops.First(x => x.OpCode == o);\n                    op.Action(a,b,c);\n                }\n    \n                Console.WriteLine(string.Join(',', reg));\n            }\n    \n            static int FindOpCodes(\n                List<Operation> ops, \n                int[] before, \n                int a, int b, int c, int opCode,\n                int[] after)\n            {\n                var count = 0;\n                Operation lastMatch = new Operation(null); \n                ops.Where(x => x.OpCode == -1).ToList().ForEach(op =>\n                {\n                    reg = (int[])before.Clone();\n                    op.Action(a, b, c);\n                    if (reg.SequenceEqual(after)) { \n                        count++;\n                        lastMatch = op;\n                    }\n                });\n                if (count == 1) {\n                    lastMatch.OpCode = opCode;\n                }\n                return count;\n            }\n        }\n    \n        public class Operation {\n            public Operation(Action<int,int,int> action) {\n                Action = action;\n            }\n            public Action<int,int,int> Action { get; set; }\n            public int OpCode { get; set; } = -1;\n        }\n    }", "id": "ebwjrv1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "I spent a lot of time trying to optimize my part1.\n\n    const LOOKUP : [u32; 64] = [38195, 38195, 38195, 38195, 4403, 13107, 54743, 48059, 5393, 39219, 21847, 39355, 37137, 47411, 21973, 39355, 4403, 13107, 22391, 48059, 46899, 46899, 46899, 46899, 5427, 47411, 22391, 48059, 37171, 47923, 22007, 48059, 5427, 13107, 22391, 39867, 5939, 14195, 55287, 48059, 38773, 38773, 38773, 38773, 38193, 47923, 21973, 39867, 37171, 47923, 22519, 48059, 45875, 47923, 57343, 48059, 38193, 47547, 22519, 48059, 46521, 46521, 46521, 46521];\n\n    pub fn solve_part1_faster(input: &str) -> usize {\n        let input = input.as_bytes();\n        let mut ret = 0;\n    \n        let mut index = 0;\n        while index < input.len() {\n            if input[index] != b'B' { break; }\n\n            let a_start = 23 + (input[index+22] != b' ') as usize;\n            let a = (input[index+a_start] & 3) as usize;\n            let b = (input[index+a_start+2] & 3) as usize;\n            let o = (input[index+a_start+4] & 3) as usize;\n            let afo = (input[a_start + 15 + (o<<1) + o] & 3) as usize;\n            let rea = (input[index + 9 + (a<<1) + a] & 3) as usize;\n            let reb = (input[index + 9 + (b<<1) + b] & 3) as usize;\n            ret += ((LOOKUP[(a<<4) | (b<<2) | rea] >> ((reb<<2) | afo)) & 0x01) as usize;\n            index += a_start + 28;\n        }\n\n        ret\n    }\n\nI got it down to 5 microseconds... but somewhat evil :)\n\n[Card] finding the secret undocumented Kaby Lake documentation", "id": "ebwk3yw", "owner_tier": 0.5, "score": -3.703703681194552e-10}, {"content": "A concise way to solve problem 1 in Python 3\n\n```python\nfrom re import findall\n\n\ndef optResultMatch(before, after, index, result):\n    \"\"\"Checks, whether the result of an opt code on a set of registers before\n    match the result after.\"\"\"\n    return int(before[:index] + [result] + before[(index + 1):] == after)\n\n\ndef workingOptCodes(b, a, i):\n    \"\"\"Test all of the opt-codes and return the number of those that work.\"\"\"\n    return sum([optResultMatch(b, a, i[3], ocode(b, i)) for ocode in optcodes])\n\n\n# the optcodes as lambda functions that take registers and instructions\noptcodes = [lambda reg, inst: reg[inst[1]] + reg[inst[2]],          # addr\n            lambda reg, inst: reg[inst[1]] + inst[2],               # addi\n            lambda reg, inst: reg[inst[1]] * reg[inst[2]],          # mulr\n            lambda reg, inst: reg[inst[1]] * inst[2],               # muli\n            lambda reg, inst: reg[inst[1]] & reg[inst[2]],          # banr\n            lambda reg, inst: reg[inst[1]] & inst[2],               # bani\n            lambda reg, inst: reg[inst[1]] | reg[inst[2]],          # borr\n            lambda reg, inst: reg[inst[1]] | inst[2],               # bori\n            lambda reg, inst: reg[inst[1]],                         # setr\n            lambda reg, inst: inst[1],                              # seti\n            lambda reg, inst: int(inst[1] > reg[inst[2]]),          # gtir\n            lambda reg, inst: int(reg[inst[1]] > inst[2]),          # gtri\n            lambda reg, inst: int(reg[inst[1]] > reg[inst[2]]),     # gtrr\n            lambda reg, inst: int(inst[1] == reg[inst[2]]),         # eqir\n            lambda reg, inst: int(reg[inst[1]] == inst[2]),         # eqri\n            lambda reg, inst: int(reg[inst[1]] == reg[inst[2]])]    # eqrr\n\n\ninput = open(\"16.in\", \"r\")\ndata = input.read().splitlines()\n\ni, total = 0, 0\nwhile data[i] != \"\":\n    before = [int(number) for number in findall(\"\\d+\", data[i])]\n    after = [int(number) for number in findall(\"\\d+\", data[i + 2])]\n    instruction = [int(s) for s in data[i + 1].split(\" \")]\n\n    if workingOptCodes(before, after, instruction) >= 3:\n        total += 1\n\n    i += 4\n\nprint(total)\n```", "id": "ebwl5w1", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Python, 59 lines:\n\n    import itertools\n    import re\n    import random\n\n    ops = [\n        lambda r, a, b: r[a] + r[b],\n        lambda r, a, b: r[a] + b,\n        lambda r, a, b: r[a] * r[b],\n        lambda r, a, b: r[a] * b,\n        lambda r, a, b: r[a] & r[b],\n        lambda r, a, b: r[a] & b,\n        lambda r, a, b: r[a] | r[b],\n        lambda r, a, b: r[a] | b,\n        lambda r, a, b: r[a],\n        lambda r, a, b: a,\n        lambda r, a, b: int(a > r[b]),\n        lambda r, a, b: int(r[a] > b),\n        lambda r, a, b: int(r[a] > r[b]),\n        lambda r, a, b: int(a == r[b]),\n        lambda r, a, b: int(r[a] == b),\n        lambda r, a, b: int(r[a] == r[b])\n    ]\n\n    def apply(reg, op, a, b, c):\n        return reg[:c] + [op(reg, a, b)] + reg[c+1:]\n\n    part_a = 0\n    edges = [set(range(len(ops))) for _ in ops] # my number -> {possible their number}\n    for l1, l2, l3, _ in itertools.zip_longest(*[open('16_1.in')]*4):\n        reg1 = [int(v) for v in re.findall('\\d+', l1)]\n        opcode, a, b, c = [int(v) for v in re.findall('\\d+', l2)]\n        reg2 = [int(v) for v in re.findall('\\d+', l3)]\n\n        possibilities = 0\n        for i, op in enumerate(ops):\n            if apply(reg1, op, a, b, c) == reg2:\n                possibilities += 1\n            else:\n                edges[i].discard(opcode)\n\n        if possibilities >= 3:\n            part_a += 1\n    print('Part A:', part_a)\n\n    ass = [-1]*len(ops) # their number -> my number\n    def assign(v):\n        w = random.choice(list(edges[v]))\n        u, ass[w] = ass[w], v\n        if u != -1: assign(u)\n    for i in range(len(ops)):\n        assign(i)\n\n    reg = [0]*4\n    for line in open('16_2.in'):\n        opcode, a, b, c = [int(v) for v in re.findall('\\d+', line)]\n        reg[c] = ops[ass[opcode]](reg, a, b)\n\n    print('Part B:', reg)", "id": "ebwly02", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "**Red**\n\nParts 1 and 2\n\n    Red []\n    ;;;; Part 1\n    input: replace/all read %input comma \"\"\n    ops: [\n        addr [before/(C + 1): before/(A + 1) + before/(B + 1)]\n        addi [before/(C + 1): before/(A + 1) + B]\n        mulr [before/(C + 1): before/(A + 1) * before/(B + 1)]\n        muli [before/(C + 1): before/(A + 1) * B]\n        banr [before/(C + 1): before/(A + 1) and before/(B + 1)]\n        bani [before/(C + 1): before/(A + 1) and B]\n        borr [before/(C + 1): before/(A + 1) or before/(B + 1)]\n        bori [before/(C + 1): before/(A + 1) or B]\n        setr [before/(C + 1): before/(A + 1)]\n        seti [before/(C + 1): A]\n        gtir [before/(C + 1): make integer! A > before/(B + 1)]\n        gtri [before/(C + 1): make integer! before/(A + 1) > B]\n        gtrr [before/(C + 1): make integer! before/(A + 1) > before/(B + 1)]\n        eqir [before/(C + 1): make integer! A = before/(B + 1)]\n        eqri [before/(C + 1): make integer! before/(A + 1) = B]\n        eqrr [before/(C + 1): make integer! before/(A + 1) = before/(B + 1)]\n    ]\n    op-nums: repeat i 16 [append [] i - 1]\n    foreach [op _] ops [set op copy op-nums]\n\n    count0: 0\n    parse input [some [\n        copy before thru newline (do before)\n        copy instruction thru newline (set [op* A B C] load instruction)\n        copy after thru 2 newline (do after)\n        (   \n            count: 0\n            _C: before/(C + 1)\n            foreach [op code] ops [\n                do code \n                either after = before [count: count + 1][remove find get op op*]\n                before/(C + 1): _C\n            ]\n            count0: count0 + make integer! count >= 3\n        )\n    ]]\n    print [\"Part 1:\" count0]\n\n    ;;;; Part 2\n    op-list: foreach [op _] ops [append [] op]\n    forall op-list [\n        sort/compare either 1 = length? get op-list/1 [next op-list][op-list] \n            func [a b][(length? get a) < (length? get b)]\n        foreach op next op-list [remove find get op first get op-list/1]\n    ]\n    foreach op op-list [set op first get op]\n    ops: reduce ops\n    before: [0 0 0 0]\n    foreach [op A B C] load %tests [do select ops op]\n    print [\"Part 2:\" before/1]\n", "id": "ebwlzn3", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Python3, part1 in 43 lines\n\n    import operator\n    from functools import partial\n    import re\n\n    def instruction(op, A_type, B_type, A, B, C, registers):\n        if A_type == 'r':\n            A = registers[A]\n        if B_type == 'r':\n            B = registers[B]\n        registers[C] = int(op(A, B))\n\n    # Build the set of ops\n    ops = []\n    for op in [operator.add, operator.mul, operator.and_, operator.or_]:\n        ops.append(partial(instruction, op, 'r', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n    ops.append(partial(instruction, lambda a, b: a, 'r', None))\n    ops.append(partial(instruction, lambda a, b: a, 'i', None))\n    for op in [operator.gt, operator.eq]:\n        ops.append(partial(instruction, op, 'i', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n        ops.append(partial(instruction, op, 'r', 'r'))\n\n    with open('input') as f:\n        text = f.read()\n        part1, _ = text.split('\\n\\n\\n')\n        examples = part1.split('\\n\\n')\n\n    count = 0\n    for example in examples:\n        before_str, inst_str, after_str = example.splitlines()\n        registers = [int(i) for i  in re.findall('\\d+', before_str)]\n        opcode, A, B, C = [int(i) for i  in re.findall('\\d+', inst_str)]\n        target_registers = [int(i) for i  in re.findall('\\d+', after_str)]\n\n        consistent_ops = 0\n        for op in ops:\n            registers1 = registers.copy()\n            op(A, B, C, registers1)\n            consistent_ops += (registers1 == target_registers)\n        count += (consistent_ops >= 3)\n\n    print(count)", "id": "ebwn6tw", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "python3\n\nlong and i probs didn't need to use classes, but it does the job\n\nthink some of my var naming is a little awkward\n\n    #!/usr/local/bin/python3\n    \n    import time\n    from parse import parse\n    \n    input_filename = \"../../input/input_day16.txt\"\n    \n    class InsChange:\n        def __init__(self, before, ins, result):\n            self.before = before\n            self.ins = ins\n            self.result = result\n    \n    class Rule:\n        def __init__(self, a, b, c):\n            self.a = a\n            self.b = b\n            self.c = c\n    \n        def __repr__(self):\n            return f\"{type(self)}, {self.a}, {self.b}, {self.c}\"\n    \n    class Addr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a + b\n            return state\n    \n    class Addi(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a + self.b\n            return state\n    \n    class Mulr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a * b\n            return state\n    \n    class Muli(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a * self.b\n            return state\n    \n    class Banr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a & b\n            return state\n    \n    class Bani(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a & self.b\n            return state\n    \n    class Borr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            state[self.c] = a | b\n            return state\n    \n    class Bori(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a | self.b\n            return state\n    \n    class Setr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            state[self.c] = a\n            return state\n    \n    class Seti(Rule):\n        def apply_rule(self, state):\n            state[self.c] = self.a\n            return state\n    \n    class Gtir(Rule):\n        def apply_rule(self, state):\n            b = state[self.b]\n            if self.a > b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Gtri(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            if a > self.b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Gtrr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            if a > b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Eqir(Rule):\n        def apply_rule(self, state):\n            b = state[self.b]\n            if self.a == b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Eqri(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            if a == self.b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    class Eqrr(Rule):\n        def apply_rule(self, state):\n            a = state[self.a]\n            b = state[self.b]\n            if a == b:\n                state[self.c] = 1\n            else:\n                state[self.c] = 0\n            return state\n    \n    def apply_rule(applying, part1=True):\n        ins_list = [Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori,\n                    Setr, Seti, Gtir, Gtri, Gtrr, Eqir, Eqri, Eqrr]\n        applied = [(ins, ins(*applying.ins[1:]).apply_rule(applying.before[:])) for ins in ins_list]\n        if part1:\n            return len([res for ins, res in applied if res == applying.result])\n        else:\n            return [ins for ins, res in applied if res == applying.result]\n    \n    def setup():\n        with open(input_filename) as f:\n            lines = f.read().splitlines()\n            prev_space = False\n            part1_ins = []\n            part2_ins = []\n            lines = iter(lines)\n            while True:\n                line = next(lines)\n                if line == '':\n                    if prev_space:\n                        next(lines)\n                        for line in lines:\n                            part2_ins.append(tuple(parse('{:d} {:d} {:d} {:d}', line)))\n                        return part1_ins, part2_ins\n                    prev_space = True\n                else:\n                    prev_space = False\n                    before = list(parse(\"Before: [{:d}, {:d}, {:d}, {:d}]\", line))\n                    ins = tuple(parse(\"{:d} {:d} {:d} {:d}\", next(lines)))\n                    after = list(parse(\"After:  [{:d}, {:d}, {:d}, {:d}]\", next(lines)))\n                    part1_ins.append(InsChange(before, ins, after))\n            return part1, part2\n    \n    def part1(ins_list):\n        total = 0\n        for ins in ins_list:\n            if apply_rule(ins) >= 3:\n                total += 1\n        return total\n    \n    def part2(ins_list, actual_data):\n        opcodes = {}\n        for ins in ins_list:\n            res = apply_rule(ins, False)\n            if ins.ins[0] in opcodes:\n                opcodes[ins.ins[0]] = opcodes[ins.ins[0]] & {r for r in res}\n            else:\n                opcodes[ins.ins[0]] = {r for r in res}\n    \n        actual = {}\n        while len(actual) < 16:\n            for k, v in opcodes.items():\n                if len(v) == 1:\n                    ins = v.pop()\n                    actual[k] = ins\n                    for code in opcodes:\n                        if ins in opcodes[code]:\n                            opcodes[code].remove(ins)\n    \n        opcodes = actual\n        state = [0, 0, 0, 0]\n        for ins in actual_data:\n            apply = opcodes[ins[0]](*ins[1:])\n            apply.apply_rule(state)\n        return state[0]\n    \n    def main():\n        start_setup = time.time()\n        ins1, ins2 = setup()\n        end_setup = time.time()\n    \n        start_part1 = time.time()\n        res_part1 = part1(ins1)\n        end_part1 = time.time()\n    \n        start_part2 = time.time()\n        res_part2 = part2(ins1, ins2)\n        end_part2 = time.time()\n    \n        print(f\"part 1: {res_part1}\")\n        print(f\"part 2: {res_part2}\")\n        print(f\"setup took {end_setup - start_setup} seconds\")\n        print(f\"part 1 took {end_part1 - start_part1} seconds\")\n        print(f\"part 2 took {end_part2 - start_part2} seconds\")\n        print(f\"overall took {end_part2 - start_setup} seconds\")\n    \n    if __name__ == '__main__':\n        main()\n", "id": "ebwnde4", "owner_tier": 0.7, "score": -3.703703681194552e-10}, {"content": "Haskell!\n\n[CARD] the secret technique to beating today's puzzle is -SPREADSHEETS-\n\np1- https://github.com/Benjmhart/AdventOfCode2018-haskell/blob/master/day16-1.hs\n\np2 - https://github.com/Benjmhart/AdventOfCode2018-haskell/blob/master/day16-2.hs", "id": "ebwqnp1", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "Python3, part 2 in 69 lines:\n\n    import re\n    import operator\n    from functools import partial\n\n\n    def instruction(op, A_type, B_type, A, B, C, registers):\n        if A_type == 'r':\n            A = registers[A]\n        if B_type == 'r':\n            B = registers[B]\n        registers[C] = int(op(A, B))\n\n    ops = []\n    for op in [operator.add, operator.mul, operator.and_, operator.or_]:\n        ops.append(partial(instruction, op, 'r', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n    ops.append(partial(instruction, lambda a, b: a, 'r', None))\n    ops.append(partial(instruction, lambda a, b: a, 'i', None))\n    for op in [operator.gt, operator.eq]:\n        ops.append(partial(instruction, op, 'i', 'r'))\n        ops.append(partial(instruction, op, 'r', 'i'))\n        ops.append(partial(instruction, op, 'r', 'r'))\n\n\n    with open('input') as f:\n        text = f.read()\n    part1, part2 = text.split('\\n\\n\\n')\n    examples, program = part1.split('\\n\\n'), part2[1:]\n\n\n    # Record which ops are consistent with the behaviour observed for each opcode\n    opcode_consistent = {i: set(ops) for i in range(16)}\n    for example in examples:\n        before_str, inst_str, after_str = example.splitlines()\n        r = [int(i) for i  in re.findall('\\d+', before_str)]\n        opcode, A, B, C = [int(i) for i  in re.findall('\\d+', inst_str)]\n        target_r = [int(i) for i  in re.findall('\\d+', after_str)]\n\n        consistent = opcode_consistent[opcode]\n        for op in consistent.copy():\n            r1 = r.copy()\n            op(A, B, C, r1)\n            if r1 != target_r:\n                consistent.remove(op)\n\n\n    # Once we've gone through all the examples, any op that is only consistent\n    # with a single opcode cannot be consistent with any other opcode.\n    # Repeatedly remove such ops from other opcodes.\n    opcodes = {}\n    while True:\n        try:\n            opcode, op_set = next((opcode, ops.copy()) for opcode, ops in opcode_consistent.items() if len(ops) == 1)\n        except StopIteration:\n            break\n\n        opcodes[opcode] = next(iter(op_set))\n        for consistent in opcode_consistent.values():\n            consistent.difference_update(op_set)\n        del(opcode_consistent[opcode])\n\n\n    # Run the program\n    r = [0, 0, 0, 0]\n    for line in program.splitlines():\n        opcode, A, B, C = [int(i) for i  in re.findall('\\d+', line)]\n        opcodes[opcode](A, B, C, r)\n\n    print(r[0])", "id": "ebwsdz8", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "Haskell.\n\nCard: The secret technique to beat today's puzzles is `99 Lines of Haskell fun`.\n\n    import Data.List\n    import Data.Bits\n    \n    data State = State Int Int Int Int deriving (Show, Eq)\n    data Opcode = Addr | Addi | Mulr | Muli | Banr | Bani | Borr | Bori | Setr | Seti | Gtir | Gtri | Gtrr | Eqir | Eqri | Eqrr deriving (Show, Eq)\n    data Op = Op Int Int Int Int deriving (Show, Eq)\n    data Sample = Sample State Op State deriving (Show, Eq)\n    \n    opCodeList :: [Opcode]\n    opCodeList = [Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori, Setr, Seti, Gtir, Gtri, Gtrr, Eqir, Eqri, Eqrr]\n    \n    opList :: [State -> Op -> State]\n    opList = pure operate <*> opCodeList\n    \n    split :: String -> String -> String -> [String]\n    split str sep acc\n        | str == [] = [reverse acc]\n        | take (length sep) str == sep = (reverse acc) : (split (drop (length sep) str) sep \"\")\n        | otherwise = let (x:xs) = str in split xs sep (x : acc)\n    \n    readState :: String -> State\n    readState str =\n        let [a, b, c, d] = map (\\x -> read x :: Int) (split ((drop 9 . takeWhile (/= ']')) str) \", \" \"\")\n        in State a b c d\n    \n    readOp :: String -> Op\n    readOp str = \n        let [op, a, b, c] = map(\\x -> read x :: Int) (words str)\n        in Op op a b c\n    \n    getReg :: State -> Int -> Int\n    getReg (State a _ _ _) 0 = a\n    getReg (State _ b _ _) 1 = b\n    getReg (State _ _ c _) 2 = c\n    getReg (State _ _ _ d) 3 = d\n    \n    setReg :: State -> Int -> Int -> State\n    setReg (State _ b c d) 0 v = State v b c d\n    setReg (State a _ c d) 1 v = State a v c d\n    setReg (State a b _ d) 2 v = State a b v d\n    setReg (State a b c _) 3 v = State a b c v\n    \n    operate :: Opcode -> State -> Op -> State\n    operate Addr state (Op _ a b c) = setReg state c $ (getReg state a)  + (getReg state b)\n    operate Addi state (Op _ a b c) = setReg state c $ (getReg state a)  + b\n    operate Mulr state (Op _ a b c) = setReg state c $ (getReg state a)  * (getReg state b)\n    operate Muli state (Op _ a b c) = setReg state c $ (getReg state a)  * b\n    operate Banr state (Op _ a b c) = setReg state c $ (getReg state a) .&. (getReg state b)\n    operate Bani state (Op _ a b c) = setReg state c $ (getReg state a) .&. b\n    operate Borr state (Op _ a b c) = setReg state c $ (getReg state a) .|. (getReg state b)\n    operate Bori state (Op _ a b c) = setReg state c $ (getReg state a) .|. b\n    operate Setr state (Op _ a _ c) = setReg state c $ (getReg state a)\n    operate Seti state (Op _ a _ c) = setReg state c $ a\n    operate Gtir state (Op _ a b c) = setReg state c $ if a > (getReg state b) then 1 else 0\n    operate Gtri state (Op _ a b c) = setReg state c $ if (getReg state a) > b then 1 else 0\n    operate Gtrr state (Op _ a b c) = setReg state c $ if (getReg state a) > (getReg state b) then 1 else 0\n    operate Eqir state (Op _ a b c) = setReg state c $ if a == (getReg state b) then 1 else 0\n    operate Eqri state (Op _ a b c) = setReg state c $ if (getReg state a) == b then 1 else 0\n    operate Eqrr state (Op _ a b c) = setReg state c $ if (getReg state a) == (getReg state b) then 1 else 0\n    \n    filterOutAmbiguities :: [[Opcode]] -> [Opcode]\n    filterOutAmbiguities ops\n        | all ((==1) . length) ops = map head ops\n        | otherwise =\n            let determined = map head . filter ((==1) . length) $ ops\n            in filterOutAmbiguities . map (\\xs -> if length xs == 1 then xs else xs \\\\ determined) $ ops\n    \n    analyze :: [Sample] -> [[Opcode]] -> [State -> Op -> State]\n    analyze [] ops = map operate . filterOutAmbiguities $ ops\n    analyze ((Sample before op@(Op opcode _ _ _) after):xs) ops = analyze xs newops\n        where\n            current = ops!!opcode\n            filtered = filter (\\x -> operate x before op == after) current\n            newops = (take opcode ops) ++ filtered : (drop (opcode + 1) ops)\n    \n    execute :: [State -> Op -> State] -> [Op] -> State -> State\n    execute _ [] state = state\n    execute ops (op@(Op opcode _ _ _):xs) state = execute ops xs $ (ops!!opcode) state op\n    \n    part1 :: [Sample] -> Int\n    part1 = length . filter (\\(Sample before op after) -> (length . filter (==after) $ opList <*> pure before <*> pure op) >= 3)\n    \n    part2 :: [Sample] -> [Op] -> Int\n    part2 samples program = let (State a _ _ _) = execute (analyze samples (replicate 16 opCodeList)) program (State 0 0 0 0) in a\n    \n    main :: IO()\n    main = do\n        f <- readFile(\"16.in\")\n        let [inp1, inp2] = split f \"\\n\\n\\n\\n\" \"\"\n        let input1 = [ Sample (readState l1) (readOp l2) (readState l3) | sp <- split inp1 \"\\n\\n\" \"\", let [l1, l2, l3] = lines sp]\n        let input2 = [ readOp x | x <- lines inp2]\n        putStrLn \"Solution for part 1:\"\n        print $ part1 input1\n        putStrLn \"Solution for part 2:\"\n        print $ part2 input1 input2\n\nOk, they are actually just 95 lines.\n\n&#x200B;\n\nTo disambigue the opcodes, I just filtered them repeatedly until every ambiguity was resolved, removing the lone opcodes from the groups.\n\n\\[1,2\\] \\[1\\] -> \\[1\\] \\[2\\]", "id": "ebwvnno", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "My elixir solution: [Github link](https://github.com/acmfi/AdventCode/blob/master/2018/day16/rock/solve.ex)\n\nAnother one in Elixir :) Not as elegant as your though.\n\n[Gist](https://gist.github.com/bartlomiej-korpus/9d858ad4fcf5793018f9167ade460936)", "id": "ebwwwn4", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "Python3\n\n```python\nfrom aocd import get_data\nfrom dataclasses import dataclass, field\nfrom typing import List\nfrom collections import defaultdict\n\n\n@dataclass\nclass Sample:\n    before: List\n    instr: List\n    after: List\n    behaves_like: List = field(default_factory=list)\n    \n\nclass Solver16:\n    def __init__(self, inp):\n        self.samples = []\n        self.test = []\n        self.mapping = defaultdict(list)\n        it = iter(inp.split('\\n'))\n        \n        while True:\n            try:\n                line = next(it)\n                if not line:\n                    break  # next would be test program\n                before = list(map(int, line[9:-1].split(', ')))\n                line = next(it)\n                instr = list(map(int, line.split(' ')))\n                line = next(it)\n                after = list(map(int, line[9:-1].split(', ')))\n                self.samples.append(Sample(before=before, instr=instr, after=after))\n                next(it)  # skip blank line\n            except StopIteration:\n                break\n                \n        while True:\n            try:\n                line = next(it)\n                if not line:\n                    continue\n                instr = list(map(int, line.split(' ')))\n                self.test.append(instr)\n            except StopIteration:\n                break\n            \n    def execute(self, opcode, instr, regs):\n        if opcode is None and instr[0] in self.mapping and len(self.mapping[instr[0]]) == 1:\n            opcode = self.mapping[instr[0]][0]   \n        if opcode is None:\n            raise Exception(f'{instr[0]} ambiguous')\n\n        if opcode == 'addr' or opcode == 0:\n            regs[instr[3]] = regs[instr[1]] + regs[instr[2]]\n        if opcode == 'addi' or opcode == 1:\n            regs[instr[3]] = regs[instr[1]] + instr[2]\n        if opcode == 'mulr' or opcode == 2:\n            regs[instr[3]] = regs[instr[1]] * regs[instr[2]]\n        if opcode == 'muli' or opcode == 3:\n            regs[instr[3]] = regs[instr[1]] * instr[2]\n        if opcode == 'banr' or opcode == 4:\n            regs[instr[3]] = regs[instr[1]] & regs[instr[2]]\n        if opcode == 'bani' or opcode == 5:\n            regs[instr[3]] = regs[instr[1]] & instr[2]\n        if opcode == 'borr' or opcode == 6:\n            regs[instr[3]] = regs[instr[1]] | regs[instr[2]]\n        if opcode == 'bori' or opcode == 7:\n            regs[instr[3]] = regs[instr[1]] | instr[2]\n        if opcode == 'setr' or opcode == 8:\n            regs[instr[3]] = regs[instr[1]]\n        if opcode == 'seti' or opcode == 9:\n            regs[instr[3]] = instr[1]\n        if opcode == 'gtir' or opcode == 10:\n            regs[instr[3]] = 1 if instr[1] > regs[instr[2]] else 0\n        if opcode == 'gtri' or opcode == 11:\n            regs[instr[3]] = 1 if regs[instr[1]] > instr[2] else 0\n        if opcode == 'gtrr' or opcode == 12:\n            regs[instr[3]] = 1 if regs[instr[1]] > regs[instr[2]] else 0\n        if opcode == 'eqir' or opcode == 13:\n            regs[instr[3]] = 1 if instr[1] == regs[instr[2]] else 0\n        if opcode == 'eqri' or opcode == 14:\n            regs[instr[3]] = 1 if regs[instr[1]] == instr[2] else 0\n        if opcode == 'eqrr' or opcode == 15:\n            regs[instr[3]] = 1 if regs[instr[1]] == regs[instr[2]] else 0\n        \n    def solve(self):\n        for sample in self.samples:\n            for opcode in range(16):\n                regs = sample.before[:]\n                self.execute(opcode, sample.instr, regs)\n                if sample.after == regs:\n                    if opcode not in self.mapping[sample.instr[0]]:\n                        self.mapping[sample.instr[0]].append(opcode)\n                    sample.behaves_like.append(opcode)\n        \n        return sum([1 for x in self.samples if len(x.behaves_like) >= 3])\n    \n    def eliminate_dups(self):\n        while True:\n            changed = False\n            \n            to_remove = []\n            not_touch = []\n            for op, maps in self.mapping.items():\n                if len(maps) == 1:\n                    to_remove.append(maps[0])\n                    not_touch.append(op)\n                    \n            for remove in to_remove:\n                for op, maps in self.mapping.items():\n                    if remove in maps and op not in not_touch:\n                        maps.remove(remove)\n                        changed = True\n            \n            if not changed:\n                break\n    \n    def solve2(self):\n        self.solve()\n        self.eliminate_dups()\n\n        regs = [0] * 4\n        for test in self.test:\n            self.execute(None, test, regs)\n        \n        return regs[0]\n        \n\nsolver = Solver16(get_data(day=16, year=2018))\nprint(solver.solve())\nprint(solver.solve2())\n\n\n```", "id": "ebwzl2o", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Well, one fun today. Yesterday is still pending ... My solution is quite extense because I implemented some classes and enums for the opcodes.\n\n[https://github.com/blfuentes/AdventOfCode\\_2018/tree/master/day16](https://github.com/blfuentes/AdventOfCode_2018/tree/master/day16)\n\n**Typescript**\n\n\"happy\" with the algorithm I created to resolve the opcodes.\n\n    function operatorsToResolve(){\n    \treturn operatorDictionary.filter(_o => _o.length > 0).length > 0;\n    }\n    \n    let operatorsSolution: Array<OperatorType> = [];\n    \n    function resolveOpCodes() {\n    \tlet tmpOperator = operatorDictionary.find(_o => _o.length == 1);\n    \tlet initialOperator = -1;\n    \tlet index = -1;\n    \tif (tmpOperator != undefined) {\n    \t\tindex = operatorDictionary.indexOf(tmpOperator);\n    \t\tinitialOperator = tmpOperator[0];\n    \t\ttmpOperator.pop();\n    \t\toperatorsSolution[index] = initialOperator;\n    \t}\n    \twhile (operatorsToResolve()) {\n    \t\t// find next \n    \t\tfor (let operator of operatorDictionary) {\n    \t\t\tindex = operator.indexOf(initialOperator);\n    \t\t\tif (index != -1) {\n    \t\t\t\toperator.splice(index, 1);\n    \t\t\t}          \n    \t\t}\n    \t\ttmpOperator = operatorDictionary.find(_o => _o.length == 1);\n    \t\tif (tmpOperator != undefined) {\n    \t\t\tindex = operatorDictionary.indexOf(tmpOperator);\n    \t\t\tinitialOperator = tmpOperator[0];\n    \t\t\ttmpOperator.pop();\n    \t\t\toperatorsSolution[index] = initialOperator;\n    \t\t}\n    \t}\n    }", "id": "ebx7q86", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Ocaml**\n\nParsing was a bit annoying in Ocaml, but the rest is a breeze. Used Sets to keep track of possible values for each op-code, and set intersection/difference to remove the impossible values for each of them. Note that the input was crafted so that we didn't need any backtracking, so I\u00a0didn't bother implementing one.\n\n```\ntype instruction = {\n  code : int;\n  a : int;\n  b : int;\n  c : int;\n};;\ntype sample = {\n  before : int array;\n  after : int array;\n  instr : instruction;\n};;\n\ntype op =\n  | Mulr | Muli\n  | Addr | Addi\n  | Banr | Bani\n  | Borr | Bori\n  | Setr | Seti\n  | Gtir | Gtri | Gtrr\n  | Eqir | Eqri | Eqrr\n  | UKN;;\n\nlet execr reg i f = reg.(i.c) <- (f reg.(i.a) reg.(i.b));;\nlet execi reg i f = reg.(i.c) <- (f reg.(i.a) i.b);;\n\nlet exec_comp reg i f a b = reg.(i.c) <- (if (f a b) then 1 else 0);;\n\nlet process reg i = function\n  | Mulr -> execr reg i ( * );\n  | Muli -> execi reg i ( * );\n  | Addr -> execr reg i (+);\n  | Addi -> execi reg i (+);\n  | Banr -> execr reg i (land);\n  | Bani -> execi reg i (land);\n  | Borr -> execr reg i (lor);\n  | Bori -> execi reg i (lor);\n  | Setr -> reg.(i.c) <- reg.(i.a);\n  | Seti -> reg.(i.c) <- i.a;\n  | Gtir -> exec_comp reg i (>) i.a reg.(i.b);\n  | Gtri -> exec_comp reg i (>) reg.(i.a) i.b;\n  | Gtrr -> exec_comp reg i (>) reg.(i.a) reg.(i.b);\n  | Eqir -> exec_comp reg i (==) i.a reg.(i.b);\n  | Eqri -> exec_comp reg i (==) reg.(i.a) i.b ;\n  | Eqrr -> exec_comp reg i (==) reg.(i.a) reg.(i.b);\n  | UKN -> failwith \"unknown op code\";;\n\nlet all_ops =  Mulr :: Muli :: Addr :: Addi :: Banr :: Bani :: Borr :: Bori :: Setr :: Seti :: Gtir :: Gtri :: Gtrr :: Eqir :: Eqri :: Eqrr :: [];;\n\nlet make_instr co a b c = {code = co; a = a; b = b; c = c};;\n\nlet make_sample i1 i2 i3 i4 co a b c j1 j2 j3 j4 =\n  let before = [|i1; i2; i3; i4|] and after = [|j1; j2; j3; j4|] in\n  {before = before; after = after; instr = make_instr co a b c};;\n\n\nlet rec parse =  function () ->\ntry\n  let l1 = read_line () in\n  if l1.[0] != 'B' then failwith \"end\";\n  let l2 = read_line () and l3 = read_line () and l4 = read_line () in\n  let inp = l1 ^ \"\\n\" ^ l2 ^  \"\\n\" ^ l3 ^  \"\\n\" ^ l4 ^ \"\\n\" in\n  let s = Scanf.sscanf inp \"Before: [%d, %d, %d, %d]\\n%d %d %d %d\\nAfter:  [%d, %d, %d, %d]\\n\\n\" make_sample in\n  s :: (parse ());\nwith _ -> [] ;;\n\nlet l = parse ();;\n\nlet _ = read_line ();;\n\nlet rec parse_instr =  function () ->\ntry\n  let l = read_line () in\n  let s = Scanf.sscanf l \"%d %d %d %d\" make_instr in\n  s :: (parse_instr ());\nwith _ -> [] ;;\n\nlet all_instr = parse_instr ();;\n\nlet matches s oper =\n  let in_reg = Array.init 4 (fun i -> s.before.(i)); in\n  process in_reg s.instr oper;\n  s.after = in_reg;;\n\nlet result = List.fold_left (fun sum spl ->\n    let match_count = List.fold_left (fun sum m -> sum + (if (matches spl m) then 1 else 0)) 0 all_ops in\n    sum + (if match_count >= 3 then 1 else 0)\n  ) 0 l ;;\n\nPrintf.printf \"Part 1 = %d\\n\" result;;\n\nmodule OpSet = Set.Make(\n  struct\n    let compare = Pervasives.compare\n    type t = op\n  end );;\n\nlet possible_ops = Array.init (List.length all_ops) (fun _-> OpSet.of_list all_ops) ;;\n\n(* filter based on input *)\nList.iter (fun spl ->\n    let matching = List.filter (matches spl) all_ops in\n    let possible = OpSet.of_list matching in\n    possible_ops.(spl.instr.code) <- OpSet.inter possible_ops.(spl.instr.code) possible\n  ) l;;\n\nlet true_ops = Array.make (List.length all_ops) UKN;;\n\n(* filter based on already known operation. Note that this is greedy, in general we would need to backtrack if needed*)\nwhile (Array.exists (fun o -> match o with |UKN->true |_->false) true_ops) do\n  let affected = OpSet.of_seq (Seq.filter_map (fun ops ->\n      if OpSet.cardinal ops == 1 then Some (OpSet.choose ops) else None)\n      (Array.to_seq possible_ops)) in\n  Array.iteri (fun i ops ->\n      if (OpSet.cardinal ops) > 1 then\n        possible_ops.(i) <- OpSet.diff ops affected\n      else\n        true_ops.(i) <- OpSet.choose ops) possible_ops;\ndone;;\n\nlet reg = Array.make 4 0;;\n\n\n(* execute program *)\nList.iter (fun i -> process reg i true_ops.(i.code)) all_instr;;\n\nPrintf.printf \"Part 2 = %d\\n\" reg.(0);;\n```", "id": "ebxgwvb", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Clojure\n\n&#x200B;\n\n    (def input (clojure.string/split (slurp \"input.txt\") #\"\\r\\n\"))\n    \n    (defn read-state [line]\n      (mapv\n        read-string\n        (rest (re-matches #\"Before: \\[(\\d+), (\\d+), (\\d+), (\\d+)\\]\" line))))\n    \n    (defn read-op [line]\n      (mapv read-string (rest (re-matches #\"(\\d+) (\\d+) (\\d+) (\\d+)\" line))))\n    \n    (defn load-line [[before cmd after _]]\n     [(read-state before) (read-op cmd) (read-state after)])\n    \n    (def commands (->> input (take 3112) (partition 4) (map load-lines)))\n    \n    (def prog (->> input (drop 3114) (map read-op)))\n    \n    (defn addr [r [a b c]] (assoc r c (+ (r a) (r b))))\n    (defn addi [r [a b c]] (assoc r c (+ (r a) b)))\n    (defn mulr [r [a b c]] (assoc r c (* (r a) (r b))))\n    (defn muli [r [a b c]] (assoc r c (* (r a) b)))\n    (defn banr [r [a b c]] (assoc r c (bit-and (r a) (r b))))\n    (defn bani [r [a b c]] (assoc r c (bit-and (r a) b)))\n    (defn borr [r [a b c]] (assoc r c (bit-or (r a) (r b))))\n    (defn bori [r [a b c]] (assoc r c (bit-or (r a) b)))\n    (defn setr [r [a b c]] (assoc r c (r a)))\n    (defn seti [r [a b c]] (assoc r c a))\n    (defn gtir [r [a b c]] (assoc r c (if (> a (r b)) 1 0)))\n    (defn gtri [r [a b c]] (assoc r c (if (> (r a) b) 1 0)))\n    (defn gtrr [r [a b c]] (assoc r c (if (> (r a) (r b)) 1 0)))\n    (defn eqir [r [a b c]] (assoc r c (if (= a (r b)) 1 0)))\n    (defn eqri [r [a b c]] (assoc r c (if (= (r a) b) 1 0)))\n    (defn eqrr [r [a b c]] (assoc r c (if (= (r a) (r b)) 1 0)))\n    \n    (def ops [addi addr muli mulr bani banr bori borr\n              seti setr gtir gtri gtrr eqir eqri eqrr])\n    \n    (defn op-match [line]\n     (filter\n       (fn [op] (= (op (first line) (rest (second line))) (last line)))\n       ops))\n    \n    (defn at-least-three-ops [line]\n      (<= 3 (count (op-match line))))\n    \n    (prn (count (filter at-least-three-ops commands)))\n    \n    ;; manually determined\n    (def cmd-map {7 bori 0 muli 14 mulr 2 addi 12 addr\n                  11 borr 6 setr 1 bani 15 banr\n                  3 seti 5 eqir 13 gtrr 4 eqrr 8 gtri\n                  9 eqri 10 gtir})\n    \n    (def op-maps (map (fn [x] [(first (second x)) (op-match x)]) commands))\n    \n    (defn run-cmd [state line]\n     ((cmd-map (first line)) state (rest line)))\n    \n    (prn (reduce run-cmd [0 0 0 0] prog))", "id": "ebxijb9", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Loved the challenge! \n\nNode.js solution: [https://github.com/fhinkel/AdventOfCode2018/blob/master/day16.js](https://github.com/fhinkel/AdventOfCode2018/blob/master/day16.js)", "id": "ebxitbp", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Not as bad as day 15's. Pretty standard python code.\n\n    import re\n    from collections import defaultdict\n    from collections import Counter\n    from itertools import dropwhile\n    inplines = open('day16_input.txt').read().splitlines()\n    count = 0\n    counter = defaultdict(Counter)\n\n    pat1 = re.compile(r'(\\[.+\\])')\n    pat2= re.compile(r'(\\d+)')\n    before = []\n    opcode = []\n    after = []\n\n    for line_index, line in enumerate(inplines):    \n        if line == '':\n            count+=1\n            if count == 3:\n                line_index+=1\n                break\n            continue\n        count = 0\n\n        if 'Before' in line:\n                before.append(eval(pat1.findall(line)[0]))\n        elif 'After'in line:\n                after.append(eval(pat1.findall(line)[0]))\n        else: \n            opcode.append([int(n) for n in pat2.findall(line)])\n        \n    def addr(register, input):\n        A, B, C = input\n        register[C] = register[A] + register[B]\n        return register\n\n    def addi(register, input):\n        A, B, C = input\n        register[C] = register[A] + B\n        return register\n\n    def mulr(register, input):\n        A, B, C = input\n        register[C] = register[A] * register[B]\n        return register\n\n    def muli(register, input):\n        A, B, C = input\n        register[C] = register[A] * B\n        return register\n\n    def banr(register,input):\n        A, B, C = input\n        register[C] = register[A] & register[B]\n        return register\n\n    def bani(register, input):\n        A, B, C = input\n        register[C] = register[A] & B\n        return register\n\n    def borr(register, input):\n        A, B, C = input\n        register[C] = register[A] | register[B]\n        return register\n\n    def bori(register, input):\n        A, B, C = input\n        register[C] = register[A] | B\n        return register\n\n    def setr(register, input):\n        A, B, C = input\n        register[C] = register[A]\n        return register\n\n    def seti(register, input):\n        A, B, C = input\n        register[C] = A\n        return register\n\n    def gtir(register, input):\n        A, B, C = input\n        register[C] = int(A > register[B])\n        return register\n\n    def gtri(register, input):\n        A, B, C = input\n        register[C] = int(register[A] > B)\n        return register\n\n    def gtrr(register, input):\n        A, B, C = input\n        register[C] = int(register[A] > register[B])\n        return register\n\n    def eqir(register, input):\n        A, B, C = input\n        register[C] = int(A == register[B])\n        return register\n\n    def eqri(register, input):\n        A, B, C = input\n        register[C] = int(register[A] == B)\n        return register\n\n    def eqrr(register, input):\n        A, B, C = input\n        register[C] = int(register[A] == register[B])\n        return register\n\n    samplecounter = 0\n\n    for b, a, i in zip(before, after, opcode):\n        opcounter = 0    \n        for op in [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]:\n            r = b[:]\n            code, *input = i\n            if op(r, input) == a:\n                opcounter +=1\n                counter[op][i[0]] +=1\n        \n        if opcounter >= 3:\n            samplecounter+=1\n\n    print(samplecounter)\n\n    counters = sorted(list(counter.items()), key= lambda t: len(t[1]))\n\n    assigned = []\n    mapping = {}\n    while len(assigned)< 16:\n        for op, counter in counters[:]:\n            if len(counter) == 1:\n                for c in counter:\n                    assigned.append(c)\n                    mapping[c] = op\n                    counters.remove((op,counter))\n\n            else:\n                for k in counter.copy():\n                    if k in assigned:\n                        del counter[k]\n\n    r = [0,0,0,0]\n\n\n    for _, line in dropwhile(lambda t: t[0] < line_index, enumerate(inplines)):    \n        opid, *in_ = [int(n) for n in pat2.findall(line)]\n        mapping[opid](r,in_)\n\n    print(r)", "id": "ebxly5m", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Hello!\n\nTHANK YOU for this neat and easy puzzle. I don't know if you intended it to be \"easy\" but it really feels good to find a working solution in less than hour after yesterday's gigantic mess which ended in manually adding and substracting numbers to my output until the answer was accepted. :3\n\nSince I do actually have a working program and it has not happened in ages (smth like day 13), I submit it today: https://github.com/tut-tuuut/advent-of-code-shiny-giggle/blob/master/2018/16/part-1.php\n\nIt's written in PHP, with a few array_intersect (first time I used it this year), the usual regex-attack at the beginning to parse the input, and a little drop of sudoku logic to find which opcode has which number.\n\n[CARD] regexes (like every other day's puzzles, in fact)", "id": "ebxqdxm", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "My solution in Scala. The more I've done AoC the more I've loved what this language has to offer. \n\n    val TESTCASE_REGEX = \"\"\"^(\\w+):\\s+\\[([^]]*)\\]$\"\"\".r\n    val OPCODE_REGEX = \"\"\"^(\\d+(?:\\s+\\d+){3})$\"\"\".r\n    \n    type Regs = Vector[Int]\n    type Opcode = Vector[Int]\n    \n    case class MyOp(code: Int)\n    case class TestCase(inRegs: Regs, outRegs: Regs, opcode: Opcode)\n    \n    def operation(regs: Regs, op: MyOp, opcode: Opcode): Regs = {\n      val Seq(_, a, b, c) = opcode\n      regs.updated(c, op.code match {\n        case 0 => regs(a) + regs(b)\n        case 1 => regs(a) + b\n    \n        case 2 => regs(a) * regs(b)\n        case 3 => regs(a) * b\n    \n        case 4 => regs(a) & regs(b)\n        case 5 => regs(a) & b\n    \n        case 6 => regs(a) | regs(b)\n        case 7 => regs(a) | b\n    \n        case 8 => regs(a)\n        case 9 => a\n    \n        case 10 => if (a > regs(b)) 1 else 0\n        case 11 => if (regs(a) > b) 1 else 0\n        case 12 => if (regs(a) > regs(b)) 1 else 0\n    \n        case 13 => if (a == regs(b)) 1 else 0\n        case 14 => if (regs(a) == b) 1 else 0\n        case 15 => if (regs(a) == regs(b)) 1 else 0\n      })\n    }\n    val allOps = 0 to 15 map {MyOp(_)}\n    \n    val (testcases, instructions) = {\n      val input = scala.io.Source.fromFile(\"input\").getLines.toVector\n      val instructionPos = input.lastIndexWhere { x => TESTCASE_REGEX.findFirstMatchIn(x).isDefined } + 1\n      val (unparsedTestCases, unparsedInstructions) = input.splitAt(instructionPos)\n    \n      val testcases =\n        unparsedTestCases.sliding(3).collect {\n          case Seq(TESTCASE_REGEX(\"Before\", input),\n                   OPCODE_REGEX(v),\n                   TESTCASE_REGEX(\"After\", output)) =>\n            TestCase(inRegs = input.split(\", \").map(_.toInt).toVector,\n                     outRegs = output.split(\", \").map(_.toInt).toVector,\n                     opcode = v.split(\" \").map(_.toInt).toVector)\n        }.toVector\n      val instructions = unparsedInstructions.collect {\n        case OPCODE_REGEX(v) => v.split(\" \").map(_.toInt).toVector\n      }\n      (testcases, instructions)\n    }\n    \n    def matchingOps(tc: TestCase) = allOps.filter { op =>\n        operation(tc.inRegs, op, tc.opcode) == tc.outRegs\n      }\n    \n    @scala.annotation.tailrec\n    def removeKnownSolutions[T](curr: Map[T, Set[MyOp]], last: Map[T, Set[MyOp]] = Map.empty[T, Nothing]): Map[T, Set[MyOp]] = {\n      if (curr == last) curr\n      else {\n        val singles = curr.values.filter(_.size == 1).reduce((a, b) => a | b)\n        removeKnownSolutions(curr.mapValues { v =>\n          if (v.size == 1) v\n          else v &~ singles\n        }, curr)\n      }\n    }\n    \n    def determineOps(tcs: Seq[TestCase]) = {\n      val byOpcode = tcs.groupBy(_.opcode(0))\n      val opcodeMeanings = removeKnownSolutions(byOpcode.mapValues(_.foldLeft(allOps.toSet)((acc, tc) => acc & matchingOps(tc).toSet)))\n      assert(opcodeMeanings.values.forall(_.size == 1))\n      opcodeMeanings.mapValues(_.head)\n    }\n    \n    def part1 = testcases.filter { t => matchingOps(t).size >= 3 }.size\n    def part2 = {\n      val realOps = determineOps(testcases)\n      val finalRegs = instructions.foldLeft(Vector(0, 0, 0, 0)) { (regs, op) => operation(regs, realOps(op(0)), op) }\n      finalRegs(0)\n    }\n    \n    println(part1)\n    println(part2)\n", "id": "ebxqmbi", "owner_tier": 0.7, "score": -3.703703681194552e-10}, {"content": "Seems like I ended up doing pretty much the same thing everyone else did :)\n\n[https://github.com/kennethdmiller3/AdventOfCode2018/tree/master/16](https://github.com/kennethdmiller3/AdventOfCode2018/tree/master/16)", "id": "ebyld0b", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "The assembly problems are usually my favorite ones each year. This one was interesting! Python:\n\n    import re\n\n    samples, program = open('input.txt').read().strip().split('\\n\\n\\n\\n')\n\n    samples = [map(lambda x: tuple(map(int, re.search(r'(\\d+),? (\\d+),? (\\d+),? (\\d+)', x).groups())), s) for s in [s.split('\\n') for s in samples.split('\\n\\n')]]\n    program = [map(int, s.split(' ')) for s in program.split('\\n')]\n\n    opcodes = {\n        'addr': lambda a, b, regs: regs[a] + regs[b],\n        'addi': lambda a, b, regs: regs[a] + b,\n        'mulr': lambda a, b, regs: regs[a] * regs[b],\n        'muli': lambda a, b, regs: regs[a] * b,\n        'banr': lambda a, b, regs: regs[a] & regs[b],\n        'bani': lambda a, b, regs: regs[a] & b,\n        'borr': lambda a, b, regs: regs[a] | regs[b],\n        'bori': lambda a, b, regs: regs[a] | b,\n        'setr': lambda a, b, regs: regs[a],\n        'seti': lambda a, b, regs: a,\n        'gtir': lambda a, b, regs: int(a > regs[b]),\n        'gtri': lambda a, b, regs: int(regs[a] > b),\n        'gtrr': lambda a, b, regs: int(regs[a] > regs[b]),\n        'eqir': lambda a, b, regs: int(a == regs[b]),\n        'eqri': lambda a, b, regs: int(regs[a] == b),\n        'eqrr': lambda a, b, regs: int(regs[a] == regs[b]),\n    }\n\n    matching_samples = {}\n    possible_matches = [set(op for op in opcodes) for _ in range(16)]\n    total = 0\n\n    for before, operation, after in samples:\n        op, a, b, c = operation\n        matching_samples[(before, operation, after)] = set()\n        matches = set()\n        for instruction, opcode in opcodes.iteritems():\n            registers = list(before)\n            registers[c] = opcode(a, b, before)\n            if registers == list(after):\n                matching_samples[(before, operation, after)].add(instruction)\n                matches.add(instruction)\n        possible_matches[op] &= matches\n        if len(matching_samples[(before, operation, after)]) >= 3:\n            total += 1\n\n    print total\n\n    disambiguated = set()\n\n    while any(len(s) > 1 for s in possible_matches):\n        for s in possible_matches:\n            if len(s) == 1:\n                disambiguated |= s\n            else:\n                s -= disambiguated\n\n    possible_matches = [s.pop() for s in possible_matches]\n    registers = [0, 0, 0, 0]\n\n    for op, a, b, c in program:\n        registers[c] = opcodes[possible_matches[op]](a, b, registers)\n\n    print registers[0]", "id": "ebyt3n5", "owner_tier": 0.9, "score": -3.703703681194552e-10}, {"content": "**Rust, SweetRust**\n\nUncomment print out and sort the output -- it's pretty easy to find what virtual command (1xx, assigned by me) corresponds to what real command (0..15), and that is already included in fn exec, for execution of part 2.\n\n    use std::io::{BufRead,BufReader}; // lines() in BufRead\n    type U=usize;\n\n    fn exec( cmd:U, ops:&[U], rbf:&Vec<U> ) -> Vec<U>:\n      let mut r = rbf.clone();\n      let (a,b,c) = (ops[0],ops[1],ops[2]);\n      match cmd:\n        100|11 => /* addr ra+rb->rc */ { r[c] = r[a] + r[b]; },\n        101| 5 => /* addi ra+ b->rc */ { r[c] = r[a] +   b;  },\n        102| 1 => /* mulr ra*rb->rc */ { r[c] = r[a] * r[b]; },\n        103| 8 => /* muli ra* b->rc */ { r[c] = r[a] *   b;  },\n        104|13 => /* borr ra|rb->rc */ { r[c] = r[a] | r[b]; },\n        105| 9 => /* bori ra| b->rc */ { r[c] = r[a] |   b;  },\n        106| 4 => /* banr ra&rb->rc */ { r[c] = r[a] & r[b]; },\n        107|12 => /* bani ra& b->rc */ { r[c] = r[a] &   b;  },\n        108|10 => /* setr ra   ->rc */ { r[c] = r[a]; },\n        109| 6 => /* seti  a   ->rc */ { r[c] =   a;  },\n        110| 7 => /* gtir  a>rb->rc */ { r[c] = if   a  >  r[b] {1} else {0}; },\n        111| 2 => /* gtri ra> b->rc */ { r[c] = if r[a] >    b  {1} else {0}; },\n        112| 3 => /* gtrr ra>rb->rc */ { r[c] = if r[a] >  r[b] {1} else {0}; },\n        113|14 => /* eqir  a=rb->rc */ { r[c] = if   a  == r[b] {1} else {0}; },\n        114| 0 => /* eqri ra= b->rc */ { r[c] = if r[a] ==   b  {1} else {0}; },\n        115|15 => /* eqrr ra=rb->rc */ { r[c] = if r[a] == r[b] {1} else {0}; },\n        _ => {}\n      r\n\n    fn main():\n      let file = std::fs::File::open( \"16.dat\" ).unwrap();\n      let mut d:Vec<(String,String,String)> = vec![]; // data\n      let mut t:(String,String,String) = (String::new(),String::new(),String::new());\n      let mut b = false; // 'before' is done, command is expected\n      let mut p:Vec<String> = vec![]; // prorgam for part 2\n      for optline in BufReader::new(file).lines():\n        let line = optline.unwrap();\n        if line.starts_with(\"Before\"):\n          t.0 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          b = true;\n        else if line.starts_with(\"After\"):\n          t.2 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          d.push(t.clone());\n          b = false;\n        else if b:\n          t.1 = line[..].to_string();\n        else if line.len()>6:\n          p.push( line );\n\n      let mut o = 0;\n      for (b,c,a) in d: // (before, command, after)\n        let rbf: Vec<U> = b.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let raf: Vec<U> = a.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let mut n = 0; // how many matched the result\n        let mut good: Vec<U> = vec![];\n        for i in 100..=115: // virtual op codes\n          let res = exec( i, &cmd[1..], &rbf );\n          if raf == res:\n            good.push( i );\n            n += 1;\n        // print out and sort for analysis (yeah, by a human being, sorry)\n        // println!( \"{} -- {:?} -- ({:?}) {:?}->{:?}\", n, &good, &cmd, &rbf, &raf );\n        if n>=3:\n          o += 1;\n      println!( \"{}\", o ); // part 1\n\n      let mut r = vec![0;4];\n      for c in p:\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let res = exec( cmd[0], &cmd[1..], &r );\n        r = res;\n      println!( \"{}\", r[0] ); // part 2\n\n[My AOC2018 in J&Rust](http://zw.rf.gd/aoc2018/) | [SweetRust](http://zw.rf.gd/sweetrust/) \n\nOK, all is automatic now :)\n\n    use std::io::{BufRead,BufReader}; // lines() in BufRead\n    use std::collections::HashMap;\n    type U=usize;\n\n    fn exec( cmd:U, ops:&[U], rbf:&Vec<U> ) -> Vec<U>:\n      let mut r = rbf.clone();\n      let (a,b,c) = (ops[0],ops[1],ops[2]);\n      match cmd:\n        100 => /* addr ra+rb->rc */ { r[c] = r[a] + r[b]; },\n        101 => /* addi ra+ b->rc */ { r[c] = r[a] +   b;  },\n        102 => /* mulr ra*rb->rc */ { r[c] = r[a] * r[b]; },\n        103 => /* muli ra* b->rc */ { r[c] = r[a] *   b;  },\n        104 => /* borr ra|rb->rc */ { r[c] = r[a] | r[b]; },\n        105 => /* bori ra| b->rc */ { r[c] = r[a] |   b;  },\n        106 => /* banr ra&rb->rc */ { r[c] = r[a] & r[b]; },\n        107 => /* bani ra& b->rc */ { r[c] = r[a] &   b;  },\n        108 => /* setr ra   ->rc */ { r[c] = r[a]; },\n        109 => /* seti  a   ->rc */ { r[c] =   a;  },\n        110 => /* gtir  a>rb->rc */ { r[c] = if   a  >  r[b] {1} else {0}; },\n        111 => /* gtri ra> b->rc */ { r[c] = if r[a] >    b  {1} else {0}; },\n        112 => /* gtrr ra>rb->rc */ { r[c] = if r[a] >  r[b] {1} else {0}; },\n        113 => /* eqir  a=rb->rc */ { r[c] = if   a  == r[b] {1} else {0}; },\n        114 => /* eqri ra= b->rc */ { r[c] = if r[a] ==   b  {1} else {0}; },\n        115 => /* eqrr ra=rb->rc */ { r[c] = if r[a] == r[b] {1} else {0}; }, _ => {}\n      /* return */ r\n\n    fn main():\n      let file = std::fs::File::open( \"16.dat\" ).unwrap();\n      let mut d:Vec<(String,String,String)> = vec![]; // data\n      let mut t:(String,String,String) = (String::new(),String::new(),String::new());\n      let mut b = false; // 'before' is done, command is expected\n      let mut p:Vec<String> = vec![]; // prorgam for part 2\n      for optline in BufReader::new(file).lines():\n        let line = optline.unwrap();\n        if line.starts_with(\"Before\"):\n          t.0 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          b = true;\n        else if line.starts_with(\"After\"):\n          t.2 = line[9..line.len()-1].to_string().replace(\",\",\"\");\n          d.push(t.clone());\n          b = false;\n        else if b:\n          t.1 = line[..].to_string();\n        else if line.len()>6:\n          p.push( line );\n\n      let mut dbl: HashMap<(U,Vec<U>),U> = HashMap::new(); // n, ops -> cmd\n      let mut o = 0; // output, part 1\n      for (b,c,a) in d: // (before, command, after)\n        let rbf: Vec<U> = b.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let raf: Vec<U> = a.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let mut n = 0; // how many matched the result\n        let mut cand: Vec<U> = vec![]; // candidates\n        for i in 100..=115: // virtual op codes\n          let res = exec( i, &cmd[1..], &rbf );\n          if raf == res:\n            cand.push( i );\n            n += 1;\n        let key=(n,cand);\n        if dbl.contains_key( &key ):\n          if *dbl.get( &key ).unwrap() != cmd[0] { panic!(\"not ready for that\"); }\n        else:\n          dbl.insert( key, cmd[0] );\n        if n>=3:\n          o += 1;\n      println!( \"{}\", o ); // part 1\n\n      // analyse - build a map of real ops to virtual ops\n      let mut op2vop = vec![0;16]; // maps op --> virtual op; will be the result of analysis\n      let mut dd: Vec<(U,Vec<U>,U)> = dbl.iter().map( |(k,v)| (k.0,k.1.clone(),*v) ).collect();\n      while dd.len()>0:\n        dd.sort();\n        let (n,vops,op) = dd.remove(0);\n        if n!=1 { panic!(\"not ready for that\"); }\n        let vop = vops[0];\n        op2vop[ op ] = vop;\n        while let Some(p) = dd.iter().position( |x| x.2==op ):\n          dd.remove( p );\n        for i in 0..dd.len():\n          if let Some(p) = dd[i].1.iter().position( |&x| x==vop ):\n            dd[i].0 -= 1;\n            dd[i].1.remove( p );\n      // execute\n      let mut r = vec![0;4];\n      for c in p:\n        let cmd: Vec<U> = c.split_whitespace().filter_map( |x| x.parse().ok() ).collect();\n        let res = exec( op2vop[cmd[0]], &cmd[1..], &r );\n        r = res;\n      println!( \"{}\", r[0] ); // part 2\n", "id": "ebyv8ag", "owner_tier": 0.1, "score": 0.03703703666666667}, {"content": "My rust solution(after several refactor):\n\nI split the input into two files.\n\n    #[macro_use]\n    extern crate lazy_static;\n    extern crate regex;\n    \n    use regex::Regex;\n    use std::collections::HashSet;\n    use std::fs::File;\n    use std::io::{BufRead, BufReader};\n    \n    #[derive(Debug)]\n    struct Assertion {\n        before: [usize; 4],\n        cmd: [usize; 4],\n        after: [usize; 4],\n    }\n    \n    impl Assertion {\n        fn try_assert(&self, index: usize) -> bool {\n            self.after == execute(&self.before, &self.cmd, index)\n        }\n    }\n    \n    fn parse_line_num(line: &str) -> [usize; 4] {\n        lazy_static! {\n            static ref RE: Regex = Regex::new(r\"(\\d+)[,\\s]+(\\d+)[,\\s]+(\\d+)[,\\s]+(\\d+)\").unwrap();\n        }\n        let caps = RE.captures(line).unwrap();\n        let u1 = caps.get(1).unwrap().as_str().parse::<usize>().unwrap();\n        let u2 = caps.get(2).unwrap().as_str().parse::<usize>().unwrap();\n        let u3 = caps.get(3).unwrap().as_str().parse::<usize>().unwrap();\n        let u4 = caps.get(4).unwrap().as_str().parse::<usize>().unwrap();\n        [u1, u2, u3, u4]\n    }\n    \n    fn execute(before: &[usize; 4], cmd: &[usize; 4], index: usize) -> [usize; 4] {\n        let mut after: [usize; 4] = Default::default();\n        after.copy_from_slice(before);\n        match index {\n            0 => after[cmd[3]] = before[cmd[1]] + before[cmd[2]],\n            1 => after[cmd[3]] = before[cmd[1]] + cmd[2],\n            2 => after[cmd[3]] = before[cmd[1]] * before[cmd[2]],\n            3 => after[cmd[3]] = before[cmd[1]] * cmd[2],\n            4 => after[cmd[3]] = before[cmd[1]] & before[cmd[2]],\n            5 => after[cmd[3]] = before[cmd[1]] & cmd[2],\n            6 => after[cmd[3]] = before[cmd[1]] | before[cmd[2]],\n            7 => after[cmd[3]] = before[cmd[1]] | cmd[2],\n            8 => after[cmd[3]] = before[cmd[1]],\n            9 => after[cmd[3]] = cmd[1],\n            10 => after[cmd[3]] = if cmd[1] > before[cmd[2]] { 1 } else { 0 },\n            11 => after[cmd[3]] = if before[cmd[1]] > cmd[2] { 1 } else { 0 },\n            12 => after[cmd[3]] = if before[cmd[1]] > before[cmd[2]] { 1 } else { 0 },\n            13 => after[cmd[3]] = if cmd[1] == before[cmd[2]] { 1 } else { 0 },\n            14 => after[cmd[3]] = if before[cmd[1]] == cmd[2] { 1 } else { 0 },\n            15 => after[cmd[3]] = if before[cmd[1]] == before[cmd[2]] { 1 } else { 0 },\n            _ => {}\n        };\n        after\n    }\n    \n    fn main() {\n        let path = format!(\"./input/{}\", \"day16_q1.txt\");\n        let vec: Vec<String> = BufReader::new(File::open(path).unwrap())\n            .lines()\n            .map(|l| l.expect(\"Could not parse line\"))\n            .collect();\n    \n        let asserts: Vec<Assertion> = vec\n            .chunks(4)\n            .map(|s| Assertion {\n                before: parse_line_num(&s[0]),\n                cmd: parse_line_num(&s[1]),\n                after: parse_line_num(&s[2]),\n            })\n            .collect();\n    \n        let q1 = asserts\n            .iter()\n            .filter(|ass| (0..=15).map(|id| ass.try_assert(id)).filter(|&b| b).count() >= 3)\n            .count();\n        println!(\"result of q01 is {}\", q1);\n    \n        // gen opcode->Set(indexes) mapping\n        let mut opcode_mapping: Vec<HashSet<usize>> = vec![HashSet::new(); 16];\n    \n        asserts.iter().for_each(|ref ass| {\n            let opcode = ass.cmd[0];\n            let mut index_set: HashSet<usize> = HashSet::new();\n            (0..=15usize).for_each(|idx| {\n                if ass.try_assert(idx) {\n                    index_set.insert(idx);\n                }\n            });\n            let un_init = opcode_mapping[opcode].is_empty();\n            if un_init {\n                opcode_mapping[opcode] = index_set;\n            } else {\n                opcode_mapping[opcode] = opcode_mapping[opcode]\n                    .intersection(&index_set)\n                    .map(|&x| x)\n                    .collect::<HashSet<usize>>();\n            }\n        });\n        println!(\"DEBUG before deduction {:?}\", opcode_mapping);\n    \n        // repeat deduction until every Set.len() == 1\n        let mut handled: HashSet<usize> = HashSet::new();\n        while opcode_mapping.iter().any(|set| set.len() != 1) {\n            for set in opcode_mapping.iter_mut() {\n                if set.len() > 1 {\n                    handled.iter().for_each(|num| {\n                        set.remove(&num);\n                    })\n                } else {\n                    handled.insert(*set.iter().next().unwrap());\n                }\n            }\n        }\n        // deduction & normalize\n        let opcode_mapping = opcode_mapping\n            .into_iter()\n            .map(|set| set.into_iter().next().unwrap())\n            .collect::<Vec<usize>>();\n        println!(\"DEBUG after deduction {:?}\", opcode_mapping);\n    \n        // parsing q2 input\n        let path = format!(\"./input/{}\", \"day16_q2.txt\");\n        let instructions: Vec<[usize; 4]> = BufReader::new(File::open(path).unwrap())\n            .lines()\n            .map(|l| l.expect(\"Could not parse line\"))\n            .map(|line| parse_line_num(&line))\n            .collect();\n    \n        let register = instructions.iter().fold([0; 4], |acc, ins| {\n            execute(&acc, ins, opcode_mapping[ins[0]])\n        });\n        println!(\"result of q02 is {}\", register[0]);\n    }\n\n&#x200B;", "id": "ebyzgbi", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Here is my Kotlin solution:\n\n[https://github.com/davidaayers/advent-of-code-2018/blob/master/src/day16/day16.kt](https://github.com/davidaayers/advent-of-code-2018/blob/master/src/day16/day16.kt)", "id": "ec010k3", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "**Rexx** 133/175\n\nWell I came nowhere but I'll share this because Rexx is a very neglected language.  Unfortunately it also lacks direct and/or on decimal numbers, so we have to convert to binary and back.  I used separate programs to do part 1 and part 2, but this is both of them merged together.\n\n    signal on notready\n    ans=0\n    ops.='addr addi mulr muli banr bani borr bori setr seti gtir gtri gtrr eqir eqri eqrr'\n    do forever\n        parse pull . '[' r0.0 ', ' r0.1 ', ' r0.2 ', ' r0.3 ']'\n        parse pull op opa opb opc\n        parse pull . '[' r1.0 ', ' r1.1 ', ' r1.2 ', ' r1.3 ']'\n        pull .\n        if r0.0 == '' then leave\n        t=0\n        if (r1.0=r0.0)+(r1.1=r0.1)+(r1.2=r0.2)+(r1.3=r0.3) >=3 then do\n            if r1.opc \\= r0.opa+r0.opb then call eliminate op,'addr'\n            else t=t+1\n            if r1.opc \\= r0.opa+opb then call eliminate op,'addi'\n            else t=t+1\n            if r1.opc \\= r0.opa*r0.opb then call eliminate op,'mulr'\n            else t=t+1\n            if r1.opc \\= r0.opa*opb then call eliminate op,'muli'\n            else t=t+1\n            if r1.opc \\= band(r0.opa,r0.opb) then call eliminate op,'banr'\n            else t=t+1\n            if r1.opc \\= band(r0.opa,opb) then call eliminate op,'bani'\n            else t=t+1\n            if r1.opc \\= bor(r0.opa,r0.opb) then call eliminate op,'borr'\n            else t=t+1\n            if r1.opc \\= bor(r0.opa,opb) then call eliminate op,'bori'\n            else t=t+1\n            if r1.opc \\= r0.opa then call eliminate op,'setr'\n            else t=t+1\n            if r1.opc \\= opa then call eliminate op,'seti'\n            else t=t+1\n            if r1.opc \\= (opa>r0.opb) then call eliminate op,'gtir'\n            else t=t+1\n            if r1.opc \\= (r0.opa>opb) then call eliminate op,'gtri'\n            else t=t+1\n            if r1.opc \\= (r0.opa>r0.opb) then call eliminate op,'gtrr'\n            else t=t+1\n            if r1.opc \\= (opa=r0.opb) then call eliminate op,'eqir'\n            else t=t+1\n            if r1.opc \\= (r0.opa=opb) then call eliminate op,'eqri'\n            else t=t+1\n            if r1.opc \\= (r0.opa=r0.opb) then call eliminate op,'eqrr'\n            else t=t+1\n            if t>=3 then ans=ans+1\n        end\n        else do; say \"?\" r0.0 r0.1 r0.2 r0.3 \",\" r1.0 r1.1 r1.2 r1.3; exit; end\n    end\n    notready:\n    say 'Part 1:' ans\n    do until ok\n        ok=1\n        do i=0 to 15\n            if words(ops.i)=1 then\n                do j=0 to 15\n                    if j \\= i then call eliminate j,ops.i\n                end\n            else ok=0\n        end\n    end\n    /* do i=0 to 15; say i ops.i; end */\n    \n    signal on notready name eof2\n    r.=0\n    do forever\n        parse pull op opa opb opc\n        if op='' then iterate\n        select\n            when ops.op = 'addr' then r.opc=r.opa+r.opb\n            when ops.op = 'addi' then r.opc=r.opa+opb\n            when ops.op = 'mulr' then r.opc=r.opa*r.opb\n            when ops.op = 'muli' then r.opc=r.opa*opb\n            when ops.op = 'banr' then r.opc=band(r.opa,r.opb)\n            when ops.op = 'bani' then r.opc=band(r.opa,opb)\n            when ops.op = 'borr' then r.opc=bor(r.opa,r.opb)\n            when ops.op = 'bori' then r.opc=bor(r.opa,opb)\n            when ops.op = 'setr' then r.opc=r.opa\n            when ops.op = 'seti' then r.opc=opa\n            when ops.op = 'gtir' then r.opc= (opa>r.opb)\n            when ops.op = 'gtri' then r.opc= (r.opa>opb)\n            when ops.op = 'gtrr' then r.opc= (r.opa>r.opb)\n            when ops.op = 'eqir' then r.opc= (opa=r.opb)\n            when ops.op = 'eqri' then r.opc= (r.opa=opb)\n            when ops.op = 'eqrr' then r.opc= (r.opa=r.opb)\n        end\n    end\n    eof2:\n    say 'Part 2:' r.0\n    exit\n    \n    eliminate: procedure expose ops.\n    parse arg op,word\n    p=wordpos(word,ops.op)\n    if p=0 then return\n    ops.op=strip(subword(ops.op,1,p-1) subword(ops.op,p+1))\n    return\n    \n    band:procedure\n    parse arg a,b\n    a=x2b(d2x(a))\n    b=x2b(d2x(b))\n    l=max(length(a),length(b))\n    c=bitand(right(a,l,0),right(b,l,0))\n    return x2d(b2x(c))\n    \n    bor:procedure\n    parse arg a,b\n    a=x2b(d2x(a))\n    b=x2b(d2x(b))\n    l=max(length(a),length(b))\n    c=bitor(right(a,l,0),right(b,l,0))\n    return x2d(b2x(c))\n", "id": "ec0ftts", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "Belated **Perl** solution.\n\n[Card] \u201cThe secret technique to beat today's puzzles is\u201d ...\u00a0not to spend so long on the previous day's puzzle that you only get round to this one half a week later.\n\nQuite structurally similar to /u/raevnos's and /u/drbagy's solutions, but I think using sub signatures with named arguments makes the dispatch table a bit easier to read.\n\nI like that running the entire opcode program is just a one-line loop:\n\n    $reg[$4] = $op{$1}($2, $3) while !eof && <> =~ /^(\\d+) (-?\\d+) (-?\\d+) (\\d+)$/;\n\nThe op codes and numbers both end up as keys in the same hash: `$op{addr}` and `$op{3}`, for instance, both point to the calculation sub for that operation; the codes and numbers don't clash, so there's no need to have another layer of indirection converting one to the other.\n\n    use v5.20; use warnings; use experimental qw<signatures>; use List::AllUtils qw<pairfirst>;\n\n    my @reg;\n    my %op = (\n      addr => sub($idxA, $idxB) { $reg[$idxA] +  $reg[$idxB]      },\n      addi => sub($idxA, $valB) { $reg[$idxA] +  $valB            },\n      mulr => sub($idxA, $idxB) { $reg[$idxA] *  $reg[$idxB]      },\n      muli => sub($idxA, $valB) { $reg[$idxA] *  $valB            },\n      banr => sub($idxA, $idxB) { $reg[$idxA] &  $reg[$idxB]      },\n      bani => sub($idxA, $valB) { $reg[$idxA] &  $valB            },\n      borr => sub($idxA, $idxB) { $reg[$idxA] |  $reg[$idxB]      },\n      bori => sub($idxA, $valB) { $reg[$idxA] |  $valB            },\n      setr => sub($idxA, $    ) { $reg[$idxA]                     },\n      seti => sub($valA, $    ) { $valA                           },\n      gtir => sub($valA, $idxB) { $valA       >  $reg[$idxB] || 0 },\n      gtri => sub($idxA, $valB) { $reg[$idxA] >  $valB       || 0 },\n      gtrr => sub($idxA, $idxB) { $reg[$idxA] >  $reg[$idxB] || 0 },\n      eqir => sub($valA, $idxB) { $valA       == $reg[$idxB] || 0 },\n      eqri => sub($idxA, $valB) { $reg[$idxA] == $valB       || 0 },\n      eqrr => sub($idxA, $idxB) { $reg[$idxA] == $reg[$idxB] || 0 },\n    );\n\n    {\n      local $/ = \"\\n\\n\";\n      my $samples_matching_3;\n      my %maybe_op_num = map { $_ => {map { $_ => 1 } 0 .. (keys %op) - 1} } keys %op;\n      while (<>) {\n        last if /^\\n$/; # blank line separates samples from program\n        my ($op_num, @input, $output_idx, @after, $matches);\n        (@reg[0..3], $op_num, @input[0..1], $output_idx, @after) = /(-?\\d+)/g;\n        while (my ($op_code, $calc_sub) = each %op) {\n          if ($calc_sub->(@input) == $after[$output_idx]) {\n            $matches++;\n          }\n          else {\n            delete $maybe_op_num{$op_code}{$op_num}; # This num can't be this op.\n          }\n        }\n        $samples_matching_3++ if $matches >= 3;\n      }\n      say \"Samples matching at least 3 opcode behaviours: $samples_matching_3\";\n\n      # While there are opcodes that haven't been assigned numbers, grab the first\n      # one that only has one possible number remaining, and assign that:\n      while (%maybe_op_num) {\n        my ($code, $num) = pairfirst { keys %$b == 1 } %maybe_op_num;\n        ($num) = keys %$num; # Extract the only number for this code.\n        $op{$num} = $op{$code};\n        delete $maybe_op_num{$code}; # Stop trying to match this code.\n        delete @{$_}{$num} foreach values %maybe_op_num; # A found number can't be other codes'.\n      }\n    }\n\n    @reg = (0) x 4;\n    $reg[$4] = $op{$1}($2, $3) while !eof && <> =~ /^(\\d+) (-?\\d+) (-?\\d+) (\\d+)$/;\n    say \"final value of register 0: $reg[0]\";\n", "id": "ec7j4ps", "owner_tier": 0.3, "score": -3.703703681194552e-10}, {"content": "When you stop thinking in English and start thinking in python\n\n    from re import findall\n    \n    to_ints = lambda x: (map(int, findall('-?\\d+', i)) for i in x.split('\\n') if i)\n    with open('../input/16.txt') as f:\n        test, program = map(to_ints, f.read().split('\\n\\n\\n\\n'))\n    \n    commands = { 'name': lambda r, A, B: r[A] + B } # all of them\n    \n    ambiguities = 0\n    translate = {}\n    for before, (number, A, B, C), after in zip(*[test]*3):\n        potential = set()\n        for opcode in commands:\n            if commands[opcode](before, A, B) == after[C]:\n                potential.add(opcode)\n    \n        if len(potential) >= 3:\n            ambiguities += 1\n            \n        potential = potential.difference(set(translate.values()))\n        if len(potential) == 1:\n            translate[number] = potential.pop()\n    \n    r = [0, 0, 0, 0]\n    for number, A, B, C in program:\n        r[C] = commands[translate[number]](r, A, B)\n    \n    print ambiguities\n    print r[0]\n\nMight be possible that mapping numbers to opcodes won't work without cycling through the (before, code, after) many times, for my input works to do it just once.", "id": "ed1d0is", "owner_tier": 0.1, "score": -3.703703681194552e-10}, {"content": "This was so refreshing after day 15. I did it in C, browsing solutions I didn't see a solution yet that would store the opcodes as \\[actual function, function to lookup a, function to lookup b,\\] and then an apply function that uses those.\n\n```\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nconst bool DEBUG = false;\nconst int OPCODES_COUNT = 16;\n\nint regs[4] = { 0 };\n\nstruct opcode {\n  char* name;\n  int (*fn)(int a, int b);\n  int (*a)(int arg);\n  int (*b)(int arg);\n};\n\nint add(int a, int b) {\n  return a + b;\n}\n\nint mul(int a, int b) {\n  return a * b;\n}\n\nint ban(int a, int b) {\n  return a & b;\n}\n\nint bor(int a, int b) {\n  return a | b;\n}\n\nint set(int a, int _b) {\n  return a;\n}\n\nint gt(int a, int b) {\n  return a > b ? 1 : 0;\n}\n\nint eq(int a, int b) {\n  return a == b ? 1 : 0;\n}\n\nint r(int reg) {\n  return regs[reg];\n}\n\nint i(int immediate) {\n  return immediate;\n}\n\nstruct opcode opcodes[OPCODES_COUNT] =\n  {\n   {.name = \"addr\", .a=r, .b=r, .fn=add},\n   {.name = \"addi\", .a=r, .b=i, .fn=add},\n   {.name = \"mulr\", .a=r, .b=r, .fn=mul},\n   {.name = \"muli\", .a=r, .b=i, .fn=mul},\n   {.name = \"banr\", .a=r, .b=r, .fn=ban},\n   {.name = \"bani\", .a=r, .b=i, .fn=ban},\n   {.name = \"borr\", .a=r, .b=r, .fn=bor},\n   {.name = \"bori\", .a=r, .b=i, .fn=bor},\n   {.name = \"setr\", .a=r, .b=r, .fn=set},\n   {.name = \"seti\", .a=i, .b=i, .fn=set},\n   {.name = \"gtir\", .a=i, .b=r, .fn=gt},\n   {.name = \"gtri\", .a=r, .b=i, .fn=gt},\n   {.name = \"gtrr\", .a=r, .b=r, .fn=gt},\n   {.name = \"eqir\", .a=i, .b=r, .fn=eq},\n   {.name = \"eqri\", .a=r, .b=i, .fn=eq},\n   {.name = \"eqrr\", .a=r, .b=r, .fn=eq}\n  };\n\nvoid apply(const struct opcode* op, int a, int b, int c) {\n  regs[c] = op->fn(op->a(a), op->b(b));\n}\n\nvoid print_regs(int* arg_regs) {\n  if (arg_regs == NULL) arg_regs = regs;\n\n  int i = 0;\n  while (i < 3) printf(\"%3d, \", arg_regs[i++]);\n  printf(\"%3d\", arg_regs[i]);\n}\n\nint main(void) {\n  int oregs[4] = { 0 };\n  int eregs[4] = { 0 };\n\n  int matching3 = 0;\n  int total = 0;\n\n  int defs[16][16] = { { 0 } };\n  int map[16];\n  for (int i = 0; i < 16; i++) map[i] = -1;\n\n  while (true) {\n    int o, a, b, c;\n    int res = scanf(\" Before: [%d, %d, %d, %d]\",\n          &oregs[0], &oregs[1],\n          &oregs[2], &oregs[3]);\n    if (res != 4) break;\n\n    int rres = scanf(\" %d %d %d %d\", &o, &a, &b, &c);\n    int eres = scanf(\" After: [%d, %d, %d, %d]\",\n          &eregs[0], &eregs[1],\n          &eregs[2], &eregs[3]);\n\n    total++;\n    int matching = 0;\n    for (int i = 0; i < OPCODES_COUNT; i++) {\n      memcpy(regs, oregs, 4 * sizeof(int));\n      if (DEBUG) {\n        printf(\"`%s %d %d %d`:  \", opcodes[i].name, a, b, c);\n        print_regs(regs);\n        printf(\" -> \");\n      }\n\n      apply(&opcodes[i], a, b, c);\n\n      int comp = memcmp(regs, eregs, 4 * sizeof(int));\n\n      if (DEBUG) {\n        print_regs(regs); printf(\" =? \");\n        print_regs(eregs);\n        printf(\" -- %d\\n\", comp);\n      }\n\n      if (comp == 0) matching++;\n      else defs[o][i]++;\n    }\n\n    if (matching >= 3) matching3++;\n  }\n  printf(\"Matching 3+ opcodes: %d/%d\\n\\n\", matching3, total);\n\n  int unmapped = OPCODES_COUNT;\n  int iterations = 0;\n  while (unmapped > 0 && iterations++ < 1000) {\n    for (int i = 0; i < OPCODES_COUNT; i++) {\n      if (map[i] != -1) continue;\n\n      int last_option = -1;\n      int options = 0;\n      for (int j = 0; j < OPCODES_COUNT; j++) {\n        if (defs[i][j] == 0) {\n          options++;\n          last_option = j;\n        }\n      }\n\n      if (options == 1) {\n        map[i] = last_option;\n        for (int j = 0; j < OPCODES_COUNT; j++) {\n          defs[j][last_option]++;\n        }\n        unmapped--;\n      }\n    }\n  }\n\n  printf(\"Opcode mapping:\\n\");\n  for (int i = 0; i < OPCODES_COUNT; i++) {\n    printf(\"%d = %s\\n\", i, opcodes[map[i]].name);\n  }\n  printf(\"\\n\");\n\n  memset(regs, 0, sizeof(regs));\n  while (true) {\n    int o, a, b, c;\n    if (scanf(\" %d %d %d %d\", &o, &a, &b, &c) != 4)\n      break;\n\n    if (DEBUG) {\n      print_regs(NULL);\n      printf(\" | %2d %2d %2d %2d == %s %2d %2d %2d | \",\n             o, a, b, c,\n             opcodes[map[o]].name, a, b, c);\n    }\n\n    apply(&opcodes[map[o]], a, b, c);\n\n    if (DEBUG) {\n      print_regs(NULL);\n      printf(\"\\n\");\n    }\n  }\n\n  printf(\"\\nThe final value in register 0 is %d\\n\", regs[0]);\n\n  return 0;\n}\n```", "id": "edcgdqq", "owner_tier": 0.1, "score": -3.703703681194552e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/a6mf8a/2018_day_16_solutions/", "question": {"content": "#--- Day 16: Chronal Classification ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Advent of Code: The Party Game!\n\n[Click here for rules](/r/adventofcode/w/aoctpg)\n\nPlease prefix your card submission with something like [Card] to make scanning the megathread easier.  THANK YOU!\n\n#### [Card prompt: Day 16](https://i.imgur.com/5ZQn6nGm.jpg)\n\nTranscript:\n> The secret technique to beat today's puzzles is ___.\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n###*edit:* Leaderboard capped, thread unlocked at 00:39:03!", "id": "a6mf8a", "title": "-\ud83c\udf84- 2018 Day 16 Solutions -\ud83c\udf84-", "traffic_rate": 38.33703939008895}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "We're aware of some issues during unlock today; we'll let you know when we have more information.", "id": "gesvzui", "owner_tier": 0.5, "score": -1.0869565151331837e-10}, {"content": "ruby 1/1 woo\n\n    p read.split(\"\\n\\n\").map{|x|x.split.join.chars.uniq.size}.sum\n    p read.split(\"\\n\\n\").map{|x|x.lines.map{|x|x.chomp.chars}.reduce(:&).size}.sum\n\nThat is just... amazing timing and amazing code. Kudos!\n\nAny reason you use `split` in the first one but `lines` in the second one?\n\nno lol, the first time my brain was like \"ok how do i kill all the whitespace\" and it spit out `.split.join` as a unit, then for part 2 i deleted everything in the braces to start again and the first thing that came to mind to transform the lines was `.lines.map`", "id": "ges7bz7", "owner_tier": 0.1, "score": 0.7826086955434783}, {"content": "# [Python](https://github.com/arknave/advent-of-code-2020/blob/main/day06/day06.py) / [C](https://raw.githubusercontent.com/arknave/advent-of-code-2020/main/day06/day06.c)\n\nLost a bit of time because of site issues and an off by one error, but I doubt I'm ever going to leaderboard on a string parsing problem when people are so fast these days.\n\nFirst time I've done the art the night of instead of the next day! I'm starting to learn the tiny ones are the hardest to tinker with because there's just no wiggle room.\n\n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    // AOC DAY NUMBER //\n    int main(int c,char*\n    *v){int       t,p,q;\n    char           b[66]\n    ,h[    66],*k   ,*l=\n    b,*   e=h+26;for(p=q\n    =0   ;l;   ){for(k=h\n    ;k            <e;++k\n    )*    k=0;for   (t=0\n    ;(   l=gets(b   ))&&\n    *l   ;++t)for(  k=l;\n    *k;   ++k)++h   [-97\n    +*k];          for(k\n    =h;k<e;     ++k){p+=\n    *k>0;q+=*k==t;}}--c;\n    printf(\"%d\",c?q:p);}\n\n>`blocks = fin.read().split(\"\\n\\n\")`\n\nI've been writing a really awkward for loop that appended each line manually if it wasn't empty lol. Definitely going to use this method in the future :)", "id": "gesc8cy", "owner_tier": 0.1, "score": 0.33695652163043477}, {"content": "38/27, Python. https://github.com/sophiebits/adventofcode/blob/main/2020/day06.py\n\nServer problems during unlock again today? I had to refresh several times to get each page to load.\n\nI got 504 and couldn't see the page for more than 2 minutes.\n\nSame-- by the time my page loaded, 18 people had already finished part 1, judging from leaderboard times.\n\n(115/38-- at least part 2 loaded right away!)\n\nTook me a full five minutes before I could grab the inputs; 504s all along the way, and a bunch of people on IRC (names redacted) had trouble. Guess scores won't count today.\n\n\\[06:00:17\\] <> Down again?\n\n\\[06:00:22\\] <> rip\n\n\\[06:00:29\\] <> yep for me.\n\n\\[06:00:31\\] <> yeah just wondering if anyone else was having issues\n\n\\[06:01:15\\] <> cmon\n\n\\[06:01:35\\] <> lol\n\n\\[06:01:51\\] <> NOw I know what day 1 felt like for everyone else.\n\nEdit: Asked around the private leaderboards (North Europe); looks like \\~4 minutes to get the site to load was normal.\n\nI lost around a minute or so waiting for part 2 to load.\n\nI loaded the page fine for Part 1, but then I had to try several times (and got some 504s and page-hangs) to submit the answer. It was slow for Part 2 but a bit better.\n\nThe server wouldn't serve me either. I think the leaderboard for part 1 was done before the problem even loaded for me :(\n\n(I also wasted a minute due to using `s.splitlines()` instead of `s.split('\\n\\n')` to break my input into groups, but that one's on me.)\n\nI submitted my answer for Part 1 at 12:03, but it took several minutes to go through. My official time under stats is 7:12.\n\nOh; I wasn't the only one having issues! I was only held up for about ten seconds though, so I'm not particularly annoyed.\n\nyeah it was weird, my input changed for some reason too which threw me off\n\nYeah. I lost over a minute on both parts because of that", "id": "ges6ld4", "owner_tier": 0.1, "score": 0.9999999998913044}, {"content": "[Haskell](https://github.com/SimonBaars/AdventOfCode-Haskell/blob/master/2020/Day6.hs)\n\nHaskell has proven to be insane yet again. It's so short! Part 1:\n\n    sum $ map (length . foldr1 union) input\n\nPart 2:\n\n    sum $ map (length . foldr1 intersect) input\n\nthat's so insanely short! I'm not even using any exotic imports (nothing except Data.List).\n\nYou can even (naturally) golf this a tad further!  The Monoid for Set (how to get one from two) is union.  So <> would be union, and mconcat is the <> of all items in a foldable container.  So part 1 can be:\n\n    sum . map (size . mconcat)\n\nthis is pretty crazy\n\nAhhh, foldr1 intersect is a much nicer solution than mine (which involved sorting, grouping, and then filtering out the grouped characters that were shorter than the total number of people in a boarding group), thanks for sharing! I'm gonna remember union and intersect next time\n\nBut how did you parse the input into the nice input list? I used so much time work that out", "id": "gesc59h", "owner_tier": 0.1, "score": 0.3804347825}, {"content": "Python; would have made some work of the leaderboards today if the servers didn't crash again, and it took five minutes to get past all the 504s (and all of a sudden being logged out).\n\n    groups = data.split('\\n\\n')\n\n    # Part one\n    sum(len(set.union(*map(set, g.split('\\n')))) for g in groups)\n\n    # Part two\n    sum(len(set.intersection(*map(set, g.split('\\n')))) for g in groups)\n\ngoddamn.\nthat's incredibly tiny", "id": "ges8u7n", "owner_tier": 0.5, "score": 0.13043478249999998}, {"content": "**Raku**\n\n    my @answers = 'input'.IO.slurp.split(\"\\n\\n\");\n\n    put [+] @answers.map: { .words.join.comb.Set }\n    put [+] @answers.map: { [\u2229] .words.map(*.comb.Set) }\n\nPart 1 could have been written `[+] @answers.map: { .comb(/\\S/).Set }` but I have a habit of avoiding RegEx unless necessary.\n\nAlso, doing the plus reduction `[+]` is the same number of characters as `sum`... I guess I just felt a little _reductionist_ today.\n\n*desire to learn Raku intensifies...*\n\nI imagine if you're quick at figuring out how to solve a puzzle, the ease at which Raku lets you concisely express it might give you a speed advantage.\n\nFor most problems in general, I just find it easier to figure out a solution in Raku than any other language.", "id": "gesb5jw", "owner_tier": 0.3, "score": 0.1521739129347826}, {"content": "Ruby 9/31\n\nMy input downloader failed so I had to manually open the input text in browser to copy into file lmao\n\n\n    a=$<.read.split(\"\\n\\n\")\n    p a.sum{|x|\n    # x.split.join.chars.uniq.size <- part 1\n    x.lines.map{|x|x.chomp.chars}.reduce{|x,y|x&y}.size\n    }", "id": "ges6nvc", "owner_tier": 0.3, "score": 0.08695652163043478}, {"content": "J, both parts\n\n    echo ((1 #. #@~.@;;._2) , (1 #. ([: #@; ([-.-.)&.>/);._2)) <;._2 d\n\nhttp://urstoron.com/4COP\n\n[deleted]\n\n`[-.-.` is interesting for intersection! the one i came up with is `e.#[` (nb `]` would give length error in insert. edit: now that i actually think about why, for obvious reasons lol)\n\n`e.#[` is nice.  I can't take credit for `[-.-.` \\-- that's actually a [standard J idiom](https://code.jsoftware.com/wiki/Vocabulary/minusdot#dyadic).", "id": "gesb3z0", "owner_tier": 0.1, "score": 0.1739130433695652}, {"content": "**Raku, Parts 1 & 2**\n\nTrying to do all my solutions in functional Raku. I like the middle ground here between readability and conciseness.\n\n    sub part-one($group) {\n        (set $group.subst(\"\\n\", '', :g).comb).elems;\n    }\n    \n    sub part-two($group) {\n        [\u2229] $group.split(\"\\n\").map(-> $entry { set $entry.comb });\n    }\n    \n    sub MAIN($file, Bool :$p2 = False) {\n        say [+] $file.IO.lines(:nl-in(\"\\n\\n\")).map($p2 ?? &part-two !! &part-one);\n    }\n\nNice use of `:nl-in`, I'd never have thought of that.\n\nYou can make `part-two` even more concise like this:\n\n        [\u2229] $group.lines.map(*.comb.Set);\n\nThanks! [Saw it suggested](https://reddit.com/r/rakulang/comments/k6xhrm/does_raku_have_a_paragraphatatime_mode/) on /r/rakulang yesterday and it fit in nicely with today\u2019s challenge\n\nThanks for the tip! I didn\u2019t know about `.lines` on a string, but that makes sense. That\u2019s much more readable overall too!", "id": "getqcuj", "owner_tier": 0.1, "score": 0.1521739129347826}, {"content": "**Vim keystokes** \u2014 the first line, combining the paragraphs, is [copied from day 4](https://www.reddit.com/r/adventofcode/comments/k6e8sw/2020_day_04_solutions/geklpot/?utm_source=reddit&utm_medium=web2x&context=3) but with an added `!` at the end:\n\n    :g/^/ ,/\\v^$|%$/j!\u27e8Enter\u27e9\n    :%s/\\v(.)(.*\\1)@=//g\u27e8Enter\u27e9\n    :%j!\u27e8Enter\u27e9\n    g\u27e8Ctrl+G\u27e9\n\nYour part\u00a01 answer is displayed as \u2018Col 1 of <num>\u2019.\n\nHaving got each group on to a single line, the `:%s///` removes any character which also appears later in the line, so we have each question letter just once per group of passengers.\n\nThen the total we want is the number of letters remaining in the file. `:%j!` joins them all into a single line, and `g\u27e8Ctrl+G\u27e9` tells us (among other things) how many columns are in that line.\n\nYes, there are ways of getting that count into the buffer, but it spoils the simplicity of this and I didn't see the need \u2014 we have the answer on the screen, available for typing it into the website.", "id": "gesu64i", "owner_tier": 0.3, "score": 0.06521739119565217}, {"content": "Raku\n\n    sub rv (&code) { 'input'.IO.slurp.split(\"\\n\\n\", :skip-empty).map(&code).sum }\n    say \"One: \" ~ rv { .comb(/\\S/).Set.elems };\n    say \"Two: \" ~ rv { .lines.map({ .comb(/\\S/).Set }).reduce(&infix:<\u2229>).elems };\n\n>cggoebel\n\nThe [blog post](https://ergoletterbag.blogspot.com/2020/12/raku-advent-of-code-2020-day-6.html) which details my original solution and how I refactored it into this three line solution. FWIW: I'm using Advent of Code to learn Raku. The [Raku AoC Repo](https://github.com/codesections/advent-of-raku-2020) has been a tremendous help in providing examples of code and style.", "id": "geubpsp", "owner_tier": 0.1, "score": 0.09782608684782608}, {"content": "Placed 112/69. Python. Video of me solving at [https://youtu.be/e\\_66g1QcVlE](https://youtu.be/e_66g1QcVlE). [Code](https://topaz.github.io/paste/#XQAAAQB2AwAAAAAAAAA0m0pnuFI8c9WAoVc3IiG2khdS9RZHDy1KRQQmBUCL0xNYUHRS0RIX9qrRq01NX2n+Fwtz65btvRqlGNXvpLApfwKi0UaioHt1qJsc6HZDwlPbNt0y24RrXT4uaOTwfNM7PfP3TvD+7GNnTxP9mporexjG40EYBSJO60heY+wL90h2nC0DAQJKnmlDg1Da9XeZkO2CINCGkEQzEpraC7kxDO22iSKi7uPG5zsRzsM/tf+3lsQvqY2BeueWkS3ZNFVcPug999J3O8usKriiT0qiXiVC8UFXmXHJ3ifDEpflUWZu0fFSJRsjSQRbwUaGTQrpk20PGf0r+UCjemyin8VMjKS2MAThhnS6Vemo+AhM3uO4WqSzcRJhJID0nesHKtKazbV7eLE/DJZtfTM6Y4mncX8n405H+plbwCPsVcZxcCAkKbaxFMd+ezSq01ctXqck/jLL7A3u3VHURdVkPCWCILkx6idvFdbeGqqsgDj/+p7KbA==)\n\nThat deep exhale when you finally finished is my mood for 2020.\n\nGreat job, and I love the videos. Thanks for putting them up for others to watch.", "id": "ges7hl5", "owner_tier": 0.3, "score": 0.07608695641304349}, {"content": "#[Go/Golang](https://github.com/mnml/aoc/blob/master/2020/06/2.go) 990/1589\nI love maps.\n\n**1225/495** with [the same code less a loop](https://github.com/kindermoumoute/adventofcode/blob/master/2020/day6/main.go)\n\nEDIT: feel free to join the golang leaderboard ==> 235071-2acde629\n\nEDIT2: oh nvm you are already on it, hi mnml :-)\n\nNice!\n\n>less a loop\n\nNice! I feel silly for missing that.\n\n>feel free to join the golang leaderboard :-) ==> 235071-2acde629\n\nIs that reusing-code's leaderboard? If so, I've been on it since last year as mnml (currently first place!)\n\nIm joining the go lang leaderboard. I mean, someone needs to be in the bottom rank.", "id": "ges8oht", "owner_tier": 0.1, "score": 0.18478260858695653}, {"content": "**Python**\n\nExact same function for both parts, just changing union to intersection!\n\n    data = [list(map(set, group.splitlines())) for group in raw.split('\\n\\n')]\n    \n    def combine_with(func):\n        return sum(len(reduce(func, group)) for group in data)  # functools.reduce\n    \n    def part_one():\n        return combine_with(set.union)\n    \n    def part_two():\n        return combine_with(set.intersection)\n\nI love the purity / power of your parsing !\n\nMaybe you already know this, but TIL \\`set.union\\` and \\`set.intersection\\` can take multiple arguments, so you don't even need \\`functools.reduce\\` and can just use \\`func(\\*group)\\` in your \\`combine\\_with\\`", "id": "gesqren", "owner_tier": 0.3, "score": 0.10869565206521738}, {"content": "I love how easy **Raku** makes this:\n\n    sub MAIN(IO() $inputfile where *.f = 'aoc06.input', Bool :v(:$verbose) = False)\n    {\n        my @groups = $inputfile.slurp.split(/\\n\\s*\\n/);\n    \n        my $totalCount = @groups.map(*.comb(/<[a..z]>/).unique.elems).sum;\n        say $verbose ?? 'Part one: the sum of the counts is: ' !! '',\n            $totalCount;\n    \n        my $totalCount2 = @groups.map(-> $g { $g.comb(/<[a..z]>/).Bag.grep(*.value == $g.lines).elems }).sum;\n        say $verbose ?? 'Part two: the sum of the counts is: ' !! '',\n            $totalCount2;\n    }\n\n[https://github.com/mscha/aoc/blob/master/aoc2020/aoc06](https://github.com/mscha/aoc/blob/master/aoc2020/aoc06)", "id": "getcuvx", "owner_tier": 0.1, "score": 0.07608695641304349}, {"content": "# Python\n\nAnother horrible (lovely) set of one line solutions  \n\n\n    # Part 1\n    total = sum([len(set(\"\".join(group.split(\"\\n\")))) for group in open(\"input.txt\").read().split(\"\\n\\n\")])\n    print(f\"[P1] Sum of counts: {total}\")\n    \n    \n    # Part 2\n    total = sum([len(set.intersection(*[set(sub) for sub in group.split(\"\\n\")])) for group in open(\"input.txt\").read().split(\"\\n\\n\")])\n    print(f\"[P2] Sum of counts: {total}\")\n\nTIL set.intersection() \n\nConsider using group.replace('\\n', '') instead of the join/split combo.", "id": "getqxwh", "owner_tier": 0.3, "score": 0.08695652163043478}, {"content": "My answer for both in Python:\n\n    text = open(\"/Users/ieaston/advent6_input.txt\", \"r\").read().strip()\n    sets = [[set(member) for member in group.split('\\n')] for group in text.split('\\n\\n')]\n    print(sum([len(set.union(*l)) for l in sets]))\n    print(sum([len(set.intersection(*l)) for l in sets]))", "id": "getwy36", "owner_tier": 0.1, "score": 0.043478260760869566}, {"content": "**Python 3** short oneliners\n\nPart 1:\n\n    with open(\"input6.txt\") as f:\n        l = f.read().split(\"\\n\\n\")\n    sum(len(set.union(*(set(x) for x in group.splitlines()))) for group in l)\n\nPart 2:\n\n    sum(len(set.intersection(*(set(x) for x in group.splitlines()))) for group in l)", "id": "geuwhh9", "owner_tier": 0.5, "score": 0.05434782597826087}], "link": "https://www.reddit.com/r/adventofcode/comments/k7ndux/2020_day_06_solutions/", "question": {"content": "## NEW AND NOTEWORTHY\n\n* /u/jeroenheijmans is back with the [Unofficial AoC 2020 Participant Survey](/k76nux)!\n* /u/maus80 is back with an [interactive scatterplot](/k6nb8b) of the global leaderboard!\n\n***\n\n## Advent of Code 2020: Gettin' Crafty With It\n\n+ **UNLOCKED!**  Go forth and create, you beautiful people!\n+ Full details and rules are in the [Submissions Megathread](/k4emxn)\n+ Make sure you use one of the two templates!\n * Or in the words of AoC 2016: USING A TEMPLATE IS MANDATORY\n\n***\n\n#--- Day 06: Custom Customs ---\n\n***\n\nPost your solution in this megathread.  Include what language(s) your solution uses!  If you need a refresher, the full posting rules are detailed in the wiki under [How Do The Daily Megathreads Work?](/r/adventofcode/wiki/index#wiki_how_do_the_daily_megathreads_work.3F).\n\n**Reminder:** Top-level posts in Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the global leaderboard with gold stars for today's puzzle.~~\n###*EDIT:* Global leaderboard gold cap reached at 00:04:35, megathread unlocked!", "id": "k7ndux", "title": "-\ud83c\udf84- 2020 Day 06 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "It's my birthday :) \n\n6th/5th in Python.\n\nhttps://www.youtube.com/watch?v=_nI5uCcBTcs\n\nHAPPY BIRTHDAY! :D\n\nMan, I don't get how you can read the problem that fast. It takes me a good 2 minutes just to read through the problem and understand the puzzle. Congrats, I got 145/111, also with python\n\nThanks for sharing the video. It's very interesting to see other folks work.\n\nHappy Birthday!\n\nYour video makes it look so leisurely and relaxed.\n\n(Happy Birthday!)\n\nThanks for the video!!! i feel like i learned quite a bit even though we basically ended up with the same code in the end. I like the video because i can see your thought process. it also makes me feel better about what i am doing. i just need practice to get faster.\n\nWhy did you have graph[b].append(a)?  It seems to me like all that line did was make the lists double length.\n\nAs if you did this:    \n\n    for a in graph:\n        graph[a]=graph[a]*2\n\nThank you!\n\nSame here. I did it in C++, but I have all the parsing already done ahead of time. I just need to put in what characters I want to discard. Not sure what I did with that 8 minutes. This problem was extremely easy. I've done this kind of thing a million times before.\n\nedit: I tried it again from scratch knowing how to do it and it still took me 6 minutes. I gotta figure out what I'm doing wrong.\n\nedit2: Tried it again. Down to 4 minutes. Found that using iterators is super slow to type out. Checking if an item is in a container is again slow to type. Converting string to number is slow to type. I've added some macros for this and it greatly helped. We'll see next time.\n\nmy guess (not OP) was that it wasn't super clear that the input would list the return pipe. moving as fast as he did, probably read the part that they are bi-directional and this would ensure that those were set up.\n\nPython strikes a perfect balance between providing a concise way of writing code without allowing for too many options or ways of shooting yourself in the foot (e.g. Perl). It's exceedingly well suited for these kind of problems unless your solution is time constrained.\n\nThe added time (for me) comes from dealing with the type system of Rust. While it often aids me in refactoring for part 2, it's also something you need to work around. E.g. I spent ~15 seconds writing this:\n\n    let right: Vec<u64> = it.next()\n        .expect(\"right side\")\n        .trim()\n        .split(\", \")\n        .map(|s| s.parse::<u64>().unwrap())\n        .collect()?\n\nWhich is <5 seconds of this in Python:\n\n```\nmap(int, parts[1].split(','))\n```", "id": "dr4ft3r", "owner_tier": 0.1, "score": 0.999999999864865}, {"content": "2/1 today! [NetworkX](https://networkx.github.io/) makes this kind of problem very quick if you know what you're looking for. Today's question was asking about something called a [connected component](https://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29), and NetworkX provides some [nice functions](https://networkx.github.io/documentation/stable/reference/algorithms/component.html) for dealing with them.\n\n**Python 3** solution:\n\n    import networkx as nx\n\n    # Create a graph of programs\n    graph = nx.Graph()\n\n    for line in LINES:\n        # Parse the line\n        node, neighbors = line.split(' <-> ')\n\n        # Add edges defined by this line\n        graph.add_edges_from((node, neighbor) for neighbor in neighbors.split(', '))\n\n    print('Part 1:', len(nx.node_connected_component(graph, '0')))\n    print('Part 2:', nx.number_connected_components(graph))\n\n\n[Relevant xkcd.](https://xkcd.com/353/)\n\n**Connected component (graph theory)**\n\nIn graph theory, a connected component (or just component) of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. For example, the graph shown in the illustration has three connected components. A vertex with no incident edges is itself a connected component. A graph that is itself connected has exactly one connected component, consisting of the whole graph.\n\n***\n\n^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&message=Excludeme&subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/adventofcode/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate)   ^]\n^Downvote ^to ^remove ^| ^v0.28\n\nI just spent 2 hours on part 1, 28 lines including a recursive function.\nI could not figure out how to do part 2 so I came here for hints. Seeing your solution.. What am I doing with my life.\n\nWow, that's super clean and concise!\n\nNetworkX is fantastic.\n\nIt made this one quick even if you don't know what you're looking for in the NetworkX API.  I had to google the NetworkX docs to find the connected_components() method and still made leaderboard.\n\nThese are the union-find connected component videos from famed algorithms professor Robert Sedgewick\n\nhttps://www.youtube.com/watch?v=8mYfZeHtdNc&list=PLe-ggMe31CTexoNYnMhbHaWhQ0dvcy43t\n\nthat didn't give me the right answer.\n\nedit: never mind o_O\n\nman i need to learn it\n\nTo get started, the basics are:\n\n    import networkx as nx\n    g = nx.Graph()\n    g.add_node(\"foo\")\n    g.add_node(\"bar\")\n    g.add_edge(\"foo\", \"bar\")\n\nThen you can use methods like `connected_components()` and some other nifty stuff, like shortest path.\n\n(Use DiGraph for directed graphs.)", "id": "dr4fxul", "owner_tier": 0.1, "score": 0.7162162160810811}, {"content": "Perl regex.\n\n    #! /usr/bin/env perl\n    \n    use strict;\n    use warnings;\n    \n    undef $/;\n    $_ = <> . \"\\n\"; # Add a newline in case it's missing\n    \n    s/[^\\d\\n ]//sg;\n    while (s/^[^x]*\\K\\b(\\d+)\\b([^\\n]*)\\n((?:.*?\\n)?)([^\\n]*\\b\\1\\b[^\\n]*\\n)/$1 x $2 $4$3/s) { }\n    s/\\b(\\S+)\\b(?=.*?\\b\\1\\b)//sg;\n    \n    printf \"Part 1: %d\\n\", scalar(() = (m/^(.*\\b0\\b.*)$/m)[0] =~ m/\\d+/g);\n    printf \"Part 2: %d\\n\", scalar(() = m/^.*?\\d/gm);\n\n\nThis space intentionally left blank.\n\nImpressive! I had fun working out what this does. (I don't think you need the first `s///` to get rid of the punctuation though; the rest of it seems to work fine with the punctuation left in.)\n\nI tried translating it to **Vim**. A literal transliteration of the regex syntax was far too slow, but using the same basic idea I came up with:\n\n    :set nows\u27e8Enter\u27e9\n    >G:%s/[^ 0-9]//g\u27e8Enter\u27e9\n    qa:s/\\v<(\\d+)>(.*<\\1>)@=//g\u27e8Enter\u27e9\n    qg&{qb0/\\v<(\\d+)>%(\\_.{-}<\\1>)@=\u27e8Enter\u27e9\n    *dd\u27e8Ctrl+O\u27e9pkJ@aq\n\nThat merges one group into the top one. Type `@b` for the next merge (or `10@b` to see a few). Run it to the end with:\n\n    qcqqc@b@cq@c\n\n(Took 2\u20133 minutes for me.) That leaves you with each group on a separate line. Tidy it up and count things:\n\n    :%s/\\v  +/ /g\u27e8Enter\u27e9\n    {:s/ /#/g|s/\\d//g\u27e8Enter\u27e9\n    g\u27e8Ctrl+G\u27e9\n\nThe number of columns on the first line is the answer to part 1, and the number of lines the answer to part 2. (Press `u` to restore the top line to listing its group numbers instead of a row of hashes.)\n\n*Edit:* Typo fix, spotted by /u/askalski. Sorry.\n\nVery nice.  By the way, the `:%s/\\v  +/ /\u27e8Enter\u27e9` needs a `/g` modifier to squeeze out all the whitespace on each line.\n\nYou're right that the `s/[^\\d\\n ]//sg;` in my Perl code is unnecessary.  I put it in there to speed things up slightly (less text to scan each pass.)  On my input, it runs about 20% faster as a result.\n\n\nThanks, for both the explanation and for telling me about the typo (and indeed for reading the code carefully enough to spot it.) Cheers.", "id": "dr4kojx", "owner_tier": 0.3, "score": 0.2432432431081081}, {"content": "When you only care about connected components, union find is faster to code than BFS: https://gist.github.com/anonymous/02de56ccaa4c22b2388c927f00091588\n\n[removed]\n\nI use no prewritten Python code - I only have prewritten Java code for algorithms that would be difficult to implement on-the-fly - that's my fallback in case some tough algorithms problems show up in later days.\n\nI don't think it could be easier\n\n    #include <iostream>\n    #include <set>\n    \n    const int s = 2000;\n    \n    int parent[s];\n    \n    int find(int a) {\n    \tif(parent[a] == a) return a;\n    \treturn parent[a] = find(parent[a]);\n    }\n    void unite(int a, int b) {\n    \tparent[find(a)] = find(b);\n    }\n    \n    int main() {\n    \tfor(int i = 0;i < s;++ i) parent[i] = i;\n    \tfor(int i = 0;i < s;++ i) {\n    \t\tint a;\n    \t\tstd::cin >> a;\n    \t\twhile(true) {\n    \t\t\tint b;\n    \t\t\tstd::cin >> b;\n    \t\t\tif(b == -1) break;\n    \t\t\tunite(b, a);\n    \t\t}\n    \t}\n    \n    \tstd::set<int> groups;\n    \tfor(int i = 0;i < s;++ i) {\n    \t\tgroups.insert(find(i));\n    \t}\n    \tstd::cout << groups.size() << std::endl;\n        return 0;\n    }\n    \n", "id": "dr4gdze", "owner_tier": 0.1, "score": 0.16216216202702702}, {"content": "Missed the leaderboard by a few because of a typo. Grr.\n\nUsed a perl script to turn input into a graphviz dot file, and then...\n\n    perl day12.pl < day12.txt | ccomps -X 0 | gc -n\n    perl day12.pl < day12.txt | gc -c\n\nday12.pl:\n\n    #!/usr/bin/perl\n    print \"graph day12 {\\n\";\n    while (<>) {\n        s/<->/--/;\n        s/,/ -- /g;\n        print;\n    }\n    print \"}\\n\";\n\n\nThe graph as a [rather large image](https://imgur.com/o1T9Enz).\n\nThis space intentionally left blank.\n\nFrom the manpage:\n\n> If it is a directed graph, indicated by digraph, then the edgeop must be \"->\". If it is an undirected graph then the edgeop must be \"--\".\n\n>  n0 edgeop n1 edgeop ... edgeop nn [name0=val0,name1=val1,...];\n\n> Creates edges between nodes n0, n1, ..., nn and sets their attributes according to the optional list.  Creates nodes as necessary.\n\nNo commas as edge separators. Thus, the turning them into `--`. I suppose I could have split it up into a bunch of single connections, but then it wouldn't be a 8 line toy script and I would have actually had to do work.\n\nThis space intentionally left blank.\n\nAgain, according to the documentation of the dot format, it doesn't. See `man dot`\n\nThis space intentionally left blank.\n\nInteresting. They really should update the docs.", "id": "dr4fvrb", "owner_tier": 0.9, "score": 0.2432432431081081}, {"content": "This space intentionally left blank.\n\nThis space intentionally left blank.\n\nNice. I\u2019ve either got to get better at writing adhoc Parsers or at writing Parsec parsers, since writing the input parser seems to take me more time than writing the solution itself!\n\n(Maybe I should be looking at ViewPatterns?)\n\nYeah, the Data.Graph solution was basically `map flattenSCC . stronglyConnComp` (and then part one is finding the length of the sub-list that contained 0 and part two is the length of the entire list)\n\nAlternatively, part 1 is solvable directly with `length $ reachable graph 0`", "id": "dr4gt34", "owner_tier": 0.3, "score": 0.12162162148648648}, {"content": "F#. First try had some some mutable values. I managed to refactor to a functional solution I'm happy with.\n\n    let solveday12 (lines: string[]) =\n        let mapping = \n            lines\n            |> Array.map (fun l -> l.Replace(\" <-> \", \",\").Split(','))\n            |> Array.map (Array.map int)\n            |> Array.map (fun l -> (l.[0], l.[1..]))\n            |> Map.ofArray\n    \n        let rec explore seen root = \n            if Set.contains root seen then\n                seen\n            else\n                Array.fold explore (seen.Add root) mapping.[root]\n    \n        let countComponents (count, seen) (num, _) =\n            if Set.contains num seen then\n                (count, seen)\n            else \n                (count + 1, explore seen num)\n    \n        let ans1 = explore Set.empty 0 |> Set.count\n    \n        let ans2 = \n            mapping \n            |> Map.toSeq\n            |> Seq.fold countComponents (0, Set.empty)\n            |> fst\n    \n        (ans1, ans2)\n    \n\n\nI also used F#:\n\n    module AdventOfCode2017.Day12\n\n    open System\n\n    let parseInput (lines : string[]) : Map<int, Set<int>> =\n        lines\n        |> Array.map (\n            fun str ->\n                let l = str.Split ([| ' '; ',' |], StringSplitOptions.RemoveEmptyEntries)\n                int l.[0], l.[2..] |> Array.map int |> Set.ofArray\n        ) |> Map.ofArray\n\n    let graphCount (g : Map<int, Set<int>>) =\n        let rec visit (visited : Set<int>) (current : int)  : Set<int> =\n            if visited |> Set.contains current then\n                Set.empty\n            else\n                let visited' = visited.Add current\n                g.[current] + (g.[current] |> Set.map (visit visited') |> Set.unionMany)\n\n        let rec nbRoots (vertices : Set<int>) =\n            if Set.isEmpty vertices then 0 else 1 + nbRoots (vertices - (visit Set.empty (vertices |> Set.minElement)))\n\n        visit Set.empty 0 |> Set.count, g |> Map.toList |> List.map fst |> Set.ofList |> nbRoots\n\nmore F#, after a little help\n\nhttps://github.com/a-red-christmas/aoc2017-fs/blob/master/day12/Program.fs", "id": "dr4i1uo", "owner_tier": 0.1, "score": 0.06756756743243243}, {"content": "**Rust:** (231, 194), trying to optimize my workflow a bit more.\n\nEdit: cleaned up version here: https://github.com/udoprog/rust-advent-of-code-2017/blob/master/src/day12.rs\n\n    #![feature(generators)]\n    #![feature(generator_trait)]\n    #![feature(conservative_impl_trait)]\n    #![feature(never_type)]\n    #![feature(inclusive_range_syntax)]\n    #![feature(iterator_step_by)]\n\n    #![allow(unused)]\n    #![allow(dead_code)]\n\n    use std::io::Read;\n    use std::collections::{HashMap, HashSet, VecDeque};\n\n    fn count(children: &HashMap<u64, Vec<u64>>, current: u64) -> (u64, HashSet<u64>) {\n        let mut count = 0u64;\n        let mut seen = HashSet::new();\n\n        let mut queue = VecDeque::new();\n        queue.push_back(current);\n\n        while let Some(id) = queue.pop_front() {\n            if !seen.insert(id) {\n                count += 1;\n                continue;\n            }\n\n            if let Some(children) = children.get(&id) {\n                for child in children {\n                    queue.push_back(*child);\n                }\n            }\n        }\n\n        (count, seen)\n    }\n\n    fn run<R: Read>(mut reader: R) -> (u64, u64) {\n        let data = {\n            let mut data = String::new();\n            reader.read_to_string(&mut data);\n            data\n        };\n\n        let mut children: HashMap<u64, Vec<u64>> = HashMap::new();\n        let mut all_ids = HashSet::new();\n\n        for line in data.lines() {\n            let mut it = line.split(\" <-> \");\n\n            let left: u64 = it.next().expect(\"bad id\").parse().expect(\"bad id\");\n\n            let right: Vec<u64> = it.next()\n                .expect(\"bad ids\")\n                .split(\", \")\n                .map(|d| d.parse::<u64>())\n                .collect::<Result<Vec<_>, _>>()\n                .expect(\"bad ids\");\n\n            all_ids.insert(left);\n            all_ids.extend(right.iter().cloned());\n\n            children.insert(left, right);\n        }\n\n        let zero_group = count(&children, 0).0;\n\n        let mut groups = 0u64;\n\n        while let Some(next_id) = all_ids.iter().cloned().next() {\n            for found in count(&children, next_id).1 {\n                all_ids.remove(&found);\n            }\n\n            groups += 1;\n        }\n\n        (zero_group, groups)\n    }\n\n    #[test]\n    fn it_works_example() {\n        use std::io::Cursor;\n\n        assert_eq!(run(Cursor::new(include_str!(\"../day12.txt\"))), (113, 202));\n    }\n\n[deleted]\n\n`Read` is just my default. It permits the most flexibility in how much data should be kept in memory at a time and anything that can be 'read' implements it. Arguably this is yet to be a problem with AoC since all inputs are rather small. Strings can be adapted using io::Cursor.\n\nAs for Option, I'm not doing that (but ? is coming for it too soon!). I can walk you through it if you can tell me what you are referring to?\n\n[deleted]\n\nAh, it is indeed a `Result`: https://doc.rust-lang.org/std/primitive.str.html#method.parse\n\nAlso, here is `try_trait` which will add support for Option:\n\nhttps://github.com/rust-lang/rust/issues/42327\n\nhttps://doc.rust-lang.org/beta/unstable-book/library-features/try-trait.html", "id": "dr4g4tk", "owner_tier": 0.5, "score": 0.12162162148648648}, {"content": "**Bash** with **pipes**!\n\nPart 1 (reads from stdin):\n\n    sed -E 's/[^0-9]*([0-9]+)[^0-9]+/\\1|/g; s/[0-9]+/_&_/g' | ./find_grp.sh\n    grep -oE \"[0-9]+\" conns | sort | uniq -d | wc -l && rm -f conns match pipes\n\n\nPart 2 (reads from stdin):\n\n    sed -E 's/[^0-9]*([0-9]+)[^0-9]+/\\1|/g; s/[0-9]+/_&_/g' | ./find_grp.sh\n    arglen=-1\n    while [ $arglen -ne 0 ]\n    do cat pipes conns | sort | uniq -u > arg\n       arglen=$(cat arg | wc -l); ((i++))\n       cat arg | ./find_grp.sh\n    done\n    echo $i; rm -f arg conns match pipes\n\n`find_grp.sh`:\n\n    cat > pipes && head -1 pipes > conns\n    prev=0; rem=-1\n    while [ $rem -ne $prev ]\n    do grep -E -f conns pipes > match && cat match >> conns\n       prev=$rem; rem=$(cat pipes conns | sort | uniq -u | wc -l)\n    done\n\n\nThe solution would get even more pipeliney if I replaced\n\n    [...] | uniq -u > arg\n    [...]\n    cat arg | ./find_grp.sh\n\nwith\n\n    [...] | uniq -u | tee arg | ./find_grp.sh\n    [...]\n\nand\n\n    cat > pipes && head -1 pipes > conns\n\nwith\n\n    tee pipes | head -1 > conns\n\nbut I'm hitting some non-deterministic issue where `tee` sometimes copies only the first n*4K bytes of its input to the file. My working theory is that I'm probably using `tee` the wrong way. :-)", "id": "dr4ldcs", "owner_tier": 0.1, "score": 0.040540540405405404}, {"content": "**[Mathematica](https://github.com/HiggstonRainbird/AoC-2017)**\n----\n\nMathematica's graph theory capabilities are very useful here.  Less useful is `Import[]` - I spent far more time trying to parse the input than solving the problem itself.  199/97.\n\n**Import:**\n\n\tinput=\n\t\tToExpression[StringSplit[StringSplit[#,\" <->\"],\",\"]]&/@\n\t\tImport[FileNameJoin[{NotebookDirectory[],\"Day11Input.txt\"}],\"List\"][[;;-2]]\n\n\tg=Graph[Flatten[Thread[#[[1,1]]<->Flatten[#[[2]]]]&/@input],VertexLabels->\"Name\"]\n\n**Part 1:**\n\n\tLength@SelectFirst[ConnectedComponents[g],MemberQ[#,0]&]\n\n**Part 2:**\n\n\tLength@ConnectedComponents[g]\n\nI also used Mathematica today because I got lazy.\n\nHere's a picture of the graph\n\nhttps://imgur.com/a/6oTV7\n\n\n\nNot to nitpick, but you should do something like `Graph[DeleteDuplicatesBy[edges, Sort]]`to remove those duplicate edges, e.g. when A<->B and B<->A. Not sure why Mathematica doesn't remove those by default.\n\n^(Hi, I'm a bot for linking direct images of albums with only 1 image)\n\n**https://i.imgur.com/AxbxkYa.png**\n\n^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&subject=ignoreme&message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&subject=delet%20this&message=delet%20this%20dr4hd44) ", "id": "dr4fu9q", "owner_tier": 0.5, "score": 0.12162162148648648}, {"content": "**Rust** (235/198)\n\n    fn main() {\n        let input = include_str!(\"../input.txt\");\n        let mut ivec = Vec::new();\n        for line in input.lines() {\n            let mut parts = line.split_whitespace();\n            let program = parts.next().unwrap().parse::<usize>().unwrap();\n            parts.next();\n            let mut pipes = Vec::new();\n            for sprogram in parts {\n                let a = sprogram.split(\",\").next().unwrap().parse::<usize>().unwrap();\n                pipes.push(a);\n            }\n            ivec.push((program, pipes));\n        }\n        let mut groups = 0;\n    \n        while ivec.len() > 0 {\n            let mut connections = vec![ivec.clone().get(0).unwrap().0.clone()];\n            let mut priorconnections = Vec::new();\n            while priorconnections != connections {\n                priorconnections = connections.clone();\n                for p in ivec.clone() {\n                    if connections.contains(&p.0) {\n                        connections.append(&mut p.1.clone());\n                    }\n                }\n                connections.sort();\n                connections.dedup();\n            }\n            ivec.retain(|x| !connections.contains(&x.0));\n            groups += 1;\n        }\n        println!(\"{:?}\", groups);\n    }\n\n\nTIL about Rust's \"dedup()\" vector function. Thanks!", "id": "dr4gjdt", "owner_tier": 0.1, "score": 0.040540540405405404}, {"content": "As usual, I was less than a minute from getting on the leaderboard for both stars. Damn, this year has some fast challenges.\n\nAnyway, my solution in Python 3, written with no knowledge of existing Python graph theory modules:\n\n    pipes = {}\n    with open('day12.in') as f:\n        for line in f:\n            src, _, dsts = line.split(maxsplit=2)\n            pipes[int(src)] = set(map(int, dsts.split(', ')))\n    \n    def find_group(seed):\n        group = {seed}\n        new = {seed}\n        while new:\n            next_new = set()\n            for item in new:\n                next_new.update(pipes[item])\n            new = next_new - group\n            group.update(next_new)\n        return group\n    print('Part 1:', len(find_group(0)))\n    \n    remaining = set(pipes)\n    groups = 0\n    while remaining:\n        groups += 1\n        group = find_group(remaining.pop())\n        remaining -= group\n    print('Part 2:', groups)\n", "id": "dr4gc2e", "owner_tier": 0.5, "score": -1.3513513431385529e-10}, {"content": "PowerShell. Missed the leaderboard for part 1 by 23 seconds, partly because of a type error of mixing int and string getting it into an infinite loop.\n\nPart 1, build a hashtable of connections, recursively follow the connections but keep track of visited nodes so it doesn't go into an infinite loop:\n\n    $in = @'\n    0 <-> 199, 1774\n    1 <-> 350, 1328, 1920\n    etc.\n    '@ -split \"`r?`n\"\n\n\n    $connections = @{}\n    $in | ForEach-Object {\n\n        [int]$Left, [string]$Right = $_ -split ' <-> '\n\n        $connections[$Left] = [int[]]@($Right -split ', ')\n    }\n\n    $visited = New-Object System.Collections.ArrayList\n\n    function visit ([int]$id)\n    {\n        foreach ($node in $connections[$id])\n        {\n            if ($node -notin $visited)\n           {\n                [void]$visited.add($node)\n                visit $node\n            }\n        }\n    }\n\n    visit 0\n\n    # Part 1 answer:\n    $visited | Sort-Object -Unique | Measure-Object\n\n    # That's the right answer! You are one gold star closer to debugging the printer. You got rank 118 on this star's leaderboard. [Return to Day 12]\n\nPart 2 I mashed up, wasn't as confident with and copy-pasted my visitor, rewrote it a bit, took longer; it took all the nodes, started visiting them and removing them from the list. When that ran out, increase group count and go again, until all the nodes were visited.\n\n    [System.Collections.Generic.List[int]]$allNodes = $connections.Keys | ForEach-Object {$_}\n    $allNodes += $connections.Values | ForEach-Object {$_}\n\n    [System.Collections.Generic.List[int]]$allNodes = $allNodes | Sort-Object -Unique\n\n    function visit2 ([int]$id)\n    {\n        foreach ($node in $connections[$id])\n        {\n            if ($node -notin $visited2)\n           {\n                [void]$visited2.Add($node)\n                if ($node -in $allNodes)\n                {\n                    [void]$allNodes.remove($node)\n                    visit2 $node\n                }\n            }\n        }\n    }\n\n    $groups = 0\n    while ($allNodes)\n    {\n        $visited2 = New-Object -TypeName System.Collections.ArrayList\n\n        $node = $allNodes[0]\n        [void]$allNodes.Remove($node)\n        visit2 $node\n        $groups++\n    }\n    $groups\n\n    # 1044 wrong\n\n    # That's the right answer! You are one gold star closer to debugging the printer. You got rank 230 on this star's leaderboard.\n\n\n\nI'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:\n\n- [/r/pwsh2017aoc] [Day 12 - Travelling hashtable salesman](https://www.reddit.com/r/pwsh2017aoc/comments/7j8lnw/day_12_travelling_hashtable_salesman/)\n\n&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*\n\nyeah, my first stab at part2 was absurdly slow cause i was just going to generate the group for each node, then select distinct groups.  figuring out how to either remove or selectively start a new loop there stumbled me a bit.\n\nyours, just using $allnodes everywhere is pretty convenient :)", "id": "dr4grnp", "owner_tier": 0.7, "score": 0.027027026891891893}, {"content": "**Python 2** with a defaultdict of sets:\n\n    import time\n    from collections import defaultdict\n\n    def problem(d):    \n        dd = defaultdict(set)        \n\n        for line in d:\n            tokens = line.replace(\",\",\"\").split()\n            node, connections = int(tokens[0]), map(int,tokens[2:])\n            for item in connections:\n                dd[node].add(item)\n                dd[item].add(node)\n\n        # groupnodes starts with all nodes that need to be accounted for in a grouping\n        groupnodes = set(dd.keys())\n        \n        # now start with a node and merge adjacents\n        # any node that got accounted for in a flattening gets\n        # discarded from the groupnode set\n        def flatten(n):\n            prevl = 0\n            length = len(dd[n])\n            groupnodes.discard(n)\n            \n            # Keep merging in sets until the length stops growing from\n            # doing so\n            while length != prevl:\n                items = list(dd[n])\n                for item in items:\n                    dd[n] |= dd[item]\n                    groupnodes.discard(item)\n                prevl = length\n                length = len(dd[n])\n\n        flatten(0)\n        print \"part 1:\", len(dd[0])\n\n        # flatten all remaining nodes in the groupnodes set until every node has been processed\n        # there will be one new group per pass    \n        count = 1\n        while len(groupnodes):\n            n = groupnodes.pop()\n            flatten(n)\n            count += 1\n            \n        print \"part 2:\", count    \n\n    if __name__ == \"__main__\":\n        start = time.time()\n        problem(open(\"day12.txt\").readlines())\n        print time.time() - start,\"s\"\n\nedit: cleaned up a little and added some comments for future reference", "id": "dr4h0qj", "owner_tier": 0.3, "score": -1.3513513431385529e-10}, {"content": "\t#!/bin/bash\n\t(\twhile read a b c\n\t\tdo\tlist[a]=\"$c\"\n\t\tdone\n\t\tgroups=0\n\t\twhile :\n\t\tdo\tfound=false\n\t\t\tfor i in ${!list[@]}\n\t\t\tdo\t[[ -z ${group[i]} ]] && found=true && group[i]=1 && todo[i]=1 && break\n\t\t\tdone\n\t\t\t$found || break\n\t\t\twhile [[ ${!todo[@]} ]]\n\t\t\tdo\tfor i in ${!todo[@]}\n\t\t\t\tdo\tfor j in ${list[i]//,/}\n\t\t\t\t\tdo\t[[ -z ${group[j]} ]] && group[j]=1 && todo[j]=1\n\t\t\t\t\tdone\n\t\t\t\t\tunset todo[i]\n\t\t\t\tdone\n\t\t\tdone\n\t\t\t((groups++,groups==1)) && echo ${#group[@]}\n\t\tdone\n\t\techo $groups\n\t)<input\n", "id": "dr4hlj8", "owner_tier": 0.3, "score": -1.3513513431385529e-10}, {"content": "Went with a more obscure language today - here's my solution for part 2 in [io](http://iolanguage.org/index.html):\n\n    file := File with(\"12-input.txt\")\n    lines := file readLines\n    file close\n\n    dict := Map clone\n    lines foreach(i, v,\n        nums := v split(\" <-> \")\n        dict atPut(nums first, nums last split(\", \"))\n    )\n\n    set := Map clone\n    check := method(x,\n        dict at(x) foreach(i, v,\n            set hasKey(v) ifFalse(\n                set atPut(v)\n                check(v)\n            )\n        )\n    )\n\n    groups := 0\n    dict keys foreach(i, v,\n        set hasKey(v) ifFalse(\n            groups = groups + 1\n            set atPut(v)\n            check(v)\n        )\n    )\n\n    groups println\n", "id": "dr4j0wk", "owner_tier": 0.5, "score": -1.3513513431385529e-10}, {"content": "**Node.js/JavaScript**\n\nI'm... sorry.\n\n    const fs = require('fs')\n    let inp = fs.readFileSync(\"./day12input\").toString('utf-8').trim().split(/[\\r\\n]+/) // array of lines\n      .map((x) => x.split(\">\")[1].split(\", \").map(y => parseInt(y)))\n\n    let visited = []\n    function reach(i) {\n      if (visited.includes(i))\n        return 0\n      visited.push(i)\n      return inp[i].reduce((a,b) => a + reach(b), 1)\n    }\n\n    inp = inp.map((_, k) => reach(k))\n    console.log(\"a:\", inp[0]);\n    console.log(\"b:\", inp.filter(x => x > 0).length);\n\n\nUnit tests be damned! I like it.", "id": "dr4j2uq", "owner_tier": 0.5, "score": 0.027027026891891893}, {"content": "Ruby, silver 17 / gold 29\n\nI had the wrong answer on part 2 because I used 100.times again, which forced me to wait 1 minute :( This one was an easy incomplete BFS which assumes all groups can be found in under 100 steps.\n\n    g=[0]\n    h={}\n    $<.map{|x|a,b=x.split' <-> '\n    h[a.to_i]=b.split(', ').map &:to_i\n    }\n    l=[]\n    c=0 # part 2\n    loop{ # end part 2\n    100.times{s=[]\n    g.map{|x|s+=h[x]}\n    l+=g\n    g=s-l}\n    c+=1 if h.delete_if{|x,y|l.index x} # part 2\n    l=[]\n    break unless h.keys.any?\n    g=[h.keys.first]\n    } # end part 2\n    p l.size # part 1\n    p l.size,c # part 2\n\nYes, I messed about with 10.times, 20.times etc myself until deciding that an until loop would be more foolproof.\n\nLine 3: No need to split each line twice, just `scan` it for number-looking things:\n\n    a,*b = x.scan(/\\d+/).map(&:to_i)\n\nWhat we need is a graph library like how python has networkx :)\n\nThat is a valid and very constructive suggestion, I'm surprised I missed it. An alternative is splitting by `/\\D+/` since we don't care about non-digits:\n\n    a,*b = x.split(/\\D+/).map &:to_i\n\nIt can't stand in the shadow of NetworkX, but https://github.com/chikamichi/plexus looks like a candidate.", "id": "dr4fte4", "owner_tier": 0.3, "score": 0.06756756743243243}, {"content": "I stupidly forgot to return my hashset if I had already visited a node, which I think made me too slow for part 2 (I also slowly went through the test case instead of just bum rushing it).\nfrom collections import defaultdict\n\n    def count_connected(adj, start, seen=set()): \n        '''\n        Counts the number of nodes connected to start.\n        '''\n        if start in seen:\n            return 0\n        else:\n            seen.add(start)\n            return 1 + sum([count_connected(adj, child, seen) for child in\n                            adj[start]])\n    \n    def connected_group(adj, start, seen=set()): \n        '''\n        Returns the set of nodes connected to start.\n        '''\n        if start in seen:\n            return seen\n        else:\n            seen.add(start)\n            for child in adj[start]:\n                # This actually isn't necessary by virtue of how optional\n                # parameters work in Python, but it's better to be explicit.\n                seen = connected_group(adj, child, seen)\n            return seen \n    \n    with open('12.in') as inp:\n        # Adjacency list of the form {node: set(children)}.\n        adj = defaultdict(set)\n        for line in inp:\n            start, nodes = line.strip().split(' <-> ')\n            adj[start] = set(nodes.split(', '))\n            # This graph is bidirectional, so update the adjacency list for the\n            # children, too.\n            for node in adj[start]:\n                adj[node].add(start)\n        # Part 1.\n        print(count_connected(adj, '0')) \n        groups = set()\n        # Find the connected groups starting from each node.\n        for start in adj.keys():\n            # Sets aren't hashable, so use frozenset.\n            groups.add(frozenset(connected_group(adj, start)))\n        # Part 2.\n        print(len(groups))\n\nEdits:\n\nI also foolishly\n\n1. Didn't leverage the function I already had but instead wrote a new one for part 2 (this wasn't a big time loss, though).\n\n2. Didn't implement the bidirectionality (I only did connections one way) which I got lucky with based on how part 1 worked.\n\nEdit 2:\n\nUpdated code.\n\nBTW, it's faster to `for line in inp` than it is to `inp.readlines()`. The former is a generator that reads one line at a time, and the latter reads the entire file into memory first.\n\nMaybe in general, but since we have to fit the entire relatively small graph in memory anyway and the string representation isn't much, if any, larger than that, it doesn't matter too much for this puzzle.\n\nGiven the constraints of these puzzles, it's unlikely to matter for any of them really.  Unless topaz throws a multi-GB input at us from his poor webserver.\n\nThanks for that. It definitely looks more pythonic. I'll edit into the file once I do some more prettying up.\n\nThat's true, and it's also faster to write `for line in inp` than it is to write `for line in inp.readlines()`. Not much, but when a 5 letter variable is too long to write, so is `inp.readlines()` :P\n\nThat's true enough.", "id": "dr4g496", "owner_tier": 0.1, "score": 0.09459459445945946}, {"content": "PHP\n\nI seem to be one of the few using recursion. I don't even know why I use recursion, it came naturally to me :-/\n\nPart 1:\n\n\tfunction run_the_code($input) {\n\t\t$lines = explode(PHP_EOL, $input);\n\t\t$groups = [];\n\t\tforeach ($lines as $line) {\n\t\t\tif (preg_match('/(\\d+) <-> (.*)/', $line, $matches)) {\n\t\t\t\tlist($_, $a, $b) = $matches;\n\t\t\t\t$groups[$a] = array_map('trim', explode(',', $b));\n\t\t\t}\n\t\t}\n\t\n\t\t$nullGroup = [];\n\t\t$rec = function($root) use (&$rec, &$nullGroup, $groups) {\n\t\t\tif (!in_array($root, $nullGroup)) {\n\t\t\t\t$nullGroup[] = $root;\n\t\t\t\tforeach ($groups[$root] as $ch) {\n\t\t\t\t\t$rec($ch);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t$rec('0');\n\t\n\t\treturn count($nullGroup);\n\t}\n\nPart 2:\n\n\tfunction run_the_code($input) {\n\t\t$lines = explode(PHP_EOL, $input);\n\t\t$groups = [];\n\t\tforeach ($lines as $line) {\n\t\t\tif (preg_match('/(\\d+) <-> (.*)/', $line, $matches)) {\n\t\t\t\tlist($_, $a, $b) = $matches;\n\t\t\t\t$groups[$a] = array_map('trim', explode(',', $b));\n\t\t\t}\n\t\t}\n\t\n\t\t$subgroups = [];\n\t\t$rec = function($base, $root) use (&$rec, &$subgroups, $groups) {\n\t\t\tif (!array_key_exists($base, $subgroups)) {\n\t\t\t\t$subgroups[$base] = [];\n\t\t\t}\n\t\t\tif (!in_array($root, $subgroups[$base])) {\n\t\t\t\t$subgroups[$base][] = (int)$root;\n\t\t\t\tforeach ($groups[$root] as $ch) {\n\t\t\t\t\t$rec($base, $ch);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tforeach ($groups as $base => $root) {\n\t\t\t$rec($base, $base);\n\t\t\t// prepare for unique\n\t\t\tsort($subgroups[$base]);\n\t\t\t// array_unique does not work on multidimensional arrays, so hack it\n\t\t\t$subgroups[$base] = implode('-', $subgroups[$base]);\n\t\t}\n\t\t$simple = array_unique($subgroups);\n\t\n\t\treturn count($simple);\n\t}\n\n\nI had the same idea. I went with recursion because the problem seemed similar to Day 7.", "id": "dr4g7xs", "owner_tier": 0.1, "score": -1.3513513431385529e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/7j89tr/2017_day_12_solutions/", "question": {"content": "#--- Day 12: Digital Plumber ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Need a hint from the [Hugely^* Handy^\u2020 Haversack^\u2021 of Helpful^\u00a7 Hints^\u00a4](/r/adventofcode/w/h5)?\n\n[Spoiler](#s \"If today's puzzle is too easy, try adding: #define if(x) if ((x) && (rand() < RAND_MAX * 0.99))\")\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n\n###*edit:* Leaderboard capped, thread unlocked!", "id": "7j89tr", "title": "-\ud83c\udf84- 2017 Day 12 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "**Haskell** - single pass with `foldr`. Using foldr you work with a completely reduced tail and just adding things on to the front of that one at a time reducing as needed.\n\nhttps://github.com/glguy/advent2018/blob/master/execs/Day05.hs#L27-L31\n\n    part1 :: String -> Int\n    part1 = length . foldr step \"\"\n      where\n        step x (y:ys) | x /= y && toUpper x == toUpper y = ys\n        step x ys                                        = x : ys\n\nThat is actually pretty smart!\n\nI felt like today's challenge was really suited for Haskell, but the bruteforce algorithm I implemented (react until nothing changes) is not as elegant.\n\nWell, thanks for keep posting your solutions, I always like to learn more haskell!\n\n\n\nthis is poetry\n\nI'm so used to left folds I never remember that right folds exist.\n\nThat is a cool solution, and probably way faster than mine.\n\nEdit: Yep, waaay faster.\n\nwow this is amazing! so elegant. I spent a week hacking some recursive solution in haskell :(\n\n\n\n\nNice short solution! Did it get you onto the leaderboard?\n\nHaha! I did the same right fold in F#, but I didn't realize that the fold produced the correct solution in a single pass so I added some unneeded recursion:\n\n    let reacts a b = (abs ((int a) - (int b))) = 32 // 32 = distance between uppercase/lowercase in ASCII\n\n    let reduceOnce polymer =\n        List.foldBack (fun u polymer -> \n            match polymer with\n            | head::rest when reacts head u ->  rest\n            | _ -> u::polymer\n        ) polymer []\n\n    let rec reduce polymer =\n        let once = reduceOnce polymer\n        let twice = reduceOnce once\n        if once = twice then once\n        else reduce twice // Never actually true!\n\nAfter seeing your comment I simply removed my second function and renamed my first! \n\nThis space intentionally left blank.\n\nNice! Here was mine, which was arrived at independently.\n\n    sameType = (==) `on` toLower\n    oppositePolarity = (/=) `on` isLower\n\n    reactable x1 x2 = x1 `sameType` x2 && x1 `oppositePolarity` x2\n\n    reactTwo x1 (x2:xs) = if reactable x1 x2 then xs else x1:x2:xs\n    reactTwo x1 []      = [x1]\n\n    reactAll = foldr reactTwo \"\"\n\nLooking at yours, I think I went overboard with the function decomposition, but it's clear to see that they are using the same idea.\n\nI did this the slow way too :(.  glguy's solution is elegant and simple. \n It's a good reminder that the accumulator to fold functions needn't always grow/accrue, it can \"deaccumulate\" too", "id": "eb4dchg", "owner_tier": 0.3, "score": 0.9999999998630138}, {"content": "Missed the leaderboards because I was forgetting to trim my iinput for whitespace. Lesson learned I guess!\n\n    import sys\n    \n    line = [line for line in sys.stdin][0].strip()\n    \n    \n    def are_opp(a, b):\n        return (a.lower() == b.lower() and\n                ((a.isupper() and b.islower()) or\n                 (a.islower() and b.isupper())))\n    \n    \n    def react(line):\n        buf = []\n        for c in line:\n            if buf and are_opp(c, buf[-1]):\n                buf.pop()\n            else:\n                buf.append(c)\n        return len(buf)\n    \n    \n    agents = set([c.lower() for c in line])\n    \n    # part 1\n    print(react(line))\n    \n    # part 2\n    print(min([react(line.replace(a, '').replace(a.upper(), ''))\n               for a in agents]))\n    \n\nSame here. That pesky carriage return threw me off.\n\n>if buf and **are\\_opp(c, buf\\[-1\\])**:\n\nwhat do you think about this suggestion:\n\n*if bug and* `buf[-1] == c.swapcase():`\n\nDamn, I feel stupid. When I saw your solution, it looks so simple and ran plenty fast, where mine...\n\nWell, it is shitty reimplementation of fold with runtime measured in seconds. I am not proud for getting those gold stars.\n\nKudos on this one. It's easy to understand and much better than what I wrote.\n\nThis is really great.\n\nThanks man, that fixed my problem.\n\nI had almost the same solution, except for the condition that you have in your `are_opp`.\n\nI had `a.lower() == b or a == b.lower()`.\n\nObviously it missed some cases because I had too many chars in the end, but I don't see which ones.\n\nDo you have any idea ?\n\n[Edit] : of course I checked my output for matching pairs and there where none. I modified only the condition in my original program and I passed the puzzle.\n\nFell into this one as well.\n\nNot OP, but I think swapcase is neat! I was using \\`abs(ord(buf\\[-1\\]) - ord(c)) == 32\\` myself.", "id": "eb4ff0j", "owner_tier": 0.3, "score": 0.5342465752054795}, {"content": "Oooh, another challenge where using **Vim** seems easier than writing a program! For part\u00a01, anyway \u2014 load your input file, then make searching case-insensitive:\n\n    :set ic\u27e8Enter\u27e9\n\n and remove pairs of letters of opposite case with:\n\n    :s/\\v(\\l\\u|\\u\\l)&(.)\\2//g\u27e8Enter\u27e9\n\nThat substitution will then need repeating for newly created pairs. Do it again with `@:`, and watch as the line gets shorter on each press.\n\nIf you've had enough, you can make it loop till their are no more pairs with:\n\n    qaqqag&:redr\u27e8Enter\u27e9\n    @aq@a\n\nThen the answer is the number of columns, which is displayed with `g\u27e8Ctrl+G\u27e9`.\n\n(I have a plan for Part\u00a02, but now need to get the children breakfast. I'll try to put it in a reply to this comment later.) \n\n**Part 2 in Vim** *wasn't* easier than in a programming language ...\n\n    :set ic\u27e8Enter\u27e9\n    :s/\\v(.)\\1&(\\l\\u|\\u\\l)//g\u27e8Enter\u27e9\n    qaqqa:&&\u27e8Enter\u27e9@aq@a\n    yy26p\u27e8Ctrl+V\u27e9GI\u27e8Ctrl+V\u27e9\u27e8Ctrl+V\u27e996 \u27e8Esc\u27e9gveg\u27e8Ctrl+A\u27e9\n    qbce\u27e8Ctrl+R\u27e9-\u27e8Esc\u27e9x:s!\u27e8Ctrl+R\u27e9-!!g\u27e8Enter\u27e9\n    0Pq:+,$norm@b\u27e8Enter\u27e9\n    {qc$BC\u27e8Ctrl+R\u27e9=len(@-)\u27e8Enter\u27e9\u27e8Esc\u27e9q\u27e8Enter\u27e9\n    :s/<Up>\u27e8Enter\u27e9\n    :,$norm:redr|norm@a\u27e8Ctrl+V\u27e9\u27e8Enter\u27e9@c\u27e8Enter\u27e9\n    :2,sor n\u27e8Enter\u27e9\n\n**Update**: [Watch Vim running this](https://old.reddit.com/r/adventofcode/comments/a3i502/2018_day_5_vim_video_of_vim_solving_both_parts/).\n\nThe first 3 lines solve Part 1, pretty much as above, saving the method to macro `@a`.\n\nThen it makes 26 copies of the reacted polymer, and inserts the alphabet down the left. (*How?*). On each line, it removes that letter from the polymer (and re-inserts it at the left, so we can see which line is which). (*Why does the substitution use `s!!!` rather than the typical `s///`?*)\n\nNow we've copied the original reacted polymer, replace it with its length, saving the method to macro `@c`. And run both `@a` and `@c` on the other 26 lines (*Why is a `:norm` nested within another `:norm` there?*) \u2014 the line which gets the most units removed takes a little longer than the others.\n\nSort the alphabetical lines by the lengths. The answer to Part 1 is the unlabelled number on the top row (in orange in the video), and the answer to Part 2 is the number on the next line (in yellow, labelled with the letter of the problematic unit types).\n\nThat actually ended up being shorter, more readable, less awkward, and faster to run than I expected (*but has been edited from the original*, which was clunkier in several ways).\n\nI wrote:\n\n> Then it makes 26 copies of the reacted polymer, and inserts the alphabet down the left. (*How?*).\n\nNever mind \u2018how?\u2019, the more relevant question is \u2018why?\u2019 \u2014 and the answer is, \u2018because I didn't know about `:set nrformats+=alpha`\u2019, which enables `Ctrl+A` to work on letters, and would've been much more straightforward.", "id": "eb4iki6", "owner_tier": 0.3, "score": 0.3424657532876712}, {"content": "My initial implementation for part 1 ran fairly slowly (~10 seconds), so I assumed my part 2 was going to be horrible, but ended finishing in almost no extra time.  I eventually realized that I had used my reduced result from part 1 as the basis for part 2, which is actually a really great optimization.\n\nAccidental genius :) nice!", "id": "eb4fvko", "owner_tier": 0.1, "score": 0.1917808217808219}, {"content": "Rank 36/9. Disappointing part 1, including a wrong answer and deciding to type out the alphabet by hand. Video of me solving at: https://www.youtube.com/watch?v=VBhrueOccZ0\n\nCode (for part 2):\n\n     s = open('5.in').read().strip()\n\n     alpha = 'abcdefghijklmnopqrstuvwxyz'\n     M = {}\n     for c in alpha:\n         M[c.lower()] = c.upper()\n         M[c.upper()] = c.lower()\n\n     ans = 1e5\n     for rem in alpha:\n         s2 = [c for c in s if c!=rem.lower() and c!=rem.upper()]\n         stack = []\n         for c in s2:\n             if stack and c == M[stack[-1]]:\n                 stack.pop()\n             else:\n                 stack.append(c)\n         ans = min(ans, len(stack))\n     print ans\n\nthe key to typing out the alphabet by hand is that you didn't need to iterate through the letters in alphabetical order :)\n\n`str.swapcase` would also save you a ton of time.\n\na-ha, nice use of a stack!\n\nAwesome. I would never thought about using a stack.\n\nVery nice. I really like the trick for getting the opposites fast with a dictionary. \n\n>1e5\n\n`ans = len(polymer)`  \n**ans** can't be longer than polymer total size\n\n&#x200B;\n\n    from string import ascii_uppercase\n\n is a good one to keep in your back pocket too\n\nThis. Also, even if you need to for $REASONS:\n`alphabet = \"qwerty....cvbnm\".sort()`\n\nYeah but gotta be sure you didn't fat finger anything because it's a lot harder to check\n\nGood bye `c.lower() == c2.lower() and ((c.islower() and c2.isupper()) or (c2.islower() and c.isupper()))`", "id": "eb4cvto", "owner_tier": 0.3, "score": 0.8219178080821917}, {"content": "Absolute value between the two ASCII character codes == 32 is another way to do the letter comparison. Runs in <40ms for part 2.\n\n**JavaScript**\n\n    import { minBy } from 'lodash'\n    \n    const peek = stack => stack[stack.length - 1]\n    \n    const factorPolymer = input => {\n        const stack = []\n    \n        input.split('').forEach(char => {\n            // XOR of A and a, B and b, etc is 32\n            if (!stack.length || (peek(stack).charCodeAt() ^ char.charCodeAt()) !== 32) {\n                stack.push(char)\n            } else {\n                stack.pop()\n            }\n        })\n    \n        return stack.join('')\n    }\n    \n    export const solvePart1 = input => {\n        return factorPolymer(input).length\n    }\n    \n    export const solvePart2 = input => {\n        input = factorPolymer(input) // A first factorization pass speeds up the following passes\n    \n        const polymers = Array(26) // Indexes 0-26 represent 65-91 ASCII codes\n            .fill()\n            .map((e, i) => {\n                const re = new RegExp(String.fromCharCode(i + 65), 'gi')\n                const strippedInput = input.replace(re, '')\n                return factorPolymer(strippedInput)\n            })\n    \n        return minBy(polymers, 'length').length\n    }\n    \nEdit: Updated to use a stack instead of string concatenation and the fact that ASCII is laid out in a way that XOR of A and a is 32.\n\nDamn, that's fast! Neat! \n\nYour implementation of factorPolymer is quite neat!\n\nGreat stuff\n\n\n", "id": "eb4f2cf", "owner_tier": 0.1, "score": 0.1232876710958904}, {"content": "Python 3\n\nFun!\n\n    line = open(\"day5input.txt\").read().splitlines()[0]\n    \n    oldline = None\n    while oldline != line:\n        oldline = line\n        for i in range(0,26):\n            line = line.replace(chr(ord(\"a\") + i) + chr(ord(\"A\") + i),\"\")\n            line = line.replace(chr(ord(\"A\") + i) + chr(ord(\"a\") + i),\"\")\n    \n    print(\"Part1:\")\n    print(len(line))\n    \n    original = line\n    best = len(line)\n    for j in range(0,26):\n        line = original\n        line = line.replace(chr(ord(\"a\") + j),\"\")\n        line = line.replace(chr(ord(\"A\") + j),\"\")\n        oldline = None\n        while oldline != line:\n            oldline = line\n            for i in range(0,26):\n                line = line.replace(chr(ord(\"a\") + i) + chr(ord(\"A\") + i),\"\")\n                line = line.replace(chr(ord(\"A\") + i) + chr(ord(\"a\") + i),\"\")\n    \n        best = len(line) if len(line) < best else best\n    print(\"Part2:\")\n    print(best)\n\n    from string import *\n    \n    \n    def collapse(s):\n        p = ['.']\n        for u in s:\n            v = p[-1]\n            if v != u and v.lower() == u.lower():\n                p.pop()\n            else:\n                p.append(u)\n        return len(p) - 1\n    \n    \n    s = open('5.txt').read().strip()\n    print(collapse(s))\n    print(min(collapse(c for c in s if c.lower() != x) for x in ascii_lowercase))\n\n&#x200B;\n\nNice one!\n\nRemember, the `range` function implies starting at `0` by default, so `range(26)` are the same numbers as `range(0, 26)`.\n\nInstead of chr(ord(\"a\") + j) etc you could loop string.ascii\\_lowercase or ascii\\_uppercase.\n\nI think a regex solution is slower, but satisfying:\n\n    import re\n    import string\n\n    lower = string.ascii_lowercase\n    upper = string.ascii_uppercase\n    s = open(\"input.txt\").read().strip()\n    pat = \"|\".join(\n        a + b for a, b in list(zip(lower, upper)) + list(zip(upper, lower)))\n    ss = re.sub(pat, \"\", s)\n    while s != ss:\n        s = ss\n        ss = re.sub(pat, \"\", s)\n    print(len(s), s)\n\n(for part 1, just iterate for part 2)\n\nThis is the most efficient way to solve this problem. Great!\n\nThis is a great solution, but I'm perplexed. I have something very similar and it runs in \\~2.4 seconds, whereas yours consistently runs in \\~1.1 seconds. I'd love it if someone could point out which specific technique is faster here.\n\n    from string import ascii_lowercase\n    import re\n\n    def parse_input(filename):\n      \"\"\"Convenience method to parse a file and return a list as input\"\"\"\n      with open(filename, 'r') as input_file:\n        return input_file.readline()\n\n    def part1(input_string):\n      old_input = None\n      while old_input != input_string:\n        old_input = input_string\n        for char in ascii_lowercase:\n          input_string = input_string.replace(char.lower() + char.upper(), '')\n          input_string = input_string.replace(char.upper() + char.lower(), '')\n      return len(input_string)\n\n    def part2(input_string):\n      test_input = \"\"\n      shortest_value = len(input_string)\n      for char in ascii_lowercase:\n        test_input = input_string.replace(char, '').replace(char.upper(), '')\n        length = part1(test_input)\n        shortest_value = length if length < shortest_value else shortest_value\n      return shortest_value\n\n    if __name__ == \"__main__\":\n      INPUT = 'inputs/day05.txt'\n      TEST_INPUT = 'dabAcCaCBAcCcaDA'\n\n      assert part1(TEST_INPUT) == 10\n      print(f\"Part 1: {str(part1(parse_input(INPUT)))}\")\n\n      assert part2(TEST_INPUT) == 4\n      print(f\"Part 2: {part2(parse_input(INPUT))}\")\n\n\nI think mine is faster. I love using reduce :) \u200b\n\n    from functools import reduce\n    \n    def reactor(X, Y):    \n        if not X or not Y:\n            return X + Y\n    \n        # get ends of reaction\n        x = X[-1]\n        y = Y[0]\n    \n        if x != y and x.lower() == y.lower():\n            return X[:-1] + Y[1:] # react!\n        else:\n            return X + Y\n    \n    def react(polymer):\n        return reduce(reactor, list(polymer))\n    \n    %timeit len(react(input))\n    print(len(react(input)))\n    \n35.4 ms \u00b1 423 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)  \n9172\n\nYour version is an order of magnitude slower:\n\n548 ms \u00b1 3.16 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)  \n9172\n\nAnd Part 2:\n\n    import operator\n    def find_inhibitor(polymer):\n        types = set(polymer.lower())\n        inhibitor = {t: len(react(polymer.replace(t, '').replace(t.upper(), ''))) for t in types}\n        return min(inhibitor.items(), key=operator.itemgetter(1))\n    \n    %timeit find_inhibitor(input)\n    print(find_inhibitor(input))\n    \n873 ms \u00b1 9.74 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)  \n('x', 6550)\n\nYours:\n13.5 s \u00b1 88.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)  \n6550\n\nReally elegant! Easy to read and it's performant.          \nPorted it to Go part1: 774.41\u00b5s part2: 23.893527ms part2(concurrent): 11.518504ms     \n\nYep, this is an O(n) problem, not >O(n\\^2) as the solution above you is.\n\nThanks for sharing. I walked your code through the debugger, and once I understood the method I was able to dramatically improve the running time of my solution. Kudos!", "id": "eb4e5kl", "owner_tier": 0.3, "score": 0.6575342464383561}, {"content": "J, both parts\n\n\n    p1 =. [: # ,`(}.@])@.(32 -: |@(- {.)&(3&u:)/)/\n   \n    p2 =. [: <./ (a. {~ (,. 32 + ]) 65 + i.26) p1@-.\"1~ ]\n\n\n[Try it online!](https://tio.run/##LY7RCoIwGIXv9xSHAv1H7pdN8kIKZvYWIbRUqCgaRFeWr74GenMO34EPzj283dM/Buw57d2l7hrXHGJ27linweu441RhjexMP7attEyFgarwtaQwskyoSD6VzGUuAAhvFmXHOcgxxgmUMaK0QStRbmPf2JQSXlvFKz2hDUN3fUXGfEbMaBYMfw \"J \u2013 Try It Online\")\n\n\n\nJ will never stop to amaze me.", "id": "eb4jb1o", "owner_tier": 0.1, "score": 0.1232876710958904}, {"content": "First time I\u2019ve done it live this year (moving east was a mistake for Advent of Code purposes). 6th / 4th. Used a stack and added the characters one at a time for a O(n) solution. Similar to checking if a parenthesis string is balanced.\n\n    def run(s):\n        stk = []\n        for c in s:\n            popped = False\n            if stk:\n                bk = stk[-1]\n                if (('A' <= bk <= 'Z' and 'a' <= c <= 'z') or ('A' <= c <= 'Z' and 'a' <= bk <= 'z')) and bk.lower() == c.lower():\n                    stk.pop()\n                    popped = True\n            if not popped:\n                stk.append(c)\n        return len(stk)\n    \n    def main():\n        s = input().strip()\n        ans = 1000000\n        for k in range(26):\n            up = chr(ord('A') + k)\n            lo =  chr(ord('a') + k)\n            t = str(s)\n            t = t.replace(up, '')\n            t = t.replace(lo, '')\n            print(t)\n            ans = min(ans, run(t))\n        print(ans)\n    \n    main()\n\nAlso watch me code it and cry on youtube here: [https://youtu.be/GDx\\_rC5wXGc](https://youtu.be/GDx_rC5wXGc) (should go live at 12:30 EST).\n\nAwesome idea using a stack. I tried a link list, then had to do a doubly-linked list and eventually got it but a stack sounds way more straight-forward!", "id": "eb4cta2", "owner_tier": 0.1, "score": 0.0684931505479452}, {"content": "**Java 8**\n\nFelt really proud of the part 1 using a stack. Leetcode came in useful for once.\n\n    private int util1(String in) {\n        char[] arr = in.toCharArray();\n        Stack<Character> inStack = new Stack<>();\n        Stack<Character> q = new Stack<>();\n\n        for(char c : arr)\n            inStack.push(c);\n\n        for(char c : inStack) {\n            if(q.isEmpty())\n                q.push(c);\n            else {\n                char last = q.peek();\n\n                if(Math.abs(last-c) == 32) {\n                    q.pop();\n                } else {\n                    q.push(c);\n                }\n            }\n        }\n\n        return q.size();\n    }\n\n    // Less interesting part 2\n    public void runPart2() {\n        String in = this.getInputLines()[0];\n        int min = Integer.MAX_VALUE;\n\n        for(int i=0; i<26; i++) {\n           String temp = in.replaceAll(\"[\" + (char) (i + 'a') + (char) (i + 'A') + \"]\", \"\");\n\n           min = Math.min(min, util1(temp));\n        }\n\n        System.out.println(min);\n    }\n\nNote that the preferred abstraction for stacks in Java is `Deque`, `Stack` being an outdated one that builds upon the outdated `Vector`.\n\nI liked your solution, thanks for sharing.  I modified part 2 (rather than doing your replaceAll) but allowing to skip the letter (sorry did it in ruby)\n\n```\nrequire 'set'\n\ninput = File.read(\"input.txt\").strip\n\nstack = input.chars\n\ndef get_answer(stack, skip_letter: nil)\n  stack.each_with_object([]) do |el, final_stack|\n    next if skip_letter == el.downcase\n\n    if final_stack.empty?\n      final_stack << el\n    else\n      prev = final_stack.last\n\n      if el.swapcase == prev\n        final_stack.pop\n      else\n        final_stack << el\n      end\n    end\n  end\nend\n\n# pt 1\nputs get_answer(stack).size\n\n\n\n# pt2\nset = Set.new(stack).map(&:downcase)\n\nsizes = set.map do |letter|\n  get_answer(stack, skip_letter: letter).size\nend\n\np sizes.min\n```\n\n\nI like your solution. However, in part 1, why are you creating the \"inStack\" - you could directly iterate the chars as they come from input, e.g. [https://github.com/Meemaw/aoc-2018/blob/master/src/main/java/day5/Day5.java](https://github.com/Meemaw/aoc-2018/blob/master/src/main/java/day5/Day5.java)\n\nYour solution give me the same result of mine solution (11648) but it's not the correct answer, i'm lost. The input is https://pastebin.com/Hp0Xs9Hr\n\n```\n##### Puzzle 1 #####\nExecution : 0.001340ms\nResult: 11648\nResult BIS: 11648\n```\n\nCODE\n\n```\n\t// https://adventofcode.com/2018/day/5\n\tpublic static void main(String[] args) throws IOException {\n\t\tProgram p = new Program();\n\t\tp.puzzle1();\n\t\tp.puzzle1bis();\n\t\tp.puzzle2();\n\t}\n\t\n\tpublic Program() throws IOException {\n\t\tsuper(new File(Program.class.getResource(\"input.txt\").getPath()));\n\t}\n\t\n\t// https://www.reddit.com/r/adventofcode/comments/a3912m/2018_day_5_solutions/eb4fiod\n\tpublic void puzzle1bis()\t{\n\t\tchar[] arr = inputs.get(0).toCharArray();\n\t    Stack<Character> inStack = new Stack<>();\n\t    Stack<Character> q = new Stack<>();\n\n\t    for(char c : arr)\n\t        inStack.push(c);\n\n\t    for(char c : inStack) {\n\t        if(q.isEmpty())\n\t            q.push(c);\n\t        else {\n\t            char last = q.peek();\n\n\t            if(Math.abs(last-c) == 32) {\n\t                q.pop();\n\t            } else {\n\t                q.push(c);\n\t            }\n\t        }\n\t    }\n\n\t    System.out.println(\"Result BIS: \" + q.size());\n\t}\n\t\n\tpublic void puzzle1()\t{\n\t\t\n\t\tSystem.out.println(\"##### Puzzle 1 #####\");\n\t\tlong start = System.currentTimeMillis();\n\t\t\n\t\tint result = -1;\n\t\tString input = check(inputs.get(0));\n\t\t\n\t\tresult = input.length();\n\t\t\n\t\tlong end = System.currentTimeMillis();\n\t\t\n\t\tSystem.out.println(\"Execution : 0.00\" + (end-start) + \"ms\");\n\t\tSystem.out.println(\"Result: \" + result);\n\t}\n\n\tprivate String check(String input) {\n\t\tfor (int i = 0; i < input.length()-1; i++) {\n\t\t\t\n\t\t\tchar c1 = input.charAt(i);\n\t\t\tchar c2 = input.charAt(i+1);\n\t\t\tif (c1 != c2 && Character.toLowerCase(c1) == Character.toLowerCase(c2))\t{\n\t\t\t\tinput = input.substring(0, i) + input.substring(i+2);\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t\treturn input;\n\t}\n```\n\nIf you modify \\`util1\\` to take a lambda of \\`char->bool\\` (not sure the Java syntax), you don't need the \\`replaceAll\\` business.  If that lambda were called `exclude`, part1 is (python) `lambda c: False` and part2 is, for each letter, `lambda c: c == <lowercase> or c == <uppercase>`.\n\nand `ArrayDeque` is actually faster in most conditions.\n\nTIL, thank you for that. Always thought deque was a stack but had the extra capability of keeping a pointer to the bottom element.\n\nHappy to share. Sorry though I\u2019m not familiar with ruby, can you walk me through a little of what you did for part 2?\n\nYeah, speed-coding makes me do some questionable things at times. \n\nMake sure you don't have a newline at the end of your input - that's what got me for a bit. Assuming the inputs are always at least the same length it should be 50,000 bytes.", "id": "eb4fiod", "owner_tier": 0.5, "score": 0.2328767121917808}, {"content": "Ruby, reporting in.\n\nLeaderboard code was not nearly this clean, I copy/pasted the react code, and started out with actually just running it 100 times. That was good enough for part 1, but for part 2 I actually needed to make it run to completion. So I ate a minute penalty on part 2 for making a really far-off guess. This code is slightly less repetitive than what I submitted (I made `react` into a function) and uses the fact that `gsub` returns nil if no modifications were made.\n\n    def react(str)\n      loop {\n        break str if (?a..?z).all? { |x|\n          [\n            str.gsub!(x + x.upcase, ''),\n            str.gsub!(x.upcase + x, ''),\n          ].none?\n        }\n      }\n    end\n\n    input = (ARGV.empty? ? DATA : ARGF).read.chomp.freeze\n\n    puts (part1 = react(input.dup).freeze).size\n    puts (?a..?z).map { |tried_letter|\n      react(part1.tr(tried_letter + tried_letter.upcase, '')).size\n    }.min\n    \n    __END__\n    my input goes here\n\nIt ran on my input in about 1 second so I did not need to do anything more clever.\n\nEdit: Yeah okay, after reading others' solutions, I get it, a less wasteful way to do it would be to add letters left-to-right and therefore I know I only need to delete from the right end of the string. Let this be a lesson on there being a huge difference between what I write if I want to go as fast as possible versus what I might write if I actually have time to think about it.\n\nAs someone learning ruby for the first time, this is an excellent code snippet to study. Mind if I ask a few questions?\n\nWhat's going on with this line?\n>ARGV.empty? ? DATA : ARGF\n\nI get that there's a ternary operator here, and that you're asking if ARGV is empty, but are DATA and ARGF? Google says that DATA refers to stuff that's at the end of your program, but it doesn't look like anything's there. How does ARGF work? If you're supplying a text file as an argument (we only hit this if ARGV has something in it) why not just use ARGV[0]?\n\nWhat does \"?a\" mean in ruby? Firing up irb, it looks like it just converts that character a to a string (and can only do one character -- `?asdf` throws an error). Is there a name for this transformation?\n\nLast q: how does ruby know to execute all the code after the break statement and return str? Wouldn't loop just immediately exit when it sees \"break\"?\n\nSorry for the noob q's but this language is fascinating. \n\nI'm also solving in Ruby and I have to say that I absolutely love your solutions. They're all really smart and checking out your solution is as interesting as solving it on my own, because every day you seem to include something that I didn't even know existed in the language (like taking array slices with `[x, y]`, symbol arrays in the form of `%i()`, the safe navigation operator that you had in your refined solution for today, `Hash#to_proc`, being able to group statements in parentheses to use the modifier syntax). I really appreciate that you're publishing all your solutions so that others can learn from them. Even if I end up refactoring my solutions so that they end up looking a little bit too much like yours ;) \n\nHey there, don't hesitate to ask any more question if you have any!\n\n> but are DATA and ARGF? Google says that DATA refers to stuff that's at the end of your program, but it doesn't look like anything's there.\n\nThe fact that DATA is confusing is my fault entirely, of course. in the actual file on my computer there is an `__END__` and my input there. But I took that out before posting here because otherwise the post would become unnecessarily large.\n\nI've edited my post with the proper `__END__` and just put a placeholder for \"my input goes here\", so that would be how that works. Usually I leave ARGV empty.\n\n>  How does ARGF work? If you're supplying a text file as an argument (we only hit this if ARGV has something in it) why not just use ARGV[0]?\n\nI could, though note that the code would look slightly different because ARGV[0] would just be a string (a filename) which I can't call `read` on line I can with DATA and ARGF. I think it might be have to be something like `input = (ARGV.empty? ? DATA.read : File.read(ARGV[0])).chomp` and I preferred to have something that can just call `read` on in both cases, hence ARGF instead of ARGV[0]. Less repetition that way. Also note that ARGF enables reading from stdin really easily, if putting the filename `-` on ARGV.\n\ntherefore, I judged this DATA/ARGF combination to be the simplest way to allow for the various possible ways I might want to run the script:\n\n* Run it with no arguments. it should run on my input by default.\n* Run it with a filename on ARGV - it will run on that file\n* Run it with `-` on ARGV - it will run on stdin\n\n> What does \"?a\" mean in ruby? Firing up irb, it looks like it just converts that character a to a string (and can only do one character -- `?asdf` throws an error). Is there a name for this transformation?\n\nyou'll want to look at https://ruby-doc.org/core-2.3.0/doc/syntax/literals_rdoc.html and search for \"character literal\" . Note that it was only added to the docs in 2.3.0, but it looks like it was around for longer.  Of course reading later versions of the docs is fine too. You have of course already correctly figured out what it does.\n\n> Last q: how does ruby know to execute all the code after the break statement and return str? Wouldn't loop just immediately exit when it sees \"break\"?\n\nThat would be because of the `if` afterward. You may see this used in some pieces of code like `raise SomeError if something`. It would be \"unfortunate\" if that raised an error every time. Thus, it doesn't happen unless the condition is true. For more information you could read about \"modifier if\"\n\nThanks for writing in. Indeed one of my hopes is that I can show some interesting things that can be done in the language.\n\nOne of the things you mentioned stood out to me: the grouping with parentheses. I know you refer to the `(puts freq; break) if seen.include?(freq)` on day 1. There's also a related thing (since it also uses parentheses) which is doing an assignment in the middle of a larger expression such as `puts (part1 = react(input)).size` on day 5. I thought about it and I think these are different from most things I do in Advent of Code. Most things are things I would also do in larger projects where it's important to write maintainable code. But these two things actually stand out in this regard because these are pretty much just space-saving measures and in most other contexts I would write these out on separate lines. It may be a little too surprising otherwise, especially if other readers of the code are not watching for assignments in unexpected places like a `puts` line.\n\nJust some interesting thoughts when I consider how others might make use of my code.", "id": "eb4digq", "owner_tier": 0.1, "score": 0.10958904095890411}, {"content": "**Python** - using *functools.reduce*. Fun!\n\n    from functools import reduce\n\n    def trigger(x, y):\n        return False if not x else abs(ord(x[-1]) - ord(y)) == 32\n\n    def react(polymer):\n        return reduce((lambda x, y: x[:-1] if trigger(x, y) else x+y), polymer)\n\n    polymer = open('input.txt').read()\n    print(len(react(polymer)))\n    print(min([len(react(polymer.replace(chr(i), '').replace(chr(i-32), ''))) for i in range(ord('a'), ord('z') + 1)]))\n\nFirst off, beautiful.\n\nHere is the merge of our two codes, hope you gain something from it.\n\n    purge = lambda s: reduce(lambda x, y: x[:-1] if x and abs(ord(x[-1])-ord(y)) == 32 else x+y, s)\n    data = purge(open('../input/5.txt').read().strip())\n    \n    print len(data)\n    print min(len(purge(filter(lambda x: x.upper() != c, data))) for c in map(chr, range(65, 91)))    \n\ncheers!", "id": "eb5fy85", "owner_tier": 0.3, "score": 0.041095890273972605}, {"content": "[**APL**](https://github.com/jayfoad/aoc2018apl/blob/master/p5.dyalog) \\#47/29\n\nUsing regular expressions, the solution for part 1 boils down to `'Aa|Bb|...|aA|bB|...'\u2395R''\u2363\u2261`, i.e. keep replacing 'Aa' etc with '' until we reach a fixed point. An [alternative solution](https://github.com/jayfoad/aoc2018apl/blob/master/p5faster.dyalog) using Find (`\u2377`) instead runs a bit faster, but part 2 still takes a few seconds.\n\nUpdated [alternative solution](https://github.com/jayfoad/aoc2018apl/blob/master/p5faster.dyalog) still uses the \"fixed point operator\" `\u2363\u2261` but now does arithmetic on ASCII codepoints instead of string operations. Combined time for both parts is now about 0.02 seconds.\n\nsick! I got part 1 down to instant, part 2 basically ran part 1 26 times and took 3.2s (python)\n\nWould love to see this one unpacked - shorter *and* faster!\n\nSure. The algorithm is to remove pairs Aa etc and keep going until no more removals are possible. The clever bit is to notice that it's easy to remove many *non-overlapping* pairs in parallel, using array operations, which is how you get good performance from an interpreted array language like APL. The way we guarantee the pairs won't overlap is to first remove all occurrences of any of the pairs Aa Bb ... Zz, which can't possibly overlap, in one parallel operation; and then do the same for the other pairs aA bB ... zZ in a second parallel operation. (Note that Aa *can* overlap with aA if the input contains something like ...AaA..., and the risk is that we would end up removing those three characters, which would not be following the rules of the puzzle.)\n\n`p\u2190\u2395UCS\u2283\u2283\u2395NGET'p5.txt'1` gets the ASCII values (`\u2395UCS`) of the single line of input, sans line ending.\n\n`f\u2190{\u2375/\u2368{(\u2375,0)\u23710,\u2375}\u237a=2-/\u2375}` removes all lower-upper or upper-lower pairs from \u2375, depending on the value of \u237a. `2-/\u2375` is the pairwise difference between successive items of \u2375. `\u237a=2-/\u2375` is a mask of where this difference is equal to \u237a, which will be either +32 or -32 (the ASCII difference between 'A' and 'a'). `\u2371` is NOR, so `{(\u2375,0)\u23710,\u2375}` extends the mask with an extra 0 at the beginning, and at the end, and ORs the two together, to select *both* items of each pair, and then NOTs it to select all the items *not* part of a pair. `\u2375/\u2368` uses that to compress \u2375, i.e. keep only the selected items.\n\n`g\u2190(32\u2218f \u00af32\u2218f)\u2363\u2261` applies f twice in succession (for lower-upper *and* upper-lower pairs), and repeats that process to a fixed point. `\u2218` is used to bind (*curry*) a left argument with f, so `32\u2218f` and `\u00af32\u2218f` are both functions that take a single argument \u2375. Putting those two functions together in parentheses forms a *train*, a form of function composition that will just apply first one of the functions and then the other. `f\u2363\u2261` applies f repeatedly until two successive results Match (`\u2261`).\n\n`\u2262q\u2190g p` applies this algorithm to the puzzle input p, remembers the result as q for use in part 2, and uses Tally (`\u2262`) to return its length.\n\n`\u230a/{\u2262g q~\u2375,32+\u2375}\u00a8\u2395UCS \u2395A` applies the anonymous function {...} once for each of the ASCII codes for the upper case alphabet (`\u2395A`). The anonymous function removes that character \u2375 and its lower case counterpart \u2375+32 from q, and then applies the algorithm g to that and returns its length. `\u230a/` gives the minimum of all those results.\n\n&#x200B;", "id": "eb4efxr", "owner_tier": 0.1, "score": 0.09589041082191781}, {"content": "[Card] Staaaaars\n\nRust, first Rust I'm proud of. Never copy my input data.\n    \n    static INPUT: &str = \"data/day05\";\n    \n    fn react<'a>(input: impl Iterator<Item = &'a u8>) -> usize {\n        let mut v = Vec::new();\n        for &c in input {\n            match v.last() {\n                None => v.push(c),\n                Some(&d) => if d.to_ascii_lowercase() == c.to_ascii_lowercase() && d != c {\n                    v.pop();\n                } else {\n                    v.push(c);\n                }\n            }\n        }\n        v.len()\n    }\n    \n    fn main() {\n        let input: Vec<u8> = aoc::file::first_line(INPUT).into();\n        println!(\"  1: {}\", react(input.iter()));\n        let mut min = std::usize::MAX;\n        for i in 0u8..=26 {\n            let v = input.iter().filter(|&&c| c != b'a'+i && c != b'A'+i);\n            min = usize::min(react(v), min);\n        }\n        println!(\"  2: {}\", min);\n    }\n    \n\nI quite like this one. I was looping through the string slices and being forced to re-allocate every split. This is significantly faster and more efficient.\n\nThis is very clever. Nicely done!\n\n I am using this years AoC to learn Rust and it is wonderful to go through and see how other people tackled the problem. Such a good way to learn.\n\nThanks!\n\nCame here to post exactly the same thought: rust was really nice for this.\n\nTook roughly the same approach and ended up learning about the right way to accept iterators for input to let me reuse the reducer for both parts:\n\n    fn collapse_polymer<'_a, I>(vals: I) -> usize\n    where I: IntoIterator<Item = &'_a u8> {\n     let mut stack: Vec<u8> = Vec::new();\n     for c in vals.into_iter() {\n     let top = stack.pop();\n     match top {\n                Some(sc) if opposite(*c, sc) => {},\n                Some(sc) => {stack.push(sc); stack.push(*c);},        \n                None => {stack.push(*c);},\n            }\n        };\n        stack.len()\n    }\n    \n    pub fn part1_02(d: &str) -> i64{\n     collapse_polymer(d.trim().as_bytes()) as i64\n    }\n    \n    fn collapse_filtered<'_a, I>(vals: I, c: u8) -> usize \n    where I: IntoIterator<Item = &'_a u8> {\n     collapse_polymer(vals.into_iter().filter(|&cc| !(c==*cc || opposite(c, *cc))))\n    }\n    \n    pub fn part2_01(d: &str) -> i64 {\n        ('a' as u8 ..'z' as u8)\n        .map(|c| collapse_filtered(d.trim().as_bytes(), c))\n        .min().unwrap() as i64\n    }\n\n(the `i64` stuff is just because my wrapper expects this type for numbers)", "id": "eb4fkwu", "owner_tier": 0.1, "score": 0.0821917806849315}, {"content": "This space intentionally left blank.\n\n> [CARD]\n> \n> On the fifth day of AoC / My true love sent to me / Five golden HDMI cables\n\nI see your true love is a fan of Monster-branded cables.  >_>\n\nI got pretty much the same. This challenge was so easy and well fit for Haskell.\n\n    react :: [Char] -> [Char] -> [Char]\n    react stack []      = stack\n    react [] (c:cs)     = react [c] cs\n    react (x:xs) (c:cs)\n      | toLower x == toLower c && x /= c = react xs cs\n      | otherwise = react (c:x:xs) cs\n    \n    part1 :: Input -> Int\n    part1 input = length $ react [] input\n    \n    part2 :: Input -> Int\n    part2 input = minimum $ map (\\c -> length $ react \"\" $ filter ((/=c) . toLower) input) ['a'..'z']", "id": "eb4drzq", "owner_tier": 0.3, "score": 0.027397260136986304}, {"content": "[Card] FIVE GOLDEN STARS OK ONLY 2\n\nJava - easy one. You can test for lowercase/uppercase being the same letter using XOR 32.\n\n    package Advent2018;\n    \n    import util.AdventOfCode;\n    \n    import java.util.List;\n    \n    public class Day5 extends AdventOfCode {\n    \n        public Day5(List<String> input) {\n            super(input);\n        }\n    \n        private int remove(StringBuilder in) {\n            boolean removed = true;\n    \n            while (removed) {\n                for (int i = 0; i < in.length() - 1; i++) {\n                    if ( (in.charAt(i) ^ in.charAt(i + 1)) == 32) {\n                        in.delete(i, i + 2);\n                        removed = true;\n                        break;\n                    }\n                    removed = false;\n                }\n            }\n            return in.length();\n        }\n    \n        @Override\n        public Object part1() {\n            StringBuilder chain = new StringBuilder(input.get(0));\n            return remove(chain);\n        }\n    \n        @Override\n        public Object part2() {\n            int min = Integer.MAX_VALUE;\n    \n            String[] patterns = new String[26];\n            for (int i = 0; i < 26; i++) {\n                patterns[i] = \"[\" + (Character.toString((char)(i + 'a'))) +\n                        (Character.toString((char)(i + 'A'))) + \"]\";\n                //System.out.println(patterns[i]);\n            }\n    \n            for (int i = 0; i < 26; i++) {\n                String chain = input.get(0);\n                chain = chain.replaceAll(patterns[i], \"\");\n                int result = remove(new StringBuilder(chain));\n                System.out.println(result);\n                if (result < min) min = result;\n            }\n            return min;\n        }\n    \n        @Override\n        public void parse() {\n    \n        }\n    \n    }\n\n> You can test for lowercase/uppercase being the same letter using XOR 32.\n\nHuh, that's a neat way to check for that. Should've probably thought of it. Good to know for future challenges... Good job!\n\nNice!  My first version of part 1 took 85 minutes to complete.  I knew I couldn't use that for part 2, so I wanted tot see how other people solved this.  As I thought (hoped!), it was all in the comparison.\n\n&#x200B;\n\nif (unit.equalsIgnoreCase(nextUnit) && ! unit.equals(nextUnit)) { // same time, opposite polarity\n\nshorterPolymer = polymer.substring(0,i) + polymer.substring(i+2);\n\n} // end if\n\nNow it's sub-second.\n\nQuestion: Why do you break when you find a hit?  Don't all subsequent hits need to be eventually removed?\n\n&#x200B;\n\nThere's a lot of cool bit hacks for ASCII! https://www.techiedelight.com/bit-hacks-part-4-playing-letters-english-alphabet/", "id": "eb4eepd", "owner_tier": 0.9, "score": 0.1232876710958904}, {"content": "Since there is no Common Lisp yet\n\n    (defun destroy? (a b)\n      (and a b (char/= a b) (char-equal a b)))\n    \n    (defun reduce-polymer (polymer)\n      (let ((stack (list (elt polymer 0))))\n        (loop :for u :across (subseq polymer 1)\n              :do\n                 (push u stack)\n                 (if (destroy? (car stack) (cadr stack))\n                     (progn\n                       (pop stack)\n                       (pop stack))))\n        stack))\n    \n    (length (reduce-polymer *polymer*)) ;; => 11476\n    \n    (defun reduce-polymer2 (polymer1 unit-to-skip)\n      (let ((polymer (remove-if (lambda (c) (char-equal c unit-to-skip)) polymer1)))\n        (reduce-polymer polymer)))\n    \n    (loop :for i :from (char-code #\\a) :to (char-code #\\z)\n          :minimizing (length (reduce-polymer2 *polymer* (code-char i)))) ;; => 5446\n    \n\nVery similar to what I did in Clojure\n\n\nNice!\n\n[My Common Lisp solution](https://gitlab.com/asciiphil/advent-of-code/blob/master/2018/05.lisp) used the \"reduce until you can't reduce any more\" approach.  Your stack is much nicer.\n\nThat stack approach is really clever.\n\n> `(remove-if (lambda (c) (char-equal c unit-to-skip)) polymer1)`\n\nThis could be `(remove unit-to-skip polymer1 :key #'char-equal)`\n\nI did the same, though I rewrote it (epiphany when I woke up and showered) to use a stack. It took my Part 2 solution from ~3 seconds down to .06 seconds.\n\nIn college that solution would've been obvious. I've been in the corporate world too long. Elegant, simple solutions are not what we use.\n\nSo I went and redid my `react` function with (more or less) a stack^(0).  Similar to your experience, my runtime dropped from 1.7 seconds to 0.02 seconds.\n\n    (defun react (polymer)\n      (labels ((react-r (head tail)\n                 (cond\n                   ((endp tail)\n                    (reverse head))\n                   ((endp head)\n                    (react-r (cons (car tail) head) (cdr tail)))\n                   ((reactive-pair-p (car head) (car tail))\n                    (react-r (cdr head) (cdr tail)))\n                   (t\n                    (react-r (cons (car tail) head) (cdr tail))))))\n        (coerce (react-r nil (coerce polymer 'list))\n                'string)))\n\n\n^(0)I think of it as more of a zipper, but the principle is the same.", "id": "eb4gqny", "owner_tier": 0.1, "score": 0.10958904095890411}, {"content": "BASH Time :)\n\nNo sed, no grep, just pure bash!\n\nPuzzle #1 (6 seconds)\n\n    #!/bin/bash\n    \n    in_file=input\n    \n    polymer=$(cat $in_file)\n    \n    # 1000 iteration is enough :)\n    for i in {1..1000}; do\n        for x in {a..z}; do\n            polymer=${polymer//$x${x^^}}\n            polymer=${polymer//${x^^}$x}\n        done\n    done\n    \n    echo ${#polymer}\n\nPuzzle #2 (330 seconds)\n\n    #!/bin/bash\n    \n    in_file=input\n    polymer=$(cat $in_file)\n    min_size=${#polymer}\n    \n    for ch in  {a..z}; do\n        test_polymer=${polymer//$ch}\n        test_polymer=${test_polymer//${ch^^}}\n    \n        # 2000 iteration is enough :)\n        for i in {1..2000}; do\n            for x in {a..z}; do\n                test_polymer=${test_polymer//$x${x^^}}\n                test_polymer=${test_polymer//${x^^}$x}\n            done\n        done\n    \n        if [ ${#test_polymer} -lt $min_size ]; then\n            min_size=${#test_polymer}\n        fi\n    done\n    \n    echo $min_size\n\n&#x200B;", "id": "eb4i010", "owner_tier": 0.1, "score": -1.3698630053733275e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/a3912m/2018_day_5_solutions/", "question": {"content": "#--- Day 5: Alchemical Reduction ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Advent of Code: The Party Game!\n\n[Click here for rules](/r/adventofcode/w/aoctpg)\n\nPlease prefix your card submission with something like [Card] to make scanning the megathread easier.  THANK YOU!\n\n#### [Card prompt: Day 5](https://i.imgur.com/Vszj61Cm.jpg)\n\nTranscript:\n> On the fifth day of AoC / My true love sent to me / Five golden ___\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n###*edit:* Leaderboard capped, thread unlocked at 0:10:20!", "id": "a3912m", "title": "-\ud83c\udf84- 2018 Day 5 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "DID SOMEBODY SAY.. EXCEL?! Day 2 [Part 1 & 2]\n\n     = max, = min\n\nhttps://github.com/thatlegoguy/AoC2017/blob/master/Day%202%20Corruption%20Checksum.xlsx\n\nI feel like this one was designed for you :)\n\nI solved part 1 in Excel too, didn't feel savage enough to divide them all manually for part 2, so coded something for that\n\nMy brain had the first part done before I even pasted the input into the sheet =D\n\nSame but how do you solve the second part of it? Afaik you need a three-dimensional sheet to do it in excel. (or copy-paste a lot of formulas)\n\nMy repo shows the savage manual way, but technically I could have made one block of formulas, in which the formula was n1/n2 for each value, where n1 is an input field and n2 is that corresponding value on the chart, and just imputed column 1-17 each time into the input section, and recorded which values didn\u2019t have decimals for each input dump \n\nThat's what I did, but for each row you would have a 2D grid of possibilities, so you get a 3D table in the end, which cannot fit in excel.\n\nSAVAGE. That was awesome, thanks for the laugh.\n\nOr you could have used index() and modulus!\n\nhttps://www.reddit.com/r/adventofcode/comments/7h0zf2/calculate_the_spreadsheets_checksum_they_said/dqnyss1/\n\nI too used black magic, but not that dark of dark magic. Please explain the code?", "id": "dqnalfd", "owner_tier": 0.3, "score": 0.9999999998}, {"content": "    import itertools\n\n    def digits(string):\n        return [int(n) for n in string.split()]\n\n    with open('p02.txt') as fp:\n        rows = [digits(line) for line in fp.read().strip().splitlines()]\n\n    print(sum(b-a for a, *_, b in map(sorted, rows)))\n    print(sum(b//a for row in rows for a, b in itertools.combinations(sorted(row), 2) if b%a==0))\n\n\nAw, man. TIL `itertools.combinations'.\n\nTIL *_\nThanks!\n\nAnd nifty combo of combinations and sorted...\n\n:) Just posted the exact same solution for answer 2 because I only saw the Python 2 solution when I quickly skimmed.\n\nNice trick with the unpacking in answer 1! \n\nyou can also generate combinations without `itertools` using pure list comprehensions\n\nThe last line can be rewritten like this:\n    \n    print(sum(b // a for row in rows for a in row for b in row if b > a and b % a == 0))\n\nWhat does that part do?\n\nif I wasn't using itertools I'd do\n\n`(a, b) for i, a in enumerate(row) for b in row[i+1:]` I suppose\n\nwhich allows for duplicates (not an issue in this problem)", "id": "dqn9g7j", "owner_tier": 0.7, "score": 0.7799999998}, {"content": "Dusting off the Perl golf bag\n\n    # part 1\n    perl -ane '@o=sort{$b<=>$a}@F;$s+=$o[0]-pop@o;END{print$s}' < in.txt\n    \n    # part 2\n    perl -ane 'for$l(@F){$s+=$l%$_?0:$l/$_ for grep!/$l/,@F}END{print$s}' < in.txt\n\nHow long was the original before you whittled it down? I've got barbaric multi-line perl scripts and this shames me.", "id": "dqnaxuu", "owner_tier": 0.1, "score": 0.1999999998}, {"content": "Mathematica solution; one line for each part and one for the import.  #10 for part 1...and #456 for part 2.\n\n**Import**:\n\n    input=Import[FileNameJoin[{NotebookDirectory[],\"Day2Input.txt\"}],\"Table\"][[;;-2]]\n\n**Part 1**:\n        \n    Total[Max[#]-Min[#]&/@input]\n\n**Part 2**:\n\n    Total@Flatten@Table[Select[Flatten[input[[i]]/#&/@input[[i]]],IntegerQ[#]&&#!=1&],{i,16}]\n\nLikewise for Matlab:  \n\n    load input.txt\n    checksum = @(inp) sum(max(inp') - min(inp'));\n    checksum(input);\n\nGotta love that sweet, sweet taste of functional mapping.", "id": "dqn9gd9", "owner_tier": 0.5, "score": 0.0999999998}, {"content": "2 iterators 1 loop\n\n    #! /usr/bin/env perl\n    \n    use strict;\n    use warnings;\n    \n    my ($part1, $part2) = (0, 0);\n    \n    while (<>) {\n    \tmy @a = sort { $a <=> $b } split;\n    \n    \t$part1 += $a[$#a] - $a[0];\n    \n    \tmy ($i, $j, $n, $trial_multiple) = (-1, scalar @a, 0, 0);\n    \tfor (;;) {\n    \t\tif ($i == $#a) {\n    \t\t\tdie \"no multiple found on line $.\\n\";\n    \t\t} elsif ($j == @a) {\n    \t\t\t$j = ++$i + 1;\n    \t\t\t$n = $trial_multiple = 0;\n    \t\t} elsif ($trial_multiple < $a[$j]) {\n    \t\t\t$n++;\n    \t\t\t$trial_multiple += $a[$i];\n    \t\t} elsif ($trial_multiple > $a[$j]) {\n    \t\t\t$j++;\n    \t\t} else {\n    \t\t\t$part2 += $n;\n    \t\t\tlast;\n    \t\t}\n    \t}\n    }\n    \n    print <<\"\";\n    Part 1: $part1\n    Part 2: $part2\n\n\nStill trying to wrap my head around this... I'll let you know if I give up...", "id": "dqnbo31", "owner_tier": 0.3, "score": 0.0799999998}, {"content": "Is there a way to find the answer for each line in better than O(n^2 ) time?\n\nFor part 1, you can sort the elements first.  That would make it O(n log(n)).\n\nFor part 2, nothing immediately comes to mind.\n\nFor part 1 you just need min and max and both are O(n)\n\nI think you can even get a lower constant for the O(n) than the 2n-2 comparisons when searching for min and max separately if you search for them simultaneously, it was something like 3/2*n or so. Can't remember exactly, but you can sort of exploit that the max will never increase when the min just decreased while scanning the input, etc. Of course, it remains in O(n) still. \n\nA peculiar little optimization when you ever need both min and max at the same time. \n\nI did some visualisations of my iterations, and the best idea I could think of was \n\n        if(lines[line][i] > max){\n          max = lines[line][i];\n          maxId = i;\n        }else if(lines[line][i] < min){\n          min = lines[line][i];\n          minId = i;\n        }\n        //minId and maxId are for highlighting number\n\nEdit:\n\nI guess that makes an (iteration * (2 ifs + 1 assignment)) in worst case\n\nI tried that too, but as you said it's not optimal. I think the 3/2n solution involves iterating over the list in pairs of 2 elements and then given the current min, max and 2 items x1, x2 you can deduce the new min and max in just 3 comparisons from those 4 elements, so that gives the whole 3/2 thing.", "id": "dqndamd", "owner_tier": 0.7, "score": 0.35999999979999997}, {"content": "**Haskell**\n\n    main = do\n      s <- parse . lines <$> readFile \"input.txt\"\n      print $ sum $ map part1 s\n      print $ sum $ map part2 s\n    \n    parse :: [String] -> [[Int]]\n    parse = map (map read . words)\n    \n    part1, part2 :: [Int] -> Int\n    part1 xs = maximum xs - minimum xs\n    part2 xs = head [ a `div` b | a <- xs, b <- xs, a `mod` b == 0 && a /= b]\n\nForgot the `a /= b` part on the second question and that cost me a few places.", "id": "dqn9kil", "owner_tier": 0.1, "score": 0.0199999998}, {"content": "Hit diggity dang, I got on the leaderboard! (I'm never awake at midnight EST, except for today, apparently). Spent the first five or so minutes struggling with my setup because I wasn't prepared to do AoC now.\n\nIt's the start of \"haaaaave you met `itertools`?\"\n\n\timport string\n\timport itertools\n\t\n\tlines = []\n\twith open('02.txt') as fp:\n\t\tfor line in fp:\n\t\t\tlines.append(map(int, string.split(line.strip(), '\\t')))\n\t\n\tpart1 = 0\n\tpart2 = 0\n\tfor line in lines:\n\t\tpart1 += max(line) - min(line)\n\t\n\t\tfor i in itertools.combinations(line, 2):\n\t\t\tif max(i) % min(i) == 0:\n\t\t\t\tpart2 += max(i) / min(i)\n\t\t\t\tbreak\n\t\n\tprint 'Part 1: %s' % part1\n\tprint 'Part 2: %s' % part2\n\n\nUpdate: I don't think I actually got on the leaderboard. Which makes sense. I think I was in the first *thousand*, which, still: I'll take it!\n\nGetting onto the leaderboard is tough! I think you only have around 4 minutes for this one before all the spots are taken.\n\nEven 4 mins is too much\n\n>       -------Part 1--------\n\n>Day       Time  Rank  Score\n  \n>2   00:03:49   243      0", "id": "dqn9whw", "owner_tier": 0.5, "score": 0.3199999998}, {"content": "F#\n\n    let lines = [for x in System.IO.File.ReadLines(\"input\") -> x.Split() |> Array.map int]\n    printf \"%A\\n%A\\n\"\n    <| List.sum [for xs in lines -> (Array.max xs) - (Array.min xs)]\n    <| List.sum [for xs in lines do for x in xs do for y in xs do if x <> y && x % y = 0 then yield x/y]\n\nF#\n\nThat is incredibly elegant, kudos. I went with more listy operations\n\n\n    open System.Runtime.InteropServices\n    let input = [|\"5 9 2 8\";\n    \"9 4 7 3\";\n    \"3 8 6 5\"|]\n    \n    // Day 2 1\n    input\n        |> Array.map (fun (str: string) -> \n            str.Split([| ' ' |])\n                |> Array.map int\n                |> Array.fold (fun (max, min) item ->\n                    match (max, min) with\n                        | (None, None) -> (Some(item), Some(item))\n                        | (Some(x), Some(n)) -> \n                            match item with \n                                | i when i >= x -> (Some(i), min)\n                                | i when i <= n -> (max, Some(i))\n                                | _ -> (max, min)\n                        | _ -> failwith \"cant have one some and one none\"                    \n                ) (None, None)\n                |> (fun (max, min) -> max.Value - min.Value)\n        )\n        |> Array.sum\n    \n    // day 2 2\n    input\n        |> Array.map (fun (str: string) -> \n            let row = \n                str.Split([| ' ' |]) \n                |> Array.map int\n    \n            row\n            |> Array.map (fun x -> \n                row \n                |> Array.map (fun d -> \n                    match x with\n                        | x when x = d -> 0\n                        | x when x % d = 0 -> x / d\n                        | _ -> 0\n                )  \n                |> Array.sum\n            )\n            |> Array.sum\n        )\n        |> Array.sum\n\n\n\nNice!  Pushed my understanding of F#.  I was surprised to see there wasn't a combinations function already in F#.  Your answer could have been cleaner if that already existed.  Probably a good standard function to have for AoC.  I believe:\n\n    <| List.sum [for xs in lines do for (x,y) in (combinations xs) if x % y = 0 then yield x/y]\n\nedit: permutations is what you'd want not combinations\n\nThat is awesomely compact, although I find it really hard to read being new to F#.\n\nHere's my much more verbose solution:\n\n\n    let readLines filePath = System.IO.File.ReadLines(filePath)\n    let lines = readLines \"2017\\\\02\\\\input.txt\"\n    let parseLine (s:string) = \n        s.Split() \n        |> Array.filter (fun x -> x.Length > 0)\n        |> Array.map int\n\n    let parsed = lines |> Seq.map parseLine\n\n    let greatestDifferece (items:int []) = (Array.max items) - (Array.min items)\n\n    let evenDivide (items:int []) = \n        let result = \n            items\n            |> Array.collect (fun i -> items \n                                    |> Array.map (fun x -> (i, x)) \n                                    |> Array.filter (fun (x,y) -> x<>y))\n            |> Array.tryPick (fun (i,j) -> if i % j = 0 then Some (i / j) else None)\n\n        match result with\n        | Some i -> i\n        | _ -> 0\n\n    let result1 = parsed |> Seq.sumBy(greatestDifferece)\n    let result2 = parsed |> Seq.sumBy(evenDivide)\n\n\n\nF#\nI did yesterdays challenge in a bit too un-functional way so I tried to do it a bit better today ( ping /u/scrooch ):\n    \n    // Input\n    let toInt (s : string[]) : int[] = Array.map (fun e -> int e) s\n    let input = System.IO.File.ReadAllLines \"input-day2.txt\" \n                |> Array.map (fun x -> x.Split [|'\\t'|])\n                |> Array.map toInt\n    \n    // Part 1\n    let bigDiff (arr : int[]) : int = \n        (Array.max arr) - (Array.min arr)\n    \n    printfn \"part 1: %A\" (Array.fold (fun acc elem -> acc + bigDiff elem) 0 input)\n    \n    // Part 2\n    let isDiv (x:int) (arr:int[]) : bool = \n        Array.exists (fun i -> x%i = 0 && x <> i|| i%x = 0 && x <> i) arr\n    let ifDiv i arr = \n        if (isDiv i arr) then i else 0\n    let divs (arr : int[]) : int[] = \n        Array.map (fun e -> ifDiv e arr) arr |> Array.filter (fun e -> e <> 0)\n    let divbws (arr:int[]):int = \n        if arr.[0] > arr.[1] then arr.[0]/arr.[1] else arr.[1]/arr.[0]\n        \n    printfn \"part 2: %A\" (Array.fold (fun acc elem -> acc + divbws (divs elem)) 0 input)\n\nF#\n\n    // Permutation function from SO\n    let rotate lst =\n        List.tail lst @ [List.head lst]\n    \n    let getRotations lst =\n        let rec getAll lst i = if i = 0 then [] else lst :: (getAll (rotate lst) (i - 1))\n        getAll lst (List.length lst)\n    \n    let rec getPerms n lst = \n        match n, lst with\n        | 0, _ -> seq [[]]\n        | _, [] -> seq []\n        | k, _ -> lst |> getRotations |> Seq.collect (fun r -> Seq.map ((@) [List.head r]) (getPerms (k - 1) (List.tail r)))\n    \n    // My solution\n    let input =\n        System.IO.File.ReadAllLines \"Day2/input.txt\"\n        |> Array.map ((fun (x:string) -> x.Split [|'\\t'|]) >> (Array.map int))\n    \n    input\n    |> Array.sumBy (fun x -> Array.max x - Array.min x)\n    |> printfn \"Part 1: %A\"\n    \n    let findDiv = Seq.sumBy (fun (l: int list) -> if l.[0] % l.[1] = 0 then l.[0] / l.[1] else 0)\n    \n    input\n    |> Array.sumBy (List.ofArray >> getPerms 2 >> findDiv)\n    |> printfn \"Part 2: %A\"\n\nDid some stuff to minimize the complexity and be as linear as possible:\n\n    let s = \n        input.Split('\\n') |> Array.map(fun n -> \n                                 n.Trim().Split('\\t')\n                                 |> Array.map int\n                                 |> Array.toList)\n    \n    let p1 = \n        s\n        |> Array.map(fun x -> \n               x\n               |> List.fold (fun (mx, mn) e -> max mx e, min mn e) \n                      (System.Int32.MinValue, System.Int32.MaxValue)\n               ||> (-))\n        |> Array.sum\n    \n    let p2 = \n        s\n        |> Array.map(fun x -> \n               x\n               |> Seq.unfold(function \n                      | a :: b -> Some((a, b), b)\n                      | _ -> None)\n               |> Seq.pick(fun (a, m) -> \n                      m |> List.tryPick(fun b -> \n                               match a, b with\n                               | a, b | b, a when a % b = 0 -> Some(a / b)\n                               | _ -> None)))\n        |> Array.sum\n\nAlternatively you could have used sort, a lot of you first solution is a weird way to get the min and max:\n\n    let solve1 ss =\n        Array.map Array.sort ss \n        |> Array.map (fun (x : int[]) -> (Array.last x) - x.[0]) \n        |> Array.sum\n\nCool, man!  I work at a well known software company and there are many people there that can't write functionally, it can be tough for some people.  I think there is room to clean up what you have, but good work.  Here is my solution for 2 if you want another comparison:\n\n    let combinations array =\n        let length = Array.length array\n        let mutable answer = []\n        for i in 0 .. length-1 do\n            for j in i+1 .. length-1  do\n                answer <- [array.[i]; array.[j]] :: answer\n        answer\n\n    let solve2 (ss : int[][]) = \n        Array.map combinations ss\n        |> Array.map (List.map List.sort) \n        |> Array.map (List.find (fun x -> (x.[1] % x.[0]) = 0)) \n        |> Array.map (fun x -> x.[1] / x.[0])\n        |> Array.sum\n\n\n", "id": "dqnbe0f", "owner_tier": 0.3, "score": 0.3799999998}, {"content": "**Perl 6**\n\nPart1:\n\n    say [+] \"input\".IO.lines>>.comb(/\\d+/)>>.Int.map: { given $_.list { .max - .min } }\n\nPart2:\n\n    say [+] gather \"input\".IO.lines>>.comb(/\\d+/)>>.Int.map: { for .sort.combinations(2) { if .[1] %% .[0] { take .[1] div .[0]; last }}}\n\nNice use of gather/take!\n\nGood use of given! I was trying to figure out a way to topicize the list and given completely slipped my mind.\n\nYour reduce metaoperators were nicer!  I also forgot that grep is lazy, so yours is semantically equivalent to my gather/take and for/last combo whilst being more compact as well!", "id": "dqnfnxw", "owner_tier": 0.1, "score": 0.1999999998}, {"content": "**Python 3**\n\n    import io, itertools \n    with io.StringIO(s) as f:\n        lines = [[int(n) for n in l.split()] for l in f]\n\n    ans1 = sum(max(l)-min(l) for l in lines)\n\n    ans2 = sum(b//a for l in lines for a,b in itertools.combinations(sorted(l),2) if b%a==0)\n", "id": "dqna3zn", "owner_tier": 0.1, "score": 0.0199999998}, {"content": "Has anyone done a bash solution yet?\n\n    #!/bin/bash\n\n    PARTONE=0\n    PARTTWO=0\n\n    while read -r line; do\n      IFS=' ' read -r -a array <<< \"$(echo \"${line}\" | tr '\\t' '\\n' | sort -n | paste -s -d ' ' -)\"\n      LEN=${#array[*]}\n      MIN=\"${array[0]}\"\n      MAX=\"${array[$LEN-1]}\"\n      ((PARTONE += (MAX-MIN)))\n      MED=0 # This variable will let us break out of the loops when a match is found\n      for m in `seq 0  $((LEN-2))`; do\n        for n in `seq $((m+1))  $((LEN-1))`; do\n          M=${array[$m]}\n          N=${array[$n]}\n          if [ \"$(expr $N % $M)\" = \"0\" ]; then\n            ((PARTTWO += (N / M)))\n            MED=1\n            break\n          fi\n        done\n        if [ $MED -eq 1 ]; then break; fi\n      done\n    done < your_puzzle_input\n\n    echo \"Part 1 Solution: $PARTONE\"\n    echo \"Part 2 Solution: $PARTTWO\"\n\n\nUhhh, very nice! My [solution](https://www.reddit.com/r/adventofcode/comments/7h0rnm/2017_day_2_solutions/dqswqxo/) :)", "id": "dqncebo", "owner_tier": 0.5, "score": 0.0199999998}, {"content": "My Perl 6 solution.  Couldn't figure out a good way to avoid using map. Probably need sleep.\n\n    use v6;\n\n    my @rows = $*PROGRAM.parent.child('input').IO.lines;\n\n    # Part 1\n    say [+] @rows.map({\n        my @cols = .split(\"\\t\").>>.Int;\n        @cols.max - @cols.min;\n    });\n\n    # Part 2\n    say [+] @rows.map({\n      .split(\"\\t\").>>.Int.combinations(2).grep({ max(@_) % min(@_) == 0 }).flat.reduce({ @_.max div @_.min });\n    });\n", "id": "dqncxak", "owner_tier": 0.1, "score": -1.9999999878450582e-10}, {"content": "**Perl 6** version for part a:\n\n    sub MAIN(IO() $inputfile where *.f)\n    {\n        say $inputfile.lines.map({ [R-] $_.words.map(+*).minmax.minmax }).sum;\n    }\n\nWhy twice minmax?  minmax on a list returns a range min..max.  minmax on that range returns two values, min and max.\n\nPart b:\n\n    sub evenly-divisible-quotient(@nums)\n    {\n        for ^@nums -> $i {\n            for ^$i -> $j {\n                return @nums[$i] div @nums[$j] if @nums[$i] %% @nums[$j];\n                return @nums[$j] div @nums[$i] if @nums[$j] %% @nums[$i];\n            }\n        }\n    }\n\n    sub MAIN(IO() $inputfile where *.f)\n    {\n        say $inputfile.lines.map({ $_.words.map(+*).&evenly-divisible-quotient }).sum;\n    }\n\n\nAnd here's a one-liner version of part b:\n\n    sub MAIN(IO() $inputfile where *.f)\n    {\n        say $inputfile.lines.map({ [div] $_.words.map(+*).sort.reverse.combinations(2).grep({ [%%] $_ })[0]}).sum;\n    }\n\n\nNice use of [R-]. Also nice to know about minmax, that could come in use.\n\nIt seems like all of us using Perl 6 have not been able to figure out a way to avoid using map with a code block. There has to be a way, but it would probably be way convoluted.\n\nI really love seeing the different approaches in Perl 6.\n\nNice use of minmax!  I stumbled upon that when searching the docs but I didn't realize it could be called twice to get what we needed.\n\nI didn't use map (by name):\n\nhttps://gist.github.com/bbarry/15f55d2ef879b2e853af3a76f37faa99#file-day2-pl6\n\nTotally over-engineered `grammar` solution.", "id": "dqnizty", "owner_tier": 0.1, "score": 0.23999999979999997}, {"content": "Erlang, because of course.\n\nMost of the code was input handling; the meat is this:\n\n    cksum(_, _, eof, Sum) ->\n        Sum;\n    cksum(NextLineFun, CkSumFun, List, Sum) ->\n        cksum(NextLineFun, CkSumFun, NextLineFun(), Sum + CkSumFun(List)).\n    \n    find_greatest_diff(Ints) ->\n        lists:max(Ints) - lists:min(Ints).\n    \n    find_divisible([H|T]) ->\n        case scan_tail(H, T) of\n            nope ->\n                find_divisible(T);\n            Val ->\n                Val\n        end.\n    \n    scan_tail(_V, []) ->\n        nope;\n    scan_tail(V1, [V2|_T]) when V2 rem V1 == 0 ->\n        V2 div V1;\n    scan_tail(V1, [V2|_T]) when V1 rem V2 == 0 ->\n        V1 div V2;\n    scan_tail(V1, [_V2|T]) ->\n        scan_tail(V1, T).\n\n`CkSumFun` is either `fun find_greatest_diff/1` or `fun find_divisible/1`. `NextLineFun` is a pipeline that gives me `eof` or a list of integers.\n\nLol I forgot about lists:max and lists:min for first part.\nYour solution for second part is much better than yours, here is mine ( I had list of strings ) :\n\n    secondTask([], Acc) ->\n\t    Acc;\n\n    secondTask([First | Rest], Acc) ->\n\t    [FirstNumber | RestNumbers] = string:split(First, \"\\t\", all),\n\t    {IntegerFirstNumber, _} = string:to_integer(FirstNumber),\n\t    Result = findDivision(IntegerFirstNumber, RestNumbers, RestNumbers),\n\t    secondTask(Rest, Acc + Result).\n\t\n    findDivision(_, [], [Second | Rest]) ->\n\t    {SecondNumber, _} = string:to_integer(Second),\n\t    findDivision(SecondNumber, Rest, Rest);\n\n    findDivision(FirstNumber, [Second | Rest], AllExceptFirst) ->\n\t    {SecondNumber, _} = string:to_integer(Second),\n\t    case (FirstNumber div SecondNumber) == (FirstNumber /  SecondNumber) of\n\t    \ttrue -> FirstNumber div SecondNumber;\n\t    \tfalse -> case (SecondNumber div FirstNumber) == (SecondNumber / FirstNumber) of\n\t    \t\t\t\ttrue -> SecondNumber div FirstNumber;\n\t    \t\t\t\tfalse -> findDivision(FirstNumber, Rest, AllExceptFirst)\n\t    \t\t\t end\n\t     end.\n\nEDIT: I also didn't know/forgot to google about rem operator, well, you learn something new every day.\n\nHope you don't mind if I paste my solution here, might be nice in case any other people come looking for Erlang solutions in this thread.\n    \n    % read input\n    getInput() ->\n        {ok, Bin} = file:read_file(\"input.txt\"),\n        parse(string:tokens(binary_to_list(Bin), \"\\r\\n\"), []).\n    \n    parse([], Acc) -> Acc;\n    parse([H|T], Acc) ->\n        parse(T, [[list_to_integer(X) || X <- string:tokens(H, \"\\t \")]|Acc]).\n    \n    \n    % first task\n    solve1()-> Input = getInput(),\n               solve1(Input, 0).\n    \n    solve1([], Acc) -> Acc;\n    solve1([H|T], Acc)-> solve1(T, Acc + solveline1(H)).\n    \n    solveline1(Line) -> lists:max(Line) - lists:min(Line).\n    \n    \n    % second task\n    solve2() -> Input = getInput(),\n                solve2(Input, 0).\n    \n    solve2([], Acc) -> Acc;\n    solve2([H|T], Acc) -> solve2(T, Acc + solveline2(H)).\n    \n    solveline2([H|T]) -> \n        N = round(divisible(H, T)),\n        if N > 0 -> N;\n           N == 0 -> solveline2([hd(T)|tl(T)])\n        end.\n    \n    divisible(_, []) -> 0;\n    divisible(N, [H|T]) ->\n        if N rem H == 0 -> N/H;\n           H rem N == 0 -> H/N;\n           N rem H /= 0 -> divisible(N, T)\n    end.    \n\nThank you for the hint yesterday, btw. This time I converted the input to integers right away, and that did make things easier.\n\nI will admit that my solution when I submitted my answers was much less clean than that.\n\nIt's nice to deal with integers throughout so you can use guards. If I could write every program as nothing but function heads with pattern matching and guards I'd be happy. Makes it tough to use any other language. \n\nAbsolutely. I think that may be only the second `if` statement I've seen in the wild!\n\nYeah I made preparation lib now to read input file. I've made 2 functions, one which will make list of lists of integers ( each input row is one list ) and second function makes list of lists of strings ( for future tasks ).\n\nHm, so \"case ... of\" is more idiomatic Erlang then? Interesting!\n\n`if` definitely has its use, and I think your example is a pretty good one, but yes, `case` or discrete function heads (my preference as you can see) is more common.\n\nGarrett Smith has a classic blog post that presents a very opinionated viewpoint on Erlang structure. Real world usage is all over the map, but I recommend it as a starting point; I think if you err towards his code structure, you'll find code much more readable than if you go the other direction.\n\nhttp://www.gar1t.com/blog/solving-embarrassingly-obvious-problems-in-erlang.html\n\nAnd the followup:\nhttp://www.gar1t.com/blog/more-embarrassingly-obvious-problems.html\n\nI'll give them a read. Thank you!", "id": "dqnau0p", "owner_tier": 0.3, "score": 0.1999999998}, {"content": "Perl 6.  Parts 1 and 2:\n\n\n    my $P1_checksum = 0;\n    my $P2_checksum = 0;\n    for 'input.txt'.IO.lines -> $line {\n        my @row = $line.words>>.Int.sort;\n    \n        $P1_checksum += ( @row.max() - @row.min() );\n    \n        my @combinations = @row.combinations(2);\n        for @combinations -> [$a, $b] {\n            if $b %% $a {\n                $P2_checksum += ($b / $a);\n                last;\n            }\n        }\n    }\n\n    say $P1_checksum, '|', $P2_checksum;\n\n\n    \n\nNice!\nNote that you can use `.words` instead of `.split(/\\s/)`.  And if you add a `.sort` to the end of that line, you can skip the `if $a %% $b` part, since `$a` will always be `\u2264 $b`.\n\nBoth of those were nice little optimisations to my answer:\n\n    sub evenly-divisible(@c ($l, $r)) { $r/$l if $r%%$l }\n    \n    sub part1 {$^l.max - $^l.min}\n    sub part2 {[+] $^l.sort.combinations(2).map: &evenly-divisible}\n    \n    sub process-file(Str $f where *.IO.r, Callable $c) {\n    \t$f.IO.lines\u00bb.words\u00bb.Numeric.map: $c;\n    }\n\nThere's probably a bit extra to squeeze into combinations, as I could split the test and the division but it's good enough and it was fun to do.\n\nThanks for the feedback!  I've updated my solution.\n\n\nNice.\n\nIf you're looking to shorten it at all:\n\n* Use .Int instead of .Numeric\n* Use \u00bb. insead of .map even when calling a sub rather than a method", "id": "dqnaxtm", "owner_tier": 0.7, "score": 0.2599999998}], "link": "https://www.reddit.com/r/adventofcode/comments/7h0rnm/2017_day_2_solutions/", "question": {"content": "# NOTICE\n\nPlease take notice that we have updated the Posting Guidelines in the sidebar and wiki and are now requesting that you post your solutions in the daily Solution Megathreads.  Save the `Spoiler` flair for truly distinguished posts.\n\n***\n\n#--- Day 2: Corruption Checksum ---\n\n***\n\nPost your solution as a comment or, for longer solutions, consider linking to your repo (e.g. GitHub/gists/Pastebin/blag or whatever).\n\nNote: The Solution Megathreads are for *solutions* only. If you have questions, please post your own thread and make sure to flair it with `Help`.\n\n***\n\n### Need a hint from the [Hugely^* Handy^\u2020 Haversack^\u2021 of Helpful^\u00a7 Hints^\u00a4](/r/adventofcode/w/h5)?\n\n[Spoiler](#s \"Have you tried adding your programming language to your phone\u2019s input options?\")\n\n***\n\n###~~This thread will be unlocked when there are a significant number of people on the leaderboard with gold stars for today's puzzle.~~\n\n###*edit:* Leaderboard capped, thread unlocked!", "id": "7h0rnm", "title": "-\ud83c\udf84- 2017 Day 2 Solutions -\ud83c\udf84-", "traffic_rate": 38.337674714104196}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "Python 2.7:\n\n    text = raw_input(\"Enter string: \").replace(\" \",\"\")\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    print \"\".join(letter for letter in text if letter not in vowels)\n    print \"\".join(letter for letter in text if letter in vowels)\n\nI like how incredibly readable this is. For the record, you can define vowels as:  \n\n    vowels = 'aeiou'  \n\nand it'll work the same way without the need for so many quotes and commas.\n\nI am still learning Python and these easy problems are still hard for me to solve on my own, but I learned about .replace, .join, and an alternate way to make a list just from reading your code and the comments. I even changed it to work with Python 3. Thank you!\n\nThis is a very pretty piece of Python code!\n\nJust a tip to save some keystrokes:\n\n    vowels = list(\"aeiou\")\n\nEven shorter:\n\ninstead of \n\n    .replace(\" \",\"\")\n\nuse\n\n    .strip(\" \")\n\nIt's incredible how close our solutions were. I hadn't read your comment, but wrote this:\n\n    sentence = 'two drums and a cymbal fall off a cliff'.strip(' ')\n    vowels = list('aeiou')\n    print ''.join([i for i in sentence if i not in vowels])\n    print ''.join([i for i in sentence if i in vowels])\n\nYeah, I realised this after posting, but I left it as is. Thanks!\n\nEven more:\n\n    vowels = \"aeiou\"\n\neven faster:\n\n    vowels='oiuea' # just slap 5 fingers on the 5 keys\n\n(jk)\n\nIf we're minimising keystrokes, why not:\n\n    t = raw_input(\"Enter string: \").replace(\" \",\"\")\n    print \"\".join(l for l in t if l not in 'aeiou')\n    print \"\".join(l for l in t if l in 'aeiou')\n\nEdit: Shorter again:\n\n    import re,sys\n    t=sys.argv[1]\n    print re.sub('[aeiou ]','',t)\n    print re.sub('[^aeiou]| ','',t)", "id": "cfng0od", "owner_tier": 0.1, "score": 0.4931506848858448}, {"content": "Please keep this sub alive, I can't overstate how helpful these challenges and most importantly the discussions are.", "id": "cfnmtzo", "owner_tier": 0.7, "score": 0.18264840178082192}, {"content": "x86 assembly for Windows (assembled with MASM32)\n\n    .386 \n    .model flat, stdcall \n    option casemap :none \n\n    include \\masm32\\include\\windows.inc \n    include \\masm32\\include\\kernel32.inc \n    include \\masm32\\include\\masm32.inc \n    includelib \\masm32\\lib\\kernel32.lib \n    includelib \\masm32\\lib\\masm32.lib \n\n    .data?\n        input           db      256 dup(?)      ;\"dup\" duplicates what is in parenthesis.\n        nonVowels       db      256 dup(?)      ;In these cases, it creates 3 uninitialized arrays of 256 bytes.\n        vowels          db      256 dup(?)        \n\n    .code\n    main:\n        invoke StdIn, addr input, 256           ;get input\n\n        xor esi, esi                            ;xoring a register with itself is a fast way of setting it to 0.\n        xor edi, edi\n        xor eax, eax                            ;eax will store the destination address for vowels\n        mov bl, input[esi]\n\n    _disemvowelerLoop:\n            cmp bl, 0\n            jz _disemvowelerEnd                 ;exit loop at end of string (null terminator character)\n\n            cmp bl, ' '                         ;ignore spaces\n            jz _disemvowelerContinue\n\n            cmp bl, 'a'                         ;check if current character is a vowel\n            jz _vowel\n            cmp bl, 'e'\n            jz _vowel\n            cmp bl, 'i'\n            jz _vowel\n            cmp bl, 'o'\n            jz _vowel\n            cmp bl, 'u'\n            jz _vowel\n\n            mov nonVowels[edi], bl              ;if it isn not a vowel, add it to nonVowels\n            inc edi\n            jmp _disemvowelerContinue\n\n        _vowel:\n            xchg eax, edi                       ;temporarily swap eax and edi so edi stores the vowel destination\n            mov vowels[edi], bl                 ;if it is a vowel, add it to vowels\n            inc edi\n            xchg eax, edi\n\n        _disemvowelerContinue:\n            inc esi                             ;increment character index\n            mov bl, input[esi]\n            jmp _disemvowelerLoop\n\n    _disemvowelerEnd:\n\n        mov nonVowels[edi], 10                  ;add newline and null terminator characters to strings\n        mov nonVowels[edi+1], 0\n        xchg eax, edi\n        mov vowels[edi], 10\n        mov vowels[edi+1], 10\n        mov vowels[edi+2], 0\n\n        invoke StdOut, addr nonVowels           ;print results\n        invoke StdOut, addr vowels\n        invoke ExitProcess, 0\n    end main\n\n\nWow.  As a newbie, I was just talking to someone last night about x86.  Crazy stuff.", "id": "cfnp10y", "owner_tier": 0.3, "score": 0.1232876711872146}, {"content": "Perl:\n\n    sub dp149 {\n    \t$_ = $_[0]; s/[aeiou ]//g; say;\n    \t$_ = $_[0]; s/[^aeiou]//g; say;\n    }\n\n\n\nwhat\n\nshorter weirder:\n\n    sub dp149 {\n    \t$_ = shift;\n    \tsay y/aeiou //dr;\n    \tsay s/[^aeiou]//gr;\n    }\n\nPERL:\n\n    SUB DP149 {\n    \t$_ = $_[0]; S/[AEIOU ]//G; SAY;\n    \t$_ = $_[0]; S/[^AEIOU]//G; SAY;\n    }\n\n\n\neven shorter...\n\n    sub dp149 {\n        shift;\n        say y/aeiou //dr;\n        say s/[^aeiou]//gr;\n    }\n\n($_ is implicit)\n\n--edit-- formatting is\n\n* hard\n\nomg i can't breathe\n\nyou actually need to declare it here\n\nonly some functions set $_, and shift is not one of them\n\n$_ = $_[0];s/[aeiou]//g;say;\n\nthis bit puts the input through a regex to remove spaces and vowels, then prints it. $_ is a default but could easily be substituted for any other variable name(with the expense of file size)\n\nbah, you're right, My mistake. I always thought it did.\n\nI should probably check that I'm not actually using this in production code...  but hey, everything is working, so I'm sure it will be fine.\n\nalthough...  perl can expand variables within a regex, why not just drop the shift altogether and just s/xyz/@_[0]/g\n\n(on my tablet atm, so can't test right now).", "id": "cfng7bb", "owner_tier": 0.3, "score": 0.9999999999543379}, {"content": "Ruby!\n\n    str = 'did you hear about the excellent farmer who was outstanding in his field'\n    puts \"#{str.delete('aeiou ')}\\n#{str.delete('^aeiou')}\"\n\nOutput: \n\n    ddyhrbtthxcllntfrmrwhwststndngnhsfld\n    ioueaaoueeeeaeoaouaiiiie\n    [Finished in 0.1s]\n\n[deleted]\n\nawesome!\n\nWow!\n\nI stumbled upon String.tr(), which also does pretty much exactly what we want:\n\n    str = \"all those who believe in psychokinesis raise my hand\"\n    p str.tr(\"aeiou \", \"\")\n    p str.tr(\"^aeiou\", \"\")\n\nI make one this\n\n    def disemvoweler(i)\n       i.gsub!(/a|e|i|o|u| /, '')\n    end\n\n    puts \"What do you whant to disvowel?\"\n \n    puts disemvoweler(gets)\n\nRuby is so much fun to write in. Try it :)\n\nHey, thanks! =)\n\nHa, thanks! I'm taking that as a compliment, whether you meant it that way or not.\n\nInteresting, but I think String#delete may be more idiomatic here. Thanks! \n\nThat's not going to meet the requirements, though -- you need to print BOTH the disemvoweled string AND the vowels from that string (in order).\n\nYou're only doing the first part. Also, using String#gsub! isn't a great idea -- if there are no vowels in the string, you'll get `nil` -- not the string. And finally, you shouldn't use alternation for single characters -- you can use Regex character classes for that. Here's a slightly better version of your implementation:\n\n    def disemvoweler(str)\n      str.gsub(/[aeiou]/,'') + \"\\n\" + str.gsub([^aeiou],'')\n    end\n    \n    puts \"What do you want to disvowel?\"\n    \n    puts disemvoweler(gets.chomp)\n\nKeep practicing! You'll get there.", "id": "cfnjewn", "owner_tier": 0.7, "score": 0.18721461182648402}, {"content": "This is exactly what the shell utility `tr` is for. Here I assume the first argument is a file containing the text. See /u/galaktos's comment for stdin instead.\n\n    tr -d aeiou[:blank:] < $1\n    tr -C -d aeiou < $1", "id": "cfnos7b", "owner_tier": 0.5, "score": 0.059360730547945204}, {"content": "Perl:\n\n    chomp($_ = <STDIN>);\n    ($a = $_) =~ s/[^aeiou]//g;\n    y/aeiou //d;\n    print \"$_\\n$a\";\n\nBonus Brainfuck devoweler (doing consonants takes way too long):\n\n    >,\n    [>>++++++\n    [>++++\n    [>+>+>++++>++++>++++>++++>++++>++++>+++++>+++++>+++++>+++++<<<<<<<<<<<<-]\n    <-]\n    >>++++++++>++++++++>+>+>+++++>\n    +++++>+++++++++>+++++++++\n    >--------->--------->--->---\n    [<]<<<\n    [>+>+>+<<<-]>[->>>>-<<<<]>>>>\n    [\n    <<<[<<+>>-]<<[->+>+<<]>[->>>>>>-<<<<<<]>>>>>>\n    [\n    <<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>-<<<<<<<<]>>>>>>>>\n    [\n    <<<<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>>>-<<<<<<<<<<]>>>>>>>>>>\n    [\n    <<<<<<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>>>>>-<<<<<<<<<<<<]>>>>>>>>>>>>\n    [\n    <<<<<<<<<<<[<<+>>-]<<[->+>+<<]>[->>>>>>>>>>>>>>-<<<<<<<<<<<<<<]>>>>>>>>>>>>>>\n    [[<]>.[<]]\n    [<]\n    ]\n    [<]\n    ]\n    [<]\n    ]\n    [<]\n    ]\n    [<]\n    ]\n    >>>>>>>>>>>>>\n    >,\n    ]\n\n\ni'm glad someone tried to accomplish this...I was actually wondering if anyone would.\n\nDid you use any 'convert-to-brainfuck' tool? Are are you a fucking genius?\n\nNah, I actually really suck at programming.\n\nAll it's doing is capturing invididual character input, subtracting its ASCII value from 6 others, and printing it out if it isn't equal to any of them, though, so it's very simple if you keep track of the relative memory locations.", "id": "cfo841x", "owner_tier": 0.7, "score": 0.0730593606849315}, {"content": "JavaScript:\n\n    function disemvowel(inputStr) {\n      console.log(inputStr.match(/[^aeiou ]/g).join(\"\"));\n      console.log(inputStr.match(/[aeiou]/g).join(\"\"));\n    }\n\nThis is great. This was my solution (a slight variation): \n\n    function disemvowel(s) {\n      console.log(s.replace(/[aeiou ]/g, ''));\n      console.log(s.replace(/[^aeiou]/g, ''));\n    }\n\nnew to this--why the backslash in the parameters for the match method?\n\nwow.  Mine is much more complex.  I can't believe how simple it could be.\n\n    var input = prompt(\"Please enter a string.\").toLowerCase();\n    var slicer = 0;\n    var newString = \"\"\n    console.log(input);\n\n    var vowels = \"aeiou\";\n\n    var removed = \"\";\n\n    for(var i = 0; i < input.length; i++){\n        if((vowels.indexOf(input[i]) > 0)|| (input[i] == \" \")){\n            removed += input[i];\n        }else{\n            newString += input[i];\n        }\n        slicer ++;\n    }\n\n    console.log(newString);\n    console.log(removed);\n\nNice!\n\nHave you attempted the re-envoweler challenges yet?\n\nBy the way, that's a forward slash, not a backslash! Backslashes look like they're leaning backwards against the flow of the text -- so the top is on the left.\n\nIn JavaScript, you declare a regex with the slash character.\n\nIt's a shorter way of writing regexps. Example:\n\n    console.log(/a/.exec('abcd'));\n    console.log(new RegExp('a').exec('abcd'));", "id": "cfngbti", "owner_tier": 0.5, "score": 0.0684931506392694}, {"content": "sed:\n\n    sed 's/ //g;h;s/[aeiou]//g;p;x;s/[^aeiou]//g;'\n\nNice use of `h` and `x`! (Also, TIL about `;` in `sed` \u2013 I thought you needed multiple `-e`s...)\n\nYou might still be able to minimize it a bit further by removing the first substitution, and using `[aeiou ]` (note the space) in the second.\n\nEdit: like this:\n\n    sed 'h;s/[aeiou ]//g;p;x;s/[^aeiou]//g'", "id": "cfnoay6", "owner_tier": 0.5, "score": 0.0365296803196347}, {"content": "Quick Java.\n\n    import java.util.Scanner;//import for scanner\n    import static java.lang.System.*;//import for System.in and System.out\n\n    public class dp149E\n    {\n    \tpublic static void main(String[] args)\n    \t{\n    \t\tScanner scan = new Scanner(in);//scanner for input\n\t\t\n    \t\tString a = scan.nextLine().trim().replaceAll(\" \", \"\");//get input, trim all trailing spaces, remove all spaces\n\t\t\n    \t\tout.printf(\"%s\\n%s\\n\",a.replaceAll(\"[aeoiu]\", \"\"), a.replaceAll(\"[^aeiou]\", \"\"));//replace all vowels, then replace all non-vowels\n\t\t\n    \t\tscan.close();//manage resources\n    \t}\n    }", "id": "cfnfxjz", "owner_tier": 0.1, "score": 0.00456621}, {"content": "Haskell, code golf.\n\n    main = do\n        line <- fmap (filter (/= ' ')) getLine\n        putStr . unlines $ map (\\f -> filter (f . (`elem` \"aeiou\")) line) [not, id]\n\nI've always wanted to learn Haskell as a hobby language.\n\nIn [Data.List](http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:partition), there's a function 'partition' that makes the second part of your code easier to understand. Example usage\n\n    partition (`elem` \"aeoiu\") \"hello\"\n\nWill return (\"eo\", \"hll\").\n\nI prefer doing it with one foldr \n\n    main = do\n        (o,v) <- fmap (foldr dis ([], [])) getLine\n        putStrLn o\n        putStrLn v\n      where\n        dis e (o, v) | e `elem` \"aeiou\" = (o, e:v) \n                     | e == ' '         = (o, v) \n                     | otherwise        = (e:o, v)\n\nEven if you never you never use it in an actual job, it will probably make you a better programmer. The mathematical purity that Haskell encourages is a useful concept to use in any language. Functions without side-effects are much easier to debug. If you want to give it a shot, which I highly recommend, check out [Learn You a Haskell for Great Good!](http://learnyouahaskell.com) The author is hilarious, and nothing will tickle your brain quite like functional programming.\n\nJoin us! The Haskell community is small, friendly, and helpful! Plus, there are lots of areas to shine, unlike the bigger languages like C++ or Java \n\nIt's more clear, but not as golf-y. The last line is that same amount of characters, but I have to add the extra import line, so it takes more strokes. However, if I wasn't code-golfing, I would definitely use you partition idea.\n\n    import Data.List\n\n    main = do\n        line <- fmap (filter (/= ' ')) getLine\n        let (vs, cs) = partition (`elem` \"aeiou\") line in putStr $ unlines [vs, cs]\n\nI honestly have the PDF of that book and just never got into but now it seems I'll have to!\n\nI definitely will!", "id": "cfnhgsn", "owner_tier": 0.1, "score": 0.0867579908219178}, {"content": "Concise Ruby:\n\n    puts gets.chomp.delete(' ').each_char.partition{|c| !\"aeiou\".include?(c) }.map(&:join)\n\n`String#partition` is different. We use `partition` from `Enumerable` module, so the call to `each_char` which returns an `Enumerator`", "id": "cfnjhml", "owner_tier": 0.3, "score": -4.5662100179110915e-11}, {"content": "Learning python...\n\n    import sys\n    vowels, letters, disemvoweled = 'aeiou', '', ''\n    for param in sys.argv:\n    \tif param == sys.argv[0]:\n    \t\tcontinue\n    \tparam = param.replace(' ','')\n    \tfor char in list(param):\n    \t\tif char in vowels:\n    \t\t\tdisemvoweled += char\n    \t\telse:\n    \t\t\tletters += char\n    print letters\n    print disemvoweled\n\nyou can skip the sys.argv[0] check if you iterate over sys.argv[1:] instead. also you donl't need the list(param), you can iterate over a string a character at a time.\n\nnice work. \n\nGood work, and keep cranking away at learning. I'm a Python novice as well, and writing Pythonic code is the hardest part of it all.\n\nI've been learning for a while and haven't seen import sys yet, what does sys.argv[0] do?\n\nI'm learning Python as well. This is 3.3.    \n\n    words = str(input().replace(\" \",\"\"))\n    a = list(words)\n    vowels = ['a','e','i','o','u']\n\n    extracted_vowels = ''\n    joined = ''\n\n    for letter in a:\n        if letter in vowels:\n            extracted_vowels += letter\n            a.remove(letter)\n        joined += letter\n\n    print(joined)\n    print(extracted_vowels)\n\ngreat, thanks!\n\nKind of unrelated, but is there a simple conversion of a char to ascii in python? I know that in C when you store a char with single quotes \n\n    char b = 'b'\n    # where 'b' stored as it's ascii value of 98.\n\nyou're actually storing it's ascii value (and therefore I can do math on the ascii value, think caesar cipher). Is there a python equivalent?\n\nShort answer: sys.argv is a tuple of the command line parameters that were passed to python. sys.argv[0] is ALWAYS the script name \"something.py\" that was passed to python.\n\nhere, check this out and/or google around for descriptions of argc/argv http://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean\n\nI can't really say off the top of my head what import sys does as a whole, since I only use it to get command line arguments. That's exactly what argv is though, it's what was entered on the command line. My guess is that the sys module probably provides operating system-y stuff such as architecture and maybe like process ID, date/time, idk... look it up!\n\nSo if you invoke python on the cmd line like this:\n\n    python myscript.py param1 param2 param3\n\nThen sys.argv would be a tuple that consists of ('myscript.py', 'param1', 'param2', 'param3')\n\nIn C/C++ land argv is a pointer and you are provided with another parameter called argc which is the number of parameters pointed to by argv. It seems the python sys module doesn't provide argc, but that's probably just because you can just calculate it using len(argv).\n\nLet me know if that was confusing or you have any other questions, I just typed it up real quick off the top of my head.\n\nyes, use the built in ord() function on a character:\n\n    In [55]: ord('b')\n    Out[55]: 98\n\nhope that helps. ", "id": "cfnjqls", "owner_tier": 0.5, "score": 0.095890410913242}, {"content": "Perfectly suited to a simple partition in Haskell:\n\n    import Data.List(partition)\n    import Control.Monad(liftM)\n    \n    disemvowel = partition (`elem` \"aeiou\") . filter (/=' ')\n    \n    main = do (cs, vs) <- liftM disemvowel getLine\n              putStrLn cs >> putStrLn vs\n\nEdit: Add IO\n    \n\n\nI'm just learning Haskell, your use of function composition makes yours look much nicer!\n\n    import Data.List\n\n    disemvowel :: String -> (String, String)\n    disemvowel sentence =\n        let vowels = \"aeiou\"\n            isVowel n = n `notElem` vowels\n    in partition isVowel $ filter (/= ' ') sentence", "id": "cfnl0jt", "owner_tier": 0.5, "score": 0.009132420045662101}, {"content": "+/u/CompileBot clojure\n\n    (defn disemvowler [input]\n          (loop [letter (first input)\n                 cnsnnts []\n                 vowels []\n                 remaining (rest input)]\n            (if letter\n              (case letter\n                (\\a \\A \\e \\E \\i \\I \\o \\O \\u \\U) (recur (first remaining) cnsnnts (conj vowels letter) (rest remaining))\n                \\space (recur (first remaining) cnsnnts vowels (rest remaining))\n                (recur (first remaining) (conj cnsnnts letter) vowels (rest remaining)))\n              {:consonants cnsnnts :vowels vowels})))\n\n    (defn disemvowler2 [input]\n          {:consonants (clojure.string/join (re-seq #\"[^aeiouAEIOU ]\" input)) :vowels (clojure.string/join (re-seq #\"[aeiouAEIOU]\" input))})\n\n    (println (disemvowler \"all those who believe in psychokinesis raise my hand\"))\n    (println (disemvowler2 \"all those who believe in psychokinesis raise my hand\"))\n\nEdit: Add \"one-liner\" version; compilebot\n\nOutput:\n\n    {:consonants [l l t h s w h b l v n p s y c h k n s s r s m y h n d], :vowels [a o e o e i e e i o i e i a i e a]}\n    {:consonants llthswhblvnpsychknssrsmyhnd, :vowels aoeoeieeioieiaiea}\n    \n\n[^source](http://ideone.com/HaFQhT) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&subject=Report%20Abuse&message=--report%20http%3A//www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/cfnh3uh%20Include%20your%20reason%20for%20reporting%20here.)\n\n**EDIT:** Recompile request by cdombroski\n\nOh my god, a compile bot, this is the coolest thing I have ever seen!\n\nThe bot call is awesome. Love it!\n\nLittle late, but\n\n+/u/CompileBot clojure\n\n    (defn disemvowel [s]\n      (as-> s res\n        (filter (complement #{\\ }) res)\n        (group-by #(if (#{\\a \\e \\i \\o \\u \\A \\E \\I \\O \\U} %) :vowel :consonant) res)\n        [(:consonant res) (:vowel res)]\n        (map clojure.string/join res)))\n    (-> \"all those who believe in psychokinesis raise my hand\" disemvowel println)\n\nedit: simpler; compilebot\n\n    (defn disemvowel [s]\n      (->> s\n        (filter (complement #{\\ }))\n        (group-by #(if (#{\\a \\e \\i \\o \\u \\A \\E \\I \\O \\U} %) :vowel :consonant))\n        ((juxt :consonant :vowel))\n        (map clojure.string/join)))\n    (-> \"all those who believe in psychokinesis raise my hand\" disemvowel println)\n\nI initially saw it on Sakuya_Lv9's post. It definitely fits in perfectly here.\n\nOutput:\n\n    (llthswhblvnpsychknssrsmyhnd aoeoeieeioieiaiea)\n    \n\n[^source](http://ideone.com/MKwaJl) ^|\n[^info](http://www.reddit.com/r/CompileBot/wiki) ^|\n[^git](https://github.com/renfredxh/compilebot) ^|\n[^report](http://www.reddit.com/message/compose?to=compilebot&subject=Report%20Abuse&message=--report%20http%3A//www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/cj4j2cf%20Include%20your%20reason%20for%20reporting%20here.)\n", "id": "cfnh3uh", "owner_tier": 0.5, "score": 0.0547945205022831}, {"content": "Common Lisp, using the `disjoin` higher-order function from Alexandria.\n\n    (defun vowel-p (character)\n      (find character \"aeiou\"))\n\n    (defun consonant-p (character)\n      (not (vowel-p character)))\n\n    (defun whitespace-p (character)\n      (find character \" \t\"))\n\n    (defun disemvowel (string)\n      (values (remove-if (disjoin #'whitespace-p #'vowel-p)     string)\n              (remove-if (disjoin #'whitespace-p #'consonant-p) string)))\n\nUsage:\n\n    (disemvowel \"all those who believe in psychokinesis raise my hand\")\n    ;; => \"llthswhblvnpsychknssrsmyhnd\", \"aoeoeieeioieiaiea\"\n", "id": "cfnj13u", "owner_tier": 0.7, "score": -4.5662100179110915e-11}, {"content": "Here's Scala. Decided to try to golf this one:\n\n    val x,y=readLine.filter(_!=' ')partition(\"aeiou\"contains _)\n    print(y+\"\\n\"+x)", "id": "cfnjemj", "owner_tier": 0.5, "score": -4.5662100179110915e-11}], "link": "https://www.reddit.com/r/dailyprogrammer/comments/1ystvb/022414_challenge_149_easy_disemvoweler/", "question": {"content": "# _(Easy)_: Disemvoweler\n\nDisemvoweling means removing the vowels from text. (For this challenge, the letters a, e, i, o, and u are considered vowels, and the letter y is not.) The idea is to make text difficult but not impossible to read, for when somebody posts something so idiotic you want people who are reading it to get extra frustrated.\n\nTo make things even harder to read, we'll remove spaces too. For example, this string:\n\n    two drums and a cymbal fall off a cliff\n\ncan be disemvoweled to get:\n\n    twdrmsndcymblfllffclff\n\nWe also want to keep the vowels we removed around (in their original order), which in this case is:\n\n    ouaaaaoai\n\n# Formal Inputs & Outputs\n\n## Input description\n\nA string consisting of a series of words to disemvowel. It will be all lowercase (letters a-z) and without punctuation. The only special character you need to handle is spaces.\n\n## Output description\n\nTwo strings, one of the disemvoweled text (spaces removed), and one of all the removed vowels.\n\n# Sample Inputs & Outputs\n\n## Sample Input 1\n\n    all those who believe in psychokinesis raise my hand\n\n## Sample Output 1\n\n    llthswhblvnpsychknssrsmyhnd\n    aoeoeieeioieiaiea\n\n## Sample Input 2\n\n    did you hear about the excellent farmer who was outstanding in his field\n\n## Sample Output 2\n\n    ddyhrbtthxcllntfrmrwhwststndngnhsfld\n    ioueaaoueeeeaeoaouaiiiie\n\n# Notes\n\nThanks to /u/abecedarius for inspiring this challenge on /r/dailyprogrammer_ideas!\n\nIn principle it may be possible to reconstruct the original text from the disemvoweled text. If you want to try it, check out this week's Intermediate challenge!", "id": "1ystvb", "title": "[02/24/14] Challenge #149 [Easy] Disemvoweler", "traffic_rate": 52.622466960352426}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "Python, one line for each sub-problem.\n\n    print sum(len(s[:-1]) - len(eval(s)) for s in open('inputs/problem8-input'))\n    print sum(2+s.count('\\\\')+s.count('\"') for s in open('inputs/problem8-input'))\n\nNice and tidy, but off-by-one for Part 1 of my input: https://gist.github.com/craigotis/5f456721d46c52ad86c8\n\nYour code produces `1332`, but the answer was `1333`.\n\n(But the answer for Part 2 is correct.)\n\nBrilliant. I did part 1 exactly the same as you, but implemented a decoder for the 2nd part. Figuring out the final result is simply that counting is brilliant.\n\nHere is my first:\n\n    with open('advent_8_1.in') as f:\n        print(sum(len(_) - 1 - len(eval(_)) for _ in f))\n\nAnd here my second:\n\n    import re\n    import functools\n\n    class Decoder:\n        def __init__(self):\n            self.regexp = re.compile(r'(\\\\x\\d{2}|\"|\\\\)')\n            self.subs = functools.partial(self.regexp.sub, r'\\\\\\1')\n            self.prepend = '\"'\n            self.append = '\"'\n\n        def repr(self, s):\n            return self.prepend + self.subs(s) + self.append\n\n    def main():\n        decoder = Decoder()\n        with open('advent_8_1.in') as f:\n            print(sum(len(decoder.repr(_[:-1])) - len(_[:-1]) for _ in f))\n    \n    if __name__ == '__main__':\n        main()\n\n\nYou don't have a newline at the end of your input. This code relies on the newline in s[:-1]\n\nIn the second solution the lack of new line doesn't matter because it's removed in the difference\n\nYou're right - my Python is a little rusty. Adding the newline to the input, it spits out `1333`.", "id": "cxrad1k", "owner_tier": 0.1, "score": 0.6923076920512821}, {"content": "# NEW REQUEST FROM THE MODS\n\nWe are requesting that you hold off on posting your solution until there are a significant amount of people on the leaderboard with gold stars - say, 25 or so.\n\nWe know we can't control people posting solutions elsewhere and trying to exploit the leaderboard, but this way we can try to reduce the leaderboard gaming from the official subreddit.\n\nPlease and thank you, and much appreciated!\n\n[deleted]\n\nWhile we're at it; could we post source on github/pastebin instead of directly in this topic? Less chance to spoil yourself (I tend to write a Java implementation first and then a Scala version) and it saves a lot of wear on my scrollwheel (not to mention my tablet not liking long posts).\n\nI'll be locking tomorrow's thread until the leaderboard fills up sufficiently enough for /u/topaz2078's liking (maybe 50, maybe 100, maybe after x hour(s) has elapsed), then unlock it for solution posts.\n\nDay 8 was easy for some, hard for others.  There's 17 days left to go, and they're just going to get harder and harder.\n\nAs someone who can never be awake at the start time (5AM here), roughly how long does it take contestant 1 and contestant 100?\n\nI for one would prefer that people continue to post their code directly in the comment. There's no way I'm following 100 separate links to see people's solutions, but quickly skimming through the thread and seeing if any of them look particularly interesting is great.\n\nYou can also sticky comments now if you didn't hear.\n\nGood point.", "id": "cxr7vn6", "owner_tier": 0.7, "score": 0.9999999997435898}, {"content": "Not so elegant in Go, which doesn't have an eval function, but still pretty straightforward thanks to the `strconv` package:\n\n    func unquote(str string) string {\n    \ts, _ := strconv.Unquote(str)\n    \treturn s\n    }\n\n    func quote(str string) string {\n    \treturn strconv.Quote(str)\n    }\n    \n    func main() {\n    \t// part 1\n    \tvar total int\n    \tfor _, str := range strings.Split(input, \"\\n\") {\n    \t\ttotal += len(str) - len(unquote(str))\n    \t}\n    \tprintln(total)\n    \n    \t// part 2\n    \ttotal = 0\n    \tfor _, str := range strings.Split(input, \"\\n\") {\n    \t\ttotal += len(quote(str)) - len(str)\n    \t}\n    \tprintln(total)\n    }\n\n\nit also has %q for fmt.Sprintf and fmt.Sscanf - which uses strconv under the covers\n\nDamn. That easy, didn't know this existed. Used regexes to count occurrences of the different escapes, \nstupid me. \n\nuse `strings.Count` for counting!\n\nI didn't know `strconv.Unescape` existed either. I wrote my own decoder; I handled the hex escapes using `regexp.ReplaceAllStringFunc`.\n\nHow would you count the hex escapes with this? You can't just count \\x occurrences, as this would include \\\\x, which is not a hex escape. \n\n\\\\\\x that is", "id": "cxr85fp", "owner_tier": 0.5, "score": 0.28205128179487177}, {"content": "I did this the sleuthy way in the shell.\n\n    $ wc -l input\n    300 = 300 lines in the input, so 600 quotes on the ends to remove\n    $ wc -c input\n    6789 = total characters in the input file\n    $ sed 's/\\\\\"/@/g' input | sed 's/\\\\x[a-f0-9][a-f0-9]/~/g' | sed 's/\\\\\\\\/\\\\/g' | wc -c\n    6018 = total characters after unescaping things (which was a tad tricky)\n\nSo, 6789 - 6018 + 600 = 1371 = answer to part 1\n\nAnd to go the other way, it was easier to not stick more backslashes back in the file to trip up future sed operations (we just care about correct character counts):\n\n    $ sed 's/\"/~~/g' input | sed 's/\\\\/@@/g' | wc -c\n    8306 = total characters with new ones added\n\nAdd in the 300 lines * 2 edges = 600 extra \" characters to surround each line in quotes again, and you get 8906. Subtract the 6789 characters in the original file, and you get 2117 for part 2.\n\nI'm trying to solve this with Bash at the moment, but I struggle... I do pretty much the same as you do, except\n\n* I don't pipe the seds, but use several expression in one command using `-e` &ndash; don't think that makes a difference, though\n* I match the double slash first, you match it last\n\nIf you have input like this: `\\\\xee` you first replace the `\\xee` (3 chars difference) whereas I replace just the slash - but isn't the slash escaped and the result should be `\\xee`?\n\n_Edit:_ So, I found my problem. I saved the input file using `cat <<EOF > input08` &ndash; which doesn't preserve escapes! Using `cat <<'EOF' > input08` worked finally.\n\nThis being said, I'm now pretty sure your `sed` chain isn't correct, is it? Gives me the correct result though, now that I checked...\n\nWhat platform are you on?\n\n    strax:~ jeff$ wc -c /Users/jeff/Downloads/input-3.txt \n        6502 /Users/jeff/Downloads/input-3.txt\n\nGlad you got it. I just noodled around with the seds until I got the right number :)\n\nEvery user has its own input files, so it is not surprising.\n\nOh! Good to know!", "id": "cxr8d4z", "owner_tier": 0.9, "score": 0.3589743587179487}, {"content": "I keep thinking these are going to trick me, so I never use the proper built-ins. Here's how I did it the wrong way:\n\n**Perl**\n\n    my $total_a;\n    my $total_b;\n\n    while (<>) {\n        chomp;\n\n        my $len = length $_;\n        my ($a, $b);\n\n        $a = $b = $_;\n        $a =~ s{^\"(.*)\"$}{$1};\n        $a =~ s{\\\\\\\\}{#}g;\n        $a =~ s{\\\\\"}{#}g;\n        $a =~ s{\\\\x[a-fA-F0-9][a-fA-F0-9]}{#}g;\n\n        $b =~ s{\\\\}{\\\\\\\\}g;\n        $b =~ s{\"}{\\\\\"}g;\n\n        my $len_a = length($a);\n        my $len_b = length($b) + 2;\n\n        $total_a += $len - $len_a;\n        $total_b += $len_b - $len;\n    }\n\n    print \"$total_a\\n\";\n    print \"$total_b\\n\";\n\nand here's the simpler way:\n\n    ...\n        my ($a, $b);\n\n        eval \"\\$a = $_\";\n        $b = quotemeta($_);\n\nand here are one-liners, because Perl:\n\n    cat input.txt | perl -nE '$_ = $t += length($_) - length(eval \"\\$n = $_\") - 1; say'\n    cat input.txt | perl -nE '$_ = $t += length(quotemeta($_)) + 1 - length($_); say'\n\nEDIT: Guess who learned about the -E switch today!", "id": "cxr8r39", "owner_tier": 0.1, "score": 0.051282051025641026}, {"content": "A Perl 6 solution.\n\nWith syntax highlighting: http://pygments.org/demo/3300216/\n\n    #!/usr/bin/env perl6\n    \n    # Part 1\n    say [+] 'input'.IO.lines.map: { (m:g/ \\\\x<[a..f0..9]>**2 /.list.elems * 3) + (m:g/ \\\\(\\\"|\\\\) /.list.elems) + 2 }\n    \n    # Part 2\n    say [+] 'input'.IO.lines.map: { (m:g/ \\\\x<[a..f0..9]>**2 /.list.elems) + (m:g/ \\\\ (\\\"|\\\\) /.list.elems * 2) + 4 }\n    \nThings I learned:\n\n1. Using .IO.lines on a filename string to read line-by-line\n2. Regex modifiers go before first / now\n3. Hyper operator for doing reduce operations\n4. Using .list to get group matches\n5. Using .elems to get number of items in list/array\n    \n", "id": "cxs2exg", "owner_tier": 0.1, "score": 0.07692307666666667}, {"content": "**Haskell**\n\n    module Main where\n    import BasePrelude\n\n    decode = f\n     where f ('\\\\':'\\\\':xs)    = ('\\\\':decode xs)\n           f ('\\\\':'\"':xs)     = ('\"':decode xs)\n           f ('\\\\':'x':x:y:xs) = ('!':decode xs)\n           f (x:xs)            = (x:decode xs)\n           f []                = []\n\n    encode s = \"\\\"\" <> f s <> \"\\\"\"\n      where f ('\"':xs)  = \"\\\\\\\"\" <> f xs\n            f ('\\\\':xs) = \"\\\\\\\\\" <> f xs\n            f (x:xs)    = x:(f xs)\n            f []        = []\n\n    input    = lines <$> readFile \"<snip>\"\n    output f = ((,) <$> (sum . map length <$> input) <*> (sum . map f <$> input)) >>= print\n    main1    = output ((+ (-2)) . length . decode)\n    main2    = output (length . encode)\n\n\nhaskell pattern matching always feels so magical to me\n\nHow much experience do you have with Haskell?\n\nI feel like this would be a great challenge for seasoned programmer who is a beginner to Haskell to get started with.\n\nLast time I did any Haskell was maybe 5-6 years ago.  I was trying to learn it and as an exercise wrote a Roman Numeral -> Decimal converter.\n\nI have a similar Haskell solution, although I didn't bother actually decoding the string, opting instead to just count the tokens as they come. Plus for \"encoding\" I just used Haskell's inbuilt `show`. I originally tried to use `read` for decoding, but it actually accepts variable length hexadecimal codes, so often it would consume too many digits after the `\\x`.\n\n    module Matchsticks where\n    \n    readStr, readDiff, showDiff :: String -> Int\n    \n    readStr ['\\\"']            = 0\n    readStr ('\\\"':cs)         = readStr cs\n    readStr ('\\\\':'\\\\':cs)    = readStr cs + 1\n    readStr ('\\\\':'\\\"':cs)    = readStr cs + 1\n    readStr ('\\\\':'x':_:_:cs) = readStr cs + 1\n    readStr (_:cs)            = readStr cs + 1\n    \n    readDiff l = length l - readStr l\n    showDiff l = length (show l) - length l\n    \n    fileDiff :: (String -> Int) -> String -> Int\n    fileDiff d = sum . map d . lines\n\n\nI've been writing Haskell for a long time and I highly recommend it. The ecosystem's gotten a lot better in the last year. Even if you can't write Haskell for your day job, you get better at solving problems without side effects.", "id": "cxr82rq", "owner_tier": 0.1, "score": 0.20512820487179487}, {"content": "C# in linqpad: \n\n    void Main() {\n        var lines = File.ReadLines(@\"aoc8.txt\");\n    \n        int totalCode = lines.Sum(l => l.Length);\n        int totalCharacters = lines.Sum(CharacterCount);\n        int totalEncoded = lines.Sum(EncodedStringCount);\n    \n        Console.WriteLine(totalCode - totalCharacters);\n        Console.WriteLine(totalEncoded - totalCode);\n    }\n    \n    int CharacterCount(string arg) => Regex.Match(arg, @\"^\"\"(\\\\x..|\\\\.|.)*\"\"$\").Groups[1].Captures.Count;\n    int EncodedStringCount(string arg) => 2 + arg.Sum(CharsToEncode);\n    int CharsToEncode(char c) => c == '\\\\' || c == '\\\"' ? 2 : 1;", "id": "cxr8m29", "owner_tier": 0.7, "score": 0.025641025384615386}, {"content": "I messed up real bad on my speed solve attempt today, so instead I uploaded a video of me solving Day 8 using only my text editor (vim).\n\nhttps://www.youtube.com/watch?v=2WY-01QaIIY\n\nFor those of you who did a double take when you saw the leaderboard today, my mistake was misinterpreting double-quoted, which is something of a double entendre.  I'll have to redouble my efforts tomorrow.\n\n\nAha! I was trying to do the same thing (use vim) and watching your video I see where I went wrong - I forgot that the \\x was followed by hex numbers, not decimals. So I was only grabbing \\\\x\\d\\d instead of [0-9a-z][0-9a-z]. Dang it, I think I would have made it on the board if I hadn't screwed that up. I kept coming up with the wrong answer and after a few tries, it pushes you back to 5 minutes in between guesses instead of just 1, and I was toast.\n\nGlad to hear you are ok, though.\n\nHooray for text editor solutions! Here's a video of me doing something similar in Atom: https://www.youtube.com/watch?v=zHxxzJZsj4o\n\nedit: and here's what I wrote down for those who prefer text to videos,\n\n    Part 1\n    Text editor solution, using find and replace, multiple cursors, and a character counter.    \n\n    The untouched input has 6789 characters of code. (this includes newlines but that shouldn't matter for the purposes of our calculation.) Now use text editor trickery to remove the double quotes from the beginning and end of every line, replace \\\\ with a, \\\" with a, and \\xab with b (for any characters a and b). For a new total of 5418 characters. So a difference of 1371. Note that replacing with a non special character like a was a conscious choice, otherwise you can introduce unintended new escapes sequences.    \n\n    Part 2\n    Another text editor solution using the same tools as above.    \n\n    Again we start with 6789 characters of code. Replace each \" and \\ with aa (as each takes 2 characters to encode.) Finally add quotes to the beginning and end of every line. This leaves us with 8906 characters, for a difference of 2117.\n\nedit2: damnit. this was supposed to be an edit not a reply. :'(", "id": "cxr93zy", "owner_tier": 0.3, "score": 0.1025641023076923}, {"content": "A Python 2 solution:\n\n    def raw_char_count(s):\n        return len(s)\n\n    def escaped_char_count(s):\n        count = 0\n        i = 1\n        while i < len(s) - 1:\n            if s[i] == \"\\\\\":\n                i += 4 if s[i+1] == \"x\" else 2\n            else:\n                i += 1\n            count += 1\n        return count\n\n    def encode(s):\n        result = ''\n        for c in s:\n            if c == '\"':\n                result += \"\\\\\\\"\"\n            elif c == '\\\\':\n                result += \"\\\\\\\\\"\n            else:\n                result += c\n        return '\"' + result + '\"'\n\n    def day8_part1():\n        raw, escaped = 0, 0\n        for line in open('day8input.txt'):\n            raw += raw_char_count(line)\n            escaped += escaped_char_count(line)\n        print raw - escaped\n\n    def day8_part2():\n        enc, raw = 0, 0\n        for line in open('day8input.txt'):\n            enc += len(encode(line))\n            raw += raw_char_count(line)\n        print enc - raw", "id": "cxraj80", "owner_tier": 0.1, "score": 0.025641025384615386}, {"content": "**Q**: notice that part 2 is much simpler. For part 1 I struggled with the overlapping patterns when using the vector operators so I went with an iterative solution instead.\n\n    //Part 1\n    {sum{2+first({[n;s]$[0=count s;(n;s);s[0 1]~\"\\\\\\\\\";(n+1;2_s);s[0 1]~\"\\\\\\\"\";(n+1;2_s);s[0 1]~\"\\\\x\";(n+3;4_s);(n;1_s)]}.)/[(0;-1_1_x)]}each x}\n    //Part 2\n    {sum{2+sum x in\"\\\\\\\"\"}each x}\n\n\nSomething like this (untested, but just thowing the idea out) might be better for your part 1\n\n    {2+sum 1 1 3*sum (_[1]\\[x])[;0 1] ~/:\\:(\"\\\\\\\\\";\"\\\\\\\"\";\"\\\\x\")} each x\n\nEdit - actually that doesn't work, because of your comment about overlapping patterns!\n\nIt works if you cheat slightly using ssr:\n\n    sum {2+sum 1 1 3*sum (_[1]\\[ssr[x;\"\\\\\\\\\";\"X-\"]])[;0 1] ~/:\\:(\"X-\";\"\\\\\\\"\";\"\\\\x\")} each x\n\nIndeed ssr can be used to eliminate the iteration:\n\n    {sum{2+sum sum 1 1 3*(ssr[;\"\\\\\\\"\";\"\\001\"]ssr[;\"\\\\\\\\\";\"\\000\"][x])=/:\"\\000\\001\\\\\" }each x}\n\n> {sum{2+sum sum 1 1 3*(ssr[;\"\\\\\\\"\";\"\\001\"]ssr[;\"\\\\\\\\\";\"\\000\"][x])=/:\"\\000\\001\\\\\" }each x}\n\nUsing this it can be reduced further, ssr feels like cheating though!\n\n    600+sum/[1 1 3*(ssr[;\"\\\\\\\"\";\"\\001\"]ssr[;\"\\\\\\\\\";\"\\000\"][raze x])=/:\"\\000\\001\\\\\"]\n", "id": "cxrbxyy", "owner_tier": 0.1, "score": 0.1538461535897436}, {"content": "My shortest solution yet (using C# isn't great for that...):\n\nC#\n==\n\n    using System;\n    using System.IO;\n    using System.Linq;\n    using System.Text.RegularExpressions;\n    \n    namespace Day8\n    {\n        internal class Program\n        {\n            private static void Main()\n            {\n                var words = File.ReadAllLines(\"C:/input8.txt\");\n                Console.Out.WriteLine(words.Sum(w => w.Length - Regex.Replace(w.Trim('\"').Replace(\"\\\\\\\"\", \"A\").Replace(\"\\\\\\\\\", \"B\"), \"\\\\\\\\x[a-f0-9]{2}\", \"C\").Length));\n                Console.Out.WriteLine(words.Sum(w => w.Replace(\"\\\\\", \"AA\").Replace(\"\\\"\", \"BB\").Length + 2 - w.Length));\n            }\n        }\n    }\n\nC# isn't great for this problem anyway. If you are trying to use C# string unescaping to process the file be forewarned that in C#, hex escape sequences resolve to unicode code points and may be for example `\"\\x3ffd\"` \n\n[Regex.Escape](https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex.escape(v=vs.110\\).aspx) and [Regex.Unescape](https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex.unescape(v=vs.110\\).aspx) worked for me\n\nAfter seeing a bunch of solutions using Python's eval, I decided to make something similar for C#, emitting an assembly with input lines as static constants ... it was hilarious, but was very slow and ultimately I threw it out when I came across this issue.\n\nMy initial \"solution\" parsed an input file at compile time into a string array via T4 templates. I then compared the result of `File.ReadAllLines(\"input.txt\").Select(s=>s.Length).Sum()` to `Day8().Select(s=>s.Length).Sum()` where Day8 was the template created something like this:\n\n    partial class Program {\n        static string[] Day8() {\n            return new [] { <#= string.Join(\",\", File.ReadAllLines(\"input.txt\")) #> };\n        }\n    }\n\nThat's how I found out.", "id": "cxrf0p9", "owner_tier": 0.5, "score": 0.12820512794871794}, {"content": "PHP: Really easy day, imo, thanks to built in php functions\n\n    $one = 0;\n    $two = 0;\n    foreach (file('input.txt', FILE_IGNORE_NEW_LINES) as $line) {\n    \teval('$str = ' . $line . ';');\n    \t$one += strlen($line) - strlen($str);\n    \t$two += strlen(addslashes($line))+2-strlen($line);\n    }\n    echo \"8.1: $one\\n8.2: $two\";\n\nYup. I did pretty much the same thing, but subtracting those 2 counts (part 1), and same as you for part 2.\n\n        $totalFile += strlen($line);\n        eval(\"\\$totalMem += strlen($line);\");\n\nFor some reason, I had line-endings issues, which didn't help... I'm stealing your `FILE_IGNORE_NEW_LINES` ;)\n\nAlways cautious about using `eval()` so went for pattern matching instead\n\n    <?php foreach(file(h)as$l){preg_match_all('#(\\\\\\.)#',$l,$m);$a+=2;$b+=4;foreach($m[0]as$r){$a+=($r=='\\x')?3:1;$b+=($r=='\\x')?1:2;}}echo\"$a/$b\";\n\nHoly crap, PHP wins on this one so far for shortest (while still quite readable) implementation.", "id": "cxr7wmo", "owner_tier": 0.5, "score": 0.07692307666666667}, {"content": "Haskell\n--\n    \n    readHex :: Char -> Int\n    readHex c\n        | c >= '0' && c <= '9' = fromEnum c - fromEnum '0'\n        | c >= 'a' && c <= 'f' = fromEnum c - fromEnum 'a' + 10\n        | c >= 'A' && c <= 'F' = fromEnum c - fromEnum 'A' + 10\n    \n    \n    parse :: String -> String\n    parse [] = []\n    parse ('\\\\':'\"':xs) = '\"' : parse xs\n    parse ('\\\\':'\\\\':xs) = '\\\\' : parse xs\n    parse ('\\\\':'x':a:b:xs) = toEnum (readHex a * 16 + readHex b) : parse xs\n    parse (x:xs) = x : parse xs\n    \n    parseLine :: String -> String\n    parseLine = parse . init . tail\n    \n    part1 :: String -> Int\n    part1 input = \n        length (concat (lines input)) -\n        length (concatMap parseLine (lines input))\n    \n    part2 :: String -> Int\n    part2 input =\n        length (concatMap show (lines input)) -\n        length (concat (lines input))\n\n\nTurns out calling show on each line is all that's n eeded for the second part. `parseLine` abuses the fact that the input always has one string per line to just chop off the double quotes at the start/end.\n\n\nEdit: Thinking about it, there's really no reason for it to actually parse the hex codes. Oh well!", "id": "cxr8rch", "owner_tier": 0.3, "score": -2.5641025485193053e-10}, {"content": "Java: Used code points for Part 1 then just used StringEscape for Part 2\n\n    public static void main(String[] args) {\n        String[] input = getInput().split(\"\\n\");\n        int totalLength = 0, codeLength = 0, part2Length = 0;\n        for (String in : input) {\n            totalLength += in.length();\n            codeLength += in.length();\n            part2Length += StringEscapeUtils.escapeJava(in).length()+2;\n            int offset = 0;            \n            while (offset < in.length()) {\n                int curChar = in.codePointAt(offset);\n                offset += Character.charCount(curChar);\n                if (curChar == 34) { // if quotation\n                    codeLength--;\n                } else if (curChar == 92) {  // if slash\n                    codeLength--;\n                    curChar = in.codePointAt(offset);\n                    if (curChar == 120) { // if hex\n                        codeLength -= 2;\n                        offset += Character.charCount(curChar);\n                    } else {\n                        offset += Character.charCount(curChar);\n                    }\n                }\n            }            \n        }\n        System.out.println(\"Part 1: Total length: \" + totalLength + \" Code Length: \" + codeLength + \" Answer: \" + (totalLength - codeLength));\n        System.out.println(\"Part 2: Encoded Length: \" + part2Length + \" Total length: \" + totalLength + \" Answer: \" + (part2Length - totalLength));\n    }\n\nDeleted with [this open source script](https://greasyfork.org/en/scripts/10380-reddit-overwrite)\n\nYeah I never used it before but it was cool to play around with.", "id": "cxr9b5f", "owner_tier": 0.7, "score": 0.07692307666666667}, {"content": "I tried to replace in the strings, and I got hung up on something that looked like \"fdsa\\\\\\\\x123\" because I'd replace the escaped backslash with a single backslash, then I'd see the new escaped hex character. This was a really easy one, and I managed to bungle the heck out of it. :P\n\nIn the end, I decided to just count the number of characters I skipped. C# code:\n\n\twhile ((line = file.ReadLine()) != null)\n\t{\n\t\tcount += 2; // ignore the outer quotes\n\t\tfor (int i = 1; i < line.Length - 1; i++)\n\t\t{\n\t\t\tif (line[i] == '\\\\')\n\t\t\t{\n\t\t\t\tif (line[i + 1] == '\\\\' || line[i + 1] == '\\\"')\n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if (line[i + 1] == 'x')\n\t\t\t\t{\n\t\t\t\t\tcount += 3;\n\t\t\t\t\ti += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\nWow, my code looked almost the same except I had a foreach loop instead of a while and I forgot to do \"i++\" and \"i += 3\". The rest was literally the same.\n\nI just noticed I have \"count += 1\" right next to \"i++\" That looks kinda silly. Hope you didn't do that too. :P\n\nNope, I guess that was the third difference.", "id": "cxr9h3t", "owner_tier": 0.3, "score": 0.07692307666666667}, {"content": "Boring F# using Regex's Escape/Unescape methods (needed to account for double quotes, anyone know why they don't escape?)\n\n    open System\n    open System.Text.RegularExpressions\n    \n    [<EntryPoint>]\n    let main argv = \n        let input = IO.File.ReadLines (\"..\\..\\input.txt\")\n        let literals = input |> Seq.sumBy (fun s -> s.Length)\n    \n        literals - (input |> Seq.sumBy (fun s -> (Regex.Unescape (s.Substring (1, s.Length - 2))).Length))\n        |> printfn \"Unesecaped difference: %d\"\n        \n        (input |> Seq.sumBy (fun s -> \n            (Regex.Escape s).Length + (s |> Seq.filter (fun c -> c = '\"') |> Seq.length) + 2)) - literals\n        |> printfn \"Escaped difference:    %d\"", "id": "cxraig9", "owner_tier": 0.1, "score": -2.5641025485193053e-10}, {"content": "Scala: I just went for a FSA and traverse through each string. I could just do some regex replace magic or interpret the string, but that would be no fun.\n\n    val strings = scala.io.Source.fromFile(\"input.txt\").getLines.toList\n    \n    val stringLiteralCount = strings.map(_.length).sum\n    \n    //part 1\n    val memoryDiff = stringLiteralCount - strings.map(_.foldLeft((0, 0))((s, c) => (c, s._1) match {\n        case ('\"', 0) => (1, s._2)\n        case ('\\\\', 1) => (2, s._2)\n        case ('\"', 1) => (5, s._2)\n        case (_, 1) => (1, s._2 + 1)\n        case ('\\\\', 2) => (1, s._2 + 1)\n        case ('\"', 2) => (1, s._2 + 1)\n        case ('x', 2) => (3, s._2)\n        case (_, 3) => (4, s._2)\n        case (_, 4) => (1, s._2 + 1)\n    })).map(_._2).sum\n    \n    //part 2\n    val encodeDiff = strings.map(_.foldLeft((0, \"\"))((s, c) => (c, s._1) match {\n        case ('\"', 0) => (1, s._2 + \"\\\"\\\\\\\"\")\n        case ('\\\\', 1) => (2, s._2 + \"\\\\\\\\\")\n        case ('\"', 1) => (5, s._2 + \"\\\"\\\\\\\"\")\n        case (a, 1) => (1, s._2 + a)\n        case ('\\\\', 2) => (1, s._2 + \"\\\\\\\\\")\n        case ('\"', 2) => (1, s._2 + \"\\\\\\\"\")\n        case ('x', 2) => (3, s._2 + \"x\")\n        case (a, 3) => (4, s._2 + a)\n        case (a, 4) => (1, s._2 + a)\n    })).map(_._2.length).sum - stringLiteralCount\n\nParser combinators make this much more obvious:\n\n    object Day8 extends App with JavaTokenParsers {\n\n      val input = io.Source.fromInputStream(getClass.getClassLoader.getResourceAsStream(\"day8.txt\")).getLines.toList\n\n      // Parse each element of an input string\n      def bs = \"\\\\\"\n      def quot = \"\\\"\"\n      def escBs = bs ~ bs\n      def escQuot = bs ~ quot\n      def hex = \"[0-9a-f]\".r\n      def escChr = bs ~ \"x\" ~ hex ~ hex\n      def chr = \"[a-z]\".r\n      def char = escBs | escQuot | escChr | chr\n      def escapedLine = quot ~> (char +) <~ quot\n\n      def part1 = input.map(_.length).sum - input.map(parse(escapedLine, _).get.size).sum\n\n      // Parse each element of an input string and just output the size (doesn't depend on the input)\n      def quotLen = quot ^^^ { 2 }\n      def bsLen = bs ^^^ { 2 }\n      def escQuotLen = escQuot ^^^ { 4 }\n      def escChrLen = escChr ^^^ { 5 }\n      def charLen = oneChr ^^^ { 1 }\n      def lineLen = quotLen | escChrLen | charLen | bsLen | escQuotLen\n      def escape(line: String) = parse(lineLen +, line).get.sum + 2\n\n      def part2 = input.map(escape).sum - input.map(_.length).sum\n\n      println(s\"part1 = $part1\")\n      println(s\"part1 = $part2\")\n    }\n", "id": "cxrc88r", "owner_tier": 0.7, "score": 0.07692307666666667}, {"content": "Shortest JavaScript version:\n\n\tvar str = document.body.innerText.trim();\n\n\tvar partOne = 0;\n\tvar partTwo = 0;\n\n\tstr.split('\\n').forEach(function(s, i) {\n\t\tpartOne += s.length - eval(s).length;\n\t\tpartTwo += JSON.stringify(s).length - s.length;\n\t});\n\n\tconsole.log('Part One:', partOne);\n\tconsole.log('Part Two:', partTwo);\n\nPerhaps using eval and JSON.stringify is a little cheap though...\n\n[deleted]\n\nNice! I've been avoiding ES6 here so it still works in browser's consoles :) \n\nNice!\n\nI was thinking maybe it's possible to get the correct answer without looping. Does this work for anyone else or is it just me :\n\n    var a = document.body.textContent.trim().split('\\n');\n    var b = a.join('+');\n    var c = b.length - eval(b).length + (a.length-2) * 1.5 ;\n    console.log(c);\n\nIf it does, I guess a similar technique might be used to shorten it even more?\n:D\n\n\nthat works in firefox dev console (F12 in firefox)\n\nWow, I didn't know Firefox supported arrow functions! ", "id": "cxrdtpt", "owner_tier": 0.5, "score": 0.1538461535897436}], "link": "https://www.reddit.com/r/adventofcode/comments/3vw32y/day_8_solutions/", "question": {"content": "# NEW REQUEST FROM THE MODS\n\nWe are requesting that you hold off on posting your solution until there are a significant amount of people on the leaderboard with gold stars - say, 25 or so.\n\nWe know we can't control people posting solutions elsewhere and trying to exploit the leaderboard, but this way we can try to reduce the leaderboard gaming from the official subreddit.\n\nPlease and thank you, and much appreciated!\n\n***\n\n# --- Day 8: Matchsticks ---\n\nPost your solution as a comment. Structure your post like previous daily solution threads.", "id": "3vw32y", "title": "--- Day 8 Solutions ---", "traffic_rate": 38.3351334180432}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "\\[LANGUAGE: Python 3\\] 58/9. [Solution](https://github.com/jonathanpaulson/AdventOfCode/blob/master/2023/4.py). [Video](https://youtu.be/tXnPMSSQgCU).\n\nHad a wrong answer on part 1 because I didn't read the scoring system carefully enough. It's interesting that the part 2 answer was small enough that you could afford to simulate each card (rather than each type of card) - although that would've been more complicated to code up.\n\nVery impressed by how quickly you are able to grok the puzzle descriptions. I probably spent more time reading part 2 than you spent solving both puzzles (and even with me skipping the fluff).\n\nWow, you made the same part 1 scoring error as me and yet you got a better rank than I would have gotten had I *not* made that error? I knew you were in a league above me but still, that's crazy!\n\nAnd huh, you're right. the answer is small enough to simulate each card on its own! I hope nobody truly does that though...\n\n> I hope nobody truly does that though...\n\nI did \ud83e\udd26\u200d\u2642\ufe0f 18 seconds on my machine.\n\nI'm glad someone else did as well, I got the answer after 25 seconds. I fixed it quickly but boy was it funny. The second time I ran it, finished immediately.", "id": "kbx2cek", "owner_tier": 0.3, "score": 0.8076923075}, {"content": "[LANGUAGE: Python] 70 / 70 \n\n[Original solution](https://topaz.github.io/paste/#XQAAAQAlAgAAAAAAAAA2GkofDKPu58xc5+iCM8TfuDbYvG3mtJ9ifral3nz4Y5yYuFV53W6/9Ji7dQQOafS2+hWxZQjrWjTLFeTcMK7PhEJXzpmSLHRwVkySWTXp63xQJwFtUaQEMcC4/+yRcfDgoBawUKIR+uDREwXuziLD8Lv9zY4kKmKvXABMPOfkMPRioc/nNvl/sbzPXVG65Bz6wqtQxqvl0SMvQLttU42OYygf11ccqqCbmOKsr0nulztbfc7ptLf3dcpTttv9+4qOu2uSd7hAfIkYkcO3TBDrK8rjOGqsnu6JA/DKVpBwITPnrelYZN77vn86HoHTs+uU03b2Kmb4BRmwbve74N3WbkRyn8vHrg89XsrR3sRlSdKPLP/9UOjj)\n\n[Allez Cuisine!] golfed solution that fits in 80x5 chars\n\n    m = [len(set(l[:40].split()) & set(l[42:].split())) for l in open('input.txt')]\n    c = [1] * len(m)\n    for i, n in enumerate(m):\n        for j in range(n): c[i + j + 1] += c[i]\n    print(sum(2 ** (n - 1) for n in m if n > 0), sum(c))\n\nFirst time getting top 100 since starting 3 years ago with a few close calls :)\n\n>for line in lines:  \nx, y = map(str.split, line.split('|'))\n\nWell done on the speed!\n\n I was reviewing your solution and a potential bug (which clearly wasn't there) I found would be if the 'Card #:' was in the \"numbers you have\" section, causing an extra winning match.\n\nFor example:\n\n\\`Card **13**: 31 18 13 56 72 | 74 77 10 23 35 67 36 **13**\\`\n\nGood catch! My text editor had scrolled to the right (and cut off the first 16 columns), so I thought that the puzzle input didn't have the card number text that was present in the example input.  \n\nAnother helpful thing I noticed in the input is that the number of matches + card number never exceeds the total number of cards.\n\nActually, it's not an issue, even in your example, since str.split would result in tokens: \"Card\" and \"13:\" which doesn't match against \"13\".\n\nHaha, what luck then!\n\nI took the never exceeding for granted because of this line: \n\n[(Cards will never make you copy a card past the end of the table.)](https://adventofcode.com/2023/day/4#:~:text=(Cards%20will%20never%20make%20you%20copy%20a%20card%20past%20the%20end%20of%20the%20table.))\n\nBut I'm also slow and take time to read the full description, which I can't imagine you can do if you are getting in the top 100!", "id": "kbx2ox9", "owner_tier": 0.1, "score": 0.6346153844230769}, {"content": "\\[LANGUAGE: Vim keystrokes\\] [Allez Cuisine!]\n\nLoad your input, type the following, and your part\u00a01 answer will appear:\n\n    :%s/.*:\u27e8Enter\u27e9:%s/\\v<(\\d+)>\\ze.*\\|.*<\\1>/#/g\u27e8Enter\u27e9:%s/[^#]//g\u27e8Enter\u27e9\n    :%s/#/+1/|%s/#/*2/g\u27e8Enter\u27e9\n    GvggJ0C\u27e8Ctrl+R\u27e9=\u27e8Ctrl+R\u27e9-\u27e8Enter\u27e9\u27e8Esc\u27e9\n\nAfter removing card numbers, `/\\v<(\\d+)>\\ze.*\\|.*<\\1>/` matches any entire number which is followed by a `|` and then the same number again \u2014 so a winning number that is in the list of numbers we have. Replace it with a `#` to indicate a match. Do that for all winning numbers, then get rid of everything that isn't a `#` character.\n\nThe sample input will now look like this:\n\n    ####\n    ##\n    ##\n    #\n\n\\[plus 2 blank lines at the end\\]\n\nReplace the first `#` on each line with `+1` and any subsequent `#`s with `*2`. The sample input is now:\n\n    +1*2*2*2\n    +1*2\n    +1*2\n    +1\n\nAt which point, deploy the usual design pattern to evaluate the expression and get the answer.\n\nI'm not sure whether this counts as code golf (for \u2018Allez Cuisine!\u2019 purposes) or not? I mean, I haven't *intentionally* golfed the keystrokes; it just naturally comes out like that. \n\n**Update**: A part\u00a02 solution which loops in a fraction of a second rather than ... I dunno \u2014 hours? days? And it fits within the forum rules on code size:\n\n    :%s/.*:\u27e8Enter\u27e9:%s/\\v<(\\d+)>\\ze.*\\|.*<\\1>/#/g\u27e8Enter\u27e9:%s/[^#]//g\u27e8Enter\u27e9\n    :%s/#\\+/\\=len(submatch(0))\u27e8Enter\u27e9:%s/^/+1 \u27e8Enter\u27e9\n    {qaqqa/ \\d\u27e8Enter\u27e9lDbyiwV@-joj@0\u27e8Ctrl+A\u27e9@aq@a\n    GV{J0C\u27e8Ctrl+R\u27e9=\u27e8Ctrl+R\u27e9-\u27e8Enter\u27e9\u27e8Esc\u27e9\n\nThe first line is the same set-up as in part\u00a01: creating a histogram of matching numbers out of `#`s. Replace each string of `#`s with their length and prepend `+1` to each line, to represent initially having one of each card.\n\nConsider a line like:\n\n    +17 4\n\nThis represents 17 instances of a card with 4 matching numbers, so the cards on the next 4 lines each need their counts increasing by 17. This is what the main loop does. It finds the next match count (a number that follows a space) and deletes it with `D`, which both stops it getting in the way of future calculations and handily saves it to the `\"-` small-delete register.\n\nThen it goes back and yanks the number of cards. Yanks by default get stored in the `\"0` register, which crucially is different from `\"-`.\n\nTo increase the appropriate counts it does something like `V4joj17\u27e8Ctrl+A\u27e9`: start by visually highlighting the current line, then extend down 4 lines (or fewer if near the bottom). However, that will have highlighted *5* lines, because it includes the line we started visual mode on as well as the 4 we added. To adjust for this [fence-post error](https://en.wikipedia.org/wiki/Off-by-one_error#Fencepost_error), `o` switches control to the start of the area and `j` takes the it down a line. Then `17\u27e8Ctrl+A\u27e9` adds 17 to the first number on each highlighted line, the card count that's just after the `+`.\n\nExcept of course the `4` and `17` can't be hard-coded. Just like `@a` runs the keyboard macro of keystrokes saved in the `\"a` register, `@-` runs the keystrokes stored in `\"-`. If `\"-` contains `4` then `@-j` is like doing `4j`. Yes, this means the keyboard macro \u2018runs out\u2019 partway through a command, but try not to let that bother you; the important thing is that it works! And similarly, `@0\u27e8Ctrl+A\u27e9` prefixes the `\u27e8Ctrl+A\u27e9` operator with the number stored in `\"0`.\n\nBy the time the loop ends, all the numbers of matches will have been removed, leaving just the card counts, each preceded by a `+`. Join them together and evaluate the sum to get the answer.\n\nThis is a massive improvement on my [original solution for part\u00a02](https://topaz.github.io/paste/#XQAAAQCQAQAAAAAAAAAdCUrjWNZ9/abcThvzfkP19gZqForEVZjvEhO2UlYWMVlRFzaf7gZ3A9HYMu5bWbm7kDHxUfkMfYwMcU6A5WVoxDrb0VyxQz/HMfuBAuGs710WB+H3z1rSfGBotXHACtLthrSYuQqdCPef2Qy+DZY0400IjY8R0e3so3QVRlph+FY7RYoPvqhEEX62zdnJ+vS6Fo7JsZZokh5GVWwdXEOaJVMFVrf9DG6Gc89A//9WgDwA), which represented each instance of a card visually with `#`. This worked fine on the sample input, but on my real input ... well, since I set it off, I've eaten breakfast, showered, tidied away [last night's board game](https://boardgamegeek.com/boardgame/269207/taverns-tiefenthal), walked a child to their bus stop, implemented the faster version above, and written up this explanation of it, and it's still going. I don't *think* it's going to reach [Matt Parker-like levels](https://www.youtube.com/watch?v=c33AZBnRHks) of percentage speed-up between it and the fastest solution, but we can't be sure yet. (I'll move its original explanation to a reply for posterity.)\n\n**Update\u00a02**: I `\u27e8Ctrl+C\u27e9`ed it after 6\u00bd\u00a0hours (because we needed the fan to stop being so noisy). Vim's status line said `50%`. It was processing line 99 of 196, and the first 96\u202f593 copies of the card on that line had been processed (the `#`s already turned into `.`), with 238\u202f662 cards still to go. Line 100 already has 330\u202f651 `#`s on it. So optimistically it was about halfway through. Realistically, the lines have been getting longer so it probably had much more than half to go, and it might not have finished before the boat leaves tomorrow.\n\nMy input file is 218 lines and my answer is 7 digits long, with the highest number of copies weighing in at more than 846,000.  I'd love to hear what your vim tells you tomorrow morning (especially if it's not `core dumped` :-)\n\nThanks for sharing these; I like to tell coworkers about vim keystrokes solutions when repping AoC.\n\nThe final answer for my input is about 10 million, so I'd expect that it just takes a while.\n\nThere's almost certainly to do it that doesn't involve using a character count, but I'm not good enough at using Vim to be able to come up with anything other than making like 100 #s in a row become a different character that gets processed separately.", "id": "kbx9rnq", "owner_tier": 0.3, "score": 0.42307692288461535}, {"content": "[LANGUAGE: Dyalog APL]\n\n    p\u2190\u2283\u2395nget'04.txt'1\n    c\u2190{\u2262\u2283\u2229/\u234e\u00a81\u2193\u2375\u2286\u2368~\u2375\u220a':|'}\u00a8p\n    +/\u230a2*c-1 \u235d part 1\n    m\u21901=d\u2218.\u2378\u23681+d,\u00a8c+d\u2190\u2373\u2262c\n    +/,\u2339m-\u2368\u2218.=\u2368d \u235d part 2\n\n[Video walkthrough](https://www.youtube.com/watch?v=mxBo-G6M8eQ)\n\nApparently the infinite series sum of matrix exponentiations [converges to (\ud835\udc3c\u2212\ud835\udc34)^\u22121](https://math.stackexchange.com/questions/867768/geometric-series-of-matrices), thanks to rak1507 on the APL discord for pointing that out!\n\n/r/adventofcode moderators: \"No oversized code, please.\"\n\n/u/voidhawk42 writing Alien Programming Language: \"Hold my eggnog and watch this...\"\n\nHow long did it take you to become proficient in that language? That's some _dark art_ right there.\n\nIs this actually a language or did you make this up?\n\n[removed]\n\nThe trick is finding a card punch that will handle unicode symbols.\n\nCouple years in a remote mountain monastery, nbd\n\nApparently it worked just fine on the [IBM 1130](https://aplwiki.com/wiki/APL%5C1130)!", "id": "kbx6jey", "owner_tier": 0.1, "score": 0.9999999998076923}, {"content": "\\[LANGUAGE: python3\\]\n\n89/437\n\nFirst time getting leaderboard in my life!\n\n    f = open(\"input.txt\").readlines()\n    \n    s = 0\n    cards = [1 for _ in f]\n    \n    for index, line in enumerate(f):\n        line = line.split(\":\")[1]\n        a, b = line.split(\"|\")\n        a, b = a.split(), b.split()\n    \n        n = len(set(a) & set(b))\n    \n        if n > 0:\n            s += 2 ** (n - 1)\n    \n        for i in range(n):\n            cards[index + i + 1] += cards[index]\n    \n    print(s, sum(cards))\n\nAround 0.9ms to run :)\n\n> First time getting leaderboard in my life!\n\nGood job!", "id": "kbx6htf", "owner_tier": 0.1, "score": 0.40384615365384613}, {"content": "[LANGUAGE: Python] [Code (9 lines)](https://topaz.github.io/paste/#XQAAAQAXAQAAAAAAAAAyGEruliPhODr/frYqPjojYEeXt7yUg8aNchva8dxIoouH0VOBev9LNfRCH+gX/XFKQ/FclodPBLz2EZcZrt0fE46SPy0DEMO9XvtstH3xkuZ91+U1ml/nRtEfH+dqXTpJZQ5uFDB1ZqYgpr43YBBwqRb4B+XM/B8Fon31dfZnFH1DQNKM7MGnFqL/BcgdYk468dOwn3yzpQwJm2MrhdCEmyMgzNqyOW1vJs/bshSdrizgYLjg8NsXzFbfK7B/+nvwBf555+8=)\n\nNothing clever today, but I like this part:\n\n    win, have = map(str.split, line.split('|'))\n\n    for j in range(len(set(win) & set(have))):\n        p1[i] *= 2\n        p2[i+j+1] += p2[i]\n\nwouldn't this fail on some inputs because you don't strip the \"Card %f: \" part?\n\nNope, we do get additional winning \"numbers\" `Card` and e.g. `1:` (note the colon), but those will never match the numbers we have.", "id": "kbxb2fc", "owner_tier": 0.3, "score": 0.28846153826923077}, {"content": "[Language: Rockstar]\n\nListen to my [words](https://topaz.github.io/paste/#XQAAAQAHBgAAAAAAAAAmnkAG07by9u1AZ+DYUoAIbLHQDbn8LGmwUqfKbPMBzrMN4VovQvK33rtK5dN3vaLvRWZxXwuso85Q0FtBRvb9upvnFT3mdogVYqFpAhzr5OF6kTi1gQ6X3c2l7ffzWIuFpQ1GkfyG10Mw0sKtDU8byp9BeaXh8D42ur+LghjtpG5VQDEtOIIl2x1YKssE1YhaoHsePR+7Dk7HHhZ/TB7nWhMCFyaHrgljydmxKqqd92jG0ZtD6QnQKek9kg6o4HN/E3uq1fhApny5G3RW4bf4uKvP5zrEHfEMlHz7KkpNlz0lv0zro1AvZ7kdZMkSK4y7kkf7v9dUUp7nMglny3l1DtCv7w68nNKfUPpe7CYt6e0L91dsXC6pBmlBwFHPwPg2e/PDG+VhLRP4l7oSYC6bfN8xWXaKwQvc+thHhVIJiSjZYs4/xkPrMKRhBXVpD/oYiWGl9LZD8R6cIhzPIEwpiPDO6OJSwgblbC/+oZdC3HKNJaRnofnHHEA+T5+2xrAAnYCQRJ4TR5XF3gNocalnf9tObnI0yCHaZmz71Ovk3pOW4UjWsfm0BTW+B52yza2S/QWqxpXRMkol6vSiebwyS54ysz9l18EMCDG2NT9d38GSWwuxPluotWSdqxcL8zSCY1RfmsioZm2BTI15OsgMjZE+rKzljJxY9OwEwqjtfF+zmzVNGOkdKKZLv0E//YThYg==) for they carry knowledge of thine winnings...\n\nListen to [part 2](https://topaz.github.io/paste/#XQAAAQCiBwAAAAAAAAAmnkAG07by9u1AZ+DYUoAIbLHQDbn8LGmwUqfKbPMBzrMN4VovQvK33rtK5dN3vaLvRWZxXwuso85Q0FtBRvb9upvnFT3mdogVYqFpAhzr5OF6kTi1gQ6X3c2l7ffzWIuFpQ1GkfyG10Mw0sKtDU8byp9BeaXh8D42ur+LghjtpG5VQDEtOIIl2x1YKssE1YhaoHsePR+7Dk7HH1eoPeLI1Uz/nFyLaz1KFdd3bzCgS5sFPfGeI7o0umN1k+5LV13xDy901DyJhv463T/1mh0hoGzZFFKoARRcn3cBhoFv2D53V+HtDuMyY9qspzXeUReCto7yx512tMfxpG/x5se7mZu/nD5s52a0dVA8juRhjsOPbFyvR1bLoo0xCE8Ax8pdeTVpxHakOxLDXPykoNYDRarDHZfJ25NzyccUbD3DmatJ6UzjvC+lQ1D7ZOnqqo7kzwhNrTCgRckkBP7LdS/yjjByblr6FikDegTmX+xNLkga5grx+Q3NrgoMelFUJBgPp7HkjIRa1LATMtcY+JdCcwH7jTnaGczKQPNi57etzCW9lXKBMNHGOeYhZRdzByv7sJw+2u82rCsHTtMhd37HCuXkotiznxnte0m1NwJeTqRGm/MAMk+X1NHhbyG6AZvORV3U2+eMSd6pCmFSHgtHURRCb8d9m8kufkGHVnF1mtWMfJ+CTUubtyLF989wbkCTBiiV6CzDToGmSP7qCeimZzU/GatvFGkJg41WmtGRO9O0wt7/fc8o6+Kj9phGU3Aia6uTUHPgUWwBf4itVwmsr0MpQOB2pyduovtU1AtxyFUN7tNwxHXOzhSF1DZTwLGsPVNcaUynAi4gNZvPk3pIPwXjkp0hV0GBaETVAna8ALJGOP/2zYdX) instead, would thou wish knowledge of thine truest winnings...", "id": "kbx81lp", "owner_tier": 0.9, "score": 0.1153846151923077}, {"content": "\\[LANGUAGE: Google Sheets\\]\n\n*Assuming the input is in A:A*\n\nOne formula for both parts\n\n    =MAP({3,2},LAMBDA(i,\n      SUM(INDEX(\n        LET(crds,SEQUENCE(ROWS(A:A)),\n            REDUCE({crds,crds^0,crds^0-1},\n                   crds,\n                   LAMBDA(a,i,LET(s,SPLIT(TOCOL(SPLIT(REGEXEXTRACT(SUBSTITUTE(INDEX(A:A,i),\" \",\"x\"),\":x(.*)\"),\"|\")),\"x\"),\n                       m,SUM(COUNTIF(INDEX(s,2),INDEX(s,1))),\n                       IF(m=0,a,a+IF(COUNTIF(SEQUENCE(m)+i,INDEX(a,,1)),{0,INDEX(a,i,2),2^(m-1)/m})))))),,i))))\n\nI'm going to try this just for fun because I think it's impressive", "id": "kbx8tzd", "owner_tier": 0.3, "score": 0.15384615365384616}, {"content": "\\[LANGUAGE: x86\\_64 assembly with Linux syscalls\\]\n\nAlas, even 8086 assembly would be far too late for actual punchcards,  and I would also need at least an 80386 to get 32 bit integers, a soft requirement given the size of numbers eventually encountered in the problem.\n\n[Part 1](https://github.com/JustinHuPrime/AoC/blob/main/2023/4a.s) was parsing; this was a bit fiddly, I needed to be careful about whether I interpreted the numbers as having leading whitespace (the correct way) or trailing whitespace (incorrect, since I'd be skipping the newline at the end). The actual computation was relatively nice, involving a nonconstant shift left to do the exponentiation of the base 2 required.\n\n[Part 2](https://github.com/JustinHuPrime/AoC/blob/main/2023/4b.s) was more of a fibonacci-type problem. Re-using the parser from part 1, I had to keep two lists - one list mapping the card number to the number of wins for one card, and another counting the number of cards. The one counting the number of cards had to be zero-terminated, a fact which I forgot, since I wanted to operate on variable length data (either the example or the actual input, since my personal rules require me to write code that accepts either the example or the actual input depending on what filename is passed in as a command line argument).\n\nThe actual computation was relatively straightforward, but the debugging was not. I ended up learning about GDB's foibles - it considers global labels to be actual variables and not the pointers that they so obviously are. (Well, I suppose if you're one of the folks who uses a compiler, global labels are actually variables, but this is at odds with how they're treated in assembly.)\n\nPart 1 and part 2 run in 1 ms; part 1 is 8232 bytes long, and part 2 is 8480 bytes long. I think the shrinking size is because I moved a global from the .data section to the already-existing .bss section. Since I no longer used the .data section, this could be omitted from the generated executable, saving quite a bit of space, apparently.", "id": "kbxd3du", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "\\[Language: Python\\] one-line/single-expression solutions\n\nHad fun with this one! A short solution for part 1, using as an heuristic, that numbers on each side are distinct, and a functional-style one for part 2:  \n\n    from functools import reduce\n    from itertools import chain, repeat\n    from operator import add\n\n    #print(sum((1<<len(s)-len({*s}))//2 for s in map(str.split,open(0))))\n\n    print(reduce((lambda r,x:(c:=next(r[1])) and (r[0]+c,chain(map(add,repeat(c,x),r[1]),r[1]))), (len(s)-len({*s}) for s in map(str.split,open(0))), (0,repeat(1)))[0])\n\nhttps://github.com/kaathewise/aoc2023/blob/main/4.py", "id": "kbxrpuj", "owner_tier": 0.1, "score": 0.0576923075}, {"content": "[LANGUAGE: Haskell]\n\nReally proud of my solution today, short and efficient, with no explicit recursion c:\n\n    module Main where\n    \n    import Control.Arrow (second, (&&&))\n    import Data.List (intersect)\n    import Data.Tuple.Extra (both)\n    \n    main :: IO ()\n    main = interact $ (++ \"\\n\") . show . (part1 &&& part2) . map parse . lines\n    \n    part1 :: [([Int], [Int])] -> Int\n    part1 = sum . map ((\\n -> if n >= 1 then 2 ^ (n - 1) else 0) . countMatches)\n    \n    part2 :: [([Int], [Int])] -> Int\n    part2 = sum . foldr (\\c l -> 1 + sum (take (countMatches c) l) : l) []\n    \n    countMatches :: ([Int], [Int]) -> Int\n    countMatches = length . uncurry intersect\n    \n    parse :: String -> ([Int], [Int])\n    parse = both (map read) . second tail . span (/= \"|\") . drop 2 . words\n\n[removed]", "id": "kbylhkw", "owner_tier": 0.1, "score": 0.1153846151923077}, {"content": "\\[LANGUAGE: C/C++\\]\n\n[Part 2 in 23 lines of code](https://imgur.com/a/uitewZA)\n\n(Solved on stream in twitch channel `clbi`)\n\nRuns in about two minutes on my Commodore 64. (runtime is dominated by disk accesses)\n\nEDIT: Also benchmarked the same code on AMD Ryzen 5950X, which took about 0.00075 seconds. (making it about 160,000x times faster than the C64)\n\n[Daily journal](http://clb.confined.space/aoc2023/)", "id": "kbylkw4", "owner_tier": 0.1, "score": 0.07692307673076923}, {"content": "[LANGUAGE: Python3]\n\n10th place, 22nd place\n\n    ll = [x for x in open(\"input\").read().strip().split('\\n')]\n    p1 = 0\n    multiplier = [1 for i in ll]\n    p2 = 0\n    for i,l in enumerate(ll):\n    \twinning = set([int(x) for x in l.split(\":\")[1].split(\"|\")[0].strip().split()])\n    \thave = [int(x) for x in l.split(\"|\")[1].strip().split()]\n    \thave = [x for x in have if x in winning]\n    \tif len(have):\n    \t\tp1 += 2**(len(have)-1)\n    \tmymult = multiplier[i]\n    \tfor j in range(i+1,min(i+len(have)+1,len(ll))):\n    \t\tmultiplier[j]+=mymult\n    \tp2 += mymult\n    print(p1, p2)\n\nScreen recording: https://youtu.be/IsOIBSoY85k", "id": "kbx205p", "owner_tier": 0.3, "score": 0.01923076903846154}, {"content": "\\[LANGUAGE: Python 3\\]\n\n[Part 2](https://topaz.github.io/paste/#XQAAAQB4BAAAAAAAAAARiEJHiiMzw3cPM/1Vl+2nx/DqKkM2yi+AsNSFTsnyEq6tvQ194NdE8s9q6Leu5NmZVE5/n7GL1GFISjxyXY2GpDwJ0iaL/CLTJZCVRPPBEn7RPpzqCVVteloODLtLhqzANIlee3Fa91uFAds36UOFmUU+lImtLBkWYfuB8E2vWJPjYA3TcTsuFfR6dnebT+R/CiNwQe4GtQ+QkRKwZNxHqO5wkSk03Chuvkhj15TuoMlEqmUvZBXNVPLWKVCMXah2+pj2HwvbLKGrLUGSOmZkmb2wuW5smYGlJ/efSUMnIWIc2v/y7BnFUqDJg2EG/VA5ltsj+W17sgKxcOApcrrHsn6PjKm0wl2BPsScOTNLiodFqkjYdGvF1y8vzc3FQMdRSkcjO8aKUkAA7PjYQFLZLDvTDT1109HZDIfPusxMv+Jd1FHWn8RBo+F6g5c3s9hlqKC0VI6RSLpqUGOIdEmxFT7SRN6k7Nuj1LwI1rsi70cfrUq7SILT1w0RXsEOU5JfC9ihphmV/1HeFM+w3MjFfxjs3hzH/on1u1Y6snCMf7MGTrwWrMTU+CALmvkRGjmofAGqFVXbba8DAdkVOfdwYPqzWh0yqF2AnKBwoCKnALpISydqafFcGSGBEgQSi1stP0foTnRCS+1qAxhUkmJaQJaAvwMbUv5gh+8=)\n\nFortunately no recursion needed. Just add whatever count the current card number has to the x cards that follow.\n\nIf this were later in the month we'd be making copies of *specific* cards, such as \"multiply the Card Id \\* winning number, you get another of *that* card\". But how would it ever end?\n\nMy real job isn't Python which is why I'm lacking in the list comprehensions the cool kids use.", "id": "kbx6cn6", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "[LANGUAGE: Forth] [Allez Cuisine!]\n\nFor *Allez Cuisine!*, I minimized my part 1 to less-than-punchcard size. It even executes your input file directly as code and automatically detects the scratchcard's size! Simply download your `input` file to the same directory and call `gforth part1.fth` (or use some other Forth that supports `include`). Code below:\n\n    0 : C create 0 , ; C W C M : D depth 1- ; : R here W @ over + swap ; : | W @ 0=\n    if D W ! then R do i c! loop ; : T 0 M @ 0= if D 1- M ! then M @ 0 ?do swap pad\n    ! 0 R do i c@ pad @ = + loop - loop 1 swap lshift 2/ + ; : Card T C ;\n    include input T . bye\n\n[https://github.com/tcsullivan/advent-of-code/tree/master/day4](https://github.com/tcsullivan/advent-of-code/tree/master/day4)", "id": "kbzo1dj", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "[Language: Perl] 2958 / 3056\n\nPart 1 was super straightforward. A had to read Part 2 over a couple of times to make sure I had it straight, and then I worried that the numbers might get huge, but thankfully they don't.  (A really big winning streak would be nasty!)\n\n[paste](https://topaz.github.io/paste/#XQAAAQDRAgAAAAAAAAA6nMjJFMpQu0F8vIUYL9H7bktreB2yFuCaEtxuf6Wx5iNAuLM1BuaPqLfKCPLaBP9V88XIqYfHWVeib7mZp5H8p/3aPHjl9ODn3d2kvacsUP3ZDk5fEbMzs3CIy7GeytyU+TmxASt500I5HnlZR09ogxvgLlAsGsbVnOwhMYldPe7DFC6yAsXAhV21+dixErujF7/NB06NnEUlZQyDI74AAwQfjXqXdusxd1WwwizWtqtfSfY+oHVFchSW6dRT3E/Q+jshCBL7ce4EBpCQEi0JoedtSCqXh/5T4fH8ZX76K9f3qtT6HL3t+9cllcQkP+SP3ODovY+M8HGL8y1PiU5r+VpH0zYqk3ld1swRexgwHfNZ8gH8mom5MvIbvlSdDGCl/vkju1MRF5vvk9b6X4QAliX4ewzSM15lpeEkdQuP6i/eiWMdwBFX/fiLmvo=)", "id": "kbx4z7c", "owner_tier": 0.1, "score": 0.01923076903846154}, {"content": "\\[LANGUAGE: Perl\\]\n\nPart 2\n\n(a) No need to split the winners and picks, just find the ones that appear more than once. Perl has a cute FAQ idiom using a hash to find duplicates.\n\n(b) Recursion will kill us if we try to calculate the matches every time.  Do it one pass while reading the input.\n\n(c) There's no need to carry the lists around; it's all a function of match counts and id numbers. Sequential id numbers make great array indexes.\n\n        use v5.38;\n    \n    use List::Util qw/sum/;\n    \n    use Getopt::Long;\n    my $Verbose = 0;\n    GetOptions(\"verbose\" => \\$Verbose);\n    \n    # Find numbers that occur more than once\n    sub countMatch($n)\n    {\n        my %seen;\n        $seen{$_}++ for $n->@*;\n        return scalar grep { $seen{$_} > 1 } keys %seen;\n    }\n    \n    # Make one pass to save number of matches on each card\n    my @Match;\n    while (<>)\n    {\n        my @n = m/(\\d+)/g; # Extract all the numbers\n        my $id = shift @n; # Remove the id number\n    \n        $Match[$id] = countMatch(\\@n);\n    }\n    \n    my @Count = (0) x @Match;   # Array same size as Match\n    sub countCard($id, $indent) # Recursive\n    {\n        $Count[$id]++;\n        say \"${indent}[$id] -> $Match[$id], $Count[$id]\" if $Verbose;\n        return if $Match[$id] == 0;\n    \n        for my $next ( $id+1 .. $id + $Match[$id] )\n        {\n            countCard($next, \"  $indent\") if exists $Match[$next];\n        }\n    }\n    \n    countCard($_, \"\") for 1 .. $#Match;\n    say sum @Count;", "id": "kbyg9a1", "owner_tier": 0.1, "score": 0.03846153826923077}, {"content": "\\[LANGUAGE: uiua\\]\n\n    # Parse and count\n    \u229c(\u21981\u229c\u25a1\u00ac\u220a,\":|\")\u2260@\\n.\n    \u2261(/+\u228f\u234f.\u2260\u2299\u29fb \u2297\u2299.\u2229(\u2290\u229cparse\u2260@ .) \u2283\u22a2(\u22a11))\n    .\n    # Part 1\n    /+\u230a\u207f:2-1\n    :\n    # Part 2\n    \u22990\n    :\u21af:1\u29fb.\n    ;\u2227(\u2299+:\u2299\u2b1a0+:\u21af\u2299(.\u2283\u22a2(\u21981)))", "id": "kbzu7fl", "owner_tier": 0.3, "score": 0.03846153826923077}, {"content": "[Language: Python]\n[Allez Cuisine]\n\nHow do I save more characters?\n\n    c=[len({*l[10:39].split()}&{*l[42:].split()})for l in open(\"f\")]\n    q=[1]*len(c)\n    for i,x in enumerate(c):\n     for j in range(x):q[i+j+1]+=q[i]\n    print(sum(2**x//2 for x in c),sum(q))", "id": "kc0g8ea", "owner_tier": 0.1, "score": 0.01923076903846154}, {"content": "[LANGUAGE: Common Lisp]\n\nPart 2 took my way too long because I forgot that I had to count the base tickets too, and not just the extra ones.\n\n    (defun make-ticket (line)\n      (flet ((parse (lst) (mapcar #'parse-integer  (remove-if #'str:emptyp lst))))\n        (destructuring-bind (card winning-nums ticket-nums)\n            (ppcre:split \"[|:]\" line)\n          (declare (ignorable card))\n          (list\n           (parse (ppcre:split \"\\\\s+\" winning-nums))\n           (parse (ppcre:split \"\\\\s+\" ticket-nums))))))\n    \n    (defun fold-to-score (ticket)\n      (let ((winning-nums (car ticket))\n            (ticket-nums  (cadr ticket))\n            (score        0))\n        (dolist (num ticket-nums score)\n          (when (member num winning-nums) (incf score)))))\n    \n    (defun count-tickets (tickets &key (total 0) count)\n      (if (null tickets)\n          total\n    \n          (flet ((update-count (n multi cur-count)\n                   (loop :for k :from 0 :below (max n (length cur-count))\n                         :collect\n                         (let ((cur (nth k cur-count)))\n                           (cond\n                             ((and cur (< k n)) (+ multi cur))\n                             (cur cur)\n                             ((< k n) multi))))))\n    \n            (let ((wins  (fold-to-score (car tickets)))\n                  (multi (1+ (or (car count) 0))))\n              (count-tickets\n               (cdr tickets)\n               :total (+ total multi)\n               :count (update-count wins multi (cdr count)))))))\n    \n    (defun solve-1 ()\n      (reduce\n       #'+\n       (mapcar\n        (compose\n         (lambda (score) (if (> score 0) (expt 2 (1- score)) 0))\n         #'fold-to-score\n         #'make-ticket)\n        (uiop:read-file-lines \"./input/04.txt\"))))\n    \n    (defun solve-2 ()\n      (count-tickets (mapcar #'make-ticket (uiop:read-file-lines \"./input/04.txt\"))))", "id": "kc0pg1j", "owner_tier": 0.7, "score": -1.9230769113894788e-10}], "link": "https://www.reddit.com/r/adventofcode/comments/18actmy/2023_day_4_solutions/", "question": {"content": "## NEWS\n\n* Solutions in the megathreads have been getting longer, so we're going to start enforcing [our rules on oversized code](https://reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines#wiki_no_giant_blocks_of_code).\n    * Do not give us a reason to unleash AutoModerator hard-line enforcement that counts characters inside code blocks to verify compliance\u2026 you have been warned XD\n* Before creating a `Visualization`, please review [the guidelines for creating `Visualization`s](https://reddit.com/r/adventofcode/wiki/visualizations) as there's good advice relating to accessibility, readability, colors, timing, etc.\n* Posts containing AI-generated art *must*:\n    * Use the [standardized post title syntax](https://www.reddit.com/r/adventofcode/wiki/posts/standardized_titles)\n    * [Indicate in their titles](https://reddit.com/r/adventofcode/wiki/posts/post_flair#wiki_funny) with the tag `[AI art]`\n    * [Use the `Funny` post flair](https://reddit.com/r/adventofcode/wiki/posts/post_flair#wiki_funny)\n\n## THE USUAL REMINDERS\n\n* All of our rules, FAQs, resources, etc. are in our [community wiki](https://reddit.com/r/adventofcode/wiki/).\n* Outstanding moderator challenges:\n    * [Advent of Playing With Your 3D-Printed Toys](https://www.reddit.com/r/adventofcode/comments/188kp2w/2023_day_125_my_3d_printed_advent_of_code_calendar/kblu78n/)\n* Community fun event 2023: [ALLEZ CUISINE!](https://reddit.com/r/adventofcode/comments/1883kn1/advent_of_code_2023_allez_cuisine_submissions/)\n   * ***2 DAYS*** remaining until unlock!\n\n***\n\n## AoC Community Fun 2023: ALLEZ CUISINE!\n\nToday's theme ingredient is\u2026 \\**whips off cloth covering and gestures grandly*\\*\n\n## PUNCHCARD PERFECTION!\n\nPerhaps I should have thought yesterday's Battle Spam surfeit through a little more since we are all overstuffed and not feeling well.  Help us cleanse our palates with leaner and lighter courses today!\n\n* [Code golf](https://en.wikipedia.org/wiki/Code_golf).  Alternatively, [snow golf](https://en.wikipedia.org/wiki/Snow_golf).\n* Bonus points if your solution fits on a \"punchcard\" as defined in our wiki article on [oversized code](https://reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines#wiki_no_giant_blocks_of_code).  We *will* be counting.\n* Does anyone still program with actual punchcards?  >_>\n\n***ALLEZ CUISINE!***\n\n*Request from the mods: When you include a ~~dish~~ entry alongside your solution, please label it with `[Allez Cuisine!]` so we can find it easily!*\n\n***\n\n# --- Day 4: Scratchcards ---\n\n***\n\n## Post your code solution in this megathread.\n\n* Read the [full posting rules](https://reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines) in our community wiki before you post!\n    * State which [language(s) your solution uses](https://www.reddit.com/r/adventofcode/wiki/solution_megathreads/post_guidelines#wiki_state_your_programming_language.28s.29) with `[LANGUAGE: xyz]`\n    * Format code blocks using the [four-spaces Markdown syntax](https://www.reddit.com/r/adventofcode/wiki/faqs/code_formatting/code_blocks)!\n* Quick link to [Topaz's `paste`](https://topaz.github.io/paste/) if you need it for longer code blocks\n\n\n###~~This thread will be unlocked when there are a significant number of people on the global leaderboard with gold stars for today's puzzle.~~\n\n###*EDIT:* Global leaderboard gold cap reached at 00:07:08, megathread unlocked!", "id": "18actmy", "title": "-\u2744\ufe0f- 2023 Day 4 Solutions -\u2744\ufe0f-", "traffic_rate": 38.3351334180432}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}, {"answers": [{"content": "Is golfing welcome here?  I'll delete if not.\n\nPerl:\n\n    perl -ane 'printf\"$x %+d\\n\",$.if$_=$h{$x=$F[0]}and$.=$F[1]-$_;$h{$x}=$F[1]'\n\n\nEDIT: I'll explain in case anyone's curious:\n\n     1     perl -ane           # -e means \"Here's the script on the command line\"\n     2                         # -n means \"and run this script on each line of input\"\n     3                         # -a means \"but first split each line on whitespace\n     4                         #           into an array named @F.\"\n     5 \n     6     printf \"$x %+d\\n\",  # Do a formatted print of the item name\n     7                         # we'll save in $x on line 22.\n     8                         # \"%+d\" means put a plus in front of the number\n     9                         # if it's positive.\n    10            $.           # The second argument to printf (the price change),\n    11                         # which we store in variable \"$.\" on line 28.  We use\n    12                         # $. instead of a normal variable like $d because\n    13                         # that allows us to say \"printf ...,$.if ...\", while\n    14                         # if we used a letter \"printf ...,$dif ...\" wouldn't\n    15                         # parse.\n    16 \n    17     if                  # We only print that if ...\n    18     $_ =                # (just a sec: we tuck away $h{$F[0]} in $_ to save characters...)\n    19 \n    20     $h{                 # OK, we only print that if there's something in the %h hash table\n    21                         # with our item name.\n    22         $x =            # We tuck away $F[0] (the item name) in $x to save characters\n    23         $F[0]           # This is the item name, which we're using as our hash key.\n    24     } \n    25     and                 # We use \"and\" instead of \"&&\" because it's lower precedence,\n    26                         # which allows us to do an assignment next without any parens.\n    27 \n    28     $. =                # Save the price difference for use on line 10.\n    29     $F[1]               # The new price (we didn't get this far on the old price because\n    30                         # of the if on line 17). \n    31 \n    32     - $_;               # Minus the old price, which we saved on line 18. Only print if non-zero.\n    33 \n    34     $h{$x} = $F[1]      # Now we just put the price into the hash, using the $x alias\n    35                         # for $F[0] we stored on line 22.  This is only relevant for the\n    36                         # run through the old prices.\n\n\nI think the easy problems are an excellent chance to code golf.  \n\nWhat's the minimized metric on golfing? Characters, lines, readability...? :)\n\nYou're a wizard Harry! But no, seriously, nice job. \n\nJust don't try to figure them out if you're an \"easy\" level programmer yourself :D\n\nWell, do actually.. but prepare to be saying \"WTF\" \n\nLines then characters. Readability is a moot point imo.\n\nCharacters for sure.\n\nI'm just a duffer compared to the Perl golfers of the 90s.  I've added an explanation if you're curious how it works.\n\nThanks :D", "id": "cdzmla0", "owner_tier": 0.5, "score": 0.9999999998}, {"content": "Haskell:\n\n    import Control.Monad\n    import qualified Data.Map as M\n    import Text.Printf\n    \n    main = do\n        n <- readLn\n        let toRow l = let [w1, w2] = words l in (w1, read w2)\n            readMap = fmap (M.fromList . map toRow) (replicateM n getLine)\n        xs <- readMap\n        ys <- readMap\n        let zs = M.toList (M.filter (/= 0) (M.unionWith (-) ys xs))\n        forM_ zs $ \\(key, val) -> do\n            printf \"%s %+d\\n\" (key :: String) (val :: Int)\n\n\nI've wishlisted 'Learning you a haskell for great good' for christmas. Good god I hope I get it!\n\nI've just starting reading this book just yesterday.  It's a fun change of pace from the usual curly-brace languages we're familiar with.  Back in college I had to learn Scheme and Common Lisp.  This functional language is syntactically much different than the above Lisp dialects, and seems to be much more expressive and suitable for \"real world\" programming (but I admit to being very naive still - just 1 day of experience).  I also want to have a look at Scala and Erlang some day (after I'm able to do exercises like these in Haskell).\n\nThe book is so good that it put most of the novels I read to a shame.", "id": "cdzpelq", "owner_tier": 0.7, "score": 0.3399999998}, {"content": "Python 2.7\n\n    with open('file.txt') as f:\n        n = int(f.readline())\n        data = [line.strip('\\n').split() for line in f.readlines()]\n        oldist, newlist = data[: n], data[n:]\n\n    for k1, v1 in oldist:\n        for k2, v2 in newlist:\n            if k1 == k2 and v1 != v2:\n                print \"{} {:+}\".format(k1, int(v2) - int(v1))\n\n\nI like this - my mind was locked into using a dict, but using lists like this works fine and most importantly - is very readable", "id": "ce00w1e", "owner_tier": 0.5, "score": 0.17999999979999998}, {"content": "After spending an hour and a half determined to get this done in Brainfuck, I gave up and gave it a go in bash.\n\nThere's gotta be a better way, though... anyone with better command-line-fu want to give it a go? (Also, how does `sed \"N;s/\\n/ /\"` work?)\n\n    let n=$(head -n 1 $1)\n    sed -n \"2,$ p\" $1 |\n    sed \"1,$n s/ / a /\" |\n    sed \"$(($n+1)),$ s/ / b /\" |\n    sort |\n    awk '{print $1,$3;}' |\n    uniq -u |\n    sed \"N;s/\\n/ /\" |\n    awk '{print $1, $4 - $2;}' |\n    sed \"s/ \\([0-9]\\)/ +\\1/\"\n\nUsage: ./nutsnbolts.sh [INPUTFILE]\n\nNot sure how to make it use standard input instead of having to read a file.\n\nExplanation:\n\n    # Some example input:\n        # 3\n        # Cat 20\n        # Elephant 90\n        # Dog 30\n        # Elephant 90\n        # Cat 25\n        # Dog 20\n\n    # Take everything after the first line:\n        # Cat 20\n        # Elephant 90\n        # Dog 30\n        # Elephant 90\n        # Cat 25\n        # Dog 20\n    let n=$(head -n 1 $1)\n    sed -n \"2,$ p\" $1 |\n\n    # Insert \"a\" in between item and price for the old data, and \"b\" for the new\n    # data\n        # Cat a 20\n        # Elephant a 90\n        # Dog a 30\n        # Elephant b 90\n        # Cat b 25\n        # Dog b 20\n    sed \"1,$n s/ / a /\" |\n    sed \"$(($n+1)),$ s/ / b /\" |\n\n    # Now when we sort we get the items in order, with old price first and new\n    # price second:\n        # Cat a 20\n        # Cat b 25\n        # Dog a 30\n        # Dog b 20\n        # Elephant a 90\n        # Elephant b 90\n    sort |\n\n    # Delete the added a's and b's and then keep only unique lines, so we get just\n    # the items with changes:\n        # Cat 20\n        # Cat 25\n        # Dog 30\n        # Dog 20\n    awk '{print $1,$3;}' |\n    uniq -u |\n\n    # Combine pairs of lines, perform arithmetic, and add plus signs for positive\n    # numbers\n        # Cat +5\n        # Dog -10\n    sed \"N;s/\\n/ /\" |\n    awk '{print $1, $4 - $2;}' |\n    sed \"s/ \\([0-9]\\)/ +\\1/\"\n\nI'd highly suggest if you are going to invoke awk at all...just use awk for the whole thing:\n\n    NR == 1 { next }\n    { if (v[$1] && v[$1] != $2)\n         printf \"%s %+d\\n\", $1, ($2 - v[$1])\n      else\n         v[$1] = $2\n    }\n\nOr, if you really want to be all bash, make proper use of bash's `read` functionality, and associative arrays (only available in bash > 4.2):\n\n    #!/bin/bash\n    \n    declare -A prices\n    \n    read N\n    \n    for ((i = 0; i < N; i++)); do\n    \tread item price\n    \tprices[$item]=$price\n    done\n    \n    for ((i = 0; i < N; i++)); do\n    \tread item price\n    \tif (( price != prices[$item] )); then\n    \t\tprintf '%s %+d\\n' \"$item\" \"$((price - prices[$item]))\"\n    \tfi\n    done\n\n\nNice, this problem is perfect for awk, well done!", "id": "cdzqqjc", "owner_tier": 0.7, "score": 0.15999999980000001}, {"content": "If anyone want a bigger list:\n\n    44\n    Apple 162\n    Bananas 105\n    Bed 63\n    Beef 73\n    Bottle 118\n    Bread 46\n    Brocolli 165\n    Carrots 122\n    Cat 130\n    Chicken 46\n    Chocolate 176\n    Computer 63\n    Cow 101\n    Crow 160\n    Dolphin 194\n    Dove 120\n    Drawer 125\n    Egg 13\n    Fish 16\n    Fork 110\n    Fridge 40\n    Giraffe 3\n    Hamster 145\n    Knife 104\n    Lamp 175\n    Lion 198\n    Milk 113\n    Orange 48\n    Panda 84\n    Phone 29\n    Plate 14\n    Rat 37\n    Rhino 134\n    Shark 143\n    Sheep 12\n    Sofa 83\n    Spectacles 60\n    Spoon 135\n    Squirrel 149\n    Tiger 180\n    Tomato 10\n    Turtle 187\n    Whale 140\n    Zebra 31\n    Apple 162\n    Bananas 105\n    Bed 63\n    Beef 72\n    Bottle 113\n    Bread 50\n    Brocolli 165\n    Carrots 122\n    Cat 130\n    Chicken 46\n    Chocolate 176\n    Computer 63\n    Cow 101\n    Crow 145\n    Dolphin 194\n    Dove 110\n    Drawer 125\n    Egg 13\n    Fish 16\n    Fork 110\n    Fridge 40\n    Giraffe 3\n    Hamster 145\n    Knife 104\n    Lamp 175\n    Lion 198\n    Milk 113\n    Orange 48\n    Panda 84\n    Phone 29\n    Plate 12\n    Rat 37\n    Rhino 146\n    Shark 143\n    Sheep 10\n    Sofa 83\n    Spectacles 60\n    Spoon 135\n    Squirrel 149\n    Tiger 180\n    Tomato 10\n    Turtle 179\n    Whale 140\n    Zebra 31\n\nOutput:\n\n    Beef -1\n    Bottle -5\n    Bread +4\n    Crow -15\n    Dove -10\n    Plate -2\n    Rhino +12\n    Sheep -2\n    Turtle -8", "id": "ce13t0o", "owner_tier": 0.1, "score": 0.0599999998}, {"content": "Lisp.\n\n    (defun parse-list (n)\n      (sort (loop repeat n collect (list (read) (read)))\n            #'string<\n            :key (lambda (e) (symbol-name (first e)))))\n\n    (defun inventory ()\n      (let* ((n (read))\n             (wrong (parse-list n))\n             (right (parse-list n)))\n        (loop for (item a) in wrong and (_ b) in right\n              for diff = (- b a)\n              for sign = (if (< diff 0) \"\" \"+\")\n              unless (zerop diff)\n              do (format t \"~a ~a~a~%\" item sign diff))))\n\nUnfortunately Common Lisp doesn't preserve case by default, but I\nwrote this in Elisp originally, which does preserve case.\n\n\nCan you explain the `for (item a) in wrong and (_ b) in right` bit?\n\nAlso in common lisp (don't know about elisp) you can use ~@d to force the printing of the sign.\n\n> Can you explain the for (item a) in wrong and (_ b) in right bit?\n\nThe `loop` macro supports destructuring bindings. The two lists are each in alist form, so each element in the list is a pair of values. I used `_` because I don't care about that variable, being identical to `item`, and I used an underscore as a convention for this. In Elisp there's no `(declare (ignore ...))` and instead any variable starting with an underscore tells the compiler you intend to ignore that variable.\n\n> Also in common lisp (don't know about elisp) you can use ~@d to force the printing of the sign.\n\nThanks for the tip. I've have almost no practice with the Common Lisp `format` directives so I don't know any of the tricks. Elisp only supports a printf-like `format`, and I had ported it directly from that. Now that I think about it, I could have used `%+d` in that case, too.\n", "id": "cdzktn2", "owner_tier": 0.7, "score": 0.0799999998}, {"content": "Java doesn't have to be all that long either...\n\n    import java.util.*;\n    class NutsBolts {\n    \tpublic static void main(String[] args) {\n    \t\tScanner sc = new Scanner(System.in);\n    \t\tint n = sc.nextInt();\n    \t\tHashtable<String, Integer> nTable = new Hashtable<String, Integer>();\n    \t\t\n    \t\tfor (int i = 0; i < n; i++)\n    \t\t\tnTable.put(sc.next(), sc.nextInt()); // put into hashtable\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tString item = sc.next();\n    \t\t\tint q = sc.nextInt() - nTable.get(item); // subtract item's old quantity from new\n    \t\t\tif (q != 0) System.out.println(item + \" \" + ((q > 0) ? \"+\"+q : q)); // print\n    \t\t}\n    \t}\n    }", "id": "cdzwegq", "owner_tier": 0.1, "score": 0.0799999998}, {"content": "JavaScript (using node for file I/O):\n\n    fs = require('fs');\n    \n    var priceData = fs.readFileSync(process.argv[2], 'utf8').split('\\r\\n');\n    var numItems = parseInt(priceData[0]);\n    var currPriceData = priceData.slice(1, numItems + 1);\n    var correctPriceData = priceData.slice(numItems + 1);\n    var currPrices = [];\n    \n    currPriceData.forEach(function(item) {\n        var data = item.split(' ');\n        currPrices[data[0]] = parseInt(data[1]);\n    });\n    \n    correctPriceData.forEach(function(item) {    \n        var data = item.split(' ');\n        var difference = parseInt(data[1]) - currPrices[data[0]];\n        if (Math.abs(difference) > 0) {\n            console.log(data[0] + ' ' + (difference > 0 ? '+' : '') + difference);\n        }\n    });\n    \n", "id": "cdztsmq", "owner_tier": 0.5, "score": 0.0599999998}, {"content": "Python 2.7 (as it relies on dict comprehensions):\n\n    n = int(raw_input())\n    d = {x[0]: int(x[1]) for i in xrange(n) for x in [raw_input().split()] }\n    d = {x[0]: d[x[0]]-int(x[1]) for i in xrange(n) for x in [raw_input().split()] }\n    print \"\\n\".join(k+\" \"+str(v) for k,v in d.items() if v != 0)\n\n\nassuming sanitized input the first line can just be \n\n    n = input()\n\nin 2.7 as it'll just interpret it as an int to begin with. It's dangerous to do something like that normally, but this is looking code-golfy already, so might as well.\n\ncool code!\n\n[deleted]\n\nno problem! Just remember it's not something you can normally do, as 2.7's    input() tries to interpret stdin as a well-formed python expression. If you type anything other than an int (i think) it'll just ask you what you meant as there's no variable or function named \"(whatever you typed in)\". It's weird and in fact python 3's input() is just python 2.7's raw_input() which is a lot nicer and more predictable.", "id": "cdzumjv", "owner_tier": 0.1, "score": 0.15999999980000001}, {"content": "F#\n\nStill getting used to the functional approach, but I'm loving it so far.\n\n    let parseLine (line:System.String) = \n        let parsedString = line.Split(' ')\n        ( parsedString.[0], int (parsedString.[1]) )\n\n    let printLine = function\n        | (product, price) when price > 0 -> System.Console.WriteLine(product + \" +\" + string price)\n        | (product, price) when price < 0 -> System.Console.WriteLine(product + \" \" + string price)\n        | _ -> ()\n    \n    [<EntryPoint>]\n    let main argv = \n        let number = int (System.Console.ReadLine())\n        let getLines count = \n            [for n in [1..count] -> System.Console.ReadLine()] \n                |> List.map parseLine \n        let priceMap = getLines number |> List.fold (fun acc (product, price) -> Map.add product price acc) Map.empty\n        getLines number\n            |> List.map (fun (product, price) -> (product, price - Map.find product priceMap))\n            |> List.filter (fun (product, price) -> price <> 0)\n            |> List.iter printLine\n        0\n\n\n\n\nThis is the first time I've seen an F# Entry in this sub Have an upvote \n\nThanks!\n\nI try to do all the problems in F#. I haven't gotten around to the latest ones yet (holiday season), but I have a fair few others solved in F#.", "id": "ce0xpgm", "owner_tier": 0.7, "score": 0.0999999998}, {"content": "I'm trying to teach myself PHP, so this is my first attempt at programming in PHP and doing a Daily Programmer Challenge! Any critiques welcome!\n\n    <?php\n\n    function nuts_and_bolts($filename) {\n        $filereader = fopen($filename,'r');\n        \n        # Get number of rows\n        $rows = fgets($filereader);\n        \n        # Fill out the old list\n        $old_list = array();\n        for ($i = 0; $i < $rows; $i++) {\n            $line = split(\" \", fgets($filereader));\n            $old_list[$line[0]] = $line[1];\n        }\n\n        # Scan through new list, filling out changes array\n        $changes = array();\n        for ($i = 0; $i < $rows; $i++) {\n            $line = split(\" \", fgets($filereader));\n            $change = $line[1] - $old_list[$line[0]];\n            if ($change !== 0) {\n                $changes[$line[0]] = $change;\n            }\n        }\n\n        # Print changes\n        foreach($changes as $item => $change) {\n            echo $item.\" \";\n            if ($change > 0) {\n                echo \"+\".$change.\"<br />\";\n            } else {\n                echo $change.\"<br />\";\n            }\n        }\n        \n        fclose($filereader);\n    }\n\n    ?>\n\nUsage:\n\n    <?php\n    \n    nuts_and_bolts(\"nutsandbolts_input.txt\");\n\n    ?>\n\nI think you did a good job. You even managed to support multiple price changes and only output them once, which would be nice for the person using the output :-)\n\n\nBut i think you forgot a check to output a negative change. And you might also want take a look at using [foreach](http://www.php.net/manual/en/control-structures.foreach.php). It could replace your while-loop and eliminate the usage of key, current and next functions.\n\nThanks for the response! I output the negative change in the else statement. If the change is negative, then the element of the changes array is negative, so a negative sign is automatically printed out.\n\nI looked into using `foreach` for printing out the change array, but my changes array is structured like `changes[name_of_item] = change`. If I did a `foreach`, then the syntax would be something like `foreach($changes as $change)`, right? This means that I only get access to `$change`, which is just the number. I want to also be able to print out the key of the element, since that's the name of the item. How would I do that using a `foreach`?\n\nOh yeah, forgot about php-magic that adds the minus signs :D\n\nThe foreach could look like:\n\nforeach($changes as $name => $change)\n\nThanks! Edited! :)", "id": "cdzveue", "owner_tier": 0.1, "score": 0.0799999998}, {"content": "A COBOL solution:\n\n           >>SOURCE FREE\n    IDENTIFICATION DIVISION.\n    PROGRAM-ID. nuts-and-bolts.\n    \n    DATA DIVISION.\n    WORKING-STORAGE SECTION.\n    01  num-items                           PIC 99.\n    01  items-area.\n        03  items                           OCCURS 1 TO 50 TIMES\n                                            DEPENDING ON num-items\n                                            INDEXED BY items-idx.\n            05  item-name                   PIC X(30).\n            05  old-price                   PIC 9(5).\n            05  new-price                   PIC 9(5).\n    \n    01  input-str                           PIC X(50).\n    \n    01  item-to-find                        PIC X(30).\n    01  item-to-find-price                  PIC 9(5).\n    \n    01  difference                          PIC +(5).\n    \n    PROCEDURE DIVISION.\n        ACCEPT num-items\n        PERFORM VARYING items-idx FROM 1 BY 1 UNTIL items-idx > num-items\n            ACCEPT input-str\n            UNSTRING input-str DELIMITED BY SPACES INTO item-name (items-idx),\n                old-price (items-idx)\n        END-PERFORM\n    \n        PERFORM num-items TIMES\n            ACCEPT input-str\n            UNSTRING input-str DELIMITED BY SPACES INTO item-to-find,\n                item-to-find-price\n            \n            SET items-idx TO ZERO\n            SEARCH items\n                WHEN item-name (items-idx) = item-to-find\n                    MOVE item-to-find-price TO new-price (items-idx)\n            END-SEARCH\n        END-PERFORM\n    \n        DISPLAY SPACE\n        \n        PERFORM VARYING items-idx FROM 1 BY 1 UNTIL items-idx > num-items\n            SUBTRACT new-price (items-idx) FROM old-price (items-idx)\n                GIVING difference\n            IF difference <> SPACES\n                DISPLAY FUNCTION TRIM(item-name (items-idx)) \" \"\n                    FUNCTION TRIM(difference)\n            END-IF\n        END-PERFORM\n        .\n    END PROGRAM nuts-and-bolts.\n", "id": "cdzvief", "owner_tier": 0.1, "score": -1.9999999878450582e-10}, {"content": "erlang\n\n    -module(nutsnbolts).\n    -export([main/1]).\n\n    read_prices(Count) -> \n        lists:map(\n            fun(_) -> \n                {ok, [Item, Price]} = io:fread(\"\", \"~s ~d\"),\n                {Item, Price} \n            end,\n            lists:seq(1, Count)\n        ).\n\n    show_prices(Prices) -> \n        lists:foreach(\n            fun({Item, Price}) -> \n                case Price > 0 of\n                    true -> io:fwrite(\"~s +~B\\n\", [Item, Price]);\n                    false -> io:fwrite(\"~s ~B\\n\", [Item, Price])\n                end\n            end, \n            Prices\n        ).\n\n    price_changes(Old_prices, New_prices) ->\n        [{Item, Price_change} || \n            {Item, Price_change} <- lists:zipwith(\n                fun({Item, Old_price}, {Item, New_price}) -> {Item, New_price - Old_price} end,\n                lists:sort(Old_prices),\n                lists:sort(New_prices)\n            ),\n            Price_change /= 0\n        ].\n\n    main(_) ->\n        {ok, [Count]} = io:fread(\"\", \"~d\"),\n        {Old_prices, New_prices} = {read_prices(Count), read_prices(Count)},\n        show_prices(price_changes(Old_prices, New_prices)).\n\nOn second thought it's probably more \"erlang\" to do the i/o like this:\n\n    read_prices(0) -> [];\n    read_prices(Count) -> \n            {ok, [Item, Price]} = io:fread(\"\", \"~s ~d\"),\n            [{Item, Price}] ++ read_prices(Count - 1).\n\n    show_prices([]) -> [ok];\n    show_prices([{Item, Price}|Tail]) when Price > 0 -> \n        [io:fwrite(\"~s +~B\\n\", [Item, Price])] ++ show_prices(Tail);\n    show_prices([{Item, Price}|Tail]) -> \n        [io:fwrite(\"~s ~B\\n\", [Item, Price])] ++ show_prices(Tail).", "id": "ce03atq", "owner_tier": 0.1, "score": 0.0599999998}, {"content": "D Language\n\n    import std.stdio, std.algorithm, std.range, std.conv, std.typecons;\n    \n    auto toItemAndPrice(char[] line) {\n        auto t = line.findSplit(\" \");\n        return tuple(t[0].idup, t[2].to!int());\n    }\n    void main() {\n        int[string] pricemap;\n        foreach(item, price ; stdin.byLine().drop(1).map!toItemAndPrice) {\n            auto badPrice = item in pricemap;\n            if (badPrice && *badPrice != price) {\n                writefln(\"%s %+d\", item, price - *badPrice);\n            }\n            else {\n                pricemap[item] = price;\n            }\n        }\n    }\n\nmy preferred language i c++. is D worth learning?\n\nI'd definitely say so. The language and standard library are designed in a way which makes them really enjoyable to use. Compared to C++, D does a lot of things much better; [this page](http://dlang.org/overview.html) has some comparisons.\n\nIn general, you can learn a lot from trying out a bunch of different languages and seeing how they make different ideas easy or hard to express, what trade-offs they make, etc.\n\nnoice. thanks!", "id": "cdzmccv", "owner_tier": 0.1, "score": 0.0999999998}, {"content": "C#\n\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n\n    namespace NutsAndBolts\n    {\n\n        class MainClass\n        {\n\n            public static void Main(string[] args)\n            {\n\n                var inputText = File.ReadAllLines(args[0]);\n                var nItems = Convert.ToInt32(inputText[0]);\n\n                var inventory = new Dictionary<string, string>();\n                for (var i = 1; i <= nItems; ++i)\n                {\n                    var itemStrings = inputText[i].Split(' ');\n                    inventory.Add(itemStrings[0], itemStrings[1]);\n                }\n\n                var outputText = string.Empty;\n                for (var i = 1; i <= nItems; ++i)\n                {\n\n                    var itemStrings = inputText[i + nItems].Split(' ');\n                    if (itemStrings[1] != inventory[itemStrings[0]])\n                    {\n\n                        var priceDiff = Convert.ToInt32(itemStrings[1]) \n                                           - Convert.ToInt32(inventory[itemStrings[0]]);\n                        outputText += itemStrings[0] + \" \";\n                        if (priceDiff > 0)\n                            outputText += \"+\";\n                        outputText += priceDiff.ToString() + \"\\n\";\n\n                    }\n\n                }\n\n                Console.Write(outputText);\n\n            }\n\n        }\n\n    }\n\nEdited to fix one line getting cut off due to length.\n\nC# Linq one-liner of doom:\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(string.Join(\"\\n\", Console.In.ReadToEnd().Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries).Skip(1).Select(x => x.Split()).Select(x => new { Name = x[0], Price = int.Parse(x[1]) }).ToLookup(x => x.Name).Select(x => new { x.First().Name, Diff = x.ElementAt(1).Price - x.ElementAt(0).Price }).Where(x => x.Diff != 0).Select(x => x.Name + \" \" + (x.Diff > 0 ? \"+\" : \"\") + x.Diff)));\n    }\n\n\nReadable version:\n\n    Console.WriteLine(\n        string.Join(\"\\n\",\n            Console.In.ReadToEnd()\n                .Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries)\n                .Skip(1)\n                .Select(x => x.Split())\n                .Select(x => new { Name = x[0], Price = int.Parse(x[1]) })\n                .ToLookup(x => x.Name)\n                .Select(x => new { x.First().Name, Diff = x.ElementAt(1).Price - x.ElementAt(0).Price })\n                .Where(x => x.Diff != 0)\n                .Select(x => x.Name + \" \" + (x.Diff > 0 ? \"+\" : \"\") + x.Diff)\n            ));", "id": "cdzmgrr", "owner_tier": 0.3, "score": 0.0599999998}, {"content": "Golang:  \n  \n\tpackage main\n\n\timport (\n\t\t\"fmt\"\n\t\t\"os\"\n\t)\n\n\tfunc main(){\n\t\tvar count int\n\t\tnum, err := fmt.Scanln(&count)\n\t\tif(err != nil || num != 1){\n\t\t\tfmt.Println(\"Error reading file\");\n\t\t\tos.Exit(1);\n\t\t}\n\t\titems := make(map[string]int)\n\n\t\tfor i := 0; i < count; i++ {\n\t\t\tvar cost int\n\t\t\tvar name string\n\t\t\tnum, err = fmt.Scanln(&name, &cost)\n\t\t\tif(err != nil || num != 2){\n\t\t\t\tfmt.Println(\"Error reading file\");\n\t\t\t\tos.Exit(1);\n\t\t\t}\n\t\t\titems[name] = cost\n\t\t}\n\t\t\n\t\tfor i := 0; i < count; i++ {\n\t\t\tvar cost int\n\t\t\tvar name string\n\t\t\tnum, err = fmt.Scanln(&name, &cost)\n\t\t\tif(err != nil || num != 2){\n\t\t\t\tfmt.Println(\"Error reading file\");\n\t\t\t\tos.Exit(1);\n\t\t\t}\n\n\t\t\tdifference := cost - items[name]\n\t\t\tif difference != 0 {\n\t\t\t\tvar sign string\n\t\t\t\tif (difference > 0){\n\t\t\t\t\tsign = \"+\"\n\t\t\t\t}\n\t\t\t\tfmt.Printf(\"%s %s%d\\n\", name, sign, difference)\n\t\t\t\tif(err != nil || num != 2){\n\t\t\t\t\tfmt.Println(\"Error printing result\");\n\t\t\t\t\tos.Exit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n  \n\n[deleted]\n\nDid not know, many thanks.", "id": "cdzmp0q", "owner_tier": 0.5, "score": 0.1399999998}], "link": "https://www.reddit.com/r/dailyprogrammer/comments/1sob1e/121113_challenge_144_easy_nuts_bolts/", "question": {"content": "# [](#EasyIcon) *(Easy)*: Nuts & Bolts\n\nYou have just been hired at a local home improvement store to help compute the proper costs of inventory. The current prices are out of date and wrong; you have to figure out which items need to be re-labeled with the correct price.\n\nYou will be first given a list of item-names and their current price. You will then be given another list of the same item-names but with the correct price. You must then print a list of items that have changed, and by how much.\n\n# Formal Inputs & Outputs\n## Input Description\n\nThe first line of input will be an integer N, which is for the number of rows in each list. Each list has N-lines of two space-delimited strings: the first string will be the unique item name (without spaces), the second string will be the price (in whole-integer cents). The second list, following the same format, will have the same unique item-names, but with the correct price. Note that the lists may not be in the same order!\n\n## Output Description\n\nFor each item that has had its price changed, print a row with the item name and the price difference (in cents). Print the sign of the change (e.g. '+' for a growth in price, or '-' for a loss in price). Order does not matter for output.\n\n# Sample Inputs & Outputs\n## Sample Input 1\n\n    4\n    CarriageBolt 45\n    Eyebolt 50\n    Washer 120\n    Rivet 10\n    CarriageBolt 45\n    Eyebolt 45\n    Washer 140\n    Rivet 10\n\n## Sample Output 1\n\n    Eyebolt -5\n    Washer +20\n\n## Sample Input 2\n\n    3\n    2DNail 3\n    4DNail 5\n    8DNail 10\n    8DNail 11\n    4DNail 5\n    2DNail 2\n\n## Sample Output 2\n\n    2DNail -1\n    8DNail +1", "id": "1sob1e", "title": "[12/11/13] Challenge #144 [Easy] Nuts & Bolts", "traffic_rate": 52.62312775330396}, "saved_time": "Tue, 16 Jul 2024 03:46:14 GMT", "source": "reddit"}]}