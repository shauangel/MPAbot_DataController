{"result": [{"answers": [{"content": "To solve this, I had to do the following.  I don't know which item(s) below solved the issue, but hopefully this will be helpful to someone.  The Python debugger I was using was called Python File, as opposed to the other two optional Python debuggers, Python File with Arguments and Module. 1.) Deleted the file \"pyvenv.cfg\" in the working folder.  It contained the contents.  This got created automatically somehow from earlier debugger sessions. 2.) The first time I created the virtual environment in GitBash with the Python File debugger not working was the following: 3.) The second time I created the virtual environment in GitBash, I added a new folder in my source directory (path of my Python file being debugged) called venv.", "id": 78053516, "score": 0}, {"content": "Weighing in late here but I'm not sure the version of Python is part of the issue. I think the real issue is with the 32 bit versus 64 bit versions of Python. I am on Python 3.10.11 and changed my interpreter from 64 bit to 32 bit and the debugger started hit the breakponts.", "id": 77671605, "score": 0}, {"content": "This happened to me as I was walking through this VSCode tutorial. My debugger did not work because I accidentally put the file in the .venv folder.  When I moved it out of there it ran fine.", "id": 77275295, "score": 0}, {"content": "I have been battling with this for the last hour, and it finally worked by renaming my python file from camelCase.py to snake_case.py", "id": 73972948, "score": 0}, {"content": "I (re)downloaded VS Code again: https://code.visualstudio.com/\nThe breakpoint got to show up on hover and function with the Run and Debug for the python file I was working on. Additionally, I had to solve a syntax error in my code before the debugger buttons (step over/in, etc) had to go through the code lines", "id": 73952411, "score": 0}, {"content": "For everyone coming here looking for a solution related to breakpoints in python unittests: If not already done add a configuration file, i.e. launch.json, as described in the vscode python debugging tutorial. For me the following configuration settings worked, whereby setting cwd (because of  src and test folders) and purpose (see also here) were essential. Happy debugging!", "id": 70701313, "score": 1}, {"content": "Another source of debugger not stopping at breakpoint: an homonym file,  from another directory, is open in VS Code. In fact, VS Code can set breakpoints on any Python file, even outside of your Python project's directory; if the path of the file does not match the one in launch.json, \"program\": [your-file-name-here] entry, then breakpoints are not hit. For example: copies of Python source files are located under dist/lib, the output of setuptools (run: python setup.py bdist_wheel to generate them). If dist/lib is not excluded through .gitignore, then its contents shows up in the search results sidebar and can be click open by mistake. Caveat: the above does not hold if the launch.json configuration has \"program\": \"${file}\".", "id": 73258380, "score": 0}, {"content": "Another source of no-breakpoints-working is elevate: The elevate() command restarts the program as a new (child) process, so the entire file becomes un-breakpoint-able.  From the author: On Windows, the new process\u2019s standard streams are not attached to the parent, which is an inherent limitation of UAC. In windows, to debug python applications in VS Code which need to be run as administrator, a work-around is this: Linux users could likely do the same with sudo code.  Now the process will be spawned initially as administrator, so the call to elevate() does nothing and the whole file is debuggable.", "id": 71756673, "score": 1}, {"content": "My issue was that I was putting the breakpoint on the line of the function declaration itself, so the def foo(x): line, instead of putting the breakpoint on the first non-comment line inside of the function. If the first line of your function is a comment, the debugger will assume you meant to place the breakpoint on the line of the function declaration and move your breakpoint back, so really make sure you aren't placing your breakpoint on a comment!", "id": 69229731, "score": 2}, {"content": "Downgrading from Python 3.9 to 3.8 worked for me. VC Code 1.56.2 ignored breakpoints running Python 3.9 64-bit on Windows 10 version 20H2.  Installing Python 3.8.10 64-bit fixed the problem.  I just needed to select the Python 3.8.10 interpreter within VS code and it now recognizes breakpoints.  No changes to the configuration file were needed, for example, I did not need \"justMyCode\": false I realize this is an old question, but my google search lead me to it.  Many of the previous answers no longer apply. So I'm posting this fix for others who land here in 2021 trying to use 3.9.", "id": 67630336, "score": 2}, {"content": "I recently found out ( 5th May 2020) that using Python 3.9 as interpreter the breakpoints were not hitting. Install 3.8 and it will start working again.", "id": 67400796, "score": 0}, {"content": "If you're using a pytest-cov module you might also wanna have a look at pytest configuration settings note: Note If you have the pytest-cov coverage module installed, VS Code doesn't stop at breakpoints while debugging because pytest-cov is using the same technique to access the source code being run. To prevent this behavior, include --no-cov in pytestArgs when debugging tests, for example by adding \"env\": {\"PYTEST_ADDOPTS\": \"--no-cov\"} to your debug configuration. See an example configuration file (launch.json) below:", "id": 67185092, "score": 54}, {"content": "I had the same problem having upgraded from Python version 3.7 to version 3.9. I later found out that the old version was 32 bit, and the new version I upgraded to was 64 bit, which apparently caused the issues. Uninstalling the 64 bit version and installing the 32 bit version of Python 3.9 solved my problem, and I was then able to use the Visual Studio Code breakpoint functionality again.", "id": 66935483, "score": 1}, {"content": "I experienced the same behaviour and was able to solve it by installing the virtual environment of Python in the following way: by entering the command in the console. VS Code seems to expect exactly that folder structure. Before I had installed the venv-folder-structure directly in my projects-folder, i.e. which did not work and caused exactly the described debug problems. just as a reference: VS Code version 1.52.1 and Python 3.8.5", "id": 65534376, "score": 4}, {"content": "Setting \"justMyCode\": false makes it stop at breakpoint: ", "id": 60678160, "score": 101}], "link": "https://stackoverflow.com/questions/56794940/vscode-why-isnt-debugger-stopping-at-breakpoints", "question": {"content": "I have just installed VS Code and the Python extension, and I have not been able to get the debugger to work. Every time I try to use the debugger, it just skips over any breakpoints that I have set and runs the program like normal.  I am using VS Code on a Windows 10 PC with Python 3.7.3 and the Python extension installed. I followed the instructions here (https://code.visualstudio.com/docs/python/python-tutorial) to make a test folder called 'hello' in C:\\python_work\\hello and create a program called 'hello.py' inside that folder. hello.py is shown below. I tried using the debugger both by pressing the green arrow and by pressing F5, but neither seemed to make the debugger work properly. My 'launch.json' file is also shown below. hello.py: launch.json: I expected the bottom bar to turn orange and the program to stop on the second line, allowing me to examine the local and global variables in the preview pane. Instead, the bottom bar stayed orange for 1/2 a second while the program ran as if I had pressed \"Run Python File in Terminal,\" without stopping at the breakpoint. Please help!", "id": 56794940, "title": "VSCode: Why isn&#39;t debugger stopping at breakpoints?", "views": 76353}, "resource": "StackOverflow", "tags": ["python", "visual-studio-code", "vscode-debugger"]}, {"answers": [{"content": " Check the 'Run In Terminal' in the Code Runner Settings. This is the simplest solution.", "id": 77854742, "score": 0}, {"content": "Here's the current (September 2018) extensions for running Python code: Official Python extension: This is a must install. Jupyter: A extension for running Jupyter notebooks. This is a must install if you are a data scientist. Code Runner: Incredibly useful for all sorts of languages, not just Python. I would highly recommend installing. AREPL: Real-time Python scratchpad that displays your variables in a side window. I'm the creator of this, so obviously I think it's great, but I can't give a unbiased opinion \u00af\\_(\u30c4)_/\u00af Wolf: Real-time Python scratchpad that displays results inline And of course if you use the integrated terminal you can run Python code in there and not have to install any extensions.", "id": 52240391, "score": 7}, {"content": "So there are four ways to run Python in Visual Studio Code so far: Via an integrated terminal (come on, it's integrated! So technically you run it from within Visual Studio Code ;) Via custom Task (accepted Fenton's answer): Via Code Runner extension (@JanHan's answer): Via Microsoft's official Python extension (vlad2135's answer):", "id": 49416465, "score": 14}, {"content": "Running the current python file as is does not have a keybinding associated by default, but you can set this with:", "id": 70348290, "score": 10}, {"content": "If it is just a one file you want to run, make sure you have python installed on your system, then run python <filename Its just that simple", "id": 76055627, "score": 0}, {"content": "\n", "id": 75423442, "score": 0}, {"content": "There is a lot of confusion around Visual Studio Code tasks and the debugger. Let's discuss about it first so that we understand when to use tasks and when to use the debugger. The official documentation says - Lots of tools exist to automate tasks like linting, building,\npackaging, testing, or deploying software systems. Examples include\nthe TypeScript Compiler, linters like ESLint and TSLint as well as\nbuild systems like Make, Ant, Gulp, Jake, Rake, and MSBuild. ....  Tasks in VS Code can be configured to run scripts and start\nprocesses so that many of these existing tools can be used from within\nVS Code without having to enter a command line or write new code. So, tasks are not for debugging, compiling or executing our programs. If we check the debugger documentation, we will find there is something called run mode. It says - In addition to debugging a program, VS Code supports running the\nprogram. The Debug: Start Without Debugging action is triggered with\nCtrl+F5 and uses the currently selected launch configuration. Many of\nthe launch configuration attributes are supported in 'Run' mode. VS\nCode maintains a debug session while the program is running, and\npressing the Stop button terminates the program. So, press F5 and Visual Studio Code  will try to debug your currently active file. Press Ctrl + F5 and Visual Studio Code will ignore your breakpoints and run the code. To configure the debugger, go through the documentation. In summary it says, you should modify the launch.json file. For starters, to run the code in integrated terminal (inside Visual Studio Code), use - To run the code in an external terminal (outside of Visual Studio Code), use - N.B. If all documentation was easy to search and understand then we probably would not need Stack\u00a0Overflow. Fortunately, the documentation I mentioned in this post is really easy to understand. Please feel free to read, ponder and enjoy.", "id": 57994700, "score": 15}, {"content": "On your Mac use control+F5(fn+F5)", "id": 74864790, "score": 0}, {"content": "If I just want to run the Python file in the terminal, I'll make a keyboard shortcut for the command because there isn't one by default (you need to have the Python interpreter executable in your path): I use Ctrl + Alt + N.", "id": 60458336, "score": 10}, {"content": "To run python3 on windows vs code: Download the python interpreter from their official site Install the python packages for vs code. This can be installed directly from vscode's extension manager Verify that your python3 has been installed by running this command: py -3 --version Run your script with the following command from vscode's terminal: py -3 main.py For more information, head over here for details installation procedure.", "id": 72999489, "score": 1}, {"content": "One workaround is to the following :", "id": 72842045, "score": 0}, {"content": "", "id": 66089716, "score": 0}, {"content": "I used my existing anaconda environment to run python.  rather than using the python user appdata\\local\\programs\\python use the anaconda install python by environment.  This will give you access to all your libraries in the environment.", "id": 69036913, "score": 0}, {"content": "There is an easiest way to make a shortcut for run in terminal command:", "id": 67827602, "score": 4}, {"content": "If you install Python language extension for VSCode, it also installs Jupyter and Pylance by default, which lets you run Python code in interactive manner. All you have to do is use # %% before the code that you want to execute interactively. As soon as you insert # %%, you can see that VSCode creates a new Jupyter Cell for you.  And from there you can click on the Run Cell cell menu and you can see the result. So, all you have to do is type the following code in your VSCode,", "id": 67494625, "score": 2}, {"content": "Super simple: Press the F5 key and the code will run. If a breakpoint is set, pressing F5 will stop at the breakpoint and run the code in debug mode. Other Method - To add Shortcut Note: You must have Python Extension By Microsoft installed in Visual Studio Code, and the Python interpreter selected in the lower-left corner. Go to File \u2192 Preferences \u2192 Keyboard Shortcuts (alternatively, you can press Ctrl + K + S)\nIn the search box, enter python.execInTerminal\nDouble click that result (alternatively, you can click the plus icon)\nPress Ctrl + Alt + B to register this as the keybinding (alternatively, you can enter your own keybinding) Now you can close the Keyboard Shortcuts tab\nGo to the Python file you want to run and press Ctrl + Alt + B (alternatively, you can press the keybinding you set) to run it. The output will be shown in the bottom terminal tab.", "id": 50995541, "score": 7}, {"content": "in new Version of VSCode (2019 and newer) We have run and debug Button for python, Debug :F5 Run without Debug :Ctrl + F5 So you can change it by go to File > Preferences > Keyboard Shortcuts\nsearch for RUN: start Without Debugging and change Shortcut to what you want.\nits so easy and work for Me (my VSCode Version is 1.51 but new update is available).", "id": 65338024, "score": 7}, {"content": "Note: You must have Python Extension By Microsoft installed in Visual Studio Code, and the Python interpreter selected in the lower-left corner.", "id": 62937633, "score": 5}, {"content": "I use Python 3.7 (32 bit). To run a program in Visual Studio Code, I right-click on the program and select \"Run Current File in Python Interactive Window\". If you do not have Jupyter, you may be asked to install it. ", "id": 57777730, "score": 3}, {"content": "If you have a project consisting of multiple Python files and you want to start running/debugging with the main program independent of which file is current you create the following launch configuration (change MyMain.py to your main file).", "id": 57729032, "score": 0}, {"content": "In the latest version (1.36) of Visual Studio Code (Python): Press F5 and then hit Enter to run your code in the integrated terminal. Ctrl + A and then hit Shift + Enter to run your code in the interactive IPython shell.", "id": 57282235, "score": 9}, {"content": "Install the Python extension (Python should be installed in your system). To install the Python Extension, press Ctrl + Shift + X and then type 'python' and enter. Install the extension. Open the file containing Python code. Yes! A .py file. Now to run the .py code, simply right click on the editor screen and hit 'Run Python File in the Terminal'. That's it! Now this is the additional step. Actually I got irritated by clicking again and again, so I set up the keyboard shortcut.", "id": 55767329, "score": 16}, {"content": "From Extensions, install Code Runner. After that you can use the shortcuts to run your source code in Visual Studio Code. First: To run code: Second: To stop the running code:", "id": 55622125, "score": 2}, {"content": "If you are running code and want to take input via running your program in the terminal, the best thing to do is to run it in terminal directly by just right click and choose \"Run Python File in Terminal\". ", "id": 51579083, "score": 2}, {"content": "If you are using the latest version of Visual Studio Code (version 1.21.1). The task.json format has changed, see here. So the answer by Fenton and by python_starter may no longer be valid. Before you start configuring Visual Studio Code for running your Python file. Now you can configure the task. The following steps will help you run your python file correctly:   Then in the opened task.json file, use the following settings: In the above settings, you can give a meaningful label to this task. For example, run python.   For a more complete tutorial about task configuration, go to the Visual Studio Code official documentation.", "id": 49452598, "score": 7}, {"content": "You can add a custom task to do this. Here is a basic custom task for Python. You add this to file tasks.json and press Ctrl + Shift + B to run it.", "id": 29989061, "score": 79}, {"content": "I had installed Python via Anaconda. By starting Visual Studio Code via Anaconda I was able to run Python programs. However, I couldn't find any shortcut way (hotkey) to directly run .py files. (Using the latest version as of Feb 21st 2019 with the Python extension which came with Visual Studio Code.\nLink: Python extension for Visual Studio Code) The following worked: The below is similar to what @jdhao did. This is what I did to get the hotkey: I made the code look like this: After saving it, the file changed to this: Now every time that you press Ctrl + Shift + B, the Python file will automatically run and show you the output :)", "id": 54819872, "score": 4}, {"content": "In order to launch the current file with the respective venv, I added this to file launch.json: In the bin folder resides the source .../venv/bin/activate script which is regularly sourced when running from a regular terminal.", "id": 51798700, "score": 0}, {"content": "As stated in Visual Studio Code documentation, just right-click anywhere in the editor and select Run Python File in Terminal.", "id": 47701288, "score": 21}, {"content": "To extend vlad2135's answer (read his first); that is how you set up Python debugging in Visual Studio Code with Don Jayamanne's great Python extension (which is a pretty full featured IDE for Python these days, and arguably one of Visual Studio Code's best language extensions, IMO). Basically, when you click the gear icon, it creates a launch.json file in your .vscode directory in your workspace. You can also make this yourself, but it's probably just simpler to let Visual Studio Code do the heavy lifting. Here's an example file:  You'll notice something cool after you generate it. It automatically created a bunch of configurations (most of mine are cut off; just scroll to see them all) with different settings and extra features for different libraries or environments (like Django). The one you'll probably end up using the most is Python; which is a plain (in my case C)Python debugger and is easiest to work with settings wise. I'll make a short walkthrough of the JSON attributes for this one, since the others use the pretty much same configuration with only different interpreter paths and one or two different other features there. You can go here for more information on the Visual Studio Code file variables you can use to configure your debuggers and paths. You can go here for the extension's own documentation on launch options, with both optional and required attributes. You can click the Add Configuration button at the bottom right if you don't see the config template already in the file. It'll give you a list to auto generate a configuration for most of the common debug processes out there. Now, as per vlad's answer, you may add any breakpoints you need as per normal visual debuggers, choose which run configuration you want in the top left dropdown menu and you can tap the green arrow to the left to the configuration name to start your program. Pro tip: Different people on your team use different IDEs and they probably don't need your configuration files. Visual Studio Code nearly always puts it's IDE files in one place (by design for this purpose; I assume), launch or otherwise so make sure to add directory .vscode/ to your .gitignore if this is your first time generating a Visual Studio Code  file (this process will create the folder in your workspace if you don't have it already)!", "id": 43057949, "score": 27}, {"content": "There is a Run Python File in Terminal command available in the Python for Visual Studio Code extension. ", "id": 42537490, "score": 27}, {"content": "All these answers are obsolete now. Currently you have to: No additional extensions or manual launch.json editing is required now.", "id": 42180398, "score": 99}, {"content": "Here is how to configure Task Runner in Visual Studio Code to run a .py file. In your console, press Ctrl + Shift + P (Windows) or Cmd + Shift + P (Apple). This brings up a search box where you search for \"Configure Task Runner\"  If this is the first time you open the \"Task: Configure Task Runner\", you need to select \"other\" at the bottom of the next selection list. This will bring up the properties which you can then change to suit your preference. In this case you want to change the following properties;  You can now open your .py file and run it nicely with the shortcut Ctrl + Shift + B (Windows) or Cmd + Shift + B (Apple).", "id": 34975137, "score": 126}, {"content": "You no longer need any additional extensions. You can simply switch the output of the debugger to the integrated terminal. Ctrl+Shift+D, then select Integrated Terminal/Console from the dropdown at the top.", "id": 44599904, "score": 8}, {"content": "A simple and direct Python extension would save both time and efforts.\nLinting, debugging, code completion are the available features once installation is done. After this, to run the code proper Python installation path needs to be configured in order to run the code. General settings are available in User scope and Workspace can be configured for Python language\u2013 \"python.pythonPath\": \"c:/python27/python.exe\" \nWith above steps at least the basic Python programs can be executed.", "id": 43157596, "score": 2}], "link": "https://stackoverflow.com/questions/29987840/how-to-execute-python-code-from-within-visual-studio-code", "question": {"content": "Visual Studio Code was recently released and I liked the look of it and the features it offered, so I figured I would give it a go. I downloaded the application from the downloads page, fired it up, messed around a bit with some of the features ... and then realized I had no idea how to actually execute any of my Python code! I really like the look and feel/usability/features of Visual Studio Code, but I can't seem to find out how to run my Python code, a real killer because that's what I program primarily in. Is there is a way to execute Python code in Visual Studio Code?", "id": 29987840, "title": "How to execute Python code from within Visual Studio Code", "views": 804619}, "resource": "StackOverflow", "tags": ["python", "visual-studio-code"]}, {"answers": [{"content": "If you use VS Code, you can debug SCons script like a usual python script, just create a configuration in .vscode/launch.json: The program should be set to the path where your SCons is installed. You can get it by scons --version. Don't forget to add __main__.py as the entry script. It's recommended to set justMyCode to false so that you can set breakpoints at Scons' source code. You can set arguments in args if necessary: VSCode brings debugging features such as inspecting variables, setting breakpoints, and other activities with GUI. For details, goto Python debugging in VS Code", "id": 75318107, "score": 1}, {"content": "With PyCharm you can use remote debugging. Find the remote debugger package in your PyCharm installation: Install the egg using easy_install. It should be found in your Python deployment. On Windows look into the Scripts folder. Follow the Remote Debugging HowTo. Run the Python code you would like to debug in any way you want, it will connect to PyCharm's debug server and stop in the script. Screenshot of debugging Godot's SConstruct file:\n Scons was executed from a Visual Studio command line in order to receive the right environment variables for the build (not from PyCharm). UPDATE: A simpler solution is to add a run configuration directly for scons.py itself. You can issue a SET command in an Visual Studio command prompt, copy all environment variables printed and paste into the Environment setting of the run configuration inside PyCharm. With that configuration you can debug the whole scons based build, including your SConstruct file.", "id": 49209217, "score": 1}, {"content": "In your SConstruct: And you'll drop into the debugger inside your SConstruct (or SConscript if that's what you're trying to debug).", "id": 49213454, "score": 2}, {"content": "From my experience, it is really difficult to debug if you are thinking about using step-by-step debugging in SCons. My advice is to add a good logging system in your SConstruct file(or adding one).\nFor example, level debug-detailed will log the variables in your custom builder fonction, level debug will only log the most crucial variables, level production(default) will only log when there is a warning or error, in order to minimize the impact on performance. Personally, I think it's common practice to depend on logging system for debugging in a complicated system.", "id": 27365269, "score": 0}], "link": "https://stackoverflow.com/questions/22818734/how-to-debug-scons-script", "question": {"content": "I have a SCons script that I need to debug. Somewhere down inside of everything that is happening, I have a problem and I need to find out where it is going bad.  I'd like to debug the SCons script, but I'm not sure how to get it set up. I have both PyCharm and Komodo IDEs, but I couldn't figure out how to make those work.  I've tried this: but that just gets me inside of SCons; I need to be inside of the scripts that I've created that SCons runs. Can someone show me how to set up PyCharm or Komodo to debug a SCons script? If that isn't possible, I'm open to other debugging options.", "id": 22818734, "title": "How to debug SCons script", "views": 5948}, "resource": "StackOverflow", "tags": ["debugging", "pycharm", "scons", "komodo"]}, {"answers": [{"content": "Running the app in debug mode will show an interactive traceback and console in the browser when there is an error. As of Flask 2.2, to run in debug mode, pass the --app and --debug options to the flask command. Prior to Flask 2.2, this was controlled by the FLASK_ENV=development environment variable instead. You can still use FLASK_APP and FLASK_DEBUG=1 instead of the options above. For Linux, Mac, Linux Subsystem for Windows, Git Bash on Windows, etc.: For Windows CMD, use set instead of export: For PowerShell, use $env: If you're using the app.run() method instead of the flask run command, pass debug=True to enable debug mode. Tracebacks are also printed to the terminal running the server, regardless of development mode. If you're using PyCharm, VS Code, etc., you can take advantage of its debugger to step through the code with breakpoints. The run configuration can point to a script calling app.run(debug=True, use_reloader=False), or point it at the venv/bin/flask script and use it as you would from the command line. You can leave the reloader disabled, but a reload will kill the debugging context and you will have to catch a breakpoint again. You can also use pdb, pudb, or another terminal debugger by calling set_trace in the view where you want to start debugging. Be sure not to use too-broad except blocks. Surrounding all your code with a catch-all try... except... will silence the error you want to debug. It's unnecessary in general, since Flask will already handle exceptions by showing the debugger or a 500 error and printing the traceback to the console.", "id": 17322636, "score": 233}, {"content": "You can install python-dotenv with\npip install python-dotenv then create a  .flask_env or a .env file\nThe contents of the file can be:", "id": 74284527, "score": 0}, {"content": "If you have PyCharm Professional, you can create a Flask server run configuration and enable the FLASK_DEBUG checkbox. Go to Run > Edit Configurations, select or create a Flask server configuration, and enable the FLASK_DEBUG checkbox. Click OK, then click the run button.", "id": 52030732, "score": 3}, {"content": "When running as python app.py instead of the flask command, you can pass debug=True to app.run.", "id": 68730895, "score": 12}, {"content": "To activate debug mode in flask you simply type set FLASK_DEBUG=1 on your CMD for windows, or export FLASK_DEBUG=1 on Linux terminal then restart your app and you are good to go!!", "id": 58817088, "score": 12}, {"content": "with virtual env activate you can configure to start the result and if you change", "id": 63762059, "score": 6}, {"content": "For Windows users: Open Powershell and cd into your project directory. Use these commandos in Powershell, all the other stuff won't work in Powershell.", "id": 63056713, "score": 5}, {"content": "From the 1.1.x documentation, you can enable debug mode by exporting an environment variable to your shell prompt:", "id": 38777394, "score": 33}, {"content": "If you want to debug your flask app then just go to the folder where flask app is. Don't forget to activate your virtual environment and paste the lines in the console change \"mainfilename\" to flask main file. After you enable your debugger for flask app almost every error will be printed on the console or on the browser window.\nIf you want to figure out what's happening, you can use simple print statements or you can also use console.log() for javascript code.", "id": 52580219, "score": 14}, {"content": "Install python-dotenv in your virtual environment. Create a .flaskenv in your project root. By project root, I mean the folder which has your app.py file Inside this file write the following: Now issue the following command:", "id": 56126838, "score": 9}, {"content": "One can also use the Flask Debug Toolbar extension to get more detailed information embedded in rendered pages. Start the application as follows:", "id": 41706878, "score": 27}, {"content": "If you're using Visual Studio Code, replace with It appears when turning on the internal debugger disables the VS Code debugger.", "id": 50146336, "score": 22}, {"content": "You can use app.run(debug=True) for the Werkzeug Debugger edit as mentioned below, and I should have known.", "id": 17309954, "score": 57}], "link": "https://stackoverflow.com/questions/17309889/how-to-debug-a-flask-app", "question": {"content": "How are you meant to debug errors in Flask?  Print to the console?  Flash messages to the page?  Or is there a more powerful option available to figure out what's happening when something goes wrong?", "id": 17309889, "title": "How to debug a Flask app", "views": 471623}, "resource": "StackOverflow", "tags": ["python", "debugging", "flask"]}, {"answers": [{"content": "Here are instructions for Visual Studio Code version 1.14.2. Older versions may work a bit different. VS Code will open manage.py and start execution. There should be a debugger tool pallet at the top of the IDE with buttons to step, continue, etc. Breakpoints are set by clicking in the code window to the left of the line number.\n I have these VS Code extensions installed (in case it matters).", "id": 45362417, "score": 7}], "link": "https://stackoverflow.com/questions/40849115/how-to-run-debug-django-app-in-visual-studio-code", "question": {"content": "launch.json In the browser http://localhost:8000/login I have a login page allow user input username and password to login. I put a break points in the code of def login in views.py and run debug but the execution is not stopped on the line with break points. Now I want to allow user input user name and password then they click on button and it will jump to break points def login in views.py. How can I do that?", "id": 40849115, "title": "How to run debug Django app in Visual Studio Code?", "views": 5260}, "resource": "StackOverflow", "tags": ["python", "django", "python-3.x", "visual-studio-code"]}, {"answers": [{"content": "Doing an optimized Python debugger is as any other software: things can be really different performance-wise (I'm the PyDev author and I've done the PyDev debugger, so, I can comment on it, but not on the others, so, I'll just explain a bit on optimizing a Python debugger -- as I've spent a lot of time optimizing the PyDev debugger -- I won't really talk about other implementations as I don't know how they were done -- except for pdb, but pdb is not really a fast debugger implementation after it hits a breakpoint and you're stepping through it, although it does work well by running things untraced until you actually execute the code that'll start tracing your code). Particularly, any 'naive' debugger can make your program much slower just by enabling the Python trace in each frame and checking if there's a breakpoint match for each line executed (this is roughly how pdb works: whenever you enter a context it'll trace it and for each line called it'll check if a breakpoint matches it, so, I believe any implementation that expects to be fast can't really rely on it). I know the PyDev debugger has several optimizations... the major one is the following: when the debugger enters a new frame (i.e.: function) it will check if there's any 'potential' breakpoint that may be hit there and if there's not, it won't even trace that function (on the other hand, when a breakpoint is added later on after the program is executing, it'll have to go and reevaluate all previous assumptions, as any current frame could end up skipping a breakpoint). And if it determines that some frame should be traced, it'll create a new instance for that frame which will be responsible for caching all that's related to that frame (this was only really possible from Python 2.5, so, when working on Python 2.4 and earlier, unless the threadframe extension is installed, the debugger will try to emulate that, which will make it considerably slower on Python 2.4). Also, the PyDev debugger currently takes advantage of Cython, even though this is only restricted to CPython... Jython, IronPython and PyPy don't take advantage of it), so, many optimizations are still done considering pure Python mode (thankfully Cython is close enough to Python so that few changes are needed in order to make it work faster on CPython with Cython). Some related posts regarding PyDev debugger optimization evolution: http://pydev.blogspot.co.id/2017/03/pydev-560-released-faster-debugger.html http://pydev.blogspot.co.id/2016/01/pydev-451-debug-faster.html http://pydev.blogspot.com/2008/02/pydev-debugger-and-psyco-speedups.html http://pydev.blogspot.com/2005/10/high-speed-debugger.html Anyways, running with the debugger in place will always add some overhead (even when heavily optimized such as the PyDev debugger), so, PyDev also provides the same approach that may be used in pdb: add a breakpoint in code and it'll only start tracing at that point (which is the remote debugger feature of PyDev): http://pydev.org/manual_adv_remote_debugger.html And depending on the features you want the debugger to support, it can also be slower (e.g.: when you enable the break for caught exceptions in PyDev, the program will execute slower because it'll need to trace more things in order to properly break).", "id": 9381482, "score": 18}, {"content": "This is like asking why is program A faster than program B. The reason may not be specific to the domain of debugging. I would imagine most graphical debuggers are built on top or a frontend to the pdb module provided in the python standard library (though not all are). The performance differences would mostly boil down to implementation details and GUI updating overhead. The difference could be as simple as doing unnecessary deep copies vs direct referencing in some layer of the code. If you are concerned about debugger performance, then you should stick with the faster graphical debugger, unless it is not satisfying some feature you need. You are asking for feature differences; since this is the case, they are both obviously current serving your needs feature-wise.  If one debugger is losing precision or sacrificing robustness, then I would discount it immediately from consideration. I would chance a guess that the slower one is either: Doing extra work or unnecessary checks (if the developer doesn't trust other parts of the code, or their are too many layers or redundancy architecturally). Using some cache-unfriendly or wasteful representation or hasn't tuned or optimised the code algorithmically as much as the faster debugger. Correct data structure choice and algorithmic optimisations can make orders of magnitudes of difference. Using low-level optimisations (like ctypes, psyco, pyrex) etc.. you can make another order of magnitude of a difference. Remember python gives you flexible and powerful default containers that you always \"pay\" for, even if you dont need all their functionality.  I have found that WinPDB is fairly lightweight, and is the one I usually use, since it doesnt tie me to an IDE, and supports remote debugging quite effectively. You might also want to try eclipse with pydev. Another new one I have just started playing around with is Python Tools for Visual Studio which looks very promising. There is also a list of python debuggers on the python wiki. It might be worth giving the others a try. As to why one is faster than the other, there are a multitude of possible factors. If you have access to the source of the debugger, you might be able to profile the debugger itself to identify the performance bottlenecks. But if you just want a fast debugger that handles all the basic use cases, just try a few more out, and stick with the fastest that serves your needs.", "id": 9370974, "score": 2}], "link": "https://stackoverflow.com/questions/9346622/what-determines-debugger-run-time-performance", "question": {"content": "I have tried debugging Python 3 with Wing IDE (v.4.1.3) and Komodo IDE (v.7.0.0). As, expected the debugger adds a lot of run-time overhead. But what surprised me is how different the debuggers can be between each other. Here are the run-times for the same program. No breakpoints or anything else, just a regular run without any actual debugging: I refer to the debuggers as anonymous #1 and #2 lest this becomes an unintentional (and possibly misguided) advertising for one of them. Is one of the debuggers really 8 times \"faster\"? Or is there some design trade-off, where a faster debugger gives up some features, or precision, or robustness, or whatever, in return for greater speed? If so, I'd love to know those details, whether for Wing/Komodo specifically, or Python debuggers in general.", "id": 9346622, "title": "What determines debugger run-time performance", "views": 5230}, "resource": "StackOverflow", "tags": ["python", "performance", "debugging", "python-3.x"]}, {"answers": [{"content": "I insert prints and so on to check what's going on.\n\nThen I'll hook up a debugger if I'm really stuck and need some validation on where/why a bug is occurring. \n\nI think a debugger is a last resort to me, it's certainly a worthwhile tool, but usually reading through the code will get your answer a lot quicker", "id": "c1dh0sj", "parent": "t3_f5n00", "vote": 130}, {"content": "Strangely enough the best programmers that I have personally known, would never use anything else than a debugger.\nThey would write down the basic structure of the program and put breakpoints instead of code in many places.\nThen they would start the program in the debugger and fill all the gaps as they went. They ended up being amazingly productive.\nThis was in Smalltalk though. Really dynamic environment to program in, with a fantastic debugger.", "id": "c1dh7l9", "parent": "t3_f5n00", "vote": 22}, {"content": "I started programming in the 80s on home computers. No debugger anyway. Ok, code size was small. But I got used to skim through my code and find bugs by just thinking what happens there.\nNowadays I'm happy that I can work that way. There are situations, where debuggers are difficult to use or nearly impossible, like multi threaded programs that access data concurrently.\nIf you have at least a good idea where the problem should be found, writing a few prints to output the state of the related variables is faster most of the time.", "id": "c1dgyth", "parent": "t3_f5n00", "vote": 48}, {"content": "Part of it has to do with changes in the way programmers think about their programs.\n\nGetting programs into the computer and getting output used to be hard. At one time your programs were entered by recording each line on a punch card, and then turning your deck over to someone who would eventually feed it into the mainframe, pick up your printout from the line printer, and deliver it to an output bin where you would retrieve it hours or sometimes days after you submitted your deck.\n\nLater, by the late '70s when I was getting started, things were a bit better. We had interactive terminals on timesharing systems. We could actually enter our code ourselves. The terminals were slow (300 baud!) so it took a long time to draw a whole screen. The editors we used were generally line oriented. You would type your code, and if you wanted to edit a prior line you would have to type commands that would pick out the line and describe the changes you want.\n\nWe generally did not have online documentation. If you couldn't remember how some library function or system call or language feature worked, you had to get up, walk to wherever the documentation was kept, and look it up.\n\nComputers were also a lot slower than they are now. Even on interactive systems where we tended not to do as much big numerical jobs (those would still be done as batch jobs on the mainframes), a lot of interesting programs would take significant time to run, and even significant time to compile.\n\nIn these kind of environments, we tended to spend more time upfront *thinking* about our programs. If the program failed, we'd go off an think about it. That worked well because we knew the program inside and out before it ran for the first time. We'd know where things went wrong, and would often only need a little bit of extra information to understand it all (if we couldn't get it from thought alone)--and so one or two print statements would do it.\n\nNowadays, editing is easy. With easy online documentation lookup (often integrated right into the editor!) and fast turnaround time (both for compiling and running) many programmers start programming as soon as they have a rough idea of what they want to do. Sometimes people copy sample code off the net when they need to do something new, and end up using libraries or language features that they have not read the documentation for. They don't develop the line by line intimacy with the code that we used to have. So when it doesn't work, they need something like an interactive debugger. That stepping through the code not only servers to help them debug--it serves to teach them about the program they just wrote.\n\nBTW, when I think back on the late '70s, I can no longer comprehend how we functioned. I can not imagine editing where I only see a few lines in context at a time, and only when I explicitly ask for it. I know it is possible because that's how I used to work, but if I hadn't done it, I would not believe it!\n\nGetting back to the masterminds, some of them are old school people who started back in '70s or even earlier, and so be necessity learned to think deeply before coding and have not found any reason to abandon that approach. They don't use interactive debuggers often because they don't need them. Those who aren't that old may have still adopted the deep thought approach to coding even if their environment never forced it on them simply because they are very smart people and the natural tendency of very smart people is to think deeply about a problem.", "id": "c1dhhoq", "parent": "t3_f5n00", "vote": 10}, {"content": "Why wouldn't you use a debugger?  People act like it is a crutch that bad programmers use because they don't understand their code.  The fact is, if you DO understand your code, then you can track down any bug pretty much instantly with a debugger.  On the other hand, if the bug is non-trivial, print statement debugging actually takes a little bit of time to design your prints in a manner that will show exactly where and what the bug is.\n\nIt sounds to me like just more elite bragging, \"Hey, i don't need to use a debugger to debug my code so I am better than you.\"  I think self-debugging can be a good way to learn when you are first starting out, but once you start writing large programs you have to be a fool to not use a debugger.", "id": "c1dh9iu", "parent": "t3_f5n00", "vote": 92}, {"content": "Ah, Bertrand Russell, haven't heard from him in years.  How's he coming with that big book on sets?", "id": "c1dh15u", "parent": "t3_f5n00", "vote": 18}, {"content": "I'm the only developer at my (admittedly pretty small) organization who ever uses a debugger.  This is despite personally writing up extensive tutorials, docs, conducting seminars / learning sessions, and one-on-one training on debugging.  They ALWAYS just resort to print / log statements no matter what my efforts.  Sure, sometimes printing is a quick'n'easy way to debug.  But sometimes you have to man up and get inside the program with a debugger.  Coincidentally I'm sure, I'm always the one tasked with the most difficult debugging assignments \"because I'm so good at it.\"\n\nI debug that shit **LIKE A BOSS**.", "id": "c1dim5d", "parent": "t3_f5n00", "vote": 9}, {"content": "It really depends on the context.  These cases cited are all systems programming where the elements can be inspected easily without a debugger.  Shipping commercial applications on schedule is a bit different and is mostly not what the people in book were doing.", "id": "c1dh5tt", "parent": "t3_f5n00", "vote": 10}, {"content": "I find that starting a debugger, stepping through code, setting watches and breakpoints and interacting with a debugger distracts me from the code I was actually writing. A simple 'print' statement gets the same job done, without having to leave the 'context' of what I was coding. \n\nAlso, a debugger is a one-time solution to a problem. Building in verbose logging, activated by some commandline switch or something, allows me to fix problems in code many times over.\n\nReading the code in combination with using logging and the occasional temporary print statement seems to be enough to locate about 99% of the problems I run into. If by then I still haven't found the problem, that usually indicates to me that the code I just wrote is too complex, and I'll generally rewrite it so it's easier to understand.", "id": "c1dh3vx", "parent": "t3_f5n00", "vote": 37}, {"content": "[removed]", "id": "c1dh49d", "parent": "t3_f5n00", "vote": 28}, {"content": "As a developer who came onto a large scale single-threaded C/C++ program that has been in active development since 1986, I could not imagine working with printf's to debug. However, the nature has more to do with what type of program you are working with I suppose. In python I often use print statements or throw exceptions to get stack traces. I'd still prefer something like pyscripter at the end of the day.\n\nI find that using a debugger, usually gets me looking in the right direction than other means. I don't need to fully understand all the code when glancing at it.  Also, I can't emphasis stuff enough like unit-testing or some other quick automated way to rerun sections of code.", "id": "c1dhaiw", "parent": "t3_f5n00", "vote": 7}, {"content": ">\" It saves me over and over again when dealing with code I don't understand. Not having it would be terrible.\"\n\n>\"code I don't understand\"\n\nThat's his problem.", "id": "c1dmysg", "parent": "t3_f5n00", "vote": 8}, {"content": "There are a few reasons I'd rather do without a debugger for most tasks.\n\n1. It's harder to troubleshoot stochastic bugs, because you have to set up the debugger every run. With print statements, I can just keep running `myprog args > output` until the bug appears, and I don't have to worry about the code running slower under the debugger, I can run with full optimization, etc.\n\n2. Debuggers for C-like languages usually can't run backwards in time, so you end basically doing a search for the right place to put a breakpoint so that you've captured where things started to go wrong without stopping so early that you have to step through a mile of good code. There are no doubt people cleverer with their debuggers than me that can better navigate this one, but especially in concert with #1, I'd rather dump everything and force it to crash once.\n\n3. With a decent logging system, you can maintain your testing solution better between runs than you can if you have to rely on an external program.\n\nBeyond that, it's just personal preference. Mostly, when something goes wrong, I'll make a quick determination of what the problem might be. Often that's pretty easy -- I've just added a new function and that's probably where the bug is. If the problem is a crash and I have no idea where to start looking, I'll fire up the debugger and get a stack trace and line number for the crash. From there, it's usually easier to toss the debugger and reason from the code and logging.", "id": "c1dh72b", "parent": "t3_f5n00", "vote": 16}, {"content": "It probably has to do with what environment they began programming in.\n\nI'm willing to bet most of them didn't use IDEs with a debugger integrated when they started (and probably still don't). When they run into a problem, they just add a few print statements and test it out a few times to find the proximity of the bug, because it's good enough in most cases and doesn't require them to switch to and interact with another program -- one that they probably aren't too familiar with to begin with. As a result, they never become familiar with a debugger, and so they train themselves to not need a debugger.\n\nThat is, using a debugger breaks their concentration on the problem at hand.\n\nMeanwhile, people who only use IDEs like XCode or Visual Studio just set a breakpoint or two and hit Run again, because for them, that's faster than typing out a few print statements. As a result, they become familiar with their debugger's usage and are more likely to use it again and again in the future.\n\nThat fluency means that using a debugger doesn't distract them from the problem.\n", "id": "c1dhipx", "parent": "t3_f5n00", "vote": 7}, {"content": "Because debuggers are a really big hammer and usually you've got everything you need with a simple caveman-style variable printing/logging?", "id": "c1dh6q0", "parent": "t3_f5n00", "vote": 15}, {"content": "Only trivial code can be reasoned out. Last company I worked for, no kidding, had three separate functions each over 1400 lines of C++ code. Poor design, difficult to debug, and because it was a real-time simulation (MMO), you had entry into each of these functions hundreds of times per second.\n\nPrint statements are WORTHLESS in this situation (simply too much text to pour over). Most of our thorny bugs would happen after 10 minutes or so and involve some weird concurrency thing: log files often stretch into millions of lines of text in these situations. Not only that, a lot of our tough bugs (which I solved) involved interaction between server and client apps. Again, this situation makes print statements almost worthless.\n\nPrint statements and alerts only work in the most trivial of code or the most deterministic and you can easily reason through that stuff anyway...so I would agree that debuggers are not necessary for basic code (but always helpful).\n\nRef: I do C++/C#/Java/Javascript (yes you read that right)/PHP/Python/Lua", "id": "c1di0rl", "parent": "t3_f5n00", "vote": 12}, {"content": "Good for them. Personally I am not a mastermind, and have no interest in pretending to be one. I just need to find bugs and get shit done, not stroke my e-peen.", "id": "c1dhscr", "parent": "t3_f5n00", "vote": 7}, {"content": "Also... when you attach and run the debugger, you are NOT running the same code.  If you've ever run into those wonderful bugs where \"it works fine in the debugger,\" then you know what I mean.  ", "id": "c1di9yw", "parent": "t3_f5n00", "vote": 3}, {"content": "Personal opinion: Using debugger is slow manual work. It's hard to automate, not easily reproducible, introduces changes to how the system behaves (especially with low level programing) and when the problem appears you can't go in time to see what caused it. When the program misbehaves I:\n\n1. turn on the logging\n2. watch the output and understand where is the problem\n3. understand the exact code the problem is in and make some hypothesis on what went wrong\n4. add some custom printfs to confirm my hypothesis\n5. if required go to 2\n6. fix the problem and confirm the solution\n", "id": "c1dhe7j", "parent": "t3_f5n00", "vote": 13}, {"content": "Hooray!  I KNEW I was actually a genius and not just a lazy prat for not using a debugger!", "id": "c1dhh18", "parent": "t3_f5n00", "vote": 11}, {"content": "You've gotta be kidding me. The best developers I've known have used debuggers with such grace and skill that, in my mind, debugging is a skillset all its own. All the people here saying debuggers are a crutch are, pretty much (a) children (b) bad programmers (c) people who don't get paid to code", "id": "c1di0vq", "parent": "t3_f5n00", "vote": 14}, {"content": "Depends on which language for me. If I am doing PHP, going over the code and inserting echos is how I do it, If I am doing C#, then the built in debugger essentially does the same thing only instead of printing something, it stops at where I want to print and can look at the values I would of printed. The end result is the same.", "id": "c1di4lf", "parent": "t3_f5n00", "vote": 3}, {"content": "A very interesting article, even though I don't agree with the headline!\n\nI agree that my first attack on a bug is to reread the code.  In fact, if there's a bug, before I start really expending effort, I go to the area I suspect it is and start cleaning and commenting the code.  \n\nYou always keep getting stuck on things - if you are commenting and cleaning you're at least getting work done while you're stuck, and it has a very good chance of finding the issue - or even some other issue.\n\nBut print statements are time-consuming - you have to recompile TWICE (when you put them in, and when you take them out) - and a lot of the time you get either not enough information, or worse, too much - but I still find I end up going to them an awful lot, particularly in real-time code where setting a breakpoint causes the program to behave completely differently.\n\nWhen I'm bug hunting, I think of print statements as photo traps for my bugs - but you need to go and scout out the territory in the debugger before you set those traps.\n\nI think the article is spot on when it points out that many of these famous people who don't use debuggers are never having to debug other people's code.  I've been privileged to have interacted with both Brian Kernighan and Guido van Rossum.  Both are brilliant, cheerful, and civilized men;  my theory is that GvR uses a debugger a heck of a lot more than BK, simply because of the nature of their work.\n\nI think the greatest debugger I ever met is a man called Michael Chastain who works at Google NYC - he has found GCC compiler code generation bugs on multiple occasions, and he has an unearthly ability to diagnose intermittent or \"Heisen\"-bugs.  He's also probably the strongest user of GDB I ever met. \n\nI also use the debugger as a jumping off point for optimization... where I step through some \"common workflow\" and see if I'm pissing away cycles.\n\nRegardless, if you are starting a project and you have the possibility of using a debugger, you should try to become completely comfortable with that debugger as fast as you can, even if you don't end up using it very often, in exactly the same way you should know where the emergency brake on your car is.", "id": "c1dijd9", "parent": "t3_f5n00", "vote": 3}, {"content": "When your build takes 30 minutes, followed by a slow upload to an embedded device, followed by a slow reboot, you'll learn that printf isn't your best option. You'll probably have to rebuild several times which will sink a good couple hours.\n\nThat said, it's frequently impractical to get a debugger working on smaller embedded devices, so the best option is often to make sure you can compile on unix or windows instead of the target device if you have to. Sometimes this requires writing fake driver responses, but it's usually worth the effort.", "id": "c1dj3un", "parent": "t3_f5n00", "vote": 3}, {"content": "A print statement is arguably a simple debugger.\n\n", "id": "c1dhe63", "parent": "t3_f5n00", "vote": 8}, {"content": "This expression:\n\n> library consumer\n\nis very revealing. One of the greatest skills you can pick up is to be able to read other peoples's code as if it's your own.", "id": "c1dh2go", "parent": "t3_f5n00", "vote": 7}, {"content": "I very seldom use a debugger these days, because debuggers are most practically used in a development environment, while most mystifying problems happen in production, and don't have so much to do with code itself as with architectural solutions.\n\nWhen I was starting out, and couldn't yet compile and run code while I was reading or writing it, or track cache line cleanliness, I did find debuggers useful in the development stage.", "id": "c1dhcgt", "parent": "t3_f5n00", "vote": 4}, {"content": "I can think of a few reasons why my first reaction is not to hit the debugger:\r\n\r\n 1. I planned ahead and wrote various log levels. Smash a SIGUSR2 at something I've written, and it starts spamming syslog with verbose logging\r\n \r\n 1. The really important parts of my programs implicitly deal with edge cases first, and report to the log if any of the unlikely ones are hit. The critical parts have unit tests that are run at compile time\r\n\r\n 1. I've run into situations where attaching the debugger changed the behavior, or worse, crashed the program somewhere else. Going from debugging the program to debugging the debugger is a nightmare. \r\n\r\nAnd here's a few counter-examples to when a debugger is damned handy\r\n\r\n 1. I had code that was segfaulting in the middle of nowhere for no reason. Whoops, ran out of memory...\r\n\r\n 2. I had code that was passing all the tests, but in practice was still returning wrong information. Whoops, read into uninitialized memory...\r\n\r\n 3. Mystical crashes on iOS practically require a debugger to solve. ", "id": "c1dhf6o", "parent": "t3_f5n00", "vote": 6}, {"content": "I can't imagine programming without a debugger.\n\nNo, they don't solve all problems, but they are very useful tools.\n\nI suppose it's possible to program without a debugger, just like it's possible to hammer in a screw with a wrench.", "id": "c1dhztb", "parent": "t3_f5n00", "vote": 4}, {"content": "[deleted]", "id": "c1dgu2j", "parent": "t3_f5n00", "vote": 10}, {"content": "I use prints most of the time, but sometimes a debugger is easier, I might want to take a look at a whole class that that I'm using, which is behaving in a unexpected way. I don't want to fill the screen with dump of all the variables inside of it. And MS Visual Studio has me spoiled.", "id": "c1dh4io", "parent": "t3_f5n00", "vote": 2}, {"content": "Mostly because they wrote the code so they know exactly where it is broken. :) I am sure as hell no mastermind but when someone describes the situation to me and I know the code because I wrote it then I don't need a debugger either. ", "id": "c1dh6nb", "parent": "t3_f5n00", "vote": 2}, {"content": "I think this really depends on the complexity of the system that you're working with.  If you're working with something that you, or perhaps even you and a few other people designed, then that's one thing.\n\nIf you are instead working on something that tens or hundreds of people have contributed code to, you're going to have a major problem trying to understand many issues without a debugger.", "id": "c1dh6v9", "parent": "t3_f5n00", "vote": 2}, {"content": "[deleted]  \n ^^^^^^^^^^^^^^^^0.4220 \n > [What is this?](https://pastebin.com/64GuVi2F/06598)", "id": "c1dh9od", "parent": "t3_f5n00", "vote": 2}, {"content": "I was purely a logger for a very long time. I the last year or so I've started using a debugger sometimes, but logging is still usually way faster for me.", "id": "c1dhcft", "parent": "t3_f5n00", "vote": 2}, {"content": "A lot of the \"masterminds\" mention are pioneers of their respective areas of expertise. As such, they are often in a situation where no debugger has yet been developed for what they're working on. \n\nAlso, they've been around for a long time, and in the early days of programming advanced debuggers were less common and sometimes impractical. These guys started out programming without debuggers, so they're used to doing things that way.", "id": "c1dhlok", "parent": "t3_f5n00", "vote": 2}, {"content": "I've never learned to use a proper debugger. In high school we learned Turbo Pascal and while we had access to debugger most applcations we wrote were either mathematical based or we got to do some graphical type coding on our own time (some 8bit games). \n\nAfter High School the University i went to was pushing Java in everything. I had to pick up C/C++ on my own and during that time I was more interested in learning the language than learning a debugger and the code I was writing was lowlevel type smaller applications.\n\nWhenever I've run into output errors or other unexpected errors in my code I've usually been able to pinpoint the relative area where it is and isolate with some print statements.\n\nI can see the value of a debugger but in my experience I've never had the opportunity to learn or use one or run into a situation where hand troubleshooting would be more beneficial but this is most likely due to lack of experience. \n", "id": "c1dhqmg", "parent": "t3_f5n00", "vote": 2}, {"content": "If you're working in the kernel, you're going to need a debugger at some point.  Does that make you less of a programmer?  Nope.", "id": "c1dhwd3", "parent": "t3_f5n00", "vote": 2}, {"content": "sometimes running it inside a debugger can have unintended consequences, such as somethings working when they really shouldn't. This is especially the case with threading bugs and timing bugs. The debugger slows it down enough so that some race condition bugs don't happen because the execution of one of the threads has been slowed down.", "id": "c1dhz3h", "parent": "t3_f5n00", "vote": 2}, {"content": "I'm betting none of them uses fancy IDE either.", "id": "c1dhzln", "parent": "t3_f5n00", "vote": 2}, {"content": "Prints are far more useful to me. One night a debugger had me stopped on the same line for an hour. I inserted a few prints and was able to clearly see where the problem was.", "id": "c1djk3i", "parent": "t3_f5n00", "vote": 2}, {"content": "This is a silly question because when these \"Programming masterminds\" were in their heyday, editors, debuggers, and execution environments were not integrated so switching to a debugger for a simple task was not worth the effort.  Nowadays with modern IDEs, the context switch is nearly effortless.  If these masterminds were asked that today, they would probably have different answers.", "id": "c1djxvw", "parent": "t3_f5n00", "vote": 2}, {"content": "Could some of the masterminds that don't use debuggers please briefly describe the applications and platforms they are working on?  I suspect that a lot of the disagreement stems from people generalizing their own situation as if it applied to everyone.\n\nI use debuggers continuously.  I work on console games using VisualC++.  I work in large teams making huge systems under strong time pressure.  A single session of tracking down a bug often involves inspecting the behavior of multiple systems that I didn't know existed before I single-stepped into them.", "id": "c1dkn7p", "parent": "t3_f5n00", "vote": 2}, {"content": "From my experience, many environments simply do not allow debuggers. This can range from a server in a data center you don't own/control to a customer's computer where the trouble is occurring. Understanding how to create effective debug logs is a big part of product support.\n\nEven when testing locally, adding a log/print line can be remarkably fast. Especially when dealing with more complex programs (multiple threads, multiple program elements, multiple systems, etc).\n\nDebuggers don't magically find problems. Unless the problem is simple, it can take significant time to get when/where the trouble is occurring. They can make problems disappear or grow larger when timing is an element. Also if the problem is intermittent or difficult to reproduce, debuggers are almost useless. Knowing when to use them is a learning experience.", "id": "c1dls6l", "parent": "t3_f5n00", "vote": 2}, {"content": "There is something missing from all this debate - the context of the process; The kind of a bug. The work process I've applied in our team simply does not require a debugger.\n\nI for example apply full blown XP at my job. So the first \"bugs\" to be caught are failing unit tests. Since in my environment hitting a single key runs the tests of this specific unit and the results are almost instant, i use print statements. Why bother integrating another tool for this, if it works really well. \n\nBut lets say the system \"fails\" in one of the tests the QA is running. Before fixing the bug, we first make sure it's visible through the logging system. One of the tasks assigned to the QA is to be the playground for our debugging infrastructure, so it will be mature once we deploy. But making the bug visible is not a phase in the debugging, but just a \"training session\". We then write a test that recreates the bug: either a unit, whitebox or blackbox test. But before fixing the bug, the programmer must show he knows how to reproduce it. If a new utility for recreating the bug is needed, we write one, and give instructions to the QA of how to use it, and which new tests are possible. But only after this the programmer is allowed to fix the bug. Of course verification of the tests then follow to make sure no other tests failed due to this fix. Think this is slow? Usually takes minutes. The quality of the software, and happy faces of the team when coming to work can tell you it makes all the difference.\n\nTL;DR my opinion: never just \"fix\" the bug, recreate it in testing environments. Debugger becomes useless.", "id": "c1dmb6j", "parent": "t3_f5n00", "vote": 2}, {"content": "Honestly, debuggers don't appeal to me. I get told by my colleages \"USE AN IDE\" or \"GET A DEBUGGER\" but I prefer not to. I used Eclipse once for a project.\r\n\r\nMost of my bugs are syntax (say 99%+) errors and are easily solved by attempting to compile/interpret the code. A debugger is rarely useful for that, since the compiler/ interpreter can check for you. Little notices telling me I'm doing it wrong put me off of my flow. ", "id": "c1dmekj", "parent": "t3_f5n00", "vote": 2}, {"content": "[Linus Torvalds has an interesting opinion on it](http://linuxmafia.com/faq/Kernel/linus-im-a-bastard-speech.html)\n\n> I happen to believe that not having a kernel debugger forces people to think about their problem on a different level than with a debugger. I think that without a debugger, you don't get into that mindset where you know how it behaves, and then you fix it from there. Without a debugger, you tend to think about problems another way. You want to understand things on a different level.", "id": "c1dmhsv", "parent": "t3_f5n00", "vote": 2}, {"content": "I prefer log statements for debugging. I sometimes use step-by-step \"debugging\" to understand how a code works. \n\nIf the codebase is very large, then well placed log statements can also be used to understand it. ", "id": "c1dmv4m", "parent": "t3_f5n00", "vote": 2}, {"content": "I haven't used a debugger for quite a few years.  I've often thought that perhaps I should make a habit of using debuggers more often, but frankly, there hasn't been a need.\n\nI occasionally used them when hacking C on UNIX systems for analyzing core dumps.  We also sometimes used debuggers to attach to live programs that had ended up in a bad state.  Usually we'd emit an alert and call pause(3) so we could inspect the program state in a system where errors could be really hard to reproduce (our first generation web crawler, which was a monster and which ran in a distributed fashion and could take hours to reach a \"steady\" state -- so not the easiest environment to reproduce problems in).\n\nBut in the past 7-8 years I don't think I have used a debugger even once.  I think this might have something to do with the way I write code now.  \n\nWhile programming I usually write unit tests in tandem with the code.  I try to cover all of the code paths.  I also make sure that the tests verify the semantics that are promised by the accompanying class and method documentation.  I also, sometimes, write tests that look at specific boundary conditions that the implementation might be susceptible to.  When I'm done writing a piece of code it is usually of much higher quality than the code I wrote 10-15-20 years ago -- before I got really anal about writing thorough tests.\n\nIf something goes wrong I can usually narrow it down to a few lines of code immediately.  Most of the mistakes I make are relatively trivial, but I anticipate that I do make mistakes and I usually catch them when I write my unit tests.\n\nBut I've also gotten better at structuring my code and the way I work.  I take small bites when I program.  Meaning, I try to focus on solving one problem at a time and I try to write code that can be understood and verified in isolation.  (When observing inexperienced programmers I am often struck by how they often try to solve too many problems at the same time and in the same piece of code)\n\nIt is extremely important that code is easy to understand.  I usually tell people to write code that they'll be able to understand at 0300 on a sunday morning while drunk,  with a production system that has come to its knees and an angry boss on the phone demanding that you get it running ASAP.  Or expressed more snappily: \"the idiot who has to read the code might be you\".\n\nI've also gotten better at structuring my designs and code over the years.  It isn't particularly easy to articulate, but this process has two components.  The first is to become good at decomposing problems and addressing each of the sub-problems in as clear a manner as you can.  The second component of this is to be good at putting the decomposed solution together forming a whole that makes sense to other people.  In doing this simplicity, minimalism and clarity is key.  For instance it is important what you *name* things. This is what software patterns are about.  It is not about a \"bag of tricks\" -- it is about naming things so that people know what to expect and so that people understand the structure without actually having to study the details (ie. read all the code).  There are few things worse than having to read the code of someone who isn' good at naming things consistently and correctly.\n\nI am by no means a fast programmer. My process usually takes a bit longer for a given line count than most other programmers I've met.  On the other hand: I rarely have to debug my code and when I do discover bugs I can usually isolate and fix them quickly. Usually while writing the unit tests in tandem with the code under test.\n\nAs to how \"masterminds\" do it: the best programmers aren't necessarily that much smarter or have greater intellectual capacity -- they just have more humility towards their own stupidity and a profound lack of patience with unreadable code.  In bright enough people this leads to a defensive style of programming that reduces the need for the kind of archeology you usually employ a debugger for.", "id": "c1dpcbq", "parent": "t3_f5n00", "vote": 2}, {"content": "[deleted]", "id": "c1dh9kk", "parent": "t3_f5n00", "vote": 2}, {"content": "The likely reason is that early on there were not a lot of options for interactive debuggers. They learned programming and became proficient doing this out of necessity. Today, they just keep doing it that way because they are used to it. I have worked with many older programmers who will feel more comfortable with this method over interactive debuggers. ", "id": "c1dhdx2", "parent": "t3_f5n00", "vote": 4}, {"content": "It's only recently that debuggers aren't 'expensive' anymore as in: it doesn't take a long time to get to the point in the code where you want to look at in the state you want the program to be in. 10 years ago or more, you had to do way more effort to get to that point, and printing values to a console was easier. \n\nDebugging is also time consuming, even if you set conditional breakpoints at the right location. And what will you do at that moment? You'll verify state with what you expect it to be, eventually looking for control flow but that's often less important. While complicated for novices, verifying state can be done as well by reading code, although interpreting code is harder for a human, as a human tends to assume things, which can make the human overlook bugs. \n\nPeople who have written code for many many years (think 15+ years straight) have learned many solutions to problems they run into and know how to avoid bugs because they know solutions that work and can spot easily where things will go wrong. That doesn't mean they will never introduce bugs but it's less likely they'll overlook one when they read code. Sadly, most developers don't have that amount of experience yet as programmers who have done development for a long time tend to move up in the hierarchy, writing less and less code. ", "id": "c1dhb4n", "parent": "t3_f5n00", "vote": 2}, {"content": "Eh. I think they don't because it is boring.\n\nNo comment on whether I'd be considered a \"mastermind\" or not by anyone in particular. Much of the code I write for a living these days is low-level C, often state machine code, for DSPs. But I often damned well _will_ step through a piece of new code I've written using whatever IDE debugger I've got on hand, even if I have to build a separate project and put some effort into writing a little framework to drive it.\n\nIt's a piece of advice given by Steve McConnell in his book _Code Complete_* and it's a valuable piece of advice. The biggest reason is that just because your code compiles, and works, it may still be very broken. It may be working by accident. It may be reading an uninitialized variable. It may be reading past the end of your array. You may have forgotten that special first case or last case or edge case. It may be writing through a pointer that doesn't point where you expect. Stepping through in a debugger can help you validate these things. Once you've found a few of these classes of bugs in your own code it will help change your habits: to always think about initialization, what guarantees the compiler makes, what explicit initialization you need to provide. And lifetime of variables! Bugs are often found in the _dumbest_ little bits of code. Often just a dumb typo. Or a brain fart where you use && instead of &. I once had a hard-to-find bug that was ! instead of ~. Bleah.\n\nBut very occasionally -- a compiler bug!\n\n* UPDATE: I'm wrong, I probably had the wrong Steve (MacGuire, not McConnell) and the wrong Microsoft Press book (Writing Solid Code, not Code Complete).\n\nhttp://www.approxion.com/?p=88", "id": "c1di9ai", "parent": "t3_f5n00", "vote": 2}, {"content": "Ah, another stellar entry in the \"I have no idea what I'm talking about, but I'm going to write a blog post about it\" genre. How do these things garner upvotes? Who gives a shit about what some novice thinks?", "id": "c1dhru3", "parent": "t3_f5n00", "vote": 1}, {"content": "[deleted]", "id": "c1dhjds", "parent": "t3_f5n00", "vote": 2}, {"content": "Using a debugger just slows me down, print statements, tests and reading code is works better for me.\n\nBut you **need** the debugger when writing assembly.", "id": "c1dh8sm", "parent": "t3_f5n00", "vote": 1}, {"content": "They do. Just those don't.\n\nAnd GDB isn't the state of the art.\n", "id": "c1dh9wo", "parent": "t3_f5n00", "vote": 1}, {"content": "I don't use one becasue I don't know how to use one. Print is the only thing I know.", "id": "c1dhabp", "parent": "t3_f5n00", "vote": 1}, {"content": "Printf's really shine when you need to analyse code paths - ie. do I go down path A or path B, which is helpful for finding logic bugs.  Inspecting variables is only useful for coding bugs (did I set varA properly).  After more than a decade in the trenches, I've noticed that I spend more time looking at program flow and sequencing, and less time examining variable state.  This would explain the original posters question.", "id": "c1dhafw", "parent": "t3_f5n00", "vote": 1}, {"content": "Some other things not actually in use by programming masterminds, web megasites:\n\n*unit testing (there was a link kicking around about facebooks non-adherance to unit testing yesterday)\n\n*IDEs (amongst others Steve Yegge, but basically everybody who develops on vi or emacs)\n\napologies for being too lazy to find proper references", "id": "c1dhaz7", "parent": "t3_f5n00", "vote": 1}, {"content": "Anything I write in visual studio (.NET code) I use the debugger. All other code (c, c++, perl, etc...) I reason through the code and use print statements. ", "id": "c1dhb6f", "parent": "t3_f5n00", "vote": 1}, {"content": "If the code is so complex that you can't easily reason about it without a debugger, you should rethink your design.", "id": "c1dhbe3", "parent": "t3_f5n00", "vote": 1}, {"content": "Interactive debugging is just TMI sometimes, a quick print for something specific gets more to the point.", "id": "c1dhbfc", "parent": "t3_f5n00", "vote": 1}, {"content": "I tend to hook up a debugger to confirm my suspicions or if I am hitting segfaults. The rest of the print print statements make it easier to watch the flow of the program as it runs.", "id": "c1dhbqz", "parent": "t3_f5n00", "vote": 1}, {"content": "I only use a debugger if I'm seriously stuck. Aside from that, print statements all the way.", "id": "c1dhhew", "parent": "t3_f5n00", "vote": 1}, {"content": "A number of comments here talk about writing print statements and using logging.  Does anyone know of an example project (open source) that demonstrates this kind of logging?  Verbose logging? etc.", "id": "c1dhi77", "parent": "t3_f5n00", "vote": 1}, {"content": "I think a good programer gets to a point where he his code always checks all preconditions on the input in all his functions. if something goes wrong, it gets logged, together with function name, error code and line number. the errorhandler code is generic and doesn't need to be developed and tested for every function / object seperately. then, when something goes wrong, he knows exactly where, how and, soon after, why. at this point you don't need debuggers anymore, except for 3rd party (opensource-)code.", "id": "c1dhjru", "parent": "t3_f5n00", "vote": 1}, {"content": "Different tools will suit different situations, currently a lot of the code I write is designed to either work with or run in the context of SharePoint. It is very very easy to attach the Visual Studio debugger making it a very low cost option. Debugging is very useful for working within the SharePoint APIs, it can be very useful to see what values different calls are returning, and an incredibly useful feature is that the 'quick watch' tool allows you to enter and evaluate expressions dynamically which weren't in your code in the first place. This last part saves me buckets of time and is something you can not achieve with print/logging. Of course print/logging is still very important, you can't really attach a debugger and pause a live critical system. ", "id": "c1dhlq1", "parent": "t3_f5n00", "vote": 1}, {"content": "My view is that if you *need* a debugger to understand your code, you're probably doing it wrong, it's too complicated, or you just suck.\n\nThere have been probably two times when I thought, \"Hey a debugger would be nice here\", but then I actually took the time to figure out what was going on and how to fix it.\n\nOf course, I don't deal with much high-level cookie cutter GUIs either. I can see a debugger being invaluable for those kinds of software.", "id": "c1dhmca", "parent": "t3_f5n00", "vote": 1}, {"content": "Debuggers can be very useful for inspecting what a program is doing **at a given point in time**. Bugs, however, rarely exist at a given point in time; the state of the program must be tracked over time to accurately determine what is going wrong.  \n\nI'd say 80% of my debugging is done with trace (print) statements. 20% with a debugger.  \n\nThat being said, I also rely heavily on logs and trace statements **during development itself** - you can never test your code too early, in my opinion.", "id": "c1dhmmz", "parent": "t3_f5n00", "vote": 1}, {"content": "Depends on a situation. I don't use a debugger with small JavaScript or Perl scripts. With the C++ multi-MLOC monster I spend most time on, a debugger is pretty much a must. \r\n\r\nDebugging core dumps is another situation where you just have to use a debugger.", "id": "c1dhmrq", "parent": "t3_f5n00", "vote": 1}, {"content": "90% of the time when a program misbehaves, an expert programmer goes \"doh!\" and knows exactly where the problem is. The other 10% of the time they put in a print statement or break out the debugger. For some types of bugs logging/printing is the right answer (it shows you a time-history of what's going on), if debuggers had easy-to-setup log/waveform viewers I'd probably use them more. I think with experience you tend to know which method will solve a particular class of bug fastest and just use it instinctively.\n", "id": "c1dixg4", "parent": "t3_f5n00", "vote": 1}, {"content": "A \"mastermind\" probably wouldn't discard a tool if it even had the slightest hope of being useful.", "id": "c1djhfc", "parent": "t3_f5n00", "vote": 1}, {"content": "I use print statements and a debugger for slightly different tasks. Debuggers are good at inspecting how variables change in a local area of the code. Print statements are better for gaining a temporal understanding of the code.", "id": "c1djjfb", "parent": "t3_f5n00", "vote": 1}, {"content": "\"every bug is a representation of the unknown side effects of code you've written\"\n\ndebuggers are a way to get a a laser-focused view of what's going wrong, but if you don't understand the bigger ideas, there are going to be a lot of problems. ideally your code is easy enough to read that it's obvious why it's wrong. ", "id": "c1djr0q", "parent": "t3_f5n00", "vote": 1}, {"content": "I think generally it's quicker and easier to just use print statements. I rarely use debuggers and maybe I should but quite frankly I haven't really felt the need to in most situations.", "id": "c1djupp", "parent": "t3_f5n00", "vote": 1}, {"content": "I keep yelling at the hardware guys that I HAVE to have my UART so I can debug the code I write for them.  (low-level embedded stuff)\n\nA debugger is handy for sure, but the end of the day I find I do most of my debugging by sprinkling the code with printf's, even for embedded.  I find that a lot of the hard bugs are the ones that happen because of timing issues.\n\nFor example, a recent bug which was caused by a piece of code blocking for longer than expected, caused all kinds of subtle issues.  It was only by watching UART output over the course of a day or two (while doing other things) that it finally clicked what was happening.  There is no way I could have found the debugger, as the debugger would have hidden the bug completely.", "id": "c1dk1u9", "parent": "t3_f5n00", "vote": 1}, {"content": "If your functions try not to mutate their parameters and only do one obvious thing, then you may not even need print statements.", "id": "c1dk3hv", "parent": "t3_f5n00", "vote": 1}, {"content": "Not one of these languages has what I would call an interactive debugger; and none encourage coding-in-the-debugger in the way that Smalltalk did.\n\nI didn't really get this for the longest time and I'm still getting the used to the idea but it's an incredible way to work. Not only does it help you avoid littering code with debugging statements that you inevitably forget about, but it's an unbelievably productive way to produce and explore your code.\n\nIn the hands of the masters I've seen interactive debuggers and refactoring browsers used to do some amazing things.\n\nEdit: Not that I can blame people who don't want to use an interactive debugger. Most interactive debuggers really suck ;).", "id": "c1dkgzr", "parent": "t3_f5n00", "vote": 1}, {"content": "I don't need one.", "id": "c1dkh7b", "parent": "t3_f5n00", "vote": 1}, {"content": "I struggle watching my colleague adding print statements, recompiling and running our GUI again just to test theory #1 about what is the cause of the bug.\n\nWe program Java using Eclipse, where debugging is as easy as clicking a button on the line you want to go to, and once you're there you can jump up and down the stack, look at any variable, pause and resume threads, evaluate code, etc. If I have to debug third-party code I don't know by heart (which is trickier to 'just add some print statements to'), I just throw it at the debugger and have a look at the stack to see what's going on - this often gives a good feeling about the architecture of different functions and modules.\n\nMy favourite Eclipse feature is that I can just edit the source code from within the debugger, click Save, and let Eclipse automatically re-run (within reason) using the new code. Several times I've committed bug fixes while in the middle of a debug session that is still running - having just tested live what went wrong, it's also easy to write the unit test.", "id": "c1dki1t", "parent": "t3_f5n00", "vote": 1}, {"content": "I do all my coding in TextMate.  To use a debugger I would have to launch an IDE such as Eclipse or ZendStudio and configure it for my current project.  Much easier to just insert a print statement.", "id": "c1dkjfg", "parent": "t3_f5n00", "vote": 1}, {"content": "You can't always use a debugger.  At my work production code goes into an environment where you can not debug (no room for a debug compile).  So, if you can't reproduce a problem in a simulated environment you have little choice but to add correct, and thorough logging and try to reproduce the problem on a live system.  \n\nYou can't always rely on your debugger, I've seen debuggers cause crashes.  I don't have anything empirical to offer you (how often, etc...), but I know it does happen.  \n\nYou can't see everything with a print statement ... threading race conditions can be almost impossible to see with a print statement on a real time system.  \n\nReading code doesn't solve all problems either.  \n\nI realize this example is a bit contrived but it is a great strawman: \n\n    #include <stdio.h>\nmain(int t,char _,char *a)\n{\nreturn!0<t?t<3?main(-79,-13,a+main(-87,1-_,main(-86, 0, a+1 )+a)):1,t<_?main(t+1, _, a ):3,main ( -94, -27+t, a )&&t== 2 ?_<13 ?main ( 2, _+1, \"%s %d %d\\n\" ):9:16:t<0?t<-72?main(_,t,\"@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l,+,/n{n+\\,/+#n+,/#;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l q#'+d'K#!/\\+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# ){n\\l]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#\\ n'wk nw'iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c \\;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;\\#'rdq#w! nr'/ ') }+}{rl#'{n' ')# }'+}##(!!/\") :t<-50?_==*a?putchar(a[31]):main(-65,_,a+1):main((*a == '/')+t,_,a+1 ):0<t?main ( 2, 2 , \"%s\"):*a=='/'||main(0,main(-61,*a, \"!ek;dc \\i@bK'(q)-[w]*%n+r3#l,{}:\\nuwloca-O;m .vpbks,fxntdCeghiry\"),a+1);\n\nSource: http://www.funenclave.com/reality-bites/most-confusing-c-code-7690.html#ixzz1BctbOhUP\n \n\nPoint is:  use all tools available, they all have their place.\n\nAside:  I prefer print statements, and I am no where near as good as the people they wrote about.  I probably never will be, but I will aspire.  ", "id": "c1dkkha", "parent": "t3_f5n00", "vote": 1}, {"content": "Debugging by print statement, bitchez. Been doing it since 1987. No reason to change. ", "id": "c1dkluh", "parent": "t3_f5n00", "vote": 1}, {"content": "I usually only use a debugger as a last resort, but if I get a segfault in a C or C++ program the first thing I do is run it through gdb to get a stack trace.\n\nThe other main use for debuggers is stepping through code. I've almost never done this except when I was learning. It's less useful when you can write clearer code and can see what is going on with more experience (and maybe some prints to help). I've learned to write code simple enough to step through in my head.", "id": "c1dko89", "parent": "t3_f5n00", "vote": 1}, {"content": "> Another guess is that they just have more brain \"stack space\" and they can simply hold more code in their heads than people who need to rely on debuggers.\n\nFor me, it's the opposite. Concentrating on the problem is hard enough on its own; I don't want to have to think about a debugger as well.\n\nI use a mixture of print statements and unit tests. Unit tests generally mean that most bugs I get are simple, trivial ones. When I've fixed the bug, I put it in a regression test so it doesn't come back.", "id": "c1dksbz", "parent": "t3_f5n00", "vote": 1}, {"content": "> almost to a man\r\n\r\nNever heard that one before...", "id": "c1dkse8", "parent": "t3_f5n00", "vote": 1}, {"content": "Use of a debugger really depends on the environment.  If it is python then my usage is rare to never. If it is C then it is much more frequent.  When I get a segfault gdb is the first thing that I reach for.  A few watches and I'm usually out of the woods.\n\ntl;dr: when a language has a REPL, I tend to debug upfront.", "id": "c1dloza", "parent": "t3_f5n00", "vote": 1}, {"content": "And I always thought it was because I'm too lazy to properly set up debugging. \n\nWhen I was using Visual Studio it was trivial, but when I'm using Eclipse to write PHP being run off a server... I know it can be done (the guy next to me does it all the time) but \"configuration\" is by far my least favorite part about programming. Not surprisingly, the guy next to me is much better at debugging than I am.", "id": "c1dlxqv", "parent": "t3_f5n00", "vote": 1}, {"content": "I practically never use a debugger. The only time it is necessary is when I honestly can't figure out where a bug is, which is not a very common occurrence. Simply put, if I'm writing a program I will know the layout well enough that most of what a debugger offers me is redundant. Other than that it's simply less of a hassle to add a few print statements to track the flow of logic, and confirm my suspicions that a given section is in fact what's causing the problem. \n\nIt's like that \"miserable programmer paradox\" article says, why use a complex tool which requires a bunch of setup? Compile a debug build, attach the program, set the breakpoints/watchpoints/whatever, step through the affected sections, possibly skip over various intermediate sections, analyze the affected variables or sections of memory and on and on.  I could just add print(\"a\"); print(\"b\"); print(\"c\"); to the critical sections, recompile, and run the program once or twice. Yes, a debugger could offer me more info, but again, most of that is already in my head anyway.", "id": "c1dm38d", "parent": "t3_f5n00", "vote": 1}, {"content": "I write code in pico and write one makefile in Unix.", "id": "c1dm3dk", "parent": "t3_f5n00", "vote": 1}, {"content": "External state is the answer. Try debugging networking code with a 30s timeout, or database code with a transaction timeout. \n\nFairly annoying it is.", "id": "c1dm8r1", "parent": "t3_f5n00", "vote": 1}, {"content": "I think the reason for this is that a debugger can sometimes actually confuse you more than anything. Especially an interactive one, where you have to step through things by pressing F[whatever] key over and over again. By distancing yourself from a debugger, you force yourself to pay more attention to the code and where to place you print statements. My 2 cents.\n\nSaying that, having a debugger in your tool belt is never a bad thing to whip out when you need it. I just tend not to need one most of the time.", "id": "c1dm8vb", "parent": "t3_f5n00", "vote": 1}, {"content": "Logs work on release version that has no debug info.", "id": "c1dmcnu", "parent": "t3_f5n00", "vote": 1}, {"content": "> But really, you never use a debugger? [...] It saves me over and over again when dealing with code I don't understand.\n\nThis is the crux of the matter: the 'masterminds' make it their job to understand the code. That route sometimes takes a little longer when trying to fix a bug but generally means your bug fix and any subsequent amendments will be much more robust.\n\nI think the logging vs. debugger argument is a red herring - both are just ways of observing the data, and although that is valuable, it's no substitute for understanding the system that works on the data. Well over half the bugs I fix can be found by looking at the code alone.", "id": "c1drv6l", "parent": "t3_f5n00", "vote": 1}, {"content": "Interesting. I fucking love the debugger, but of course I'm using visual studio and have edit and continue. When I'm on the Xbox or wp7 running that irritating compact framework, I lose edit and continue. It's like being shot in both knee caps. \r\n\r\nI put a metric shit tonne of stuff to the output window as well tho when I need to, so I can see how one could program quite well without the debugger.", "id": "c1dh9nh", "parent": "t3_f5n00", "vote": 1}, {"content": "If it's language designers, then surely when the answer was true, there were no debuggers only freshly written compilers? >.>", "id": "c1dh5y6", "parent": "t3_f5n00", "vote": 1}, {"content": "At my previous job, I lived in the debugger.  At my current job, the debugger is barely an option (gdb has generally been broken within the VM I develop in, amongst other things).  Two observations:\n\n1. When I can't just walk through newly written code with a debugger, I get less lazy and anticipate a lot more issues / holes in logic BEFORE hitting them.\n2. I'm forced to write more / better logging, leading to much easier debugging once the product is in the field.\n\nThe first observation, I think is just a good thing.  I have surprisingly few low-level, stupid bugs to contend with these days, and that's a good thing.  Usually those stupid bugs take a couple of minutes to resolve (null pointers, double-deletes, broken copy-constructors, all the stupid crap you hit in C++), but sometimes much longer.  With a bit of fore-thought I just avoid them altogether.\n\nThe second observation is a real life saver - I work in the broadcast industry, so generally the programs I write cannot be taken off-line for a bit, or tinkered with.  If they're flat-out broken, maybe I can be more extreme (maybe I have to be), but usually I have to produce a reason for the issue while the system is running, and provide a replacement binary that is patched in at a safe time of day/week.  Having good logging lets me really dig into the issue quickly without needing to attach a debugger or generally fuck around in a way that might break a live, on-air system.\n\nHaving said all of that, I think part of the \"I don't want/need to use a debugger these days\" ethos comes from just being a much better programmer than I was a couple of years ago.", "id": "c1dh8ai", "parent": "t3_f5n00", "vote": 1}, {"content": "Real programmers write assembly code from Edlin.", "id": "c1dhefm", "parent": "t3_f5n00", "vote": 1}, {"content": "Apparently I've been \"debugging like a mastermind\" since I was a child. I've never met a debugger that I liked, or that I trusted, and besides: I like solving the problems myself.", "id": "c1dhnnb", "parent": "t3_f5n00", "vote": 1}, {"content": "Oddly, I just haven't learned how to use a debugger yet.  I tend to \"read the code\", write output to the console, or I write exceptions.  ", "id": "c1dhs38", "parent": "t3_f5n00", "vote": 1}, {"content": "Uh.  Yes, they do.", "id": "c1dil64", "parent": "t3_f5n00", "vote": 1}, {"content": "If handy sure, but how often are they? A lot of bugs are in places that are hard to reproduce, need specific triggering, or on platforms with limited debugging support. Printk and a few scripts to build/copy/load quickly work well. Also, having to watch the debugger go through a function 50 times, because it only triggers on the 51st loop can be a pain (there are tricks for this I know).\n\nPersonally it might just be taste, but for kernel programming, gdb is about useless.\n\nOh, and just try it for an IE activex plugin, written without ATL or MFC using mingw... I've debugged a virtex 5fxt with less trouble than that... jesus...", "id": "c1dim83", "parent": "t3_f5n00", "vote": 1}, {"content": "i work mainly in server-side scripting languages, and I never use debuggers and almost never use interactive shells.  The closest i come is using Firebug to monitor javascript execution, but that is just to read console.log statements and object dumps.\n\n\ni'm not going to just come out and say everyone who works this way is a genius, but having some musician friends, the closest i can liken the act is a musician who can cold read sheet music.  you just see it and execute it in a shorthand manner in your brain, and then pick it apart a little to work out the finer details.\n\nedit: i don't use an ide and i work with un-compiled languages where inserting print statements is cheap and quick, and therefore rely exclusively on that method to debug.", "id": "c1dips5", "parent": "t3_f5n00", "vote": 1}, {"content": "    Segmentation Fault\n\nHuh, wonder where that happens. Let's fire up gdb. Oh, I see, let me go back into that code and have a look at it.\n\n99% OF MY DEBUGGING.\n", "id": "c1divan", "parent": "t3_f5n00", "vote": 1}, {"content": "From the article: \n> It saves me over and over again when dealing with code I don't understand.\n\nThis is at the heart of the conversation and the OP's question. Programming Masterminds spend most of their time trying to understand the question they are attempting to solve. The invention/modification of a programming construct (the code) is written last. If we don't understand the code or, more importantly, the question of why we are writing something, I encourage all my colleagues to step away from the project code. If one understands the question and the language they are using, clear print statements work very well.", "id": "c1dhr5k", "parent": "t3_f5n00", "vote": 0}, {"content": "I've programmed in probably 8 languages in the last year, across several IDEs. Some don't have debuggers at all. Print statements are just a habit that is portable.", "id": "c1dhbb5", "parent": "t3_f5n00", "vote": 0}, {"content": "Not that I'm bragging or anything but neither do I...\n\nPrint statements and logic are all I usually need to solve a problem. I've only been programming for 4 or 5 years but I've never even USED a debugger, never had a need for it.", "id": "c1dhsvi", "parent": "t3_f5n00", "vote": 0}, {"content": "The problem with debuggers is that they interrupt the flow of the system that they are debugging.\n\nI use gdb all the time to do postmortems, and I dearly love the crash command, but interactive debugging is rarely useful.", "id": "c1diqh2", "parent": "t3_f5n00", "vote": 0}, {"content": "Third option besides debugging and prints: use tests. I know this isn't applicable everywhere. Sometimes you might be better off by writing a set of tests to assert the behavior of some specific part.\n\nI personally don't use this (logger/debugger myself :) ) but I can see it being quite useful if you are dealing with some weirdo code you have to maintain or something. :)\n\nI saw this tip in Uncle Bob's Clean Code and concur with it. As an added benefit you can refactor the code with good confidence once you have reached the needed coverage.", "id": "c1dh5qv", "parent": "t3_f5n00", "vote": -2}, {"content": "in php you have to scatter echos everywhere anyway if you want to debug", "id": "c1dh4t1", "parent": "t3_f5n00", "vote": -1}, {"content": "Most of the people interviewed were famous algorithm developers. When writing algorithms or data processing stuff, it is usually easiest to split up your code into small chunks that work properly, and to have the code verify itself that it is working properly.\n\nDebugging is usually needed when using someone else's code or libraries, and having to check in real time what the stupid 3rd party code is actually doing. This happens most when using GUI libraries, and/or anything microsoft realted.\n\nUnix developers have a more stable code base and better documentation on apis. As a result, algorithm developers, who tend to test and create first on unix/linux, have little need for a debugger. Essentially; they write all their code correctly and aren't interested in trashy 3rd party libraries.", "id": "c1diyr2", "parent": "t3_f5n00", "vote": -1}, {"content": "Because we don't create bugs. /s", "id": "c1dh6np", "parent": "t3_f5n00", "vote": 0}, {"content": "Most of the problems I need a debugger for are a result of me not knowing the language or the libraries well enough. I can imagine the people who wrote the languages and libraries don't need to debug often enough to get use out of a debugger.", "id": "c1dh9ws", "parent": "t3_f5n00", "vote": 0}, {"content": "Been programming since 1982 in basic, fortran, pascal, C, C++, perl, visual basic, java, assembly and probably some others I've forgotten.  Never used a debugger.  Hell I should be honest and admit I've no real idea what a debugger is or does.  I've always been able to debug my code just by (as the article mentions) inserting print statements and just looking at the code.", "id": "c1dhdpi", "parent": "t3_f5n00", "vote": 0}, {"content": "Why do I use prints instead of a debugger (most of the time)?\r\n\r\nSimple.  My programs involve a lot of state transitions, complex ones.  Looking at the output of a series of prints enables me to trace both good and bad sequences over longer periods of time.  A debugger shows me only a few things at one moment; the prints show me a larger quantity (in a format *I* want) over longer sequences of time.\r\n\r\nMaybe it's the kinds of problems that people are doing, and not the superiority of one technique over the other.  Nice to be familiar with both, though.", "id": "c1dhj1t", "parent": "t3_f5n00", "vote": 0}, {"content": "Huh... that's interesting. I've always considered my debugging to be the same... insert some print statements and follow the code to the problem. Why is that amazing? Are there easier ways?", "id": "c1dhlir", "parent": "t3_f5n00", "vote": 0}, {"content": "Many people here seem to think that it's either logging or debugging one should use. Buuuut they serve different purposes - to me, logging is for tracing event sequences or when I want to look at a lot of data (loops, etc.) - a debugger allows me to jump between stack frames and inspect everything in a complex call hierarchy, and while you COULD do that with logging, it's rather tedious to implement.", "id": "c1dho1j", "parent": "t3_f5n00", "vote": 0}, {"content": "They put few enough bugs in their programs that using a debugger wouldn't really help all that much.", "id": "c1dhvig", "parent": "t3_f5n00", "vote": 0}, {"content": "[deleted]", "id": "c1di2aa", "parent": "t3_f5n00", "vote": 0}, {"content": "I use a debugger to find out what libraries I'm using (source code frequently unavailable) are actually doing instead of what they're advertised to do.  That would be every API on Windows ever.", "id": "c1di2om", "parent": "t3_f5n00", "vote": 0}, {"content": "printf is all you really need.", "id": "c1di46r", "parent": "t3_f5n00", "vote": 0}, {"content": "Some say the world will be fixed with a debugger\nSome say println\nFrom what I've tasted of the buggers\nI hold with those who favor attaching debugger\nBut if I had little to find\nI think I know enough of my clients' ire\nTo say that for println\nIs also great\nAnd would not get me fired\n", "id": "c1di49u", "parent": "t3_f5n00", "vote": 0}, {"content": "The only time I find myself in need of a debugger is when complex dynamic data structures (like trees) are involved in C code. But that doesn't happen much, since most of the times inserting print statements is enough. In Python I don't think I've ever used a debugger at all - `print` and `pprint` are very handy. And I'm pretty good in debugging, so I guess this is working for me.\n\nLong time ago I read some interview where the guy said that debuggers encourage laziness. When you have a misbehavior, you can either read the code and try to verify your assumptions with printouts, or fire up the debugger and start stepping. I agree that except for a few rare cases, the first approach is much more likely to find the bug.", "id": "c1di50o", "parent": "t3_f5n00", "vote": 0}, {"content": "Debuggers for RTOS (real time operating systems) and the software that run on them frequently cause the real-timeness of the OS to go out the window. I've found that the debugger works pretty well to show you where a halted thread died, but otherwise it just screws up the timing and the system doesn't work anymore.", "id": "c1di6fp", "parent": "t3_f5n00", "vote": 0}, {"content": "I find that the way debuggers work and present information is simply too far detached from how I think about my code.", "id": "c1di6s3", "parent": "t3_f5n00", "vote": 0}, {"content": "1. Systems programmers tend to program in languages in which debuggers aren't tremendously useful.\n2. Debuggers have come a long way, but it seems likely that people who have been programming for decades got their start at a time when they were far less useful, and developed their habits based on that.\n\nTo quote Rob Pike from http://www.simple-talk.com/opinion/geek-of-the-week/rob-pike-geek-of-the-week/,\n\n>  .. a good debugger - and let's admit that most of them aren't that good - will answer questions correctly, but the problem is that you need to know what questions to ask, and that's the hardest part of debugging. \n\nTo me, that's a key insight. I use a debugger maybe once or twice a year, but it's not because they aren't useful or shouldn't be used.\nOf the available means for answering questions about the code, the debugger is simply not usually the best. Tests are more beneficial in the long term, just examining observable behavior or logs is quicker short-term, and reading the code is usually faster and just as effective (and if it is not, that's usually a bug in and of itself).", "id": "c1dicyv", "parent": "t3_f5n00", "vote": 0}, {"content": "I wrote a [terminal emulator](http://qodem.sf.net) that needs to do lots of networking stuff where timeouts matter a great deal and being paused in the debugger will dramatically change the program flow.  X/Y/Zmodem timeouts, ssh password timeouts, a remote BBS timing out, etc.  And many of the bugs were logic errors (e.g. what is the right Kermit response in this situation?) rather than crashes (for which gdb + core file generally did fine locating).\n", "id": "c1did6u", "parent": "t3_f5n00", "vote": 0}, {"content": "The only time I touch a debugger is to catch a bug that only occurs deep within a loop, for a special circumstance.\n\nOtherwise I just run the program in my head and when it doesn't make sense... that's the bug.", "id": "c1dii5m", "parent": "t3_f5n00", "vote": 0}, {"content": "I don't use a debugger as its tough (not impossible) to get the debugger to run in the right place... e.g. logged into a web application already, or an API call.", "id": "c1diit3", "parent": "t3_f5n00", "vote": 0}, {"content": "I use the system monitor (in the emulator) a lot when doing 8-bit assembly... things like breakpoints on write to the ROM range... but in higher level programming I admit to being a printf debugger.", "id": "c1dirq3", "parent": "t3_f5n00", "vote": 0}, {"content": "I only really use a debugger for embedded development when there is no reliable analogue to printf; if you have to roll your own serial driver, obviously you can't debug it by writing statements out to an RS232 port.\n\nFor applications programming, though, I can't remember when I've ever used a debugger other than out of curiosity for how they work; for example, when I taught myself python years ago I played with pdb for a day or two to get a feel for it. Neat concept, but I prefer print statements.\n\nprint statements are what I'm most comfortable with; I'm sure if I found one killer feature for a debugger and ended up using it extensively I'd grow used to it. I'm not opposed to them on any real basis; it's just the same reason why I can bang out hundreds of lines of code in vim in a couple hours but if I have to use emacs or pico or whatever, it feels like I'm using hunt-and-peck typing.", "id": "c1diwlc", "parent": "t3_f5n00", "vote": 0}, {"content": "I don't use a debugger unless I'm really stuck (so perhaps once every year), instead I insert logging statements. You can't use debuggers on live systems so need to develop the ability to debug the code by using your brain and your log files. That isn't to say I log every branch decision or function entry point but if your code is focussed to a specific task it shouldn't be that difficult to have a small amount of logging which is sufficient. If you have complex objects it isn't a bad idea to log their state occasionally. Debuggers let you peer into the system but only at development time.", "id": "c1diwog", "parent": "t3_f5n00", "vote": 0}, {"content": "This matches my actual experience.\n\nI've been programming since the 1980's,  I mostly stopped using debuggers years ago.  From experience I almost always know where and what the problem is just by seeing the problem occur.\n\nBugs I can't narrow down that quickly tend to be bizarre race conditions or timing issues.  In these cases the debugger is too slow (too many steps required) or make the problem go away.  In which case I use logging statements to show the relevant data so I can see where they occur.\n\nI programmed in .Net for about 3 months before I needed the debugger,  I had to ask a junior developer how to set it up in our environment.  He was a bit surprised because I had put version one of my data analysis app into production a month earlier.", "id": "c1dix9d", "parent": "t3_f5n00", "vote": 0}, {"content": "I use the debugger for debugging, and sometimes I use other methods for debugging.  Sometimes I even use the debugger for non-debugging purposes.\n\nIf there's a problem, a technique I sometimes use is to fire the program up in the debugger and then start stepping through it.  But as I step through it, before a statement/function/whatever executes, I figure out in my head how that should change the program state.  Then I let the debugger execute it, and then I inspect whether the actual state matches what I expected based on re-reading my own code.\n\nSo, this is similar to the \"I just read the code and see what's wrong\" non-debugger style of debugging, but I use the debugger to make sure I haven't gotten off track in that process.  Not infrequently, I will see a line of code, try to predict what it's going to do, and see the problem before I ask the debugger to execute it.\n\nBefore I discovered unit testing, I also often used the debugger as a sort of ad hoc testing tool.  I'd just fire it up and call some code then inspect the output and see if it's what I expected.", "id": "c1dj0dc", "parent": "t3_f5n00", "vote": 0}, {"content": "having to navigate breakpoints and watch variables... etc takes longer for what i'm doing than just putting in the necessary print/test statements at the right points in the program (ordered to tell me if&where something breaks)... then i either comment or delete them once done. for bigger programs, i'll use a debug bool tag to enable verbose output so i can double check my work while it runs.  but that's just me.\n\ndebuggers can help with more complex problems, but for the most part it would take more time to use.", "id": "c1dj1ui", "parent": "t3_f5n00", "vote": 0}, {"content": "I only ever use print statements to debug code. It's never failed me.", "id": "c1dj4wa", "parent": "t3_f5n00", "vote": 0}, {"content": "If you use a debugger you're restricted to what the debugger can do.\n\nIf you use print statements you're only restricted to what you can read, but you can monitor anything you want.", "id": "c1dj5ij", "parent": "t3_f5n00", "vote": 0}, {"content": "My first debugger back in '68 was a can of raid.", "id": "c1djj5m", "parent": "t3_f5n00", "vote": 0}, {"content": "I am a mastermind and I love using debuggers and profilers and unit tests and code coverage tools.", "id": "c1dof9b", "parent": "t3_f5n00", "vote": 0}, {"content": "Wake me up when I can go backwards to past breakpoints during execution. ", "id": "c1dh7j7", "parent": "t3_f5n00", "vote": -1}, {"content": "I've only been a programmer for 4-5 years and I hate using debuggers. I usually insert print statements and the like. Debuggers just always seem to take longer and can be cumbersome. ", "id": "c1dhand", "parent": "t3_f5n00", "vote": -1}, {"content": "If I could only have one, I would take print statements. I can solve any problem with enough print statements, I cannot solve everything with debugging.\n\nPrint statements aggregate better than debugging so in many cases it's faster in discovering the issue. Also sometimes issues occur rarely, and you would need to have logging statements that go to production just to figure out the nature of what is happening.\n\nHowever, in development/unit testing. a debugger is nice especially those with live code replace. Sometimes I'll stub out a method and fire up a debugger and just write the code as the debugger is running.", "id": "c1dhuck", "parent": "t3_f5n00", "vote": -1}, {"content": "Using a debugger is like taking a Spanish class then using Google Translate to do your homework.  If you really know what's going on in your code then debuggers are a waste of time.  And if you don't know what's going on with your code then you're in the wrong profession.", "id": "c1dhvuy", "parent": "t3_f5n00", "vote": -1}, {"content": "Why was this submitted? Are you making fun of the guy who created the topic?\n\nHe answers his own question:\n\n>It saves me over and over again when dealing with code I don't understand.\n\n\"Programming masterminds\" understand the code they use... especially if they're the ones who wrote it. Not sure why that's hard for the OP to grasp.\n\nI think of debuggers like spell check. If the program is telling me there is an error in the sentence, \"You is stupid,\" I know English well enough to correct it to, \"You are stupid,\" without having MS Word tell me which word needs to be changed and to what.\n", "id": "c1dhyh6", "parent": "t3_f5n00", "vote": -1}, {"content": "I have been at my current position for a little over 6 months now and I could count the number of times I have broken out the debugger on one hand.\n\nThis does NOT make me or anyone else who doesn't use a debugger a mastermind. I just work better that way and I am able to solve problems fairly quickly. My other two colleagues consistently use a debugger and are able to also solve problems in a short space of time.\n\nI have never thought of either group being better or having an advantage over the other.", "id": "c1diw3f", "parent": "t3_f5n00", "vote": -1}, {"content": "Because they run afoul of the Heisenberg Uncertainty Principle. \n\nThe act of inserting debugging hooks into the program changes the program. (This is also true of printfs, but much less so.)\n\n", "id": "c1dizf6", "parent": "t3_f5n00", "vote": -1}, {"content": "Since learning TDD, I've found I've never had to use a debugger.  I think if your design is fairly SOLID and has a good test suit you can avoid the debugger.  Every time I fire up a debugger, I feel like I've gone down a wrong path somewhere.\n\nEdit:\n\nOk, so I thought I would expand this to try and explain why I find using test-first methodology means I don't use the debugger!\n\nEvery single like of code has a corresponding test, this means I has a very clear picture of how it is going to run in a given situation.  However, unforseen situations can and do arise, and historically these are areas I would have ended up using a debugger.  This has changed with having a good test suite.  Because the code complies to SOLID, I can easily replace sections of the code to get the state in which an app is when the problem arises and can use this to construct a test that completely recreates the state and context that lead to the original error.  Not only do I now know exactly what is happening, but I have a repeatable test that will ensure it can't arise again.\n\nTHIS is why TDD and other test-first methodologies can lead to reduced debugger usage.  TDD isn't suitable for every project or developer, but it's another tool in the box that can really make your life easier\n", "id": "c1dh8nk", "parent": "t3_f5n00", "vote": -5}, {"content": "Why bother manually inserting print statements and recompiling? \r\n\r\nA good debugger takes a couple of seconds to attach and lets you add/remove print statements on the fly just as easy as if they were break points.", "id": "c1dh4j6", "parent": "t1_c1dh0sj", "vote": 56}, {"content": "> I insert prints and so on to check what's going on.\n\nI also do that, and more if needed... for instance, if in a game I want to track a specific's sprite state then I might add something like sprite.trackMe = true, which would add a big red border around the sprite as it moves through the screen, and it throws additional information to the debug output on the screen.\n\nI think it helps to realize that different approaches, people, workflows, and languages may equally work, depending. I'm currently hooking up a Windows machine to a Mac to write code in Lua wrapped in Corona to compile for the iPad. And I use the very same \"print\" that I used last year when I was doing JavaScript, or the year before when I did PHP, or Python, or ASP.NET, etc., and I use the same homemade development editor too. In my current Lua Corona code I have a small framework with various output methods for debugging, like showDebugInfoOnScreen, printToTerminal, showClockandFPS, showDebugInfoAndStop, etc. (the names are paraphrases). And when I compile to put it on the iPad, I still got the debug info on screen to help me watch some of the info when people play.\n\nHowever, this is a specific context I'm talking about, and this approach my be a total failure for other context, so one would need to adjust... for instance, I rarely debug other people's code (I'm sometimes facing bugs in the middleware or render engine but can't open that either way).\n\nSo, generally I think we should accept that there are different tastes and contexts and different pros and cons. In fact, if I'd work in a team it might be absolutely excellent if one programmer was of mindset A and another of mindset B, because this way you cover additional \"idea space\" and avoid groupthink. I love to see how other people use tools and I bet there's a lot of win in using a debugger and break points etc.\n\ntl;dr: Frogs fall in love like people, too.", "id": "c1dhbxr", "parent": "t1_c1dh0sj", "vote": 7}, {"content": "I pretty much use the same process also (nice to see I'm not alone). I almost exclusively just look at the code and go into 'spot what's wrong' mode, I then insert print statements or popup boxes as and when if it's not behaving the way I expect.\n\nI only really tend to use the debugger when I'm dealing with masses of data and sporadic random bugs which only happen under, rare conditions, or to look at the data as it's running and look for any behaviour that doesn't look right. \n\nThat said, the recompile time is frequently not a big factor for me, like everything it depends on the context.\n\nEach to their own though, whatever works best for the individual. I tend to get annoyed at these \"Only good coders do X, use Y, if your not doing this then your doing it wrong\" crap, just do whatever works and just use common sense.", "id": "c1dhryt", "parent": "t1_c1dh0sj", "vote": 8}, {"content": "Reading the code + current state(debugging) is usually much more easy than just reading the code.\n\nUsing a language like C# and an IDE like Visual Studio will also let you edit the code in debugging and then running it again - you can fix the bug and test the fix without even stopping the debugging in some cases.", "id": "c1dinyp", "parent": "t1_c1dh0sj", "vote": 3}, {"content": ">but usually reading through the code will get your answer a lot quicker\n\nWell yes and no. This assumes you know where to begin looking in the first place. If you have a several hundred thousand line code base and all you have is a crash dump file from a customers machine then good luck just reading the code. ", "id": "c1dhnif", "parent": "t1_c1dh0sj", "vote": 2}, {"content": "It sounds like hooking up a debugger is a chore.  Is that the problem?\n\nI find that if I'm working on some c++ project on Linux in a command line, possibly not even compiled with debugging symbols, I'll really resist a debugger.  It's hard to even examine data within unicode strings and STL data structures in gdb.\n\nBut then when I'm in Java in eclipse, writing a unit test that doesn't work, I don't hesitate at all to just add a breakpoint and debug it.  It takes about 1 second and all of my variables are easily visible.", "id": "c1diaaq", "parent": "t1_c1dh0sj", "vote": 2}, {"content": "It's so strange to see this.  I'm the same way, but have always been too embarrassed to admit it.  I just feel it takes longer to find the issue when I am using a debugger, but feel prints and so on are amateurish.", "id": "c1diqx8", "parent": "t1_c1dh0sj", "vote": 2}, {"content": "In embedded systems, there is nothing to \"print\" to.", "id": "c1dhz6r", "parent": "t1_c1dh0sj", "vote": 1}, {"content": "Agreed. The bugs I run into are not usually the type that a debugger will show (excepting seg faults). Fixing a bug requires understanding what should happen and what is happening. A debugger won't tell you what should happen, which is the hard part anyway.", "id": "c1dignm", "parent": "t1_c1dh0sj", "vote": 1}, {"content": "*Master programmers don't use debuggers*. What self congratulatory counter productive nonsense is that? *Only a fool does not use all tool available to him.* \n\nI would be very surprised if Bjarne said anything of the sort.\n\nLittering your code with debug logging is the intrusive, highly coupled naive solution. Automatic debuggers, profilers, and tracers you can connect or disconnect at will represents a better solution. Logging is still useful for creating a historical \"paper trail\". You should not not use that as your only way of debugging unless you are forced too though.\n\n", "id": "c1disvy", "parent": "t1_c1dh0sj", "vote": 1}, {"content": "Yep. This.", "id": "c1dl9ls", "parent": "t1_c1dh0sj", "vote": 1}, {"content": "Inserting prints is useless if you have a debugger. But I do agree with the masterminds, using a debugger should not be necessary. It means you've made a logic error and if it's your own code then you can fix it faster by proof-reading the code. If it's not your code then I think a debugger would be more productive to isolate the problem.", "id": "c1dhgxn", "parent": "t1_c1dh0sj", "vote": -2}, {"content": "I do this with C#.  Edit and Continue FTW!", "id": "c1dhufr", "parent": "t1_c1dh7l9", "vote": 7}, {"content": "Yeah, but sometimes it's still nice to see the stack trace :)", "id": "c1dh2ex", "parent": "t1_c1dgyth", "vote": 9}, {"content": "Ah, yes.  This would explain the slew of new programmers that avoid threads.", "id": "c1dh9mv", "parent": "t1_c1dgyth", "vote": 5}, {"content": "> Why wouldn't you use a debugger?\n\nI find that for most bugs, it isn't that useful.\n\nIf a bug involves \"Why does execution **get** there?\" then running a debugger with a break in the relevant code, then looking at a stack trace, is the fastest and best way to figure it out.\n\nBut in practice, most bugs I work on tend to be of the kind where this isn't the case. It's just faster to think about the problem a bit, figure out what are the relevant actions to the bug, add some printfs in the right places, then run it, and finally analyze the output. The last part tends to take the longest - the output might be very long, and I end up doing searches, grep, etc. to find the problem.\n", "id": "c1diqgv", "parent": "t1_c1dh9iu", "vote": 7}, {"content": "I've taught programming before, and having early access to a debugger like visual studio IS a crutch. It leads to the bad habit of going to the debugger first when something goes wrong, rather than simply re-reading code. It also leads to a guess-and-check style of programming. Eventually once the students are able to do a little thinking to fix minor bugs, the debugger is a powerful too to fix pointer problems.", "id": "c1diizn", "parent": "t1_c1dh9iu", "vote": 20}, {"content": "> The fact is, if you DO understand your code, then you can track down any bug pretty much instantly with a debugger.\r\n\r\nI can't count the times I've stepped through my code for 5mins only to find a trivial typo that I could've found in 30s by just reading. Certainly you shouldn't eschew debuggers, but there is a significant cost in booting it up and changing mental contexts, so in many cases you can likely save time by \"rubber-ducking\" the code instead.", "id": "c1dhwt3", "parent": "t1_c1dh9iu", "vote": 16}, {"content": "The issue is that everyone assumes they're dealing with the same problems and the same environments and the same tools.  Which is almost never the case.  In some cases, using a debugger is so easy it's almost difficult not to use one and in other cases using a debugger is slow and painful or simply unavailable.  Put two people with those two environments in a debate about debuggers and you'll get a lot of different opinions.\n\nIn my case, when I'm developing desktop software in .NET using the debugger is pretty much the default.  But I never use a debugger when writing PHP code, even though one exists, because it's so much more finicky than just inserting some print statements, debug logging, or exception throws.\n", "id": "c1digpz", "parent": "t1_c1dh9iu", "vote": 8}, {"content": "This.  (no pun intended)\nOne thing I've noticed is that the people who don't use debuggers usually just can't.  I've caused senior software developers to go wide-eyed when I pick out a simple break point, take a few steps, and then tell them exactly where and why they're getting an exception.  Takes less than a minute - and doesn't require dropping in print/logging statements.\n\nWhen you know where the problem is before it happens, you put in a print statement.  When something that's really a problem occurs, I see people put a print statement at the start and then the end of the questionable block - then start working (by moving them around) to find out where/why things went wrong.  This takes much, much more time than just stepping through.\n\nIf you know the problem, or have a reasonable guess as to where/what it is, then you can just print out some things, fix it and move on - if it really is an unexpected problem, it's better to be able to look at things step by step.  You can (*if you know how to use your debugger* <- important) find the exact line(s) where things fall apart - and you can even (let's say that there's a problem with a pointer not being set) test a simple fix on the fly, to prove what the problem was.", "id": "c1dhgns", "parent": "t1_c1dh9iu", "vote": 34}, {"content": "Welcome to the new /r/programming!  Where doing an obscure math problem in Haskell makes you an expert on all things programming related!\n\nWe have more smart people per square inch then MIT!", "id": "c1dhh5t", "parent": "t1_c1dh9iu", "vote": 18}, {"content": "We didn't use a debugger at my last job for the following reasons:\n\nThe system consisted of multiple executables that synchronized on boot.  If one of the executables was late, the system would fail boot.  If one of the executables crashed or was killed, the entire system would need to be restarted.\n\nThe system was event driven, caused by periodic hardware inputs.  Failure to respond to an event would cause the system watchdogs to trigger and shutdown the system, so \"Stepping through\" the code was not feasible.\n\n90% of our issues were not seen on systems where the effected programmer was directly in front of the system (when you work with systems that cost 250k and need specially designed rooms, each developer gets maybe 1-2hrs of time on the system a day).  You'd hope for a good description & a complete log dump.  If it wasn't in the log, good luck finding out what the issue was.\n\nWe did use the debugger to get a stack trace when we had a core dump.  This usually pointed exactly to what caused the crash to happen.", "id": "c1dhw54", "parent": "t1_c1dh9iu", "vote": 6}, {"content": "It's not bragging.  Rather, it's the realization that virtually always, hitting the debugger is a sign that you've already made a terrible mistake.  An interactive debugger is occasionally quite useful, but most of the time it's a time suck, and a poor substitute for other things you should have done already that would have prevented you from getting into that mess.\n\ntl;dr: Using a debugger is generally inefficient, so good programmers tend to avoid spending time in them.", "id": "c1dk47j", "parent": "t1_c1dh9iu", "vote": 2}, {"content": "Thank you for bringing some sanity to this rockstar programmer wankfest.", "id": "c1dj9v2", "parent": "t1_c1dh9iu", "vote": 5}, {"content": "Plus they forget that many programming masterminds have either designed or implemented debuggers themselves.", "id": "c1dhu72", "parent": "t1_c1dh9iu", "vote": 1}, {"content": "> The fact is, if you DO understand your code\n\nIf you do understand your code, then by definition what it actually does is the same as what you intended it to do, and there can't be any bugs in it.\n\nIt follows that no programmer fully understands the code they are writing.", "id": "c1dku1e", "parent": "t1_c1dh9iu", "vote": 1}, {"content": "Did you read the blog post?  The author is confused why people wouldn't use debuggers - there is no bragging involved.  But that doesn't change the fact that a lot of the \"master\" level developers don't use one.\n\nYou're just too insecure in your own skills and believe that people can't do things differently than you.", "id": "c1dj0ex", "parent": "t1_c1dh9iu", "vote": 1}, {"content": "Nah, it's not elitism -- a debugger's just a bad tool.\n\nWell designed logging gives you the same information you'd be hunting and pecking for using a debugger. As long as you've managed to predict what's the important information, your existing logs will _already_ have the info you'd want from the debugger (not always, but overwhelmingly so; the missing bits you can just add a new print statement or two).\n\nAnd how do you predict what's the important information? Familiarity with the codebase and general experience with coding. Guido and friends have plenty of both.", "id": "c1dhhll", "parent": "t1_c1dh9iu", "vote": -4}, {"content": "Or...\n\nYou are not a a very good programmer yet.", "id": "c1dihxg", "parent": "t1_c1dh9iu", "vote": 0}, {"content": "> If you DO understand your code...\n\nThen it doesn't have bugs. Bugs are where the program does something you didn't expect, don't understand, and don't want.\n\n> It sounds to me like just more elite bragging\n\nThat might explain some of the people in the book, maybe the more conceited of them, taking this position. It doesn't explain its near-universality.", "id": "c1di2kx", "parent": "t1_c1dh9iu", "vote": -2}, {"content": "I'm impressed they got an interview with him. He doesn't give many these days.", "id": "c1dh8uo", "parent": "t1_c1dh15u", "vote": 10}, {"content": "He's still trying to figure out where the barber gets shaved.", "id": "c1dhcpl", "parent": "t1_c1dh15u", "vote": 13}, {"content": "Last I heard, he sent it to Godel for peer review. Guess he made a lot of revisions; that was about 80 years ago.", "id": "c1dks1w", "parent": "t1_c1dh15u", "vote": 1}, {"content": "Not to mention system debugging, especially kernel debugging, often requires attaching a separate computer via a serial cable.", "id": "c1dh6ap", "parent": "t1_c1dh5tt", "vote": 10}, {"content": "What do you program in?\r\n\r\nI ask because as a .NET developer I often don't feel a context switch going from straight coding to debugging and back. It is just part of the flow to me.", "id": "c1dh4od", "parent": "t1_c1dh3vx", "vote": 19}, {"content": "I would add: good logging statements comes from good understanding of the code.  So adding the logging improves the understanding of the code, and helps avoiding bugs in the first place.\n\nAnd some code (e.g. multithreadded code) *needs* to be clear as you simply can't debug bugs out of it. Finding race conditions using a debugger aint easy.", "id": "c1dh97t", "parent": "t1_c1dh3vx", "vote": 3}, {"content": "That's too much logging for my taste.\r\n\r\nMy logs are not for myself. My logs are for my production support staff so they can fix stuff without bothering me. That means it only contains stack traces and stuff that they care about.", "id": "c1dh4rb", "parent": "t1_c1dh49d", "vote": 9}, {"content": "Yes, this is a good point.\n\nHowever, I would clarify this further by saying that logging and debuggers can be important with heavy systems that need a long time to start and stop.\n\nA important criteria for well designed system is that the cycle of \"1. change the code 2. run the code\" is short. For such systems it is easy to add assertions and print statements, and even add more automatic tests. This is very powerful.\n\nMy assertion is that if you need to use a debugger, you have a bad system design :-)", "id": "c1dh8he", "parent": "t1_c1dh49d", "vote": 1}, {"content": "gdb can debug backwards just fine now.", "id": "c1dkg4o", "parent": "t1_c1dh72b", "vote": 1}, {"content": "Not to mentioned that print statements are behaving more or less the same in every language in existence while debuggers are different everywhere or don't exist for some languages at all.", "id": "c1dha3k", "parent": "t1_c1dh6q0", "vote": 10}, {"content": "Yea this is correct I think. The only reason we break out the debugger is when we, for example, are connecting to some third party web server and we want to see how it is behaving. Usually you already know the cause of the bug just from a quick look at the code. ", "id": "c1dh7tl", "parent": "t1_c1dh6q0", "vote": 1}, {"content": "Incidentally, the debugger in Javascript is genius. I am thinking of Firefox and Chrome specifically. It's easy to forget all of the member variables of a DOM object and popping it up in the debugger allows full inspection/introspection.\n\nAlso, finding variables being stomped because of scoping issues is easy to find in the debugger (you can see it happening) but you'd never think to look for it with print statements (or I wouldn't).", "id": "c1di1cx", "parent": "t1_c1di0rl", "vote": 2}, {"content": "Which game?", "id": "c1dj24u", "parent": "t1_c1di0rl", "vote": 1}, {"content": "I'm posting from my ivory tower here, but wouldn't a more functional side-effect free style allow you to decompose these problems where you don't have to trace state from the beginning of time all the way through to a crash in this situation?  I can't imagine how you'd hold something like this together with imperative code.", "id": "c1do2sd", "parent": "t1_c1di0rl", "vote": 1}, {"content": "> Only trivial code can be reasoned out. Last company I worked for, no\n> kidding, had three separate functions each over 1400 lines of C++\n> code.\n\nIf the code is hard to figure out *and* buggy, it should be rewritten by someone capable of expressing him or herself more clearly.  \n\nAny idiot can write complex code -- whether or not the problem it tries to solve is complex.  Good programmers write code that is easy to understand and easy to verify for correctness even if the underlying problem is complex.  \n\nOf course, writing code that is clear and correct is more time consuming than hammering out brutish code that is bulky, badly structured and hard to follow -- and then hoping that it is largely correct. If the code is important, it is worth the extra effort of doing properly.\n\nRemember, you don't write source code to talk to the compiler -- you write source code to communicate knowledge to other programmers.", "id": "c1dorxw", "parent": "t1_c1di0rl", "vote": 1}, {"content": "But the same is true if you add print statements to the code. I've dealt with more than a few bugs that went away when I added some logging.", "id": "c1dil5q", "parent": "t1_c1di9yw", "vote": 3}, {"content": ">Also... when you attach and run the debugger, you are NOT running the same code.\n\nSometimes no, sometimes yes. that said...\n\nThere is no such thing as \"runs fine in debugger\" (and not without). If code doesn't run well without debugger, it also doesn't run with it. It may *appear* to run well, but it does not.\n\nAnd whoever says it does run in debugger is not making himself any favours, because he failed to spot the error while code was running in front of his very eyes.", "id": "c1dj53q", "parent": "t1_c1di9yw", "vote": 1}, {"content": "You, and most other people here, are assuming that good logging is either present or trivial to add. Debuggers are invaluable when you have to figure out code that you have no source to, can't get source to, and doesn't log very well.\n\nAlso kicks ass for figuring out core dumps.", "id": "c1djeka", "parent": "t1_c1dhe7j", "vote": 3}, {"content": "Really? I'm both...", "id": "c1dinhk", "parent": "t1_c1dhh18", "vote": 1}, {"content": "I cannot fire up a debugger for CPE issues.\n\nI cannot get a detailed core file back from certain processes because of the memory footprint (rare nowadays)\n\nI cannot use a debugger on certain parts of my code because it has real time constraints.\n\nI have problems where using a debugger changes the behavior of the platform (signal processing, IPC, too many damn threads).\n\nI am not going to fire up a debugger for a bug that can be RCA'd by looking at the code for 5 minutes. \n\nIf the first thing you do when you encounter a bug is start up a debugger, then it is no longer a luxury but a necessary tool in your programming tool chest. \n\nThe best programmers *I've* known advocate that debuggers be a supported feature of the tool chain and support, but understand we live in a world where it's not always possible to do so.\n\nA Debugger is a luxury/crutch that is taken for granted. **You need to know how to debug without one.**\n\nSo, am I (a) (b) or (c)?", "id": "c1dj3xc", "parent": "t1_c1di0vq", "vote": 9}, {"content": "In all fairness, I was also part of the  \"We just need printf everywhere!!!\" camp while working with the GNU tool chain. \n\nNow that I actually get *paid* to do work, and having discovered the Eclipse visual debugger, and later, the Visual Studio compiler/debugger, I had to retrain myself on everything I thought I knew about debugging. \n\nGCC/GDB just plain suck. If that's all people know, you can't blame them. \n\nI'm relieved beyond belief that Apple is pouring cash into LLVM/Clang. The sooner we leave the old GNU cruft behind, the more productive we all can be. ", "id": "c1diwor", "parent": "t1_c1di0vq", "vote": 5}, {"content": "of course it is, and anyone who downvoted you for that statement doesn't understand computers.  What do they think a print statement does?  It does absolutely fundamentally the same thing that a debugger does when it shows you the value of a variable or expression.\n\nI think this post (hardly an article) is pretty inane.  You use the tools that best fit the situation.  Integrated debuggers come at a cost and are not as facile as simply keeping track of your code and testing often. Print statements are one of the debugging tools.  It isn't that there are masterminds that choose not to use integrated debuggers because they are mentally superior.  Partly they are careful enough that a situations don't often arise where they need an integrated debugger, and partly they don't want the hassle of firing up the debugger.", "id": "c1dhjc9", "parent": "t1_c1dhe63", "vote": 2}, {"content": "Fuck yes, cheers for the encouragement. I use middleware/open source like it's going out of fashion. I shit my pants with joy when I see I can have full source linked as a project, not just the dll. Why reinvent the wheel? Plus you'll spot some really funky shit you've never seen before and asimilate it after looking it up. That's how I learnt about anonymous delegates and how lambda's *really* used and worked.\r\n\r\nStill gotta be careful and able to sculpt what I need tho.\r\n\r\nEdit: clarification", "id": "c1dh9i9", "parent": "t1_c1dh2go", "vote": 5}, {"content": "Let me judge your skills by the wording you use, would you?", "id": "c1dhaf3", "parent": "t1_c1dh2go", "vote": -1}, {"content": "I've always done this. Between the exception output and error handling, plus any logging, you *usually* don't need a debugger. They can be useful for tracking down oddball nulls, but that's about it I find.\n\nOn the other hand, I currently do work with portlets and converting legacy code (typically small 4g languages) to java. These all end up being very small most of the time, so that could be the reason.", "id": "c1dhlq0", "parent": "t1_c1dgu2j", "vote": 2}, {"content": "I couldn't agree more.  If you just want to look at a value somewhere in the program, you can either add prints or use a debugger.  There is not much fundamental difference in the way you have to think to use either of these strategies - it's mostly a matter of choosing what is faster in your environment.", "id": "c1dldzy", "parent": "t1_c1djxvw", "vote": 1}, {"content": "If 99% of your \"bugs\" are syntax errors, you should damn well get an IDE that helps you dotting the i's.", "id": "c1dozdy", "parent": "t1_c1dmekj", "vote": 1}, {"content": "Sometimes you simply don't have the time to go read through the code until you get it.", "id": "c1dhsa5", "parent": "t1_c1dh9kk", "vote": 1}, {"content": "Using a tool is a lot different than needing it or relying on it.  I don't *need* to use a calculator to do long division, but it makes it a lot faster.  I also still have to figure out on my own what numbers to divide, and even the fact that division is the correct operation to solve the problem.\n\nLikewise, I don't think I've ever met someone who *needed* a debugger.  You still have to have an \"understanding of how things work.\"  The debugger doesn't tell you what results to expect at any given breakpoint, or even where you should start looking.\n\nHeck, when I first started learning programming, I didn't even have regular access to a computer.  I wrote my programs down on paper, debugged them the best I could by executing in my head, then entered them in the next chance I got.  I find it interesting that the same people who consider a debugger a \"crutch\" have no problem at all with constant access to an editor, compiler, and runtime environment.", "id": "c1djpqd", "parent": "t1_c1dh9kk", "vote": 1}, {"content": "You say that like it's a problem? When you work on a program with 500K + lines of code you don't have time to understand it when you just need to figure out why some number isn't calculating right or whatever. Just step to it in your debugger and see all the values, etc. \nSometimes to get paid you just have to fix the bug, not spend 4 hours figuring out the ins and outs of some algorithm. \n", "id": "c1dlwad", "parent": "t1_c1dhjds", "vote": 1}, {"content": ">But you need the debugger when writing assembly.\n\nI'm sorry, I do not entirely agree with this statement... but then again I've never **had** a debugger when writing assembly.", "id": "c1dinwn", "parent": "t1_c1dh8sm", "vote": 0}, {"content": "You can use printf's to show both variable state and code paths... I don't know why anyone in their right mind would use a debugger, unless they are novices of course.", "id": "c1djq8z", "parent": "t1_c1dhafw", "vote": 1}, {"content": "Bonus: Agile methodologies- only explicitly used in environments that are the exact opposite of agile (big corps, big name consultancy houses, etc).", "id": "c1dhb7p", "parent": "t1_c1dhaz7", "vote": 2}, {"content": "The proper tool here would be a code formatter, not a debugger.\n", "id": "c1drika", "parent": "t1_c1dkkha", "vote": 1}, {"content": "A possibly better question would be \"Why don't some programming masterminds use debuggers as a first-line of offense?\". \r\n\r\nThe answer: it doesn't tell them anything they don't already know. ", "id": "c1dkpem", "parent": "t1_c1dil64", "vote": 2}, {"content": "> Print statements and logic are all I usually need to solve a problem. I've only been programming for 4 or 5 years but I've never even USED a debugger, never had a need for it.\n\nFYI - You've never used a debugger because you've only been programming for 4-5 years and you're still in an environment where a print statement is a viable option.", "id": "c1di1v0", "parent": "t1_c1dhsvi", "vote": 3}, {"content": "Tests are for determinig if there is a problem. Debuggers are for determinig what caused the problem. \r\n\r\nIf you use tests as a debugging tool then you usually end up with sub-unit tests. These extremely low-level tests make refactoring much harder than it should be. ", "id": "c1dh6hd", "parent": "t1_c1dh5qv", "vote": 5}, {"content": "How about instead of writing tests to assert your code, you just add asserts to your code. How come people forget that asserts exist?", "id": "c1didyo", "parent": "t1_c1dh5qv", "vote": 1}, {"content": "Because x-debug and zend-debug aren't good enough for you?", "id": "c1dh5z7", "parent": "t1_c1dh4t1", "vote": 3}, {"content": "I guess the majority of the commenters here insert numerous print statements with begin and end timestamps.\n\nThe real masterminds simply run the program in their head, and instantly know where the bottleneck is. \n\nAfter all, profilers make you lazy.\n</sarcasm>", "id": "c1dit6n", "parent": "t1_c1di2aa", "vote": 3}, {"content": "You're a lucky one. Where I work there is never time for performance improvement.", "id": "c1dj30g", "parent": "t1_c1di2aa", "vote": 1}, {"content": "I tend not to use debuggers very often, but I do use profilers. Usually only when something is actually slow - there doesn't seem to be any point in profiling when your program is still fast on the slowest machine you can get your hands on.\n\nPerformance problems are, basically, impossible to reason about simply by looking at the code. Even in low-level languages like C, there's not a simple mapping between C and machine code, so an apparently simple operation may actually be complex. Multiplication on a machine without a hardware multiplier, for example. Then you have CPU caches, virtual memory and paging, whatever the operating system is doing, interactions with other software or with the hardware. If you're using higher level languages, you have to factor in garbage collection, or things the runtime is doing that are invisible in your code, or the fact that the code you're writing bears no resemblance at all to what's going on in the CPU. A profiler will simply tell you what's slow, although you're on your own if you want to work out why.\n\nFor C / C++, Valgrind is incredibly useful. Instead of trying to work out if you have a memory leak or other memory related problem (accessing uninitialized or deallocated memory, double-frees, accesses past the end of a buffer), you just run Valgrind, and it'll tell you what your problem is and, usually, where.\n\nCachegrind's actually a pretty good profiler-like tool. It's useless for timing, but great for finding cache misses. No need to wonder - just measure it. I gather Intel's profilers provide similar measurements directly from their CPUs as well.\n\nI tend to use static analysis tools. At least, for some languages (it's pretty much essential to use JSLint for JavaScript code, for example). Most of the time (and particularly if you run them during development, instead of on an existing codebase) the warnings they spit out are potential problems, and should be fixed.\n\nSometimes, unit tests help.\n\nNone of that will actually help you fix a bug, of course. But they do help eliminate potential bugs, simply by forcing you to be more careful, and showing your mistakes before they cause problems.", "id": "c1drk8a", "parent": "t1_c1di2aa", "vote": 1}, {"content": "You can wake up. [Google Tech Talk: Debugging Backwards in Time](http://www.youtube.com/watch?v=gBVQYNfckhQ)", "id": "c1dh7vh", "parent": "t1_c1dh7j7", "vote": 4}, {"content": "This is possible in .Net and Visual Studio", "id": "c1dh937", "parent": "t1_c1dh7j7", "vote": 3}, {"content": "Somebody is SO going to post a comment that will \"wake me up\" now. ", "id": "c1dh7k1", "parent": "t1_c1dh7j7", "vote": 2}, {"content": "Intellitrace can do it in .NET, if you are willing to pony up the 1100 bucks for Visual Studio Ultimate.", "id": "c1dhb9u", "parent": "t1_c1dh7j7", "vote": 2}, {"content": "Force yourself to learn to use a debugger, printf's are a bad habit.", "id": "c1dhk3i", "parent": "t1_c1dhand", "vote": 2}, {"content": "It's not so straight-forward when dealing with 500K+ lines of legacy code from the last 20 years.\n\nTDD and SOLID design principles do not make complex code easier or less bug-prone.  I'd have to argue that you may not have been exposed to extremely complex applications.\n\nEven if you break down the application into the tiniest of components that all come together in a cacophony of factories, service locators, and dependency injection, you'll still have to test the system as a whole.  With complex business rules driving service integration, you're bound to have to debug *something* in the normal course of development.\n\nOr, perhaps you're a coding ninja, and I'm just bitter because I have to work with 500K+ lines of legacy code..", "id": "c1dhks7", "parent": "t1_c1dh8nk", "vote": 3}, {"content": "Because what you want is a transcript of interesting states to see where it deviates from what you expect.\n\nAs you become a good programmer the simpler errors that debuggers help with become more and more obvious, so the debuggers become less useful.\n\nA good debugger with the ability to produce transcripts would be fine, but you'd either lose the information between sessions or machines, or you'd have to annotate the source code with it.\n\nSo why not just annotate the source code in the first place?", "id": "c1dhj9q", "parent": "t1_c1dh4j6", "vote": 19}, {"content": "Exactly. Eventually it always becomes \"but I also need to see variable X\" and then you have to add the print statement, recompile, repro the bug, and get to the right part again. How is that faster than just looking at X?\n\nIn my experience the main reason people don't like debuggers is because a lot of \"hardcore\" programmers have such convoluted or masochistic build/dev environments that running the app in the debugger of your platform (gdb, windbg, VS, whatever) is a major chore instead of just hitting/typing \"go\" \n\nThe workflow of using a debugger isn't really different than not, everything you can do using one you can do without one....just slower.", "id": "c1dh59p", "parent": "t1_c1dh4j6", "vote": 32}, {"content": "> A good debugger\n\nNot available on all platforms. Can't rely on having one.", "id": "c1dh809", "parent": "t1_c1dh4j6", "vote": 62}, {"content": "Because debuggers can change the behavior of the code? I've had bugs disappear while a debugger was in use, unable to replicate a crash that would occur w/o a debugger.", "id": "c1dhuk9", "parent": "t1_c1dh4j6", "vote": 13}, {"content": "Depends on your language. Let's say you're like me, and develop most of your apps for the web, (eg: PHP), it's almost easier to just use prints rather than debuggers.", "id": "c1dhsav", "parent": "t1_c1dh4j6", "vote": 3}, {"content": "[deleted]", "id": "c1dh4tt", "parent": "t1_c1dh4j6", "vote": 8}, {"content": "I guess it just depends on what environment you're working in. \n\nAt home I do a lot of development in Ruby using Vim and the good old CLI. Debugging a ruby program is fairly simple, but it's nothing comparable to having a full blown IDE debugger so I tend to just use print statements/read the code as it's much quicker. ", "id": "c1dh6yq", "parent": "t1_c1dh4j6", "vote": 2}, {"content": "Debugging code without needing to freeze it is a skill worth practicing.  \n\nThere's no debugger in production. ", "id": "c1dhq2e", "parent": "t1_c1dh4j6", "vote": 2}, {"content": "Stepping through code with a debugger is pretty useless when one has multithreading bugs (race conditions, interlocking, shared data, etc), in those cases, only traces/logs can help you.", "id": "c1di9yg", "parent": "t1_c1dh4j6", "vote": 2}, {"content": "recompiling? what's that?\r\n\r\nas in Perl, bash, php or javascript. And yes, Perl has its own debugger.", "id": "c1djodt", "parent": "t1_c1dh4j6", "vote": 1}, {"content": "An even better method is to have variable log level print statements. Add new log statements that help expose that bug, then they're also there for future bugs. Sure you can configure a debugger to find it, or add temporary print statements but neither helps the longterm maintainability.\r\n\r\nHaving said that there are some bugs (mostly race conditions) that will always want a debugger to explore a wide range of state of the program.", "id": "c1djxvg", "parent": "t1_c1dh4j6", "vote": 1}, {"content": "Because recompiling with debugging on takes me about 5 hours. Always compiling in debug mode generates code that is too slow. ", "id": "c1dkjqq", "parent": "t1_c1dh4j6", "vote": 1}, {"content": "A good compiler lets you add print statements on the fly too.", "id": "c1dnny5", "parent": "t1_c1dh4j6", "vote": 1}, {"content": "> Why bother manually inserting print statements and recompiling?\n\nQuite, the logging code should be there to start with. Just increase the logging level and run the code.", "id": "c1doday", "parent": "t1_c1dh4j6", "vote": 1}, {"content": "> recompiling?\n\nnot everybody uses compiled languages :P\n\nEDIT: Despite downvotes, i maintain that debugging with print statements is much less costly when you work with interpreted languages. Some environnements even allows you to reload only the specific function you need to change without restarting the program.", "id": "c1di7ba", "parent": "t1_c1dh4j6", "vote": 1}, {"content": "[deleted]", "id": "c1djn60", "parent": "t1_c1dh4j6", "vote": 0}, {"content": "Don't get me wrong, I think a debugger is an important part of a programmers set of tools, but it's not the only way of doing things.\n", "id": "c1dj9uz", "parent": "t1_c1diaaq", "vote": 1}, {"content": "Happy birthday!", "id": "c1dicrn", "parent": "t1_c1diaaq", "vote": 0}, {"content": "Unless you spew it out the com port and capture that to a terminal on the dev host.", "id": "c1dioah", "parent": "t1_c1dhz6r", "vote": 3}, {"content": "The equivalent of 'print' for embedded systems would be 'toggle a pin' which you then capture on a scope or analyser.\n\nI've often done this by sprinkling these operations throughout a suspect chunk of code, and then looking at the pattern of transitions on the output pin. You can quickly determine what path it took through the code.", "id": "c1dinvb", "parent": "t1_c1dhz6r", "vote": 2}, {"content": "I disagree. Putting in logging statements for state changes (most bugs are where the program is in an unexpected state) often help document the code. It also means the logging is there for debugging future bugs, setting up watches and trace points etc is time that is lost.", "id": "c1djyp7", "parent": "t1_c1disvy", "vote": 1}, {"content": "Wait, what? You can edit mode while debugging? I just figured out what 'Step out' did...", "id": "c1di405", "parent": "t1_c1dhufr", "vote": 2}, {"content": "I just wish Java would do this as well as Smalltalk did 15 years ago.", "id": "c1dmilt", "parent": "t1_c1dhufr", "vote": 1}, {"content": "You should really give Java a try then. It's a DSL that can convert XML into stacktraces.", "id": "c1dh9nj", "parent": "t1_c1dh2ex", "vote": 62}, {"content": "Theres a function for that...", "id": "c1dimp7", "parent": "t1_c1dh2ex", "vote": 1}, {"content": "And the function you are debugging depends on some value from parameter, it probably is too much of a chore to turn all of the depended values into a string for printing. ", "id": "c1dhiwv", "parent": "t1_c1dh2ex", "vote": 0}, {"content": "Fair enough about \"too early,\" though I think interactive debugging can be a good way to demonstrate program flow and how things work (and why, if you hop into the assembler).\n\nThat said, as a developer for ~25 years the debugger is one of the first tools I reach for when having trouble.", "id": "c1dtete", "parent": "t1_c1diizn", "vote": 1}, {"content": "Good point. You should always use the right tool for the job.", "id": "c1dkv7e", "parent": "t1_c1digpz", "vote": 1}, {"content": "Debugging works like you describe it is most instances. But debugging threads or problems that are timing critical (i.e. problem does not happen when you stop at a break point in one of the threads), then you really don't have much option than to understand the code to see what could go wrong and to insert some Logger statements to print out useful state info. \n\nThese kind of scheduling, timing critical bugs are the hardest to debug and the debugger usually doesn't help much. \n\nBut in general I agree with the sentiment. Using a good debugger that allows you to edit, compile and continue debugging (hot swapping code), with conditional breakpoints is essential.", "id": "c1di54g", "parent": "t1_c1dhgns", "vote": 7}, {"content": "That's true of simple, localized problems.\n\nAnd if you are getting an exception then a debugger useful to inspect the immediate state at that point.\n\nIf you're using print statements to attack those problems then it's inappropriate.\n\nBut with experience those kinds of problems tend to disappear and the problems that you debug shift toward those with a larger scope, generally over longer periods of time, involving extensive flows of code.\n\nIn these cases a debugger is almost useless as what you want is a transcript of interesting events over that period so that you can see where it starts to get derailed.\n\nThat's where logging rather than debugging comes in.", "id": "c1dhjrs", "parent": "t1_c1dhgns", "vote": 17}, {"content": "Or people who program in C/C++ - if you're getting a memory corruption error, debuggers can sometimes be less than helpful, and who the fuck wants to wait for memcheck if you have absolutely any other option (and sometimes you get an error that _only_ occurs when you compile in release).", "id": "c1dm2pk", "parent": "t1_c1dhgns", "vote": 3}, {"content": "\"Here's an unfamiliar code base, there's a problem happening somewhere in this 10 step process.\"  I swear by stack traces, crash dumps and breakpoints for scenarios like that.  My big problem with print statements and alerts is that they have a nasty habit of ending up in production code because someone forgot to take them out.", "id": "c1djndr", "parent": "t1_c1dhgns", "vote": 2}, {"content": "> One thing I've noticed is that the people who don't use debuggers usually just can't.\r\n\r\nThat's about as fair an assessment as it is to say that bad developers use debuggers as a crutch (as mentioned in the grandparent). As with many things, different people have different ways of solving similar problems. Personally, I almost never use debuggers (but I honestly thought that pretty much everyone did, because that has always been the case with fellow developers in various projects -- so I found the article interesting). Debuggers work for you -- great. I have personally rarely found them worthwhile compared to logging, unit tests, and simply reading the damn code thoroughly.", "id": "c1djpjj", "parent": "t1_c1dhgns", "vote": 2}, {"content": ">One thing I've noticed is that the people who don't use debuggers usually just can't.\n\nBingo.  ", "id": "c1di86y", "parent": "t1_c1dhgns", "vote": 5}, {"content": "> and you can even (let's say that there's a problem with a pointer not being set) test a simple fix on the fly\n\nBetter still, write the test as part of your test suite. Then if the problem re-appears at any point, you'll know instantly.", "id": "c1dkuk1", "parent": "t1_c1dhgns", "vote": 1}, {"content": "Yes, Chuck Moore \"just can't\" use a debugger.  I'm sure a break point really scares that man.  You're beyond stupid if you think that is the case with people like Guido, Gosling, Russel", "id": "c1dj0o9", "parent": "t1_c1dhgns", "vote": 1}, {"content": "> We have more smart people per square inch then MIT!\n\nThe word you wanted was \"than.\"  (See, it's true!)", "id": "c1di1h7", "parent": "t1_c1dhh5t", "vote": 10}, {"content": "You're just terrible!", "id": "c1dhia0", "parent": "t1_c1dhh5t", "vote": 0}, {"content": ">We have more smart people per square inch then MIT!\n\n... Speaking from here, no... no you don't...", "id": "c1dimjm", "parent": "t1_c1dhh5t", "vote": -2}, {"content": "I think we worked at the same place.\n\nNo seriously, do I know you?", "id": "c1dj8h2", "parent": "t1_c1dhw54", "vote": 3}, {"content": "Finally the correct answer. From the moment I implemented my first app. console my need for actually getting in the debugger diminished close to 0. Further, the simple effort of finding the right place and content that shows you what went wrong actually stimulates you to better design the code and be in  constant understanding of what the code does. Also, the debug prints can always be reactivated anytime (although it's considered not to so fancy to leave them in code, I find them too useful) so if you come back after some time to some piece, it's already prepared for debugging, just check the console. I only use the debugger when I'm in a bad and impatient hurry or my mind doesn't seem to function well.", "id": "c1diokw", "parent": "t1_c1dhw54", "vote": 1}, {"content": ">Did you read the blog post?\n\nDid you read *my* post?  I was obviously referring to the cowboy programming mentality that is prevalent throughout the field, and this thread.  I never once referenced the article in my post.\n\n>You're just too insecure in your own skills and believe that people can't do things differently than you.\n\nGood guess, but no.  It seems that you, and many others, did not read my post careful and just knee-jerk responded because you felt threatened for some reason.  If you are going to sit there and tell me you can debug faster without a debugger then it's obvious that you just don't know how to use a debugger.\n\n\n\n", "id": "c1dlkze", "parent": "t1_c1dj0ex", "vote": 1}, {"content": "That is absolutely the most ridiculous statement I've ever read about programming.\n\nLogging is *NOT* intended to be your debugger. Your logging is heavily overdone if you are using it for any complex debugging. Logging should be a relatively minimal push in the right direction (A trace is often enough for debugging anyway).", "id": "c1dhmhz", "parent": "t1_c1dhhll", "vote": 12}, {"content": "Geez, how I hate people that put log statements every two lines of code. ", "id": "c1djae1", "parent": "t1_c1dhhll", "vote": 1}, {"content": "The barber is a WOMAN!", "id": "c1dkp9a", "parent": "t1_c1dhcpl", "vote": 1}, {"content": "I program in Vim (I know, not the answer which you were looking for) . This is probably the reason why firing up a debugger is a context-switch for me. ", "id": "c1dh59o", "parent": "t1_c1dh4od", "vote": 13}, {"content": "I, too, am a .NET developer but I prefer print statements, if only because the company-provided laptop slows down if I use a debugger.", "id": "c1dhcyn", "parent": "t1_c1dh4od", "vote": 3}, {"content": "i concur, with a breakpoint and just hover the cursor over the variable, and you're good to go.\n\nyou're flexible enough to put a print anywhere too, it's the best of both world.", "id": "c1dhjr1", "parent": "t1_c1dh4od", "vote": 1}, {"content": "I find most of my problems in .NET are seldom helped by the debugger; they're usually silly things like uninitialized variables and the like. And the debugger crashes at like 27, which I already knew (because I knew where in my code the program stopped working so I had a good idea of where to look). But the function call on like 27 is actually fine; the error is 11 lines up where I overlooked setting that int. And all the debugger tells me is that the int is set to some random bits, that, as far as I know, may very well be an integer it picked up somewhere.", "id": "c1dj5b9", "parent": "t1_c1dh4od", "vote": 1}, {"content": "I carry a very small header file (in C++) that defines some global ostream variables like `debug`, `info`, `warn`, etc. There's a little init function that looks for a file in the current directory named the same as the stream. If the file is there, the stream gets bound to cout or cerr. If not, it gets bound to /dev/null.\n\nI still don't end up writing a lot of really verbose logging, but it's nice to be able to adorn a tricky bit of code with logging that's easily turned off and on by just touching or deleting a file named \"debug\" or \"info\" before I run the program.", "id": "c1dh67m", "parent": "t1_c1dh4rb", "vote": 7}, {"content": "You have logging which is for release and logging which is for debugging. Sane languages allow you to turn off debug logging at compile time. Less sane ones at least allow you to do so at run time.", "id": "c1dhg1a", "parent": "t1_c1dh4rb", "vote": 3}, {"content": "You have production support staff that can fix problems without bothering you? i jelly.", "id": "c1dhwi2", "parent": "t1_c1dh4rb", "vote": 2}, {"content": "[removed]", "id": "c1dijvc", "parent": "t1_c1dh4rb", "vote": 2}, {"content": "My logging is usually:\n\n\"[timestamp]Transaction started\"\n\n\"[timestamp]arguments\"\n\n\"[timestamp] transaction finished successfully\" OR \"[timestamp]oops something happened [stacktrace]\"\n\nWhich would be used for a service which accepts and processes transactions. There is no need to have anything else. I have the arguments, I have the stack trace and I have the time. That's as much as you should get from logging. You are over logging if you are printing out every variable and every block entry and whatever else.", "id": "c1dhn1m", "parent": "t1_c1dh4rb", "vote": 1}, {"content": "> My assertion is that if you need to use a debugger, you have a bad system design :-)\n\nOr occasionally a bad language or language runtime design, e.g. in C++ you can't even get a stacktrace on a segfault without a debugger even though it would be perfectly possible (and indeed some libraries exist that do so) to print a stacktrace without one.", "id": "c1dhb1z", "parent": "t1_c1dh8he", "vote": 1}, {"content": "What's the performance penalty like?", "id": "c1dkjw4", "parent": "t1_c1dkg4o", "vote": 1}, {"content": "I think there's something to this. Good programmers are more likely to be programming in languages that they haven't used much before while bad programmers are more likely to just stick with one or two languages. This would mean that the bad programmers have spent enough time with the language to become familiar with the debugger whereas good programmers are more likely to not have gotten around to becoming familiar with the debugger.", "id": "c1dj9ky", "parent": "t1_c1dha3k", "vote": 1}, {"content": "As yet unreleased. Last I checked, the name was Influx, but that is a working title and probably not the release title.\n\nThey've fixed a lot of those large functions but the point remains: what to you do with large functions, reentrant code, concurrency, etc.", "id": "c1dj8so", "parent": "t1_c1dj24u", "vote": 1}, {"content": "Agreed. If you are very careful, and instrument the code to catch a particular condition for which you are searching, then you may be better off using cout, printf, or some equivalent. I often do.\n\nBut, these are poor substitutes for debugging. Setting a breakpoint in instrumented code allows you to 'poke around' the state a bit. It's often surprising what you find. Many things might be wrong that you would never think to check using some form of logging. Worse is memory stomp where writing a value to a log can actually crash your application.\n\nAll that I am saying is logging is valuable but only rarely. Anything with large complexity or indeterminant conditions makes logging virtually worthless.", "id": "c1doe9w", "parent": "t1_c1do2sd", "vote": 1}, {"content": "I agree with you wholeheartedly. The programmers with whom I was working liked to put all related functionality into a single function. It was common to see functions running into the hundreds of lines as a result.\n\nHonestly, they argued that long functions made the code clearer. To their credit, the did organize large functions in a very organized and proceedural way. Still, when I am in charge, functions over 100 lines are a fireable offense. \n\nThese three functions I mentioned were shared code. The result was code that no one owned and people routinely 'stuck in' what they needed and then moved on. Plus the code base was over four years.\n\nAll I can say is that not everyone shares your or my philosophy...", "id": "c1dp1it", "parent": "t1_c1dorxw", "vote": 1}, {"content": "> Debuggers are invaluable when you have to figure out code that you have no source to, can't get source to, and doesn't log very well.\n\nYou mean like programs where you have only x86 binary without debug information? Yes, having debugger is then better than not having it, but fixing non-trivial code in this way is something I would prefer to not do.\n\nBut I've read stories about software, where there were no source for the binary used, as it was binary-patched for years. The way real programmers do it. ;)\n\n> [Real Programmers are reluctant to actually edit a program that is close to working. They find it much easier to just patch the binary object code directly, using a wonderful program called SUPERZAP (or its equivalent on non-IBM machines). This works so well that many working programs on IBM systems bear no relation to the original FORTRAN code. In many cases, the original source code is no longer available.](http://www-personal.edfac.usyd.edu.au/staff/souters/Humour/Real.Programmer.Stories.html)", "id": "c1djrp9", "parent": "t1_c1djeka", "vote": 1}, {"content": "The \"programming\" in the title has mislead us.", "id": "c1dm6xh", "parent": "t1_c1djeka", "vote": 1}, {"content": "Sounds like B", "id": "c1dlvf6", "parent": "t1_c1dj3xc", "vote": -1}, {"content": "Honest question: what will LLVM/Clang improve in this area?", "id": "c1dp2bv", "parent": "t1_c1diwor", "vote": 2}, {"content": "I'm happy with my way of doing it. Speed of development has never been my problem. ", "id": "c1dpmst", "parent": "t1_c1dozdy", "vote": 1}, {"content": "> A possibly better question would be \"Why don't some programming masterminds use debuggers as a first-line of offense?\".\n\n> The answer: it doesn't tell them anything they don't already know.\n\nIn my opinion, a still better question is \"why is there this myth that a master programmer is somehow significantly different than other programmers, other than in depth of knowledge and experience?\"\n\nI've never known a great programmer who didn't use every tool available to them.", "id": "c1dl6bm", "parent": "t1_c1dkpem", "vote": 2}, {"content": "Hence why I prefaced my statement with that fact. I know I'm not doing anything very high level.", "id": "c1di6eh", "parent": "t1_c1di1v0", "vote": 1}, {"content": "I agree on the latter point. Every time you write tests you get some extra code to maintain as well. Writing them on the wrong level of abstraction is bound to cause issues later on.\n\nI guess the main gist of Uncle Bob's idea was to use tests as a form of learning, not quite as debugging.", "id": "c1dh762", "parent": "t1_c1dh6hd", "vote": 2}, {"content": "Sure. That's a working solution. Taken further you end up with \"Design by Contract\" (see Eiffel).\n\nI guess the difference lies within whether you treat your code as a black or white box.", "id": "c1dim17", "parent": "t1_c1didyo", "vote": 1}, {"content": "How does zend-debug perform compared to x-debug?", "id": "c1dj3bb", "parent": "t1_c1dh5z7", "vote": 1}, {"content": "I got through college using nothing but print statements.", "id": "c1dkg58", "parent": "t1_c1dhk3i", "vote": 1}, {"content": "No, TDD is not going to help you with legacy code!  I'm not saying debuggers are not good tools to have, just that TDD and SOLID can reduce your dependency on them overtime and is surprising how much time you can make up by not using debuggers.  \n\nAs for testing as a whole, I try and push to keep that achievable in as controlled away as possible, isolating things as much as I can.  As an Asp.Net developer, that has been a nightmare until recently!\n\nI'm not coding Ninja, anyone that thinks that are cocks.  I've left my fair share of very bad legacy code... I'm still waiting for some of mine to turn up on DWTF! :D\n\nHave you read: [Working Effectively with Legacy Code](http://www.amazon.co.uk/Working-Effectively-Legacy-Robert-Martin/dp/0131177052/ref=sr_1_1?ie=UTF8&qid=1295535557&sr=8-1) Highly recommend it.  There is a flow chart that gives you a good idea of how to chain refactorings together, but I can't find it just now.  Will post it if I can find it.\n\nEDIT: Not sure why my original comment is being down voted... That's my experience and your mileage might vary, doesn't mean I'm wrong :(\n\nEdit 2: My google-fu is strong today: http://timhigh.wordpress.com/2008/08/27/legacy-patterns-decision-tree/", "id": "c1dhre3", "parent": "t1_c1dhks7", "vote": 0}, {"content": "> what you want is a transcript of interesting states to see where it deviates from what you expect.\n\nYes, debugger only gives you info about one state at a time. Looking at a transcript (from print statements) is like looking at time collapsed.", "id": "c1dieib", "parent": "t1_c1dhj9q", "vote": 12}, {"content": "If the state was really that interesting it would be in the transaction log for the associated record.... oh that's right. My company does extensive data logging external to the application changing the data.", "id": "c1di7b0", "parent": "t1_c1dhj9q", "vote": 0}, {"content": "> Because what you want is a transcript of interesting states\n\nThat's what unit tests are for. And should ideally be written before the code. \n\nUnit tests should, as a matter of course, include special cases. E.g. if you're writing a function to copy a block of memory, it should include special cases where the source and destination are partially overlapping, where they are the same, where the size of the block is zero.", "id": "c1dktg3", "parent": "t1_c1dhj9q", "vote": 0}, {"content": "I disagree. Using a debugger is generally a lot slower, especially when you need non-trivial output. Sure, if you just want a memory dump of a variable or the value of something with a primitive type go ahead, use your debugger, most of the really interesting output needs some preprocessing to be useful though.\n\nDebuggers also usually make it hard to get all the values over an extended period of time on one screen, you need to go through dozens of breakpoints which is very slow compared to just seeing the output of all your print statements at once.", "id": "c1dha0o", "parent": "t1_c1dh59p", "vote": 36}, {"content": "No. It always becomes  \"why variable X is so fucked up right now?\" and if your debugger has no reliable rewind button, then there are two ways:\n1) set one breakpoint in one point before and restart program.\nCons: if value became incorrect before newly created BP, then you'll need to restart again\n2) set several breakpoints. \nCons:most of the times they will pause program where X is still being correct.\n\n\nIt's easier to insert dozens of `print __FILE__, __LINE__, X` around the sources, run whole program and decide at which step X became incorrect.\n", "id": "c1dhbge", "parent": "t1_c1dh59p", "vote": 17}, {"content": "The dev flow is really important. What a lot of people don't realize is that they can inject the debugger in the flow as well. For example, the feature that sold me to Eclipse was the ability to instantly run unit-tests under debugger with exactly one input action.", "id": "c1di317", "parent": "t1_c1dh59p", "vote": 2}, {"content": "Interactive debugging and logging are not mutually exclusive or competing techniques. They are often used simultanuously. For one, logging is great for seeing a big picture or performing remote diagnostics.", "id": "c1dk3u4", "parent": "t1_c1dh59p", "vote": 1}, {"content": "> Not available on all platforms. Can't rely on having one.\n\nSurely 95%+ of all programmers CAN rely on having one?  There are fine debuggers for Windows, Mac OS/X and Linux, for almost all development environments on these platforms.\n\nNow, there are some languages that really don't have any debuggers at all - like Javascript (yes yes, I know there are a few but you eventually have to debug your issues inside the browser...)  But again, this is nothing to do with the platform.\n\nSo I can't come up with an interpretation of your statement that makes it true.  Can you help with an example?", "id": "c1didlj", "parent": "t1_c1dh809", "vote": 8}, {"content": "This.  If you are deploying your code to multiple machines or devices, and it's not working on a handful, searching standard out is much easier than setting up an environment on each.", "id": "c1dhxsa", "parent": "t1_c1dh809", "vote": 0}, {"content": "Truth is, print statements can do that as well (alignment changes, buffer fllushes, ...).\n\nUsing dtrace probably gives you a better shot at not changing code behavior.", "id": "c1djsvg", "parent": "t1_c1dhuk9", "vote": 2}, {"content": "This is a fact not generally known. Compiling with/without symbols and optimizations also changes a lot. ", "id": "c1digya", "parent": "t1_c1dhuk9", "vote": 6}, {"content": "If you don't require recompiling then why would you ever leave the debugger? \r\n\r\nBefore I started using .NET I would write the vast majority of my code while the application was running. When it comes to T-SQL, you can say I still do.", "id": "c1dh662", "parent": "t1_c1dh4tt", "vote": 15}, {"content": "Yes there is. I will remotely attach a debugger to production code of I need to see something. It takes special clearance from production support, but that is just a formality.\n\nWhat do you mean by freeze? My debugger doesn't stop the code just to dump variables in the trace window.", "id": "c1di6qi", "parent": "t1_c1dhq2e", "vote": 4}, {"content": "Sure there is, as long as you have the debugging symbols.  Just attach the debugger to a process (even a remote process).", "id": "c1dhui2", "parent": "t1_c1dhq2e", "vote": 2}, {"content": "Who said anything about stepping? I certainlly didn't.\r\n\r\nMy debugger allows me to add tracing, print lines if you prefer, to any part of my application without interrupting it. I just mark the line and type in the macro I want it to print.", "id": "c1didn9", "parent": "t1_c1di9yg", "vote": 2}, {"content": "If you've got heisenbugs that come from threading, then print statements might not be of much use either. Sure, a print statement generally doesn't take as much time as the program stopping on a debug breakpoint, but it still is enough to alter the behavior of timing issues.", "id": "c1djkar", "parent": "t1_c1di9yg", "vote": 1}, {"content": "My logs are designed. Everything that goes in them has been carefully thought about in terms of how it will assist production support monitor and correct runtime issues. I'm not exagerating here when I say that I've been in design meetings with the BAs and support team where all we talk about is logging.\r\n\r\nSo at this point in my career I find the very idea of randomly throwing in variable dumps to be unprofessional.", "id": "c1dk8m2", "parent": "t1_c1djxvg", "vote": 2}, {"content": ">  I always read the code first and almost always have idea what is wrong.\r\n\r\nSo do I. But if I'm wrong I don't need to start over from the beginning to look at something else.\r\n\r\n> Because it's faster than launching debugger, waiting it to run to the trouble spot and looking what they value you are interested in is?\r\n\r\nAdding the debugger takes me 0 time. Running the program normally or in debug mode is literally the difference between hitting F5 or Shift-F5.\r\n\r\nThat's why we gave up plain text editors for IDEs back in the 80's.", "id": "c1dk083", "parent": "t1_c1djn60", "vote": 2}, {"content": "Don't believe the GNU propaganda. \nGCC/GDB feel like relics from the 70's when you use *real* tools that, sadly, cost money. \n\nThere's a reason why Apple's investing so much money into the Clang/LLVM compilers/debuggers. ", "id": "c1diw2w", "parent": "t1_c1di405", "vote": 4}, {"content": "Yup, it's an option you can set in Visual Studio.  Tools-> options, then in that window it's under debugging -> Edit and Continue.  Just click the box to enable it.  It only works for 32 bit assemblies tho, so you might have to force VS to compile as x86 instead of Any CPU.", "id": "c1dj62h", "parent": "t1_c1di405", "vote": 2}, {"content": "I'm too close to that joke.  It hurt.  We use Java and FOP to produce stacktraces of XML with the very occasional accidental PDF output.", "id": "c1dhcg4", "parent": "t1_c1dh9nj", "vote": 10}, {"content": "It was a long time since I laughed that hard about a programming joke. Have an upcrement.", "id": "c1dhf8j", "parent": "t1_c1dh9nj", "vote": 15}, {"content": "DAE find the pointless incessant Java-bashing on proggit tiring?", "id": "c1dhh9e", "parent": "t1_c1dh9nj", "vote": 1}, {"content": "Well, then that begs the question of what do you log?  A lot of those super complex problems involve interactions between lots of tiny pieces - so yes, it's nice to have logger.debug(blah) after every line of code, but it also makes your code quite difficult to read and considerably longer than it needs to be.  If it's over a long period of time, yes, logging will help you find out when it happened simply because you can have logging occur at every function call of some type - at the end of the day, you've still got to go in and see what caused X to be null.  Knowing is, unfortunately, only half the battle.\n\nMaybe the best solution is to use logging (I'm including printing in that), to locate the general area and then a debugger to find what actually happened.  This is especially important if you didn't write some parts of code (that is, you may not be able to say, with any certainty, that your \"level\" or \"style\" of logging is present in the functions that you call if you didn't write them) - which is exactly the problem in large projects.\n\nLord knows logging has saved me over and over when dealing with long-running server applications, but at the end of the day, it will not come down to the logger printing where something went wrong - it will come down to the logger telling you the last time something \"normal\" happened, so that then you can go and investigate why that last time was the last time.", "id": "c1dhnt9", "parent": "t1_c1dhjrs", "vote": 1}, {"content": ">My big problem with print statements and alerts is that they have a nasty habit of ending up in production code because someone forgot to take them out.\n\nThere are several elegant ways that can automatically take care of the issue.", "id": "c1dzhdr", "parent": "t1_c1djndr", "vote": 1}, {"content": "I can't believe you fell for that. ", "id": "c1diqlr", "parent": "t1_c1di1h7", "vote": 1}, {"content": "*Your.*", "id": "c1dj5x6", "parent": "t1_c1dhia0", "vote": -4}, {"content": "Same here actually... term minisystem mean anything?", "id": "c1dk1dx", "parent": "t1_c1dj8h2", "vote": 2}, {"content": "I wasn't looking for anything in particular. Not every conversation on reddit has to be a debate.", "id": "c1dh602", "parent": "t1_c1dh59o", "vote": 21}, {"content": "So what you are saying is you aren't a programmer :-p", "id": "c1djbti", "parent": "t1_c1dh59o", "vote": 1}, {"content": "I program also in Vim, but the real reason for not using debugger most of the time is that, it's usually with terrible interface (gdb), or I haven't had time to look out what debugger the language I'm using at the moment has, or installing development environment on the system where software actually runs would mean multiple-day mail-exchange with sysadmin, or is plain impossible, or some combination of all of the above. In the end it's usually just easier to not think about using debugger and add print statements, and use gdb mostly for getting backtraces on crashes (backtrace is very useful, but languages with exceptions usually have some inbuilt mechanism for showing exceptions backtrace).", "id": "c1djpki", "parent": "t1_c1dh59o", "vote": 1}, {"content": "Doesn't Vim let you open up a shell window on the screen with a interactive command line, where you can search and copy and paste text back and forth with regular editing commands, like Emacs? If not, then why in the world do you use Vim???", "id": "c1dhdxg", "parent": "t1_c1dh59o", "vote": -1}, {"content": "I am a .NET developer and I have 8 cores and 16 GB of RAM. \nNone of that matters when you attempt to use the VS2010 WPF designer though :-/ ", "id": "c1divkz", "parent": "t1_c1dhcyn", "vote": 2}, {"content": "That is why I almost never use mutable variables. I try to make everything is either write-once or hidden behind a property I can monitor. The only thing that I think should be directly mutating is my index variables.", "id": "c1dk1u1", "parent": "t1_c1dj5b9", "vote": 1}, {"content": ".NET has that via the Debug and Trace module, but I cannot say that I've ever used it. In theory you can just hook up to the streams just like you can hook into stdOut and errOut. ", "id": "c1dh6my", "parent": "t1_c1dh67m", "vote": 3}, {"content": "I just use the \"-d\" flag when I want the to see warn/debug/info for my program. Super easy to implement with parseopt.", "id": "c1dhtpx", "parent": "t1_c1dh67m", "vote": 1}, {"content": "Did that myself, added a stacktrace for DebugInfo::error(char*), and a few other tricks. Debugging IE activex plugins in pure C++ teaches you effective debugging techniques really damn fast.", "id": "c1din8j", "parent": "t1_c1dh67m", "vote": 1}, {"content": "I know for Java, and I think it's similar for C++, that assert statements are not run unless you pass in a flag at run (compile) time.  For Java you can enable/disable assertions by class name, package name, or other parameters.  When you're not using them they are basically free. ", "id": "c1dpn3d", "parent": "t1_c1dhg1a", "vote": 1}, {"content": "The trick is having really good error messages and a database-centric design. \r\n\r\nFor example, I if they see a message like \"Error doing XXX with trade number YYY\" so they know to go into the database, find that trade key, and manually correct the problem.\r\n\r\nThe downside is they sometimes get too focused on damage control they forget to tell me about the errors so that I can permantly fix the code. That is why I started having the application automatically email the logs to me when there is a failure.", "id": "c1divfl", "parent": "t1_c1dhwi2", "vote": 1}, {"content": "Why add the manual steps? When my application fails up to three groups are alerted:\r\n\r\n* Development\r\n* Production Support\r\n* The affected user\r\n\r\nEach is given information about the error via email or instant message with the steps they need to do in order to correct the problem. ", "id": "c1diujt", "parent": "t1_c1dijvc", "vote": 1}, {"content": "> There is no need to have anything else.\n\nValues used from the global context? Return values from methods that might also use global context (or even call other systems)? Maybe we work on different things, but I know a lot of other things you would want to log. Of course, these are at a low logging level (these I would put at DEBUG) that can be turned on only when needed.", "id": "c1dhxih", "parent": "t1_c1dhn1m", "vote": 1}, {"content": "Sorry, I can't answer you, I just know that it is capable of doing it.", "id": "c1dkntr", "parent": "t1_c1dkjw4", "vote": 1}, {"content": "Not to mention that it is less rational to invest a huge amount of time into learning single language tools if you are going to use any given language only a small percentage of your time.", "id": "c1djtw3", "parent": "t1_c1dj9ky", "vote": 1}, {"content": "Programming doesn't involve working with purchased libs for you? Nice.", "id": "c1dmk6w", "parent": "t1_c1dm6xh", "vote": 1}, {"content": "> I've never known a great programmer who didn't use every tool available to them.\r\n\r\nEvery useful tool. If you have to load a debugger because your 2+2 function is returning 5, you're doing it wrong. \r\n", "id": "c1dmidi", "parent": "t1_c1dl6bm", "vote": 1}, {"content": "I'm willing to bet that most of the programmers that said they never use a debugger are heavily into TDD and the majority that do use the debugger don't.", "id": "c1dh8yi", "parent": "t1_c1dh762", "vote": 1}, {"content": "I believe code should be read. Either you put the assertions in unit tests, and read that code, or you put it in the actual code that executes when the service is used. Either way, you are reading code. ", "id": "c1dlhq2", "parent": "t1_c1dim17", "vote": 1}, {"content": "I find them functionally identical. I presume they're not but I don't use or are aware of any features that may or may not exist ;)\n\nI have an older zend studio licence but for the last 2-3 years I've used Eclipse PDT with x-debug/apache (server2go) on windows. It'll also happily work over networks to linux dev VMs etc.", "id": "c1dmojo", "parent": "t1_c1dj3bb", "vote": 1}, {"content": "VS2010 has an interesting thing called a historical debugger. It allows you to step back in time rather than just letting you look at the current state.", "id": "c1dkdfu", "parent": "t1_c1dieib", "vote": 1}, {"content": "Not all state is interesting at all times.\n\nA lot of state only becomes interesting once it implies a design flaw.\n\nThen once that flaw is fixed it ceases to be interesting.", "id": "c1di8d5", "parent": "t1_c1di7b0", "vote": 5}, {"content": "No.\n\nThat's not what unit tests are for.\n\nYou might be thinking of functional tests.\n\nA unit test is supposed to test a discrete unit -- not the flow of state over the program in general.", "id": "c1dly7h", "parent": "t1_c1dktg3", "vote": 3}, {"content": "Yes, that's my main issue. When I debug my software I usually need a lot of rather distant elements printed out to check the state of the system because I'm usually after workflow logic bugs, not crash bugs. Checking through them all with a debugger takes ages, compared to single, compiled, print.", "id": "c1dhfl9", "parent": "t1_c1dha0o", "vote": 25}, {"content": "> most of the really interesting output needs some preprocessing to be useful though.\n\nIt all depends on your language. I set a break point and when I'm there I am free to inspect the objects on the stack, send messages to them, rewind the stack, etc.: http://i.imgur.com/7QRDh.png", "id": "c1dhtbe", "parent": "t1_c1dha0o", "vote": 6}, {"content": "Modern debuggers support tracepoints, which are essentially non-intrusive log statements. Anything that you can do with a log statement, you can do with a tracepoint. That includes complex data preprocessing. As a plus, using tracepoints one can debug live services.", "id": "c1dhrj3", "parent": "t1_c1dha0o", "vote": 5}, {"content": "I routinely debug simulations that run for days or months. Using a debugger would be retarded. Not too mention nigh impossible.", "id": "c1djb12", "parent": "t1_c1dha0o", "vote": 2}, {"content": "It really depends on what exactly you're doing. I find that I've always used \"mental debugging\" also, and in a lot of cases it is much quicker than recompiling and running a debugger. There are a LOT of cases though, where mentally running your code isn't at all feasible, or the variables you need to see change too quickly or are unsuitable for console output, in which case a debugger is your only option.\n\n\nI can totally see where this article/these masters are coming from. I imagine that in 25 years I won't need to use a debugging env very often either. But then again, I don't think too many of these masters are crunching out commercial code.", "id": "c1dhbb0", "parent": "t1_c1dha0o", "vote": 2}, {"content": "Yup, in that case, I log to a file.\n\nIn most others, the debugger is a good tool.", "id": "c1dhzy7", "parent": "t1_c1dha0o", "vote": 1}, {"content": "What, are you using a debugger from the 60's?\r\n\r\nDon't set breakpoints. Just use your debugger to inject tracing statements into your running code and watch the output window. ", "id": "c1die8d", "parent": "t1_c1dha0o", "vote": 1}, {"content": "Good debuggers have the ability to log whatever data you choose when a watchpiont is hit, and to choose stop at one of them if conditions set by you are met.", "id": "c1diq43", "parent": "t1_c1dhbge", "vote": 1}, {"content": "smalltalk's debugger comes pretty damn close", "id": "c1dk0ay", "parent": "t1_c1dhbge", "vote": 1}, {"content": "That doesn't work if your bug is a multi-threaded race condition, printf's might hide the bug. Then again, stepping the debugger might do the same thing.", "id": "c1dhoh8", "parent": "t1_c1dhbge", "vote": 1}, {"content": "And if you miss one you have to start the process all over again.\r\n\r\nWith a debugger you just add one more trace point to the running program. ", "id": "c1dier1", "parent": "t1_c1dhbge", "vote": 0}, {"content": "Consider putting the emphasis on the word \"one\", and then I think you'd agree there isn't \"one\". I work in a multi-platform environment with code implemented in Java, C++, Oracle PL/SQL, COBOL and Tandem SQL. I long ago tired of learning \"yet another good debugger\".", "id": "c1dii03", "parent": "t1_c1didlj", "vote": 7}, {"content": "That's great if your code is running on your laptop, less so if it's on a server on the other side of some firewall. Then you have to not only figure out how to attach to a running process (because the launch scripts do funky stuff that no one bothered to put into Eclipse/whatever) but also figure out what ports to tunnel so they're accessible. Much easier to add some logging, especially since the debugger only tells you what fucked up state you're in, not how you got there.", "id": "c1dis62", "parent": "t1_c1didlj", "vote": 2}, {"content": "Embedded.\n\nNot every embedded platform has a debugger (there may be software or hardware limitations to a particular device). And embedded software is a huge market.", "id": "c1dk3f9", "parent": "t1_c1didlj", "vote": 2}, {"content": "I work on microcontroller platforms, and there isn't always a good in-circuit debugger for them.", "id": "c1dm8ix", "parent": "t1_c1didlj", "vote": 2}, {"content": "All he is saying is you cannot rely on the fact that every programming language will come with a debugger (including existing programming languages and languages to come) - but you can usually rely on being able to print out to some sort of output in most languages (even ones that aren't supposed to have side-effects like Haskell).\n", "id": "c1dihlk", "parent": "t1_c1didlj", "vote": 2}, {"content": "A good C++ debugger for Linux. GDB is a *powerful* debugger, but it's not a good one. On small problems I think CDT with Eclipse is dragging it kicking and screaming into the realm of usability, but I don't think it's there quite yet.\n\nI'm fairly anti-Microsoft, but Visual Studio's debugger is really top notch (or was at the time I was using it, say 5-10 years ago). There are some nice hardware debuggers too.", "id": "c1dvf92", "parent": "t1_c1didlj", "vote": 1}, {"content": "This is an important case - but in any reasonably effective organization, most of the bugs will be caught during development and only a tiny number of bugs will make it that far.\n\nThis is an argument for \"print statement as last resort\", not \"print statement as your go-to for debugging\".", "id": "c1dijwb", "parent": "t1_c1dhxsa", "vote": 5}, {"content": "I've seen people code Smalltalk that way.\n\nIt's like surfing on a code wave and just implementing everything that throws a \"method not found\"-kind of error.  \nThat was really beautiful to watch", "id": "c1dh9pz", "parent": "t1_c1dh662", "vote": 20}, {"content": "That's a major part of why I like Common Lisp. A couple years ago I got to write a server application in it, and was able to fix a multi-threaded program while it was running in production, without having to recompile and restart it. That's not something I want to have to do again, but it's still impressive to have the capability when you need it.", "id": "c1dhusg", "parent": "t1_c1dh662", "vote": 8}, {"content": "i write code that requires recompiling.  i still never leave the debugger", "id": "c1dyf92", "parent": "t1_c1dh662", "vote": 2}, {"content": "In most production code I've seen attaching a debugger is useless.  The binaries are stripped and optimized so there's no useful information available.", "id": "c1die1q", "parent": "t1_c1di6qi", "vote": 3}, {"content": "I lately had to debug CGI application - short-lived processes that were automatically started by apache. For additional fun it run on ancient version of Debian (sarge). Attach the gdb to what process? :P\n\nAlso, using old gdb over ssh isn't really easier than recompiling and uploading version that logs...", "id": "c1djizy", "parent": "t1_c1dhui2", "vote": 2}, {"content": "> Just attach\n\nGood luck.", "id": "c1dik3v", "parent": "t1_c1dhui2", "vote": 3}, {"content": ">as long as\n\nGood luck.", "id": "c1dhw80", "parent": "t1_c1dhui2", "vote": 3}, {"content": "Well then if your logs are so well designed, chances are most of your bugs will be solvable without needing a debugger...\r\n\r\nI'm not suggesting random variable dumps. Random variable dumps are rarely needed.", "id": "c1dkqcb", "parent": "t1_c1dk8m2", "vote": 2}, {"content": "That is my biggest complaint having gone back to grad school from a .NET shop. The lack of a good visual debugger in linux. GDB can get the job done, but it pales in comparison to the debugger in VS.", "id": "c1dkoun", "parent": "t1_c1diw2w", "vote": 1}, {"content": "FOP?", "id": "c1dhumg", "parent": "t1_c1dhcg4", "vote": 2}, {"content": "Upcremented for introducing the word upcrement into my vocabulary.", "id": "c1dhupm", "parent": "t1_c1dhf8j", "vote": 8}, {"content": "Well no. It is just one thing we can all bash on, even if we like the way it works, we know it is not the best language in the world. At least that is how I see it, I like java, I use it, but I can enjoy a good Java bashing any time..", "id": "c1dhi6m", "parent": "t1_c1dhh9e", "vote": 11}, {"content": "I find it's too easy, kind of like bashing C++ or Cobol. But I imagine most people do it as a form of stress relief, because they either have to work with it or used to.", "id": "c1dht8n", "parent": "t1_c1dhh9e", "vote": 2}, {"content": "I agree with you, but I took this as a joke and not bashing. Bashing mostly comes off as whiny to me.", "id": "c1dhvt2", "parent": "t1_c1dhh9e", "vote": 2}, {"content": "No. I expect some people find it therapeutic, particularly those whose PHB forces them to use it.\n\nThe people behind Groovy are missing a trick here -- they should rename it something like \"Java Agile Tools\" so the PHB thinks it's just some Java tool and not a separate language (and therefore scary).", "id": "c1dkwdm", "parent": "t1_c1dhh9e", "vote": 2}, {"content": "No, not really. It would be much worse for Java if nobody talked about it at all. All big programming languages receive a lot of flack. It's a sign that people are actually using it in real programming projects instead of it being only of academic interest, where you'll never run into real problems.\n\n(**edit**: This is why I always laugh my ass off when I see programming language benchmarks that use stuff like Fibonaci sequence algos to do benchmarks. You silly academics you! :-D )", "id": "c1dhilu", "parent": "t1_c1dhh9e", "vote": 2}, {"content": "You log whatever you think is pertinent to the current problem.\n\nThat's what those printfs are that people are complaining about. :)\n\nNot all logging is appropriate for normal operation.\n\nThe thing is that once you understand where the problem is coming from, the local solution is often obvious.\n\nI think this is why with increasing experience people find less and less debugger usage.", "id": "c1di7zo", "parent": "t1_c1dhnt9", "vote": 2}, {"content": "My what?", "id": "c1dlv95", "parent": "t1_c1dj5x6", "vote": 1}, {"content": "[deleted]", "id": "c1dhb1n", "parent": "t1_c1dh602", "vote": 17}, {"content": "Vim doesn't allow you to open a shell window as far as I know.\n\nI use vim because I only have a 80gb harddrive! *badoom-chiii*\n\nI use vim because I only have 10 fingers! *badoom-chiii*\n\nThank you, thank you, I'll be here all week.\n\n(The reason I use vim is because I've always used vim. I have invested a significant amount of time in getting to know it intimately and becoming a vim power user, and I'm not going to change that because of little thing it can't do. If I want to run a shell, I'll open an xterm). ", "id": "c1dhhzw", "parent": "t1_c1dhdxg", "vote": 8}, {"content": "For reasons I can't even begin to remember now, I didn't like the command-line option solutions, and it was only like 30 lines to roll my own.", "id": "c1dig2x", "parent": "t1_c1dhtpx", "vote": 1}, {"content": "In my case, it's a matter of business process. The Production Support team is there to take a ticket, raise the ticket, and then harass you about the ticket. It's their defined role, and it doesn't matter what error messages you have because they don't directly look at the logs. Instead they co-ordinate whoever needs to be on the ticket and ensure it needs to be done. On the other side, we budget in time to all the developers to work on Prod Support tickets. It actually does work well, but sometimes it sucks that because if you are the one on call you have to respond to simple issues (like an incorrect ACL setup), interrupting your release work.", "id": "c1djbe3", "parent": "t1_c1divfl", "vote": 2}, {"content": "[removed]", "id": "c1dj846", "parent": "t1_c1diujt", "vote": 1}, {"content": "Honestly I can't recall ever using a library I didn't had a source for for anything important (if for anything at all). As Open Source fan and Linux user from primary school I regard software for which I couldn't potentially get a source code a worthless piece of binary crap. And if I had to pay for a library software for which I would not receive a source and then debug it's binary code inside debugger to find what's wrong is going on ... I'd feel like I was seriously screwed. ", "id": "c1dnhow", "parent": "t1_c1dmk6w", "vote": 1}, {"content": "Not all bugs are superficial.  You yourself were extolling the virtues of putting up with Eclipse to get the debugger yesterday on IRC.\n\nListen, you know I work without a debugger a lot of the time, and I'm not a great programmer.  I do that because the amount of work needed to debug is less, though, than the amount of work needed to set up a debugger in a given instance, given my instincts from the old pseudo-debuggable early GBA world.\n\nThat all said, there are times when I have to knuckle down and drag out the debugger, and I'm willing to bet the same can be said of you.\n\nThere is a good argument that the origin of this myth might be the rarity with which a \"great programmer\" actually crosses the cost benefit threshhold of setting up one of those horrid things.  But, all the same, sooner or later *everyone* needs a debugger, no matter how clean their code, how tricky their in-place reporting strategies, how detailed their unit/stochastic tests.", "id": "c1dmr38", "parent": "t1_c1dmidi", "vote": 1}, {"content": "Ah yes, I made one of those in 1976. It was cool for a moment. ", "id": "c1dkjcj", "parent": "t1_c1dkdfu", "vote": 0}, {"content": "And writing print statements is faster than putting a breakpoint in and adding statements to a watch window?", "id": "c1dipm2", "parent": "t1_c1dhfl9", "vote": 1}, {"content": "Why does the print statement have to be compiled? What is wrong with print statements that are injected by the debugger at runtime?", "id": "c1diegf", "parent": "t1_c1dhfl9", "vote": 0}, {"content": "Smalltalk was the only env and language where a debugger was useful to me a lot of the time.\n", "id": "c1dhuzz", "parent": "t1_c1dhtbe", "vote": 9}, {"content": "Anything but get clean output without all that other crap the debugger insists on printing in between (e.g. all those messages about threads starting and exiting in gdb that are of no interest 90% of the time).", "id": "c1dis2e", "parent": "t1_c1dhrj3", "vote": 3}, {"content": "Not in my IDE, sadly. (eclipse)", "id": "c1dm8nm", "parent": "t1_c1dhrj3", "vote": 1}, {"content": "A debugger isn't going to help you with race conditions, but luckily race conditions are pretty easy bugs to spot in code.\n", "id": "c1dhr39", "parent": "t1_c1dhoh8", "vote": 6}, {"content": "... and start the process all over again.", "id": "c1diiex", "parent": "t1_c1dier1", "vote": 6}, {"content": "That's a rather hollow argument. Modern debuggers aren't hard to learn, especially since they've all pretty much converged on the same general interface, so once you know one, you generally know everything you need to at least get up and running with basic tasks in another.\n\nGranted, there's a small investment in initial setup; but if you're working with a non-trivial workload, the investment pays off.\n\nMost people who claim otherwise are usually just set in their ways and being stubborn; or they're basing their opinions on what they saw as the state-of-the-art in debugging from a decade ago or more; or they're driven by some misguided sense of machismo in avoiding 'the easy way'.  You can usually tell which based on the arguments against debuggers that they present.", "id": "c1djp3h", "parent": "t1_c1dii03", "vote": 5}, {"content": "Most embedded platforms have some type of ICE.", "id": "c1dlate", "parent": "t1_c1dk3f9", "vote": 1}, {"content": "Yes, but if you have a reasonable belief that it will be necessary at some point, then using it (along with debuggers) isn't a bad option.  If you only use a debugger, then you're stuck.", "id": "c1dispo", "parent": "t1_c1dijwb", "vote": 3}, {"content": "I ship the debug symbols to production so that the stack traces are more accurate in the event of failure.\r\n\r\nAs for optimizations, I'm using .NET so the debugger will still work. Some stuff gets weird but usually I can get to the information I'm after.", "id": "c1dirf0", "parent": "t1_c1die1q", "vote": 2}, {"content": "Seriously.  I'm a Dapper Dan man.", "id": "c1dil00", "parent": "t1_c1dhumg", "vote": 6}, {"content": "It's a hair gel for men. Only classy coders need apply.", "id": "c1dimg5", "parent": "t1_c1dhumg", "vote": 2}, {"content": "http://lmgtfy.com/?q=FOP&l=1 :)\n\nApache FOP... it's a formatter that converts XSL-FO to PDF (ok, so it'll convert to a dozen styles, but most officially supports PDF)", "id": "c1dimks", "parent": "t1_c1dhumg", "vote": 2}, {"content": "There is no \"best language in the world\". They are all broken in some respect, ill-suited to various tasks, and so on. But Java seems to attract a much higher proportion of assault than any other language.", "id": "c1dhieu", "parent": "t1_c1dhi6m", "vote": 5}, {"content": "[Clojure? It's just a small Java library that helps with concurrency.](http://stackoverflow.com/questions/451619/what-is-your-opinion-on-clojure/560667#560667)", "id": "c1dlo2u", "parent": "t1_c1dkwdm", "vote": 1}, {"content": "Is that why everyone is so in love with Haskell? ", "id": "c1diuqj", "parent": "t1_c1dhilu", "vote": 2}, {"content": "Don't take this the wrong way, but when the mars rover went down - they didn't use logging to find the problem, they fired up gdb.\n\nWith increasing experience - the occurrence of bugs simply goes down because you understand what you're doing more.  I would even argue that putting logging in everywhere decreases the quality of the code because you end up relying on print statements to tell what's going on.  Maybe I'm just out of the loop as far as \"famous\" programmers go, but all of the really good ones I know use debuggers *when it's appropriate*.  If you've been coding for 15 years and you need print statements to figure out off-by-one errors in your data structures, then you need to do more sanity checks of your code (did I put > when I meant >=), or simply learn how the structures actually work (neither of which involves dropping logging statements into your code every other line).", "id": "c1dmoas", "parent": "t1_c1di7zo", "vote": 1}, {"content": "It was a jab at the \"smart people\" comment above.  Nobody got it. :(", "id": "c1e4ir8", "parent": "t1_c1dlv95", "vote": 1}, {"content": "I don't think you should debate about it.", "id": "c1dhbd6", "parent": "t1_c1dhb1n", "vote": 11}, {"content": "You can use scripts like ConqueTerm to get terminals in Vim buffers/splits/tabs, though it's not as good as a \"real\" terminal. You can drop out of Vim without closing it with :sh. There might be a vimscript for debugging your language, like vimpdb for Python. You can run commands with :!debugger and make mappings for inserting breakpoints and running the debugger in one go. Vim is not an excuse to not use debuggers. :)", "id": "c1dhptf", "parent": "t1_c1dhhzw", "vote": 4}, {"content": ":sh will drop you into a shell in vim.  \n\ni run a lot of my debugging scripts, tests, etc. from vim directly, though, doing something like :!./% or :!./debug_script\n", "id": "c1dhryp", "parent": "t1_c1dhhzw", "vote": 2}, {"content": "screen + vim = death...\n\nBeats the hell out of emacs, though emacs is good for reading huge files.", "id": "c1dimy1", "parent": "t1_c1dhhzw", "vote": 1}, {"content": "use tmux, screen, or dvtm and split the console.", "id": "c1dlgpp", "parent": "t1_c1dhhzw", "vote": 1}, {"content": "So basically VIM is so time-consuming to learn that after you've finally mastered it, after years of torturing yourself, you don't want to maybe discover something better and feel shitty about your wasted time and effort? \n\nI suspect this is why people stick with C++ :-) /flame on\n\nI know how that goes though, I once dated this girl for a LONG time, even though she was wrong for me, just because it took so much time and effort to \"master the right key combo\". ", "id": "c1divet", "parent": "t1_c1dhhzw", "vote": 1}, {"content": "On a typical project I will spend somewhere between 40 and 80% of my time on static error analysis. My programs cannot fix a downed database or VPN connection, but they know what the symptoms are and exactly what effect it will have on the operations it is trying to perform.\r\n\r\nThis didn't come overnight. When I first started we got the typical \"Null Reference in FooBar\" type emails. But as I started recognizing the patterns I continually improved the messages until they were usful to prod support and eventually end users.", "id": "c1dk2vx", "parent": "t1_c1dj846", "vote": 1}, {"content": "Welcome to the world of NON-OSS. It sucks here sometimes, but it's an interesting challenge.", "id": "c1dnidm", "parent": "t1_c1dnhow", "vote": 1}, {"content": "For me it is, because with debuggers I find that I am always wading around through irrelevant information (clicking reveal triangles to get deep within an object hierarchy, etc.). And most of them are very keyboard-hostile (perhaps unavoidable due to the nature of the information they are presenting), which means using the mouse, always a huge waste of time.\n\nWith print statements I get exactly what I want, no irritating clickery required.\n\nAnd as a bonus, I have an easy record of it throughout however many runs that I can compare against future runs. I can even easily stick it all in a set of files and use grep or other tools to study historical debugging output.", "id": "c1dk9tb", "parent": "t1_c1dipm2", "vote": 2}, {"content": "A watch window only shows the current state as you're debugging and only when you're in the correct context at that moment. This person is talking about having a long trace of the state of variables over time.", "id": "c1dmibk", "parent": "t1_c1dipm2", "vote": 2}, {"content": "Speaking of tools, valgrind is  freaking awesome.\n\nI once messed up with QThreads and signals/slots and function that was supposed to be called from one thread only got called from another thread. \nValgrind then showed quite beautiful stacktrace and what threads accessed data.", "id": "c1dhxbg", "parent": "t1_c1dhr39", "vote": 2}, {"content": "Print statements aren't hard to learn either.  For me it seems part of the DIY attitude.  You won't always be programming from one location, and in the event that a bug does appear while helping someone on another system or something, that debugger won't be there, but print statements will always work.", "id": "c1dm2pt", "parent": "t1_c1djp3h", "vote": 1}, {"content": "From what I've found with gdb it lies to me more often than not, especially if there's more than one thread involved.", "id": "c1diujr", "parent": "t1_c1dirf0", "vote": 2}, {"content": "I don't want **FOP**, goddamnit! I'm a Dapper Dan man.", "id": "c1dj4th", "parent": "t1_c1dimg5", "vote": 3}, {"content": "What if I don't have hair?", "id": "c1dio65", "parent": "t1_c1dimg5", "vote": 1}, {"content": "I meant because everyone seems to know a few flaws of which they hate and it is no one's \"favourite\" language, that  is what makes it fun.", "id": "c1dhmwr", "parent": "t1_c1dhieu", "vote": 7}, {"content": "Have you ever tried talking about PHP on here?\n   ", "id": "c1dihlr", "parent": "t1_c1dhieu", "vote": 7}, {"content": "I've used Haskell in network software I've written. i've cursed it also - who the fucking bastard thought that [Char] is a good way to represent String? It's perfect for creating memory bloat and space leaks... something like ByteString should be default, imho.  Still, I prefer Haskell to Java.", "id": "c1djnsk", "parent": "t1_c1diuqj", "vote": 1}, {"content": "Don't take this the wrong way, but you've completely misread everything that I have written.\n\nYou might like to try reading it again and responding appropriately.", "id": "c1dn1mv", "parent": "t1_c1dmoas", "vote": 1}, {"content": "That's no argument, that's contradiction!", "id": "c1dhcmt", "parent": "t1_c1dhbd6", "vote": 9}, {"content": "I'm on the fence, maybe one of you can convince me.", "id": "c1dhd4n", "parent": "t1_c1dhbd6", "vote": 5}, {"content": "This metadebate just broke my flow.", "id": "c1dhejt", "parent": "t1_c1dhbd6", "vote": 2}, {"content": "Scare place to be. :)", "id": "c1dnnq2", "parent": "t1_c1dnidm", "vote": 1}, {"content": "For some reason people have a hard time grasping that there is a difference between \"stop the world\" debugging and a more log style debugging.", "id": "c1dyedh", "parent": "t1_c1dmibk", "vote": 1}, {"content": "I was huge into the DIY attitude when I was in my younger years, so I can appreciate that mindset (then again, debuggers were shit in my younger years too).  But as I've grown more pragmatic, I've questioned the wisdom of reinventing wheels 'just because'.   If a tool exists and makes my life easier, I'm going to use it -- regardless of whether it's something a Mel-like 'real programmer' would do.\n\nBut the \"not always so therefore never\" argument doesn't hold weight.  Use print statements when you have to help someone else at their desk; but that doesn't preclude you from using a debugger back at your own desk.  It's not as if you're going to forget *how*.", "id": "c1dn48h", "parent": "t1_c1dm2pt", "vote": 1}, {"content": "I never have that problem with Visual Studio. On the other hand, VS does like withholding information at random times. \r\n\r\n> x? what x? I don't see no local variable called x.", "id": "c1dix1k", "parent": "t1_c1diujr", "vote": 2}, {"content": "zhivago - I actually agree with your technical points, but the whole \"learn how to read\" insult-meme routine is unnecessary and unhelpful. SubSevn obviously has at least *some* clue... and you should be well aware that no matter how clear *you* think your words are, it's almost always possible for someone else to interpret them in a way you didn't intend, especially when you consider the surrounding context. And that doesn't (necessarily) mean they're ignorant or stupid or illiterate.\n\nIn this case, as far as I can tell it looks like SubSevn misinterpreted at least a couple of your statements, eg. \"In these cases a debugger is almost useless [...]\" and \"I think this is why with increasing experience people find less and less debugger usage.\" as meaning you were at least putting down debugger-use as a viable option, and perhaps insinuating that frequent-debugger-using programmers are inexperienced or incompetent.\n\nIt seems clear to me that you didn't mean that, but I can understand why SubSevn might have read it that way.\n\nGiven the above, lines like \"you've completely misread everything that I have written\" are unhelpful, because (much as in the act of debugging itself) you left him with no useful information to narrow down what specifically he **might** have done wrong.\n\nAnd yes, from his perspective it's a \"might\" - because he can't be certain that you might not be deliberately misleading him, or even just mistaken yourself. Much like a bug in the debugger might result in a completely misleading report, suggesting a problem that doesn't actually exist. :-)", "id": "c1dtjkf", "parent": "t1_c1dn1mv", "vote": 2}, {"content": "Well, tell me where I'm wrong.  If you're going to be a dick then go for it but leave me out of it - don't simply say \"You misread it all, try again.\" when you don't even point out where I've gone wrong.  I don't think there's anyone who would disagree with \"use debuggers *when it's appropriate*\" but I would say that your statement of \"I think this is why with increasing experience people find less and less debugger usage.\" is really just insulting people who are good programmers and use debuggers.\n\nYou said the local solution is obvious when you know where the bug is coming from - well unless you log everything you do, you may not know where the bug is coming from at all.  \"You log whatever you think is pertinent to the current problem\" - well, next time you manage to think to print out every single possible thing that could go wrong, every time you do anything, let me know so I can see how your code is five lines of logging to one line of real code.\n\n\"Not all logging is appropriate for normal operation\" well no shit, that's why we have logging levels - I fail to see what this has to do with anything we're talking about.  You can also run programs without a debugger.\n\nTake this however you want: I think this is why with increasing experience people find less and less random printf's required.", "id": "c1dnhq1", "parent": "t1_c1dn1mv", "vote": 1}, {"content": "No it isn't!", "id": "c1dhh21", "parent": "t1_c1dhcmt", "vote": 9}, {"content": "Hey, I told you not to take it the wrong way ... but I'm sure you'll take this the wrong way, too. :)\n\n> You log whatever you think is pertinent to the current problem\" - well, next time you manage to think to print out every single possible thing that could go wrong, every time you do anything, let me know so I can see how your code is five lines of logging to one line of real code.\n\nSee -- this is the problem with you not being able to read properly.\n\nDo you know what \"whatever you think is pertinent to the current problem\" means?\n\nIf so, why are you turning it into \"print out every single possible thing that could go wrong?\"\n\nI'd suggest a remedial reading comprehension course, but you'd probably take that the wrong way.\n\nTry not to be a dick about it.", "id": "c1dpqm4", "parent": "t1_c1dnhq1", "vote": 1}, {"content": "Yes it isn't!", "id": "c1di2vk", "parent": "t1_c1dhh21", "vote": 5}, {"content": "Maybe you haven't seen computers, but when actual problems are encountered (read: not \"herp derp I forgot to initialize this\"), the solution often lies somewhere else in the code - pointer arithmetic that happened earlier, mallocs/frees.  Unless that is you simply never come across real problems - which probably means you've never actually coded anything real in your life, which would explain why all your problems are solved by printf's.\n\nThen again, why am I arguing?  If you're not going to use a useful tool - I look forward to fixing your code and getting a raise for it.", "id": "c1dq97q", "parent": "t1_c1dpqm4", "vote": 1}, {"content": "Please learn how to read.", "id": "c1dr2nl", "parent": "t1_c1dq97q", "vote": 1}, {"content": "Please learn how to communicate effectively!  Ever considered that your blatant disregard for the points other people are trying to make destroys your ability to tell them your side?  Do not tell people to \"learn to read\" just because you didn't see them agree with what you said.  You really are a jerk, you know that?  You can't even accept that some good developers might use a debugger - and that's really, truly, points against your character.  Guess what: people with other points of view exist - and some of them *will* be better than you at many, many things!  Get off reddit and go meet some of them!  Out of the basement, go!\n\nI'm going to put you down as a troll in my mind, because I still like a tiny portion of the Reddit community, and I'd rather keep this account and deal with your insults than simply delete it and move on with my life, self-destructive behavior - maybe, but at least I'm not you.\n\nYou, sir, are a sad human being and I feel sorry for anyone forced to deal with you in person.\n\nI'll even allow you to satisfy your fetish for always being right:\nYou win!  Everyone who's ever used a debugger is a bad programmer/developer!  They're all stupid and can't code!  Debuggers were written by losers to begin with, and anyone who's ever included debugging features in their compiler is part of the problem!  They're all failures!\n\nGo *outside* - please.", "id": "c1drwi8", "parent": "t1_c1dr2nl", "vote": 1}, {"content": "Can you quote anything indicates that \"[I] can't even accept that some good developers might use a debugger\"?\n\nYou're the troll here -- stop making stuff up and learn how to read.", "id": "c1ds4js", "parent": "t1_c1drwi8", "vote": 1}, {"content": "\"I think this is why with increasing experience people find less and less debugger usage.\"\n\nThis indirectly implies that people with experience don't use debuggers.  The only reason I took offense is that you're implying that experienced people should be able to solve their problems without a debugger simply as a side effect of having added logging.  Maybe I have misread it - but that doesn't mean you can assume every person, with more experience, uses a debugger less and less.  As I've noticed, people who have a lot of experience and don't use debuggers simply never learned how.  I know dozens of developers who have been working in the industry for 10, 15, 20 years - who've never used one until I show them how, at which point it changes the way they approach problems.  I typically get thanked for showing senior java developers that java even HAS a debugger.  I could just as well say that \"Well, with increased experience, logging becomes unncessary,\" and make the same claim that you have.  They wrote the program, they should know how it works despite complexity, if they were any good!  But for some reason, people still have logging - as much as they still maintain debuggers.\n\nOne of these days you will come across a problem that you can't solve with your printfs (or even worse - it's not your code and you're not allowed to modify to add logging), and you'll be really happy that debuggers exist.  I hear when doing operating-system level programming, they actually have to look at *assembly*!  The horror of not having log4j!  What will we do without Boost.Log!  How did people solve problems before exceptions?!?!?!", "id": "c1dt932", "parent": "t1_c1ds4js", "vote": 1}, {"content": "> \"I think this is why with increasing experience people find less and less debugger usage.\"\n> This indirectly implies that people with experience don't use debuggers.\n\nNo.\n\nIt doesn't.\n\n\"Less and less\" means with a reducing frequency.\n\nIt does not mean zero frequency.\n\nLearn to read.", "id": "c1dufp3", "parent": "t1_c1dt932", "vote": 1}, {"content": "No, \"less and less\" implies that at some point, it'll get to zero - and it has a negative connotation (oh shit son, using negative words has this effect, who knew?).  You could have phrased it in a considerably more polite manner as \"I think this is why with increasing experience people use more and more logging.\"  You might've even been able to throw an \"as opposed to debuggers\".\n\n\"I think this is why with increasing experience, pilots use fewer and fewer maps.\" as opposed to \"I think this is why with increasing experience, pilots use a GPS more and more.\"\n\nNotice how the first one can be read in a manner which implies that maps have little value?\n\nLearn to write.", "id": "c1dum7c", "parent": "t1_c1dufp3", "vote": 1}, {"content": "No.\n\nLess and less does not imply that it will reach zero.\n\nIt implies that it will approach a level below the current level.\n\nIt does not have a negative connotation.\n\ne.g., \"with effort you may become less and less stupid\".\n\nIf I had meant \"people use more and more logging\" then I would have said that.\n\nMy meaning was clear and I wrote it clearly.\n\nAs you have demonstrated, the problem is that you do not know how to read properly.", "id": "c1duon4", "parent": "t1_c1dum7c", "vote": 1}, {"content": "So what you're saying is that \"with effort you'll get smarter and smarter\" and \"with effort you may become less and less stupid\" have the exact same connotation?  Have you never read a book or something - do you not know how connotation works?\n\nGo up to someone and tell them \"You're not dumb.\" and as opposed to \"You're smart.\"  Notice the difference?  Maybe you haven't dealt with too many people before so this difference eludes you but there in fact a very real emotional intent carried with the words you use - did you never have anyone tell you that \"negative\" words carry a bad connotation?\n\nHow can anyone read \"with effort you may become less and less stupid\" and not think that there was an insult to their intelligence in the statement?\n\nAre you a student?  I can't help but wonder because the only people I know who speak as you do to me are those who have yet to leave academia and believe they are the purveyors of knowledge.", "id": "c1dvi4h", "parent": "t1_c1duon4", "vote": 1}, {"content": "Please quote where I said they have the exact same connotation.\n\nWhen you can't, go back and read what I did write until you understand it.", "id": "c1dvkm7", "parent": "t1_c1dvi4h", "vote": 1}, {"content": "\"e.g., \"with effort you may become less and less stupid\".\nIf I had meant \"people use more and more logging\" then I would have said that.\"\n\nThen why didn't you?  The way you put the former is easily taken as an insult.  You either consider them equivalent - or didn't think about how others may read it before you wrote it.\n\nIt's ok though - you've made my decision to leave Reddit a lot easier, since now I can just delete my account and rid myself of this.  To think that I even engaged in an online argument on *Reddit* of all places.  I would've thought that people here were willing to concede at least a little in the interest of continuing discussion but you clearly can't.\n\nI actually worried for a little while about what I'd say to you next every time I posted!  How sad is that?\n\nDo yourself a favor, since you clearly haven't been in this situation yet:\nDo not, when dealing with a client or peer (or worse, a superior), tell them that their solution/company/product will \"suck less and less\" if they apply your ideas.  Try \"will improve more and more\".  It's considerably more polite and will lead you to much better interactions with people.\n\nI might as well add that you will meet people who can code circles around you and solve problems in a tenth the time who *do* use debuggers - even if they (shock!) also use logging.  They will be above you in the social and corporate ladders and it is best for you to learn from them when each is appropriate, although I doubt you lack knowledge in the technical sense: you just fail at dealing with others and have yet to realize that good developers working together can come up with better code/solutions than one great developer who insists on working alone due to his own pride and his Internet Ego.", "id": "c1dwpez", "parent": "t1_c1dvkm7", "vote": 1}, {"content": "If only your mother had taught you how to read ...", "id": "c1dxinj", "parent": "t1_c1dwpez", "vote": 1}], "link": "https://www.reddit.com/r/programming/comments/f5n00/programming_masterminds_dont_use_debuggers_why/", "question": {"context": "", "id": "f5n00", "title": "Programming masterminds don't use debuggers: why?"}, "resource": "Reddit"}, {"answers": [{"content": "A whole world of creative opportunities open up when the toolchain and related debugging tools don't suck. [Check out this wild video](https://youtu.be/72y2EC5fkcE) of someone modifying and debugging a game in real time.", "id": "jbomhr9", "parent": "t3_11nmccf", "vote": 210}, {"content": "> We can snapshot the program whenever something non-deterministic happens (syscall, I/O, etc) and then we just reconstruct the program state at any moment by rewinding it to the nearest snapshot and executing the code from there. This is basically what UDB, WinDBG and rr do.\n\nThat isn't what WinDbg does. The downside of using a snapshot+replay at the syscall granularity is that you can't trace multiple threads within a process. WinDbg uses a very efficient CPU emulator, so you get full fidelity of recording including race conditions between threads.\n\nSource: I wrote a chunk of the CPU emulator for WinDbg/TTD", "id": "jbpf32s", "parent": "t3_11nmccf", "vote": 56}, {"content": "Logging is a good practice that can save you from having to use the debugger.\n\nUnit testing is also a good practice that offers some guarantees to your code. For example, your changes are less likely to break something, or at least you are more likely to be aware of it.\n\nAnd debuggers are a great tool that can help trace code flow and, as the article points, display data structures, among others.\n\nI've never understood the dogmatism of some programmers arguing against debuggers.", "id": "jbnyzfa", "parent": "t3_11nmccf", "vote": 253}, {"content": "Recently (4 years ago), I worked on a project that had a monster sized COBOL program (> 21k lines). It was NetExpress Cobol and ran on a client/server Unix system. The person who developed and maintained it initially refused to learn the NetExpress IDE editor/debugger and did all the coding/testing on a mainframe. It was a giant mess of bad coding. He complained how long it took to write and test.\n\nWhen I was tasked for making changes and updating I showed him how easy it was to use the editor and how great the debugger was. I found numerous logic errors he wasn't even aware of.\n\nI was hoping to convert this nasty Cobol program to Python and save the client money from having to license NetExpress. Alas, they weren't interested and I decided to move on for other reasons.\n\nIf you're a coder, make the effort to learn your tools. You'll save tons of time and frustration.", "id": "jbpfoyw", "parent": "t3_11nmccf", "vote": 43}, {"content": "> When people say \u201cdebuggers are useless and using logging and unit-tests is much better,\u201d\n\nThere are people that say this?", "id": "jboy5xl", "parent": "t3_11nmccf", "vote": 51}, {"content": "Hot reload is a great description. But I think of editing memory (both code and data) and register contents. Both to hot patch broken code into continuing, and to force error paths to test recovery.\n\nI prefer text console debuggers because I can use the scroll back as a poor man\u2019s time travel, to see that state earlier in time. GUI subsides that show registers and memory that auto refresh only show a current snapshot.\n\nAs an old man who shouts at clouds (and debugs them), I have also learned that both logging and debugging can mislead you. They both capture and report the state a bit before it a bit after the bug. Threaded programs don\u2019t halt atomically or even halt at the time of the fault (lots of kernel code runs before deciding to halt the thread).  Page tables and caches mutate out of band.  So have a healthy skepticism for what you see on the screen.", "id": "jbopuxo", "parent": "t3_11nmccf", "vote": 11}, {"content": "Lisps have some good tooling around debugging, for example clojure's [flowstorm](https://github.com/jpmonettas/flow-storm-debugger) or [common lisp](https://lispcookbook.github.io/cl-cookbook/debugging.html) which has built into the language most of what this article is talking about.", "id": "jbp0o5u", "parent": "t3_11nmccf", "vote": 17}, {"content": "*Whyline* was really good for it's time.\n\nI hate those fucking patents that are limiting progress again.\n\n**Stop claiming those fucking patents if you're not going to seriously work on them**!!!\n\n[https://www.cs.cmu.edu/\\~NatProg/whyline-java.html](https://www.cs.cmu.edu/~NatProg/whyline-java.html)\n\n[https://github.com/amyjko/whyline](https://github.com/amyjko/whyline)", "id": "jbp2yq4", "parent": "t3_11nmccf", "vote": 11}, {"content": "John Carmack once said that debuggers are one of the best tools for learning a new code base. He was right", "id": "jbqypxg", "parent": "t3_11nmccf", "vote": 11}, {"content": "I use Visual Studio, and I love the fact that I can put a conditional breakpoint on a line. So execution only stops there when, say, some variable is null or something like that. Very useful.", "id": "jbopl2z", "parent": "t3_11nmccf", "vote": 20}, {"content": "GDB nowadays is insanely good. Not only the less-known TUI mode, but also its Python API and stupidly simple protocol. But the first place in my opinion goes to Common Lisp debuggers, like the SBCL implementation. Bonus if you also use SLIME.", "id": "jbsvpgk", "parent": "t3_11nmccf", "vote": 4}, {"content": "Laughs in remote debugging an embedded exception handler.", "id": "jbrbla9", "parent": "t3_11nmccf", "vote": 3}, {"content": "printf is Turing Complete, so in theory it can yell back at you :-)", "id": "jbqypac", "parent": "t3_11nmccf", "vote": 4}, {"content": "I would love to be able to use a debugger more in my work. Unfortunately our stack is multiprocessing heavy python running in docker containers, which makes attaching a debugger difficult.", "id": "jbrpdwx", "parent": "t3_11nmccf", "vote": 2}, {"content": "That omniscient debugging section mentions something I've long since wanted and have repeatedly been frustrated to find it doesn't widely exist yet: breaking on usages of a variable (most commonly writes-only).\n\nIt's common that I have some field that is used in many places. I know it's getting a bad value from somewhere, but I don't know where. Isolating where it comes from is annoying and time consuming. You'd think debuggers should be able to do that *easily*, but it doesn't seem a typical feature.", "id": "jbrt3j4", "parent": "t3_11nmccf", "vote": 2}, {"content": "a tool is a tool is a.. \n\nJust use the one that works best for the job. No other trade/profession argues about this sort of thing. \n\nNever have I heard builders argue about which hammer is better. They just use what works.", "id": "jbqydid", "parent": "t3_11nmccf", "vote": 1}, {"content": "> When people say \u201cdebuggers are useless and using logging and unit-tests is much better,\u201d\n\nlmao, who tf says shit like this?", "id": "jbr7mck", "parent": "t3_11nmccf", "vote": 1}, {"content": "Who on earth was calling debuggers useless?  Seems like a very stupid position.", "id": "jbrnoi1", "parent": "t3_11nmccf", "vote": 1}, {"content": "I like nearly everything. I'm not sold on omniscient debugging yet. One really useful debugging feature I don't see here is the ability to recompile code while stopped at a breakpoint (like hot reload) and then restart execution from any stack frame. Also being able to inspect the local variables of any stack frame while at a breakpoint in a different stackframe.", "id": "jbrpo5k", "parent": "t3_11nmccf", "vote": 1}, {"content": "I haven't read the entire thing yet. I just finished the second paragraph, but I had to come back here and comment.\n\nThis is insane. This is absolutely insane. My head is spinning, and my knees are heavy and my worldview has exploded. I am genuinely not even exaggerating that much. Using a debugger like this should be within the first year of a college cs course. It was not.\n\nI...\n\nI lost so many hours of my life. A tool like this would be a godsend for me. If only I knew about this. I need to know how to do this.\n\nThat said, I don't think my current situation allows that. I do game dev with unity and C#, and all my attempts at using debuggers have been... Rough.\n\nBut it would have saved me in uni.", "id": "jbrtjsu", "parent": "t3_11nmccf", "vote": 1}, {"content": "I still fail to understand the nitty gritties of printf. Still stick with good old gdb and printing using course ;-;", "id": "jbrvl3m", "parent": "t3_11nmccf", "vote": 1}, {"content": "\\*sigh\\* Except my boss is too cheap and has me stuck on VS 2019. Also. It's Unity.", "id": "jbsyg7f", "parent": "t3_11nmccf", "vote": 1}, {"content": "[deleted]", "id": "jbtmezl", "parent": "t3_11nmccf", "vote": 1}, {"content": "That is really cool.\nI love the ability to step through code *backwards*...that would be insanely helpful in my own work.", "id": "jbopge4", "parent": "t1_jbomhr9", "vote": 74}, {"content": "This video actually motivated me to write the article :) I reference it in the section about Time Travel. It's a great example of how good things can be if everything is designed together from the beginning. Unfortunately debuggers are often an afterthought, so their potential is not realized to the fullest.", "id": "jbowp15", "parent": "t1_jbomhr9", "vote": 17}, {"content": "I can't even get the unity debugger to work in the first place, and believe me I've tried.", "id": "jbqhjfx", "parent": "t1_jbomhr9", "vote": 3}, {"content": "This goes further than just toolchain and debugging related tools. The programming environment as a whole is stuck in 70s. Programming UX evolved virtually nothing in 50 years. In some cases is actually devolved. RE: https://www.youtube.com/watch?v=8Ab3ArE8W3s", "id": "jbrjct4", "parent": "t1_jbomhr9", "vote": 4}, {"content": "[deleted]", "id": "jbqrs6k", "parent": "t1_jbomhr9", "vote": 3}, {"content": "It does leverage determinism so that it doesn't record every register for every instruction. I think on average it's like half a bit per instruction. Most traces I used to capture a bug were 2-40 GB.", "id": "jbpfwly", "parent": "t1_jbpf32s", "vote": 23}, {"content": "I have always viewed logs as something that tells me where to debug. Rather than a red herring, I have concrete data.\n\nHell, most of the time I create a snapshot of the issue and can just step through it time and time again until I am certain of the problem. Makes life pretty simple.", "id": "jbp0sg7", "parent": "t1_jbnyzfa", "vote": 56}, {"content": "Yeah I was this person then finally got around to setting up and sticking breakpoints in my unit tests. The ability to walk through API/database calls/mocks realllllly gets easier when you can see what is what line by line", "id": "jboc1d7", "parent": "t1_jbnyzfa", "vote": 26}, {"content": "I think one of the problems with debuggers is that they can require quite a lot of mental overhead to get going with - when you're in trouble, learning a new tool isn't appealing.\n\nBut, also, logging is \\*really effective\\* at showing you what you want and gives you a sense of incremental progress.\n\nThe trace points mentioned in the article are potentially a good mid-point, when packaged up right, though.  GDB has \\`dprintf\\`, VS Code exposes Log Points, full VS has its own trace points.\n\nThat way you can get an overview of what's happening but still be able to dive in and debug in detail.", "id": "jbo08lv", "parent": "t1_jbnyzfa", "vote": 61}, {"content": "\u201cI don\u2019t want you using a debugger\u201d \u2014Uncle Bob of Clean Code infamy\n\n\u201c\u201dHmmm\u2026 I don\u2019t recall asking you a god damn thing\u201d \u2014me", "id": "jbpqlet", "parent": "t1_jbnyzfa", "vote": 24}, {"content": "[deleted]", "id": "jbqm747", "parent": "t1_jbnyzfa", "vote": 13}, {"content": ">Logging is a good practice that can save you from having to use the debugger.\n\nAbsolutely!\n\nJust like a good type-system allows you to avoid a lot of debugging by offloading that work onto the compiler. Though, it's really disappointing how... lackluster logging typically is. (For example, imagine the logging system of a simulator: wouldn't it be useful to say \"click\" a timestamp and goto that particular time/state in the simulation? Sadly instead of having this sort of functionality baked-in with a typed log-file, many (most?) projects would opt for a text-based logf-file with such a \"timestamp-extractor\" being something like a RegEx.) \n\nHonestly, much of the programmer's tooling is (IMO) crippled like that: the \\[over\\]reliance on text (typically rationalized as \"*being general*\") rather than as typed structures with their own meaningful operations. The same goes with filesystem- and environment-dependencies: why the hell should your tools *depend* on the **where** you store them? or whether the system is using `/` or `\\` to delimit paths?", "id": "jbpfa43", "parent": "t1_jbnyzfa", "vote": 7}, {"content": "Well-written logging is the answer to some popular questions...\n\nThe debugger is just a tool.\n\n&#x200B;\n\nI use both. I see no reason to choose one.", "id": "jbp1pw7", "parent": "t1_jbnyzfa", "vote": 6}, {"content": "I only debug my code.", "id": "jbq5z23", "parent": "t1_jbnyzfa", "vote": 1}, {"content": "> I've never understood the dogmatism of some programmers arguing against debuggers.\n\nI've got no objections to debuggers, but I mostly find them useless.\n\nIn my experience, most non-trivial bugs happen in interconnected systems and often only when running in production with real data. If I can reproduce the bug in my dev environment quickly enough for a debugger to be useful, then it's an easy bug. I can use logging, or I can use a debugger, but I'll solve the problem fast either way. If I can't, that's a sign that the code quality is really bad, and I need to refactor.\n\nIf I can't reproduce the bug in my dev environment though, the debugger isn't going to help me much.\n\nAs a result, if I can't figure out where things went wrong from the log output, as far as I'm concerned, that *is* a bug, because when an actually difficult bug happens, that log output isn't doing its job. I'm going to focus on logging and refactoring, and the bug will go away as an afterthought.", "id": "jbqvy37", "parent": "t1_jbnyzfa", "vote": 0}, {"content": "Counterpoint: logging is preparation for bugs that've already been tested for and therefore known not to happen. This makes it boilerplate, bloat, and useless, all at the same time.", "id": "jbp0h4b", "parent": "t1_jbnyzfa", "vote": -4}, {"content": "One of the reason I kind of reluctant to do web (mostly front-end) development. It's not like we can't user debugger while doing it, nowadays it's miles better, it's just that overall my colleagues rather content with console.log and dev tools for everything, and never really invest time in setting up proper debugging pipeline (source map and the likes). I mean, sure logging will also solve most issues, but it would probably be much faster to do it with a debugger.", "id": "jbqwb1i", "parent": "t1_jbnyzfa", "vote": 1}, {"content": "I don't know if I've *heard* much dogmatism here, aside from a certain Linus flame.\n\nThe main place I've seen people overwhelmingly use logs instead of debugging is when debugging is difficult to set up, like with a massive distributed system. Or with a system that was prematurely made distributed (like someone got super-excited about microservices).", "id": "jbqyiwr", "parent": "t1_jbnyzfa", "vote": 1}, {"content": ">Logging is a good practice that can save you from having to use the debugger.\n\nThat's a weird way to say that debugging is a good practice that can save you from having to check the logs.", "id": "jbr3f3f", "parent": "t1_jbnyzfa", "vote": 1}, {"content": "One thing you can be fairly confident in is that they use vim and constantly tell everyone they do.", "id": "jbr5i8h", "parent": "t1_jbnyzfa", "vote": 1}, {"content": "I work in a cross platform C++ product team. My impression is that there are developers who are practicing debugger driven development: \n\nThey rarely if every run anything optimised and get completely paralysed when in a situation when there is no good debugger support available. You can see these folks never start the software without debugger too.\n\nI do use debuggers and I can appreciate the tools there but I there is more the development than preboxed debuggers. I think that at some point you are departing what a general tool can give you and you have to design your own temporary or persistent tools to debug issues with the specific product and specific issue.\n\nMy personal preference is to work the issue from a testing of view. Whatever step you make in the debugging process, make sure you leave some tests behind.\n\nAll too many of the debugger driven developers find their issue as the first bug report repro with hours or breakpoint-step-inspect and leave little reusable information after themselves as to what hasn't worked to discover the problem.", "id": "jbsiz9d", "parent": "t1_jbnyzfa", "vote": 1}, {"content": "Unit testing along with debugger can be awesome.\n\nSet up a failing test. Run test with debugger. Walk through it step by step to see where things go wrong. Fix the error.\n\nCan save a lot of time, especially if the main program requires a lot of setting up before it reaches the failing code. With a unit test you can jump into the failing code directly.", "id": "jbsrjl9", "parent": "t1_jbnyzfa", "vote": 1}, {"content": "I started using a debugger more frequently after watching an interview of John Carmack. He said in his world, it was pretty frequent/normal to go into the debugger well before the code ever reached any kind of error state, since it was a good way to *know* what the actual program state was, and not try to compile it in your head.", "id": "jc2f06w", "parent": "t1_jbnyzfa", "vote": 1}, {"content": "21KLoC is \"monster sized\" in 2023? In most industries, we call that size \"pet project\". COBOL must be really fucking awful if that's a true assessment.", "id": "jbqmln5", "parent": "t1_jbpfoyw", "vote": 19}, {"content": "People said it 20 years ago \\[1\\] and continue to this day \\[2\\] :)\n\n\\[1\\] [https://lkml.org/lkml/2000/9/6/65](https://lkml.org/lkml/2000/9/6/65)\n\n\\[2\\] [https://news.ycombinator.com/item?id=35095996](https://news.ycombinator.com/item?id=35095996)", "id": "jbozkx2", "parent": "t1_jboy5xl", "vote": 30}, {"content": ">\\> When people say \u201cdebuggers are useless and using logging and unit-tests is much better,\u201d  \n>  \n>There are people that say this?\n\nYes, but those same people seem to be unaware or unwilling to take a step into things like (e.g.) Ada and it's SPARK subset/proving tools, which allow you to prove correctness, and thereby eliminate huge swathes of what needs to be tested.", "id": "jbpsjbf", "parent": "t1_jboy5xl", "vote": 5}, {"content": "Yes, dumb people exists.", "id": "jbp0mt6", "parent": "t1_jboy5xl", "vote": 4}, {"content": "People say wrong things all the thing with weird conviction, especially in software development. Pithy absolutist statements are a great way to sell books and YouTube ad time, especially if it's controversial.", "id": "jbricrv", "parent": "t1_jboy5xl", "vote": 1}, {"content": "racket and emacs lisp as well. god i wish guile had a good debugger", "id": "jbqds4d", "parent": "t1_jbp0o5u", "vote": 4}, {"content": "Why is that whenever somebody quote John Carmack it sounds so pragmatic, logical, straightforward but people like Linus or anyone from GNU sphere sounds so dogmatic or just batshit insane.", "id": "jbttz7a", "parent": "t1_jbqypxg", "vote": 3}, {"content": "The best Visual Studio debugger feature that isn't mentioned in the post is this:\n\nWhen stopped at a breakpoint: you can drag the current break location around and either rerun parts of your code, or skip parts!", "id": "jbqfjql", "parent": "t1_jbopl2z", "vote": 13}, {"content": "I like it too but it's very expensive compared to a regular breakpoint, which means that you can't use it in a very hot path", "id": "jbpwylq", "parent": "t1_jbopl2z", "vote": 10}, {"content": "GDB has watchpoints that break on write. Visual studio has data breakpoints. Seems widely supported to me.", "id": "jbs029p", "parent": "t1_jbrt3j4", "vote": 4}, {"content": "If you only need to break when some variable is written, watchpoints or data breakpoints may be enough. ~All debuggers support those (gdb, lldb, visual studio, etc).\n\nWith omniscient debugging you can quickly see all reads and writes across the entire execution and trace the data flow (e.g. where the bad value came from).", "id": "jbs50hk", "parent": "t1_jbrt3j4", "vote": 3}, {"content": "Builders don't argue about tools because they always just use the best tool money can buy. In computer science, the cost of using a better tool is the learning curve. This make it easier to use worse tools that you already know how to use instead of leaning how to use the better tools. \n\nThen people who spent time to learn the better tools complain about the lazy people who keep using worse tools. This is because in computer science (different from builders), everyone still has to use the worse tools if a majority of people are stuck on them.", "id": "jbrr0lq", "parent": "t1_jbqydid", "vote": 3}, {"content": "Are you joking?  Click on any home improvement video on YouTube/TikTok/IG/wherever.  I guarantee you will find countless comments along the lines of \"I'm a [relevant kind of tradesman] and I'd never do this kind of bush-league work.  The right way is...\"", "id": "jbrokrg", "parent": "t1_jbqydid", "vote": 1}, {"content": "IIRC you can use visual studio with unity, no?", "id": "jbrzxqb", "parent": "t1_jbrtjsu", "vote": 4}, {"content": "Time travel is useful when you don't know what you're looking for - e.g. an intermittent corrupt value.  It's easier to just say \"how did this value get here?\" once it's appeared than stop before the corruption if you don't know where the bad path is yet.", "id": "jbx5vc7", "parent": "t1_jbtmezl", "vote": 2}, {"content": "I've used undodb in the past.\n\nMy experience is that I didn't find it particularly useful most of the time, but when it *was* useful it was absolute *magic*.\n\nWhere it shined *most* was in the case of memory errors. Let's say that you're seeing something that \"can't\" happen and suspect one, and that the thing you're seeing is a variable taking on a value that it shouldn't because there are no assignments. Just put a watchpoint on that variable's address and reverse-continue, and you'll land right on whereever that assignment happened. You can then start plopping additional watchpoints as-needed to figure out how *that* variable got its address or whatever.\n\nIt's far from as slick in the video posted by y00fie -- you have to be not just in the debugger but actually recording during the time in question, and that's fairly resource intensive (though *much* less so than the built-in GDB recording) so you don't want to be doing it all the time.\n\nUndodb is a paid product and not a cheap one at that (I have no relationship with them aside from the company I work for being a (potentially-past? not sure if current) customer of them); for something open source, check out Mozilla's `rr`, though I don't have firsthand experience.", "id": "jbppkjn", "parent": "t1_jbopge4", "vote": 35}, {"content": "I've seen GDB reversible debugging demonstrated but never used it myself. Having integration with an editor and the program being debugged really makes these features usable with a lower barrier to entry.", "id": "jbpea52", "parent": "t1_jbopge4", "vote": 12}, {"content": "You are interested in the [rr debugger](https://rr-project.org/)", "id": "jbptp3w", "parent": "t1_jbopge4", "vote": 7}, {"content": "It\u2019s funny I mainly have used debuggers in my hobby of reverse engineering games, not at work.", "id": "jbs1y7s", "parent": "t1_jbowp15", "vote": 2}, {"content": "What you mean by \"the same thing\", of course, is *just part* of *one* of *several* things demoed in Tomorrow Corporation's video.\n\nThere's no recording, there's no time travel, there's no truly-*live* update of the game as the code changes, there's no profiling, there's no profiling based on the recording, etc etc etc....\n\nI've seen *most* of what was demoed in that video in the past, but spread across several different sources, never integrated, and rarely implemented as smoothly as that.", "id": "jbqyfj2", "parent": "t1_jbqrs6k", "vote": 12}, {"content": "Old Notch was such a great guy :(", "id": "jbqyet7", "parent": "t1_jbqrs6k", "vote": 2}, {"content": "Thanks for pointing that out, using an emulator is an interesting approach! How much effort was it to write the emulator compared to the rest of project?\n\nFwiw `rr` can record multithreaded programs too, it was designed for Firefox after all. However it runs all threads on the same core, so there's a slowdown. It also has a [chaos mode](https://robert.ocallahan.org/2016/02/introducing-rr-chaos-mode.html), where it forces the context switches at random moments to trigger race conditions.", "id": "jbpp6k3", "parent": "t1_jbpfwly", "vote": 20}, {"content": "How did you know where to set good breakpoints?  Is it something that involved internal knowledge of your code or could a unit test framework actually come with a standard set of breakpoints?", "id": "jboe3r6", "parent": "t1_jboc1d7", "vote": 2}, {"content": "I dunno about mental overhead. I've seen coworkers struggle for hours in logging hell trying to put print statements everywhere.\n\nI don't get it.", "id": "jbowxqx", "parent": "t1_jbo08lv", "vote": 89}, {"content": "> I think one of the problems with debuggers is that they can require quite a lot of mental overhead to get going with - when you're in trouble, learning a new tool isn't appealing.\n\nWell... I guess it depends on the tech stack you're using. \n\nI mainly program in .net (C# and VB) and Python. Debugging doesn't require any significant \"mental overhead\" with those languages -- I just have to place a breakpoint somewhere and hit F5 in my IDE, and everything works. \n\nI would assume any other popular language offers a similar experience. For instance, I just wrote a small C program using vscode on Ubuntu. I placed a breakpoint and hit F5 like I would do in a Python program. The debugger started without any complication. I was able to step into and over functions, inspect the contents of data structures, change the contents of variables, etc.", "id": "jbowu71", "parent": "t1_jbo08lv", "vote": 23}, {"content": ">they can require quite a lot of mental overhead to get going with\n\nLol what? The only thing you have to do is press the green bug button instead of the green play button lmao. \"But how do set break point?\" You click in the margins of the code. Also everyone learns how to use a debugger in school. It's literally programming 101, it's the first thing they teach you.", "id": "jbq6f2m", "parent": "t1_jbo08lv", "vote": 13}, {"content": "It's possible to study use of debuggers ahead of time. They are a fundamental development tool after all.", "id": "jbp0pgy", "parent": "t1_jbo08lv", "vote": 9}, {"content": "What mental overhead? It\u2019s literally just running your code step by step.", "id": "jboqq12", "parent": "t1_jbo08lv", "vote": 9}, {"content": ">I think one of the problems with debuggers is that they can require quite a lot of mental overhead to get going with - when you're in trouble, learning a new tool isn't appealing.\n\nThat doesn't sound right. Those who can get in trouble but doesn't already know some debugger deserves all the trouble coming their way.", "id": "jbp49sg", "parent": "t1_jbo08lv", "vote": -2}, {"content": "That\u2019s why you just invest time into learning how to use it. If you haven\u2019t already figured out how to use a debugger by the time you are in trouble then you dropped the ball as a professional, if you can even call yourself that. \n\nImagine any other kind of engineer or tradesman just not bothering to learn the most powerful problem solving tools in their discipline.", "id": "jbrpsma", "parent": "t1_jbo08lv", "vote": 1}, {"content": "> gives you a sense of incremental progress\n\nPutting in a good word for something like **PySnooper**:\n\n> Your story: You're trying to figure out why your Python code isn't doing what you think it should be doing. You'd love to use a full-fledged debugger with breakpoints and watches, but you can't be bothered to set one up right now.\n> \n> Most people would use print lines, in strategic locations, some of them showing the values of variables.\n> \n> PySnooper lets you do the same, except instead of carefully crafting the right print lines, you just add one decorator line to the function you're interested in. You'll get a play-by-play log of your function, including which lines ran and when, and exactly when local variables were changed.\n\nhttps://i.imgur.com/9wkhOvp.jpg\n\n\nhttps://github.com/cool-RR/PySnooper", "id": "jbs8m36", "parent": "t1_jbo08lv", "vote": 1}, {"content": "Logging has its own problems, signal-to-noise ratio being a big one. There are also a limit to how many places you can inject logging, meaning a good chunk of bugs will never show up. And logging can affect the behavior of realtime applications, including making the symptoms go away (heisenbugs). For awful race condition bugs, a debugger with hardware breakpoints is the only real tool to use.", "id": "jbsx7sl", "parent": "t1_jbo08lv", "vote": 1}, {"content": "XD, using a computer is also cheating!", "id": "jbqshxq", "parent": "t1_jbqm747", "vote": 8}, {"content": "Sounds like they've never had to debug something multi-threaded.\n\nI *wish* I was being snarky about this one.", "id": "jbs37xx", "parent": "t1_jbqm747", "vote": 1}, {"content": "I disagree. The usually seen debug and trace logging levels really are for situations that arise in the wild where there is no debugger, or when we want to run for a long time and collect detailed info on what went on etc.\n\nSuch logging is present in major products, regularly, for supportability reasons.\n\nAnd it is often not for actual bugs in the product but rather for support during its misuse, bad environment for whatever reasons, broken lower levels, stuff like that.", "id": "jbp5f2o", "parent": "t1_jbp0h4b", "vote": 22}, {"content": "Well, of course logging can be misused. But as others have said, debug is not the only use case of logging.", "id": "jbqs7o0", "parent": "t1_jbp0h4b", "vote": 1}, {"content": "counter counter point: nobody has sufficient automated test coverage, and a seemingly innocuous changes an implicit assumption and now you get a nullref. Error logging might catch the stack, but existing \"happy path\" logging might show you the chain of events that led there.\n\nMaybe this only happens in production with a certain shape of data. Those useless logs may now be priceless. Assuming you aren't logging literal garbage.", "id": "jbrc5ab", "parent": "t1_jbp0h4b", "vote": 1}, {"content": "I like the replay.io concept, which gives you a convenient logging interface to a time travel debugger.", "id": "jbx4d15", "parent": "t1_jbqwb1i", "vote": 1}, {"content": ">They rarely if every run anything optimised\n\nWhat does it even mean?", "id": "jbtu85c", "parent": "t1_jbsiz9d", "vote": 1}, {"content": "Usually when people refer to COBOL 'program', they are referring to a single file.\n\nIt's entirely possible this was a single 21k line **file**.", "id": "jbqx0nf", "parent": "t1_jbqmln5", "vote": 15}, {"content": "Maybe monster sized for NetExpress?  On a mainframe that's not big at all.", "id": "jbqskb1", "parent": "t1_jbqmln5", "vote": 5}, {"content": "I'm not sure what other coding language you're comparing this to, but it was too large. It was a single program with some copylibs for some data division defns. It should have been broken into 4 or 5 programs.", "id": "jbr8e0e", "parent": "t1_jbqmln5", "vote": 3}, {"content": "w.r.t. Linux development, how are longstanding bugs caught if not using a debugger? Is it log statements? If so, one could easily get into a philosophical debate about how complex logging frequently borders on replicating a debugger.", "id": "jbqxhtu", "parent": "t1_jbozkx2", "vote": 4}, {"content": "Wow. I didn't know Linus was an idiot.", "id": "jbp4lbc", "parent": "t1_jbozkx2", "vote": 2}, {"content": "But to prove it's correct, I'd have to actually know what I'm trying to accomplish.", "id": "jbs200a", "parent": "t1_jbpsjbf", "vote": 2}, {"content": "Because Carmack _is_ pragmatic. Always has been, as far as I can tell.", "id": "jbv5pym", "parent": "t1_jbttz7a", "vote": 5}, {"content": "You can also right click and run to pointer. At least in c#", "id": "jbsfoge", "parent": "t1_jbqfjql", "vote": 2}, {"content": "agreed. Good point.", "id": "jbq6jci", "parent": "t1_jbpwylq", "vote": 4}, {"content": "At least you can get the same result by putting a regular breakpoint on a dummy statement inside an if, at the cost or a build/restart cycle. Perf should still be good for all but the hottest paths due to the branch predictor.", "id": "jbs7rlg", "parent": "t1_jbpwylq", "vote": 3}, {"content": "Hi could you explain what \"hot path\" means in this context? Thanks.", "id": "jbsze3r", "parent": "t1_jbpwylq", "vote": 2}, {"content": "I worked on a fast implementation of conditional breakpoints in UDB (https://undo.io/solutions/products/udb/) - a time travel debugger for Linux.\n\nIt uses an interpreter for GDB's trace / breakpoint bytecode.  By evaluating the condition in the program itself you can get thousands of times better performance:\nhttps://youtu.be/gcHcGeeJHSA\n\nSome conditions (like ones that call functions in the debugged process) will still need to be evaluated in the debugger but lots of tests are ridiculously fasts.", "id": "jbx5gdu", "parent": "t1_jbpwylq", "vote": 2}, {"content": "No I\u2019m not. If anything I see that as performative. I don\u2019t know anyone irl who cares. As long as the equipment isn\u2019t falling apart and does the job, that\u2019s good enough.", "id": "jbrrrab", "parent": "t1_jbrokrg", "vote": 1}, {"content": "Not on linux I guess.\n\nYou'd think there'd be something of equal power here too.\n\nBut the visual studio debugger didn't play nicely with unity anyway. At least last I checked that was the case.", "id": "jbs4r65", "parent": "t1_jbrzxqb", "vote": 1}, {"content": "We added the \"last\" command to make that magic flow better: https://docs.undo.io/TrackingValueChanges.html\n\nBasically git blame for memory state.\n\nFor people who've licensed LiveRecorder we'd generally suggest that an automated script just reruns failures with recording, then the developer can pick it up whenever (instead of reproducing under a debugger).\n\nYou could, of course, also do that with rr.", "id": "jbprclg", "parent": "t1_jbppkjn", "vote": 15}, {"content": "The company I work for makes a time travel debugger and a VS Code extension to provide integration https://marketplace.visualstudio.com/items?itemName=Undo.udb\n\nThe integration is getting more sophisticated over time and is pretty cool.  But the ability to hot reload code, graphical debug, etc as in the Tomorrow Corporation demo on arbitrary code needs additional solutions.\n\nIt'd be great to get this kind of thing working in the general case (without needing to be in a particular application) and I reckon eventually someone, somewhere will do that - most of the constituent problems seem to be solved.", "id": "jbpok8q", "parent": "t1_jbpea52", "vote": 11}, {"content": "Every single I've tried to use it, gdb crashed on me.\n\nAnd every time I've mentioned that, I've been told it's much better now and I should give it another try... cue the first sentence.", "id": "jbt234g", "parent": "t1_jbpea52", "vote": 2}, {"content": "Thanks, I'll check it out.", "id": "jbq6ns6", "parent": "t1_jbptp3w", "vote": 1}, {"content": "> Fwiw rr can record multithreaded programs too\n\nGood point! I should have said \"trace multiple threads simultaneously on separate cores\"\n\n> How much effort was it to write the emulator compared to the rest of project?\n\nThe emulator was a pretty big chunk of work, but made easier by the fact that you still have the ability to \"fall back\" on the CPU for rare instructions. E.g. execute them in a single stepping mode (or other ways of isolating a single instruction) and observe the results, which works for most instructions. So we could start with something that emulated 10% of instructions (which would be ~95% of instructions actually executed), and then you get incrementally better performance as you implement emulation for the long tail. So we had something working with many programs in maybe a month, and then I think within 3-4 months we had something with reasonable performance and decent compatibility.", "id": "jbptaz1", "parent": "t1_jbpp6k3", "vote": 16}, {"content": "For unfamiliar code, think of binary searching the code to find the problem. Come up with a question/experiment that cuts the code in roughly half, then break there and see what happened.  Repeat on the next sub problem.\n\nFor unit testing, force the code to exercise all code paths by feeding it good input values and confirming you got coverage. Or force error paths by editing arguments and return values and data structures at runtime.", "id": "jboqem5", "parent": "t1_jboe3r6", "vote": 13}, {"content": "How do you not know it?\n\nYou have a problem at line 103. What do you do? You want to inspect the program state right? Your options are printing things manually or putting a breakpoint on that line so that you can see the data and what the call stack look like before they went downhill.\n\nIf you put the breakpoint after the problem it'll never be triggered, but sometimes you want to put one breakpoint on the bad line and one a bit further down  so that the latter gets triggered *after* you change the bad value *inside the debugger* and continue. If you put it too early you'll have to step through loads of lines, that's useful when you want to see how the entire function or set of functions behave.\n\nThere's no good or bad. The program and your intention tells where the breakpoint should go.", "id": "jbqwhfv", "parent": "t1_jboe3r6", "vote": 5}, {"content": "Let's say for example an API response comes back with a 4xx (I can't remember the code) for invalid payload. I would put a breakpoint right before the function, make sure it's something I am actually expecting to send, it if it, I step into the function and see that the json argument actually means a dictionary and not a string of json so the next time I run the test I retry it with the correct data type. (For typed languages this probably comes up less but it happens for me often enough with python)", "id": "jbowxb6", "parent": "t1_jboe3r6", "vote": 2}, {"content": "Have you read a stacktrace?", "id": "jbsak7r", "parent": "t1_jboe3r6", "vote": 1}, {"content": "That's the flipside - you can get in too deep adding logging.\n\nBut each logging statement is a small addition and probably feels like it *might* help you solve the problem, so it gives you incremental rewards and keeps you in the loop.\n\nI think it's quite difficult to step back from that to switch approach.", "id": "jbpa9wt", "parent": "t1_jbowxqx", "vote": 21}, {"content": "And then they have to undo them too! Just watch it ship with some left in. Print statements are for dummies.", "id": "jbp0deg", "parent": "t1_jbowxqx", "vote": 6}, {"content": "I like debuggers more than print statements. I've seen colleagues struggle with `gdb` in terminal over `ssh`. That's where a lot of mental overhead is. You have to keep a cheatsheet at hand. \n\nI loved such scenarios. Like when a customer is having some glitches, we can't reproduce it at home and we have to do some remote connection and try to repeat it. Sure, we could send them a custom package with tons of additional logger calls. Or we could upload our existing `*-debug` package on their device, launch `gdb`, set up some breakpoints and look precisely what obscure bug did we bake into our app two months prior.\n\nIt's harder to be able to do it with native libraries and apps, but the tooling is there, you just have to learn it. Not everything is debuggable, though (e.g. network protocols, data races across threads), so learn your craft properly and know when to debug and when to use a logger (please don't use naked `printf`, that's lame ;-) ).", "id": "jbpldm7", "parent": "t1_jbowu71", "vote": 6}, {"content": ".net is one of the ecosystems where \"launch with debugger attached\" is the default. Certainly not the only one, but if you come from .net land, the debugger is basically shoved in your face from the get-go.\n\nNot a bad thing, imo. I mostly live in .net land, and I love the debugger.", "id": "jbrasgz", "parent": "t1_jbowu71", "vote": 3}, {"content": "Spot on.\n\nJava, dart, C++ all work exactly the same.\n\nDebuggers are one of the easiest tools to learn to use and help newbies learn how code works.\n\nA debugger is one of the first tools you should learn to use and the tool you start with when debugging. \nYou use logging when you can't find the problem with the debugger.\n\nLogging is often required for code that is time sensitive (threading issues, and some UI problems) and for production diagnostics.\n\nYou should never print to the console.\nUse a logging framework that can be configured at runtime so you can ship it in production.\n\nGood logging frameworks add minimal overhead to production code.\n\nProduction logging is critical for general monitoring and solving issues.\n\nOur support team review production logs on a daily basis and you can deploy automated tools that will trigger an alert on certain logging outputs.\n\nBoth tools are critical components in the Dev lifecycle.", "id": "jbpya13", "parent": "t1_jbowu71", "vote": 9}, {"content": "The pain in starting up can be quite a lot higher depending on the toolchain you're obliged to use - which can just be non negotiable, depending on your circumstances.\n\nBut it's also hard to reason within a debugger for some bugs.  For instance, if you know a corrupt value arrives in a certain function call *eventually* but not when it got corrupted.\n\nIf you need to step through from a known situation to a bug then a debugger is amazing.  But if you can't practically step through all the lines or you don't know where the bug might be it's harder.\n\nIf the program has a long runtime and/or lots of state you can't just step forward inspecting all the state as you go.  It can be a lot of mental work to get breakpoints and stepping sequences in place to start answering your questions.\n\nWhen the control flow between the source of the bug and the actual crash is long and complicated it gets much more attractive to use logging to narrow down approximately where things went weird.", "id": "jbzfsj7", "parent": "t1_jbq6f2m", "vote": 1}, {"content": "whenever I try to step through a react project debugger to see what everything is doing, I always end up stepping into some random package that opens up a bunch of tabs and is super annoying to get out of.", "id": "jbote13", "parent": "t1_jboqq12", "vote": 9}, {"content": "Using a non graphical debugger has a lot of overhead. Ide debugger though? Pretty simple idk", "id": "jbot94k", "parent": "t1_jboqq12", "vote": 9}, {"content": "I'd say the overhead people experience is often around:\n\n * unfamiliar tool - especially if you've only reached for it because you're on a hard problem\n * a workflow switch - you've been coding, probably iteratively whilst getting it to compile and run, now it's something else\n * sometimes you really want an overview of what the program is doing\n\nFor those things, just adding more logging is very tempting: it's just incrementally more coding, it's the workflow you're already in and it does give you a kind of \"narrative view\" of interesting things that have happened in the code.\n\nI'm a big fan of debuggers but there are some legitimate strengths of more primitive tools (at least for some situations) the put people off switching.", "id": "jbp9yu7", "parent": "t1_jboqq12", "vote": 2}, {"content": "Well, like someone else said It depends on the things u are doing, try to debug a c program in connected in SSH with gdb, i think you Will understand XD btw, i don't use gdb in SSH XD but i think can be a pain in the a.s XD", "id": "jbpv4rk", "parent": "t1_jboqq12", "vote": 1}, {"content": "Maybe for the weird vim people?", "id": "jbqzbxr", "parent": "t1_jboqq12", "vote": 1}, {"content": "I've seen a lot of people who don't use the debugger enough for the skills to be fresh - that turns it into a tool of last resort, so it's pulled out for the hardest bugs but not to make other bugs easier.\n\nSome teams have a much stronger culture of debugger use, others hardly use them at all.  I think it depends a lot on what language and environment you're used to as well.", "id": "jbx6rds", "parent": "t1_jbrpsma", "vote": 3}, {"content": "Also, and I acknowledge that this isn't a super common thing, but you simply might not have both a debugger and access to the misbehaving code. Particularly if you are running it on proprietary hardware running a proprietary OS, or if you are running it on custom hardware that might support debugging but the debug interface isn't physically available when the hardware is in use.", "id": "jbq57b2", "parent": "t1_jbp5f2o", "vote": 3}, {"content": "It's certainly the case that logging is useful (e.g. for diagnostic reports, such as when something has already gone wrong), but not to the degree where it substitutes for debugging with breakpoints, arbitrary inspection, etc. using a dedicated tool.", "id": "jbqitrg", "parent": "t1_jbp5f2o", "vote": 1}, {"content": "Native code can be compiled with or without optimisation. Optimised code is harder to debug. And so, this crowd tends to go with non-optimised debug builds.", "id": "jbwr5u2", "parent": "t1_jbtu85c", "vote": 1}, {"content": "21k lines is isn't all that for COBOL. We had to write a process to split programs up because some 50% of our customers had COBOL programs that surpassed the bytecode limit on JVM.", "id": "jbskjii", "parent": "t1_jbqx0nf", "vote": 3}, {"content": "Having worked on COBOL professionally, you are absolutely correct. I've had to deal with even larger single files.", "id": "jbs5ywi", "parent": "t1_jbqx0nf", "vote": 1}, {"content": "Ok, so it looks like the other poster is right, and in your terminology \"program\" is what we'd call a \"source file\" nowadays. Or perhaps even a \"function\".", "id": "jbr96zy", "parent": "t1_jbr8e0e", "vote": 6}, {"content": "Different techniques are better suited for diagnosing different classes of bugs.  If you're trying to hunt down rare race conditions in a kernel, a debugger would not be the tool of choice.", "id": "jbps8uk", "parent": "t1_jbp4lbc", "vote": 16}, {"content": "Can't take away from his accomplishments but I would certainly not want to deal with working with him.", "id": "jbro7sn", "parent": "t1_jbp4lbc", "vote": 1}, {"content": "If you don't know what you're trying to accomplish, how can you say whether or not you've failed?\n\nIOW, if **THAT** is your problem, you shouldn't be touching the program at all.", "id": "jc0p01d", "parent": "t1_jbs200a", "vote": 1}, {"content": "By hot path I meant a section of code that needs to run a \"high\" number of times per second. And how much \"high\" is depends on a number of things related to your particular case, such as the hardware, the rest of the program, what you're trying to achieve, etc.", "id": "jbt03kl", "parent": "t1_jbsze3r", "vote": 3}, {"content": "Performative posturing?  On an Internet forum?  In a way that would be embarrassing IRL?  yeah sounds unfamiliar", "id": "jbrwwaf", "parent": "t1_jbrrrab", "vote": 1}, {"content": "> We added the \"last\" command to make that magic flow better: https://docs.undo.io/TrackingValueChanges.html\n\nNifty! I'm not surprised you added a shortcut given how useful that operation is.\n\nIt's been ages since I've used it, personally; I moved projects years ago and have done unfortunately little in compiled languages since before then. So it's not surprising I was out of date (and that's also why I'm not sure if we've been keeping up to date).", "id": "jbpssva", "parent": "t1_jbprclg", "vote": 3}, {"content": "Yes unfortunately when I inquired about it a  few years ago it cost $50k. Has that changed?", "id": "jbptq3u", "parent": "t1_jbpok8q", "vote": 7}, {"content": "Hot reload requires some cooperation from the application. This works best for games which have a conventional \"main loop\" model, and a separation between game and engine. This means that there is A) a clean interface break where the game code can be a dynamic library, swapped out while the engine is running, and B) a clear point in the loop where the game is completely stopped between frames, and a different implementation can be brought in and invoked with the existing game state.\n\nAlso the game knows that is this concept of \"game state\" and \"game binary\", and can store a buffer of previous game states and the version of the binary they were run with, allowing them to be recalled repeatedly, or re-run with different binaries.\n\nI don't think any of these tools work with changes that would change the memory layout.", "id": "jbq8og2", "parent": "t1_jbpok8q", "vote": 3}, {"content": "Is there anything unusual about your environment?\n\nI've generally found GDB stable but at undo.io we usually end up making or backporting some fixes to the version we ship.\n\nI've seen a few issues over time and the weirdest one was a buggy compiler generating a C++ mangled name that expanded infinitely - it caused a segfault in GDB because it trusted the compiler not to do that.  Wah!", "id": "jbx64an", "parent": "t1_jbt234g", "vote": 3}, {"content": "That makes sense - especially in the general case of debugging an application fault.\n\nBut in the case of unit testing it also feels like there should be some routinely set breakpoints that could be automated, if we can assume a certain fault finding workflow.\n\nE.g. you might also want entry to and exit from each test case, after each input value is generated, when key assertions are checked, etc.\n\nIt'd be nice if a test framework could just pop those in place when you're investigating a specific test.", "id": "jbzemcn", "parent": "t1_jbqwhfv", "vote": 1}, {"content": "The trouble is that the stack doesn't always have the information you need.\n\nFor instance, you could have crashed due to a data corruption that happened much earlier in execution, in a function that's no longer on the stack.", "id": "jbze0el", "parent": "t1_jbsak7r", "vote": 2}, {"content": "And log too much, and now you are drowning in irrelevant logs. Your signal to noise ratio takes a shit.\n\nEffective logging is an art, just like effective use of a debugger.", "id": "jbra8ja", "parent": "t1_jbpa9wt", "vote": 9}, {"content": "[deleted]", "id": "jbp8qa9", "parent": "t1_jbp0deg", "vote": 1}, {"content": ">And then they have to undo them too! Just watch it ship with some left in. Print statements are for dummies.\n\nI mean, isn't that what a debugging-level type would be for?\n\n    Type Debug_Class is (Tracking, Message, Inspection, ETC);\n    \n    \n    Package Debugging is\n    \n       Generic\n         Context : In Debug_Level;\n         Message : In String;\n       Procedure Static_Message;\n    \n      Generic\n         Type Element(<>) is limited private;\n         with Image(Object : In Element) return String;\n      Procedure Value_Inspection(Value : In Element);\n    \n      -- other debugging items...\n    \n    Private\n      Type Debugging is array(Debug_Class) of Boolean\n        with Component_Size => 1;\n      Type State( Debug : Boolean := FALSE ) is record\n        case Debug is\n          when False => Null;\n          when True  => Levels : Debugging:= (Others => TRUE );\n        end case;\n      end record;\n    \n      Current : Constant State:= (Debug => True, \n          Levels => (Inspection => True, others => False)\n        ); -- We're only inspecting values right now...\n    End Debugging;\n    \n    \n    Package Body Debugging is\n      Procedure Static_Message is\n      Begin\n        -- First check debugging is on, then check if our context is \n        -- in the active levels, if so then print the message.\n        if Current.Debug and then Current.Levels(Context) then\n          Ada.Text_IO.Put_Line( Message );\n        end if; \n      End Static_Message;\n    \n      Procedure Value_Inspection(Value : In Element) is\n        -- Inspecting a value is an instance of a static-message,\n        -- with the image of the value as the message.\n        Procedure Print_Value is new Static_Message(\n            Context => Inspection,\n            Message => Image(Value)\n          );\n      Begin\n        Print_Value;\n      End Value_Inspection;\n    End Debugging;", "id": "jbpocne", "parent": "t1_jbp0deg", "vote": -5}, {"content": ">I've seen colleagues struggle with gdb in terminal over ssh.\n\nNo sane individual would ever use a debugger through a CLI. You'd have to be a die hard CLI purist to put yourself through that. It's why I only use IDEs.", "id": "jbq6r6h", "parent": "t1_jbpldm7", "vote": -5}, {"content": "> the debugger is basically shoved in your face from the get-go.\n\nThank God!\n\nI used to program in VB5 and the debugging experience was good too, despite the language itself being depressingly bad.", "id": "jbrbzny", "parent": "t1_jbrasgz", "vote": 2}, {"content": "\\> Both tools are critical components in the Dev lifecycle.\n\nIt's hard to imagine somebody who disagrees. And yet, people do.", "id": "jbrazfj", "parent": "t1_jbpya13", "vote": 1}, {"content": "Depends on the IDE. Some IDEs are better than others", "id": "jbq6y3d", "parent": "t1_jbote13", "vote": 2}, {"content": "This is a configuration issue. If your IDE doesn't have an option to get rid of this kind of thing... time for a new IDE.\n\nSeriously. 500 bucks for some license for a proper IDE is going to be cheaper than you wasting time fighting with this BS.", "id": "jbrb93r", "parent": "t1_jbote13", "vote": 1}, {"content": "Why switch? Just do both. Logging vs debuggers is a total false dichotomy.", "id": "jbrbg9w", "parent": "t1_jbp9yu7", "vote": 2}, {"content": "A lot of people, I believe, think it's not possible to compile with optimization and debug information.  But you do get a better experience from lower optimization levels, as you say.\n\nI find C++ particularly confusing to debug because it tends to have a lot of lines of code that disappear completely with optimization - and lots of inline code, which is a bit harder for a debugger to represent (you can easily end up with three different function calls all corresponding to the same single instruction).\n\nGCC has introduced -Og which specifically compiles for debugging whilst not running too slowly.  Clang supports it but as a synonym for -O1.\n\nFor debugging optimized code I think it can help to concentrate on global state and function entry/exit points.", "id": "jbx7i3m", "parent": "t1_jbwr5u2", "vote": 1}, {"content": "Yeah, but saying you shouldn't use a debugger because it will make you less careful, and therefore write worse code, is like saying you shouldn't write an operating system in C instead of assembly because it will it will make you less careful, and therefore write worse code, but there Linus goes throwing caution to the wind and carelessly writing an OS is C like some sort of adrenalin junky trust fund baby.", "id": "jbqnxup", "parent": "t1_jbps8uk", "vote": 20}, {"content": "Yeah, isn't is great working in a giant corporation?", "id": "jc0yjmm", "parent": "t1_jc0p01d", "vote": 1}, {"content": "Yes, that makes total sense.\n\n\"last\" is even a bit more clever than just a shortcut in practice because:\n\n * It catches when the memory got allocated or freed\n * It automatically watches a memory location underlying the expression you typed (like \"watch -l\") which is more usually what you want\n\nSo it's watch + rc + just do what I mean.\n\nI'm glad you've got positive memories of us - if you ever do native or Java development in future please get in touch.  I'd love us to add a JS or python product one day but that'll be a way off...  For JS there's also the awesome replay.io", "id": "jbygkjs", "parent": "t1_jbpssva", "vote": 3}, {"content": "Looks like the annual individual license cost for UDB is $1800, from their website. Not an absurd cost for a professional tool, considering the potential for time savings.", "id": "jbroz1b", "parent": "t1_jbptq3u", "vote": 5}, {"content": "That's generally true for native code or compiled languages. In lisps, hot reloading can generally be implemented as a simple code stub. Although application cooperation does make things much easier. For example, favor pure functions over closures with hidden state. (Closures can become stale)", "id": "jbswa31", "parent": "t1_jbq8og2", "vote": 1}, {"content": "I tend to use cutting edge compilers, and I've had numerous issues with demangling symbols indeed -- where the compiler generates a symbol that the demangling library doesn't handle well. This indeed causes its own share of crashes in `gdb`, though it's more an issue of the demangling library being up-to-date (or not).\n\nI've also had multiple codegen bugs. Nasty to figure out, though `gdb` has no issues with those.\n\nAnd finally, I tend to work on multi-threaded programs, for which \"going backward\" in time may be a _wee_ bit more complicated than usual.\n\nSo I guess a combination of new compiler/standard library + multi-threading tends to hit gdb where it hurts.", "id": "jbxl33z", "parent": "t1_jbx64an", "vote": 1}, {"content": "> Effective logging is an art, just like effective use of a debugger.  \n  \nAbsolutely this.  Logging is most needed around pain points, and if you're lucky you might get to remove some of it in due time.  But if you are trying to log too much you might actually be exacerbating problem discovery and even the problem itself in some environments.", "id": "jbrfl09", "parent": "t1_jbra8ja", "vote": 1}, {"content": "O'Reilly will surely publish that book ;)", "id": "jbskavb", "parent": "t1_jbra8ja", "vote": 1}, {"content": "Uhh yeah, proper logging is one thing - dumping arbitrary sections of random objects and other variables to the console and shipping that is another", "id": "jbpfrf8", "parent": "t1_jbp8qa9", "vote": 7}, {"content": "Logging is not print statements my dude.", "id": "jbptb3z", "parent": "t1_jbp8qa9", "vote": 0}, {"content": "What about when the problem only occurs in an environment that you can\u2019t connect your IDE to?", "id": "jbqhm2r", "parent": "t1_jbq6r6h", "vote": 7}, {"content": "People make these same silly arguments about using an IDE.", "id": "jbrntr3", "parent": "t1_jbqnxup", "vote": 3}, {"content": "Sure, but *that* gives you the position to push on: \"*Give me the requirements and specifications, written in such a way as to be attainable.*\"", "id": "jc2shxl", "parent": "t1_jc0yjmm", "vote": 1}, {"content": "We also offer an academic license programme and potentially licenses for open source use, you should get in touch if this applies.", "id": "jbvlizk", "parent": "t1_jbroz1b", "vote": 2}, {"content": "Ah yes, that does make sense!  I've been a bit disappointed by how crashy demangling seems to be - to the extent that GDB registers a special SIGSEGV handler before calling into it so that it can point the finger at that code specifically.\n\nI'd say time travel debugging is great for multithreaded programs though - capturing a race condition and being able to step through at instruction level is very powerful.\n\nThe main exception is where you generally have cache incoherency issues to debug e.g. you're on ARM and potentially doing something rather subtle.", "id": "jbyg2m9", "parent": "t1_jbxl33z", "vote": 2}, {"content": "> ...and shipping that is another\n\nOf course, \"the code exists\" does not necessarily lead to \"shipping that.\"\n\nThe best debugging experience I've had on complex software was based on some pretty extensive trace logging we had. \"Extensive\" in this context means a mid-sized run would produce a few hundred MB of logs, if memory serves.\n\nBut both because of the size of the produced logs and not really wanting to give access to them, not only did you have to enable logging at runtime but you had to build it into the product at compile time in the first place. Actual shipping versions had that logging compiled out.\n\nOf course, how you do this will be dependent on your language. If you have conditional compilation it's easy-peasy, but I assume if you're shipping software in JS or whatever there are ways to specify things that should be removed during packaging (I just don't know what those ways are).", "id": "jbps98o", "parent": "t1_jbpfrf8", "vote": 3}, {"content": "you can do remote debugging", "id": "jbqjopw", "parent": "t1_jbqhm2r", "vote": 8}, {"content": "There are loggers even in js, Just don't use console.print,you can set a log level and you are good to go :)\nNever Heard about pino? XD every time i read of \"pino the logger\" i start laught XD", "id": "jbpumvq", "parent": "t1_jbps98o", "vote": 1}, {"content": "> There are loggers even in js, Just don't use console.print,you can set a log level and you are good to go\n\nThere are a couple issues with this, because you might not want it compiled into your software at *all*. You might not want clients to be able to change the log level and start dumping tons of stuff for example... but the bigger problem is that you might want to log information that takes a while to compute.\n\nAnd even if `log(an_expensive_query())` doesn't actually log anything, it'll still run `an_expensive_query()` -- and you don't necessarily want that to happen in production. That's where compiling it out, or somehow removing it, entirely is important.\n\n(I guess you could get around this with lambdas -- `log(() => an_expensive_query())` -- where the logging library automatically calls anything passed in that's a callable to get the actual value to log. But this is a pretty obnoxious API IMO, and I'm a little skeptical that this is anything approaching a common feature.)", "id": "jbpxklw", "parent": "t1_jbpumvq", "vote": 2}, {"content": "Yeah i can see the point , but i think that in most simple cases a log level can be good enouth:) btw...i use the debugger XD", "id": "jbq4pkz", "parent": "t1_jbpxklw", "vote": 1}, {"content": "If your app does not make use of expensive_expression, there is very little point of of logging it.\n\nYou log stuff from which you deduce the state of your program at that point in time. Anything expensive can be run after. He'll, time travelling debuggers are nothing but very verbose loggers that can reconstruct the full state of the execution.\n\nLogging is your only resort in some cases, so you always have to account for logging in your design. Bugs that occur during development are usually the low hanging fruits that you can repro easily and understand how they come about. Any mature system however have Bugs \ud83d\udc1b that cannot be easily reproduced, intem8ttent and you have no idea what interaction with other system might have caused it. Time travelling can only work for limited amount of time and you must pay for it dearly in your runtime environment.\n\nEventually, you are left with logging as the long running service from which all debugging will orginate from.", "id": "jbsl0zy", "parent": "t1_jbpxklw", "vote": 1}], "link": "https://www.reddit.com/r/programming/comments/11nmccf/what_a_good_debugger_can_do/", "question": {"context": "", "id": "11nmccf", "title": "What a good debugger can do"}, "resource": "Reddit"}, {"answers": [{"content": "It sounds like you want a debugger? The industry standard tools for Windows are windbg and ida. Both are intimidating though without a tutor.\n\n I'd recommend downloading x64dbg, and stepping through your code, it will show you the stack and what the CPU actually does before your main code, when you make library calls etc. A little bit of reverse engineering skill is something every software engineer should have.", "id": "hps4rqp", "parent": "t3_rnfrtx", "vote": 12}, {"content": "You can step debug in vscode. It does require some setup, not a lot iirc", "id": "hpsbb3b", "parent": "t3_rnfrtx", "vote": 6}, {"content": "I'm also very interested in this. I couldn't find an interactive tool, but here is a cool video https://youtu.be/rDoqT-a6UFg", "id": "j3zy20q", "parent": "t3_rnfrtx", "vote": 1}, {"content": "FWIW, I would add GDB to the list as standard everywhere else", "id": "hpuv2pu", "parent": "t1_hps4rqp", "vote": 5}, {"content": "Oh man, x64dbg and reverse engineering look very intimidating after giving it a quick google search. \n\nI guess I just wanted a simple website/tool where I can simply paste my code in and an easy-to-follow visual style, like in the website Python Tutor does for c/c++, know what my code is doing one step at a time. I hope you understand what I am referring to as English is not my native tongue.", "id": "hps8wbc", "parent": "t1_hps4rqp", "vote": 3}, {"content": "Is this what you would recommend for Linux users as well?", "id": "hpswbh5", "parent": "t1_hps4rqp", "vote": 1}, {"content": "Yea, I'd suggest vs code + rust-analyzer", "id": "hpt0oel", "parent": "t1_hpsbb3b", "vote": 4}, {"content": "Sounds good, I'll check it out!", "id": "hpscaig", "parent": "t1_hpsbb3b", "vote": 1}, {"content": "I understand, the term you want to Google is probably 'source level debugging' for rust.\n\nI would still recommend you give x64dbg a go. The process/things to Google would be;\n\nCompile code to a binary file.\n\nOpen binary file in x64dbg.\n\nNavigate to your main function (this can be tricky).\n\nSet a breakpoint.\n\nRun the program!\n\nNow you can single-step each line of your code.\n\nIf you compile using the debug (default) cargo settings, you'll have all the function and many of the variable names available to you. \n\nThis really really is something worth learning. It's the best way to understand your program, it's called a debugger for a reason!", "id": "hpsn3w9", "parent": "t1_hps8wbc", "vote": 5}, {"content": "For Linux, you're sort of stuck with gdb for debugging. So you'll end up leaning more heavily on analysis tools like IDA for a broader view of the binary.", "id": "hptmo19", "parent": "t1_hpswbh5", "vote": 2}, {"content": "Just install C/C++ extension from Microsoft, it would suffice to debug step-by-step.\n\nHowever, I still sometimes use debugger from Visual Studio because it allows to easily switch between source code and ASM.", "id": "hpsrybs", "parent": "t1_hpscaig", "vote": 3}], "link": "https://www.reddit.com/r/learnrust/comments/rnfrtx/is_there_a_website_where_i_can_visualize_code/", "question": {"context": "Earlier today, I stumbled upon a website named [Python Tutor](https://pythontutor.com/) that would visualize code execution for python, java, c, c++, and some others except for Rust.\n\n&#x200B;\n\nI come from knowing just some python, so the concepts of memory, especially stack and heap, are pretty new to me, but being able to visualize this during code execution would help tremendously in understanding how I'm manipulating data and what not using Rust.\n\n&#x200B;\n\nAny website you guys would know of that's similar but for Rust? I would appreciate it greatly.", "id": "rnfrtx", "title": "Is there a website where I can visualize code execution for Rust?"}, "resource": "Reddit"}, {"answers": [{"content": "Have a look at [dap-mode](https://github.com/emacs-lsp/dap-mode). It\u2019s based on language servers and hence requires [lsp-mode](https://github.com/emacs-lsp/lsp-mode), but you would probably want to use that regardless.\n\nThe only thing I\u2019d say is that dap-mode is still a bit rough around the edges compared to VSCode\u2019s debug UI, but it is getting better and better as time goes by.\n\nAnd of course as others have mentioned there\u2019s also gud/gdb, but I\u2019m not that familiar with that approach myself.", "id": "gwr840u", "parent": "t3_n3p01c", "vote": 21}, {"content": "You are considering good. For C++ i suggest you three plugins: lsp-mode wich has a very good guide on how to setup c++ completition and syntax checking and enhanced highlighting with clangd without the needing of a compilation database, yasnippet for the snippets theirselves, company-mode for displaying the code completition provided by lsp-mode + snippets.\n\nP.S. If company-mode results slow on showing results it\u2019s possible to remove the delay to achieve vscode like code completition experience.\n\nP.P.S. All three plugins need a little bit of configuration which can be found in docs or in guides and to be put in .emacs\n\nHope this helps.", "id": "gwrcgvj", "parent": "t3_n3p01c", "vote": 10}, {"content": "Emacs has a debugging interface called GUD which can be used with GDB. LSP-mode supports the DAP protocol. I haven't used them really but I know of them so I just give them a mention.\n\nEDIT: Grammar", "id": "gwr3ejd", "parent": "t3_n3p01c", "vote": 19}, {"content": "I've written my setup to debug python with poetry and pytest on [this post](https://www.reddit.com/r/emacs/comments/mwvjlw/debugging_experience_in_emacs/gvm1dmx?utm_source=share&utm_medium=web2x&context=3).", "id": "gwrgtyr", "parent": "t3_n3p01c", "vote": 6}, {"content": "Like everyone has pointed out, you can use gdb with gud-mode. But, I'd switched to clang a few years ago, and, after using lldb from the command line for a while, I recently bit the bullet and switched to lldb and dap-mode.\n\nI think you'll have to weigh some things: gud-mode/gdb is easy and should just work. But,  clang has all the other tools that will make emacs feel like your old IDE. It was pretty hard for me to set up, but maybe I was just missing something. I ended up starting from scratch with my emacs configuration. (I definitely need to clean up the cruft, but I had to take a productivity hit for a little while.)", "id": "gwr78n2", "parent": "t3_n3p01c", "vote": 4}, {"content": "I use the DOOM emacs framework instead of spacemacs. I would say C++ debugging works great, no problems with it. However, I\u2019ve found that debugging python in emacs does not work well. I usually code in emacs and then use PyCharm community for debugging because I really like their debugger.", "id": "gwrnj7c", "parent": "t3_n3p01c", "vote": 5}, {"content": "Yes, Emacs has very good integration with GDB, you set breakpoints, top, step over etc with either keyboard shortcuts or mouse. Here is an example: https://www.youtube.com/watch?v=aNTFDq3e2Qo and here is one of the tutorials https://undo.io/resources/gdb-watchpoint/using-gdb-emacs/", "id": "gwr3hfj", "parent": "t3_n3p01c", "vote": 8}, {"content": "I love emacs, but they're really not comparable for debugging. lsp has bought them much closer for big code base inspection though.  dap is a work in progress and can be hard to set up properly unless you're an emacs whizz as a quick google will confirm. People talk about gub/gdb but, well, meh - most haven't used vscode. It works for C quite well, but that's about it but the benefit is that you're still in emacs.", "id": "gwr7yhs", "parent": "t3_n3p01c", "vote": 7}, {"content": "I\u2019m going to suggest something that you might not have considered or simply don\u2019t want to do, but it\u2019s worth exploring:\n\nUse emacs for editing and use a debugger that you prefer for debugging. If that\u2019s visual studio, or GDB directly, or something like JetBrains solutions. Sure now you have two programs open but this is the workflow that I use and I can\u2019t imagine trying to shoehorn debugging workflow into emacs.", "id": "gwth34a", "parent": "t3_n3p01c", "vote": 2}, {"content": "GDB integration is easier to set up. DAP is for LSP, meaning you will get roughly the same feature set as you would on VSCode. GDB mode really is better.", "id": "gwr66hj", "parent": "t3_n3p01c", "vote": 2}, {"content": "Emacs not IDE, Emacs is a extremely programmable editor. Using any editor as IDE is pain in the ass and time wasting.", "id": "gwryioz", "parent": "t3_n3p01c", "vote": -14}, {"content": "Why are you considering to switch if it works for you?", "id": "gwrpjim", "parent": "t3_n3p01c", "vote": 1}, {"content": "Cannot really comment on C++ debugging, as I rarely need it. And when I do, it' usually doesn't work because of weird bits of the program being debugged.\n\nAs for Python... there's no good way to debug it. I mean, `pdb` is pathetic pile of garbage. When it comes to Python programs that use threads / processes, `pdb` simply doesn't work. You need to connect to a running Python process: `pdb` isn't going to do anything for you.\n\nSometimes, I actually debug Python code with `gdb`. It's painfully inconvenient, but, sometimes, there just isn't another way.\n\nEven though I use Emacs for everything, I never got around to learn how to use GUD efficiently. Sometimes, at random, Emacs somehow identifies that I'm debugging a Python module that is currently open for editing. I don't really know how it knows that, and then I get visualized breakpoints and other relevant information... but, honestly, I rarely need that. It's always something very specific that I'm after, and I know most of the time what I'm looking for, if I'm going for debugger, so the multiple frames with all this extra information are usually just an annoyance.\n\nAnyways, I haven't seen anything in Emacs that would do for C++ what SLIME does for Common Lisp in terms of debugging. Though, I've never used / needed advanced debugging for C++... so, maybe I just don't know.", "id": "gwwkk6k", "parent": "t3_n3p01c", "vote": 1}, {"content": "Thanks for the suggestion. I have experience with lsp-mode so I think setting up dap-mode wouldn\u2019t be too tedious. What are the limitations of dap-mode? Does it show values for inline variables and the call stack?", "id": "gwsmdwz", "parent": "t1_gwr840u", "vote": 3}, {"content": "Yas-snippet allows for easy multi-line snippets. In VS-Code you have to make it an array of strings. One advantage to Emacs.", "id": "gwrxzku", "parent": "t1_gwrcgvj", "vote": 4}, {"content": "I've used GUD for years.  it works great.  It even works with Delve (AKA dlv), the Golang debugger.  \n\nGUD along with M-x compile -- the original IDE", "id": "gwuhgdh", "parent": "t1_gwr3ejd", "vote": 2}, {"content": "What clang tools do you mean? I use clangd for my lsp ls but I'm not sure what you mean about clang bringing things t the table that are like other IDEs. Do you mean it's language server facilities? in which case, yes but there are also other option(s) - ccls for example for C++/C.  Im impressed you've moved to dap for debugging - it's a great initiative but I find its inspection UI very hard to use. Possibly time to re-investigate. But all that aside, vscode is a much better env for debugging for now - minus the obvious benefits of using gud/gdb within the emacs mother ship.", "id": "gwr888g", "parent": "t1_gwr78n2", "vote": 2}, {"content": "In the context of switching from VS Code, I'd also suggest considering Doom Emacs. It's a bit more opinionated which helped me quite a lot in the same situation. The amount of flexibility Emacs comes with can be initially a bit paralyzing.", "id": "gws93qe", "parent": "t1_gwrnj7c", "vote": 6}, {"content": "I haven't worked with dap much yet but, in my experience, both c and c++ work really well using the LSP. Just make sure you have generated yiur compile commands file using compiledb or bear", "id": "gwyektf", "parent": "t1_gwr7yhs", "vote": 1}, {"content": "There are some annoying limitations in VS Code that while are not deal breakers, I would like to find a way to get around.\n\nIf Emacs offers me the same feature set without the inconveniences, then I want to switch.\n\nThere\u2019s also the fact that typing in Emacs is more efficient. \n\nHowever if it turns out that I can\u2019t get the same level of debugging on Emacs, I might just write plugins for VS CODE. Still have to get through all these comments.", "id": "gwskvb5", "parent": "t1_gwrpjim", "vote": 1}, {"content": "Check: https://www.youtube.com/watch?v=0bilcQVSlbM \nAnd: https://emacs-lsp.github.io/lsp-mode/tutorials/CPP-guide/\n\nGenerally, everything that is possible with vscode but not possible with dap-mode is considered a bug. At this point, most of the issues are related to the installation because dap-mode does not have good feedback when something is missing. For example, for some adapters you need nodejs but if you don't have the debug adapter will crash after the debug session startup. You can see that you don't have nodejs in the stderr buffer but it is a poor user experience overall. We are working on fixing this.", "id": "gwsu2iz", "parent": "t1_gwsmdwz", "vote": 7}, {"content": "I agree. I'm still getting used to dap-mode's UI. But, maybe I've just been using gud-mode for way too long.\n\nHmm... for clang tooling, I just mainly just thinking of clangd. But, I guess it'd be clangd, lldb-vscode and bear. It looks like I installed ccls from source, which isn't the most user friendly installation. Although, it wouldn't take any convincing to tell me that getting dap-mode working is much harder than building ccls from source.", "id": "gwragxa", "parent": "t1_gwr888g", "vote": 3}, {"content": "Yup, agreed. Doom also has the benefit of being much, much faster than spacemacs.", "id": "gws9gdg", "parent": "t1_gws93qe", "vote": 3}], "link": "https://www.reddit.com/r/emacs/comments/n3p01c/switching_from_vs_code_to_emacs/", "question": {"context": "I am considering making the switch from VS Code to Emacs (Spacemacs distribution). I have used it before but stopped due to inconvenient debugging.\n\nI have an automated setup in vs code with extensions/tools to automate various pre-compilation and post-running tasks. I know all of that can be done in Emacs. The only thing I need to verify before switching is that I am able to maintain the same debugging flow I have in VS Code.\n\nI only code in C++ and sometimes in Python. My question is:\n\nIs there a way to debug code visually? I want to be able to set breakpoints, stop, step over, step in/out etc.. it needs to be visual to be efficient. I want to be able to view the values of all the variables that are in scope of the breakpoint and the call stack at the same time. This is a very important part of my flow and cannot compromise on it.\n\nIs there a way to do this in Emacs (existing package) ? This is the only thing in the way for me. If it is doable, can someone point me to an example? I use clang for C++ but am willing to switch to gdb if necessary. I code on macOS.\n\nThanks in advance.", "id": "n3p01c", "title": "Switching from VS Code to Emacs"}, "resource": "Reddit"}, {"answers": [{"content": "On July 1st, a [change to Reddit's API pricing](https://www.reddit.com/r/reddit/comments/12qwagm/an_update_regarding_reddits_api/) will come into effect. [Several developers](https://www.reddit.com/r/redditisfun/comments/144gmfq/rif_will_shut_down_on_june_30_2023_in_response_to/) of commercial third-party apps have announced that this change will compel them to shut down their apps. At least [one accessibility-focused non-commercial third party app](https://www.reddit.com/r/DystopiaForReddit/comments/145e9sk/update_dystopia_will_continue_operating_for_free/) will continue to be available free of charge.\n\nIf you want to express your strong disagreement with the API pricing change or with Reddit's response to the backlash, you may want to consider the following options:\n\n1. Limiting your involvement with Reddit, or\n2. Temporarily refraining from using Reddit\n3. Cancelling your subscription of Reddit Premium\n\nas a way to voice your protest.\n\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/learnprogramming) if you have any questions or concerns.*", "id": "k946wo6", "parent": "t3_17uk2qd", "vote": 1}, {"content": ">Is it just a matter of experience?\n\nYes.\n\nA lot of debugging is recognizing patterns you've seen before -- and if you haven't seen much, that's going to be tough.\n\nAlso, learn to use the debugger for whatever language you are using.", "id": "k94a7de", "parent": "t3_17uk2qd", "vote": 10}, {"content": "Learn to use your debugger, you'll need to learn what error messages mean, over time you learn strategies and develop instinct for what might be wrong. \n\nIn the beginning I just used print statements, then learned to use the debugger, then would 'binary search' debug - basically narrow down where the bug might be. \n\nThe debugger is extremely useful, you can see exactly what data the running program has.", "id": "k94r27n", "parent": "t3_17uk2qd", "vote": 4}, {"content": "To debug broken code, you really need to be familiar with working code, so here's an exercise that can help with that:\n\nFind an open source project in your stack and set it up the way the readme says. Then set yourself a breakpoint on the first line of the entry point.\n\nOnce you're paused on that breakpoint in your IDE, and you establish that you can step forward, step into, step out of, and can inspect global and scoped variables... Go get yourself some snacks and some drinks, and hunker down for the next few hours while you step through the code, and learn the execution flow of the whole project. From bootstrap to framework to application.\n\nDo this as many times as you can bear to do it for as many consecutive days as you can bear to do it, and in a month or two you'll start to condition yourself to see what the author intended, but maybe where they fell short on implementation, and that's where the bugs always are.", "id": "k95750k", "parent": "t3_17uk2qd", "vote": 4}, {"content": "Whether or not it makes sense to \u201clearn OS\u201d (which in this context I would guess means Bash? I know Mac is *nix but I\u2019m not and never will be a Mac user) depends on what direction you want to go with programming. \n\nMy advice to you is to get your feet under you with a high-level language like python which has a good, reliable debugger. See if you can read the error messages your code gives you and understand what that error is trying to communicate, and have a crack at solving it without stackexchange (set a 30 minute timer. If at the end of 30 minutes you\u2019re still stuck, then go for it). This is easier in some languages than others. You\u2019ll learn what parts of the error message are helpful and what parts are less helpful.", "id": "k94qsdm", "parent": "t3_17uk2qd", "vote": 3}, {"content": "I do a lot of brainstorming when I debug. I ask myself a lot of questions (and Google). What am I trying to achieve? What is my input and what am I expecting to happen/output? What am I actually getting? That sort of thing. I use a lot of console.log of values and when things are executing too.", "id": "k95444u", "parent": "t3_17uk2qd", "vote": 2}, {"content": "Learn to use your debugger, most compilers for most languages and most interpreted languages come with a debugger, a debugger allows you to step through the program, and to set flags for program execution to stop so you can see what your variables are doing, 5 minutes of using a debugger is worth an hour of doing `print(\"here\")` statements. Also there is more to debugging that working through syntax and or program flow, you can also use what is called a profiler to check for memory leaks, and to optimize.  \n\nHonestly if you learn to get good at debugging it will one make you a better programmer, and two it leads quite nicely into learning about how to optimize code.  \n\nAnother way to get good at debugging is to go bug hunting, if you have an open source project you use for something see if you can one recreate a bug from the issues page of the repo, and two if you can identify what is causing it and 3 attempt to fix it. If you can great make a pull request if not no biggie.  \n\nI personally learned to debug by helping my classmates when they would encounter bugs they couldn't solve.", "id": "k94rgj0", "parent": "t3_17uk2qd", "vote": 4}, {"content": "You need to have a (much) better mental model of how your code is executing. It\u2019s not a matter of experience (though more experience can make the process faster). It\u2019s a matter of critical thinking.", "id": "k95201r", "parent": "t3_17uk2qd", "vote": 2}, {"content": "Like any skill, the only way to get good at debugging is to keep practicing at it.\n\nIn general, here's how you should debug:\n- Check for any compiler/runtime errors, and check the relevant code. Fix any errors there.\n- If there are none, break down your program into testable segments (usually functions) and check the input/output of them. Make changes as necessary.\n- Repeat steps until program works.", "id": "k951gvr", "parent": "t3_17uk2qd", "vote": 1}, {"content": "What type of application are you working on (iOS app? Website? Machine Learning?)? What language are you working in? These kinds of details will help us help you get the info you need.\n\n\nLearning about \"the OS\" could be interesting, but I don't think it'll provide you what you're looking for. OSs are a relatively solved problem, and unless you are developing an OS yourself, you probably don't need a deep understanding of them to do normal app development.\n\n\nOn the flip side, learning how to use the \"command line interface\" (CLI) could be very helpful, since console apps and executables started with parameters are the foundation of starting/running apps. But the command line is not the operating system. It is a text-based tool to start programs/issue commands.\n\n\nDebugging tutorial (for python, but concepts apply to all programming): https://youtu.be/7qZBwhSlfOo?si=ogj6YB3e5Lbk0LMh", "id": "k96dxtb", "parent": "t3_17uk2qd", "vote": 1}, {"content": ">Is it just a matter of experience?\n\nYes. Learn to use the debugger (placing breakpoints, looking at values, going through execution step-by-step and look at values changing) and understand error messages for starters, and after a while you will develop strategies to find and fix bugs faster\n\n>I mean...should I study \"operating system\" and specifically for MacOS?\n\nNot sure how this relates to the question. You should know a good bit about the system where your software runs on, but knowing about the system you run to write the code won't help you at all", "id": "k96xlnb", "parent": "t3_17uk2qd", "vote": 1}, {"content": "Oh I see. Do you think I can benefit by learning os?", "id": "k94eem4", "parent": "t1_k94a7de", "vote": 0}, {"content": "Thanks bud, I learned something from this", "id": "k96b89s", "parent": "t1_k94rgj0", "vote": 0}, {"content": "So where can I learn this? Should I dig some books on computer system, os, and some lower level language/assembly language at the minimum?", "id": "k9546vn", "parent": "t1_k95201r", "vote": 0}, {"content": "I have a background in math. Perhaps I'm into data science so machine learning application. But in the long run I want to be adept at anything related to data infrastructure or anything artificial intelligence.. i'm currently practicing C and Python.. actually comparing these two languages serves me well. For me understanding operating system and computer system almost feel like learning rigorous math so almost indispensible but I'm also feeling that this is not very practical at all and far from what I really need as a functional programmer who deals with data (when I get employed?)", "id": "k96ibad", "parent": "t1_k96dxtb", "vote": 1}, {"content": "It wouldn't hurt, but there's no guarantee it's going to help with any arbitrary problem you're trying to solve.  But understanding how the computer & OS works will definitely help you grow as a developer.", "id": "k952z15", "parent": "t1_k94eem4", "vote": 3}, {"content": "IDK b/c I have no idea what you know, and how you got there.", "id": "k954wb9", "parent": "t1_k9546vn", "vote": 0}, {"content": "I would agree with your analysis. \"Embedded systems\" might be something worth looking into, since that is related to operating systems on electronics (smart watches, smart TVs, smart refrigerators, raspberry pis, etc.). And those tend to have specialized programming requirements at a low level since the hardware may not support commonly used technologies.\n\nOtherwise, if you're leaning into ML, then focus on ML algorithms, data sets, etc.\n\nBut if this is for fun, learn about OS's. Everyone has hobbies, and that could be one for you.", "id": "k9e0evo", "parent": "t1_k96ibad", "vote": 1}, {"content": "Like I get sigkill error when I try to use gdb, I feel like I lack the knowledge to really solve this problem", "id": "k9555l8", "parent": "t1_k954wb9", "vote": 0}], "link": "https://www.reddit.com/r/learnprogramming/comments/17uk2qd/how_can_you_be_great_with_debugging_all_i_do_is/", "question": {"context": "whenever I get stuck, I feel so helpless. and I go to stackexchange, follow whatever it says, and the problem exacerbates. I figure I need to do something (which I don't know why it should work) in order to solve the problem, that even doesn't work.  It's soooo frustrating. I can't blame my computer.  \nIs it just a matter of experience?\n\nI mean...should I study \"operating system\" and specifically for MacOS?\n\nHow can I better handle with such a problem in general? I want to really understand and debug whatever problem I face  ", "id": "17uk2qd", "title": "How can you be great with debugging? All I do is to blindly follow stackexchange"}, "resource": "Reddit"}, {"answers": [{"content": "This is essentially exactly what we do. All of our pipelines run in k8s using Tekton, so if we really need to debug live in the running container, we add a sleep instruction before the troubled portion and SSH in to try things quickly before writing them back to the task. Cheap, quick, effective, I would want the same capability if I was using GHA so I'm sure this will find popularity!", "id": "jlojc9l", "parent": "t3_13s8jga", "vote": 57}, {"content": "I've actually found [act](https://github.com/nektos/act) to be super useful. It's not perfect, but its still pretty good.", "id": "jloma69", "parent": "t3_13s8jga", "vote": 24}, {"content": "I've started using Dagger.io for this purpose. The full pipeline then is runnable locally", "id": "jlolnei", "parent": "t3_13s8jga", "vote": 15}, {"content": "I tend to abstract all the things that need to run in CI behind Task using a Taskfile and make sure those commands ar also runnable locally. This makes debugging a lot easier. Often I create an env var that will enable verbosity in all the commands that task runs.", "id": "jloofie", "parent": "t3_13s8jga", "vote": 14}, {"content": "It's the bane of my fucking existence and I hate GitHub with a passion for not giving me an interpreter to run locally.", "id": "jloo2dw", "parent": "t3_13s8jga", "vote": 28}, {"content": "[deleted]", "id": "jlojspw", "parent": "t3_13s8jga", "vote": 8}, {"content": "Make your CI/CD code just call some scripts in your source code, like a Makefile or a .dev/", "id": "jlp3al6", "parent": "t3_13s8jga", "vote": 16}, {"content": "We install and set up the tmate action on our GitHub Action workflows. It lets you rerun the pipeline and get an ssh in to the running action whenever you need to. The only tricky part is having the tmate call in the right place. You don\u2019t want to have to manually run all the set up steps but you also want to be able to debug any step that might fail. \n\nhttps://github.com/mxschmitt/action-tmate", "id": "jlpfmzw", "parent": "t3_13s8jga", "vote": 9}, {"content": "I'm honestly baffled how major CI/CD solutions like Amazon Pipelines, GitHub Actions or GitLabCI do not provide a tool that basically allows you to execute a pipeline locally.\n\nI mean let's say I have a yaml that describes a bunch of tasks of an Azure Pipeline (and some tasks call other ad hoc scripts that are also locally). I could easily have a tool that connects to my AzureDevOps org to pull whatever service connections the yaml uses and pull the code of whatever task it calls and run all that locally in a Docker container with the same image used by the runner. Is there any actual limitation that prevents us from doing that besides simply having the tool the interprets the yaml?\n\nThis would make so many parts of my job much easier and cleaner instead of running scripts individually locally and manually (which sometimes may be different to how they are called by the yaml by simply manual error) and avoid filling the general list of CI/CD runs with a bunch of errors from my troubleshooting pipeline.", "id": "jlpgd8w", "parent": "t3_13s8jga", "vote": 6}, {"content": "Interesting. Certainly have run into pita in our environment at times while debugging. This at least gives me some ideas on what we need. I haven\u2019t even had time to move our ms hosted runners to self hosted so we can stop letting azure devops connect to our paas services over public internet. All of our stuff is supposed to use private endpoints and some portions of our pipelines access keyvault or table storage for configuration storage so there are a lot of moving parts, which means lots of points where things can go wrong", "id": "jlpbufg", "parent": "t3_13s8jga", "vote": 3}, {"content": "I usually try to abstract out all of the important stuff into their own GitHub Actions (or whatever reuse mechanism is available) and then build a dedicated pipeline that I usually call \u201cdogfood\u201d or similar. I\u2019ll then use dogfood to test the Actions by building and tearing down something that tests whatever I am trying to debug. The dogfood pipeline can then deploy to a sandbox or non prod environment.\n\nAs I add more things to the dogfood pipeline, I use that as a form of unit or integration tests for the components of all other pipelines. Anytime a shared component changes, the dogfood pipeline runs just to validate that everything is working correctly. It also runs nightly on a schedule to discover any vendor side changes that could impact pipelines.\n\nDepending on the capabilities of your CI tooling you can often version your actions, allowing you to safely test them in the dogfood pipeline prior to releasing them to be used in other more important places.", "id": "jlpm7xo", "parent": "t3_13s8jga", "vote": 3}, {"content": "If you make your own GitLab runner, you can use the web terminal to be able to run arbitrary commands in the pipeline context to get a sense for what's failing and troubleshoot jobs. \n\nhttps://docs.gitlab.com/ee/ci/interactive_web_terminal/", "id": "jlruelm", "parent": "t3_13s8jga", "vote": 3}, {"content": "You can run gitlab-ci in local mode, which is what I do.\n\nIt's a bit awkward, but:\n\n```\ngitlab-runner exec docker -cicd-config-file=$(pwd)/.gitlab/ci/deps-check.yml --docker-image=golang:1.19-rc \"mq check\"\n\n```\n\nis an example of running the \"mq check\" job that's defined in `.gitlab/ci/deps-check.yml` with a golang docker image.", "id": "jlt1ura", "parent": "t3_13s8jga", "vote": 3}, {"content": "I use pipelight \ud83e\udd2b https://pipelight.dev/", "id": "jlqee2n", "parent": "t3_13s8jga", "vote": 5}, {"content": "[deleted]", "id": "jlot5wy", "parent": "t3_13s8jga", "vote": 2}, {"content": "Like anything else: Find out a minimal repro and squash it out. This is an interesting solution though, thanks for coming up with it :P", "id": "jlp4nss", "parent": "t3_13s8jga", "vote": 2}, {"content": "There should be some indication in the logs about what's wrong. In the most dire situations I sleep it and go inspect it manually. But you can usually get enough info from archiving all relevant files or the workspace itself, or from debugging the container locally. Pipelines taking hours to finish is a whole other issue in and of itself...", "id": "jlpm5jb", "parent": "t3_13s8jga", "vote": 2}, {"content": "How complex are your pipelines? We also are on GitHub Actions with Self-Hosted Runners on AWS, different kind of pipelines:\n  - Testing\n  - Validations\n  - Building\n  - Deployment\n  - Environment resource shutdowns\n  - VPN setups\n  - Mobile\n  - Etc.\n\nNever have we truly had a case where we require getting into the container? I don't understand. Test or syntax error is clear in the logs.\n\nIn any case, the tool looks interesting and I'll get it into our list for research should we need to.\n\nThanks for sharing!", "id": "jlq2334", "parent": "t3_13s8jga", "vote": 2}, {"content": "Gitlab pipeline jobs are just docker containers. So easy to debug locally.", "id": "jlq3c4o", "parent": "t3_13s8jga", "vote": 2}, {"content": "Introducing conditional execution steps or stages in your pipeline can help isolate specific parts of the pipeline for debugging purposes. By selectively running or skipping certain stages, you can focus on the problematic areas *without* executing the entire pipeline.", "id": "jlql23h", "parent": "t3_13s8jga", "vote": 2}, {"content": "Dagger.io. Write pipelines that run absolutely anywhere. Develop/test locally, in a language with actual features instead of coding everything in bash from scratch.", "id": "jlqx0l1", "parent": "t3_13s8jga", "vote": 2}, {"content": "Others have mentioned tmate to SSH into a running GitHub Actions workflow; there is a [roadmap issue](https://github.com/github/roadmap/issues/637) making that functionality built-in to Actions, planned for 2023/Q4.", "id": "jlr9mlm", "parent": "t3_13s8jga", "vote": 2}, {"content": "Looks amazing; I'd love to have this working on our Bitbucket Pipelines!", "id": "jlrosv8", "parent": "t3_13s8jga", "vote": 2}, {"content": "`ECHO`", "id": "jlptxxs", "parent": "t3_13s8jga", "vote": 4}, {"content": "I\u2019m not a fan of these questions that\u2019s really to hawk software your company made. Why ask a question when you already came up with a solution?", "id": "jlqi2q1", "parent": "t3_13s8jga", "vote": 3}, {"content": "I heard about something logger.groovy for jenkins pipeline, please correct if I'm wrong as did use but heard about in team.", "id": "jlqgxhf", "parent": "t3_13s8jga", "vote": 0}, {"content": "One thing I really like (and miss) about circle ci was that you could ssh into the job runner and debug the environment and pipeline. I shit you not, that saved me so much time.", "id": "jlue5qk", "parent": "t3_13s8jga", "vote": 1}, {"content": "Tekton seems quite interesting. I will try it out! Thanks for the pointer! \n\nIs there a way to tell Tekton pipeline to only trigger this \"sleep\" in case of failures? \n\nBreakpoint CLI can be installed anywhere, and it is not specific to GitHub Actions. Just call `breakpoint wait` when you want to pause the pipeline, and you automatically get an SSH endpoint to connect to. On top of that, you get a Slack notification if you configure the Slack token.", "id": "jlosu4j", "parent": "t1_jlojc9l", "vote": 11}, {"content": "I second this but would also add a bit. You will save yourself a lot of pain by using standard non-platform specific patterns relative to your CI platform. This will make it far easier to shell into your build container and just step thru your workflows. We have ours where you just set a few environment variables and you are good to go on testing.", "id": "jlonyf4", "parent": "t1_jlojc9l", "vote": 7}, {"content": "Can confirm we do something similar. We use Jenkins for CI/CD which uses a k8s pod as an agent. Anytime we have to debug something we just replay the pipeline and put a sleep step before the failing step and then ssh into the container in the pod. We can even comment out other stages if we want in the replay script. I mean this is the quickest and cheapest way to debug.", "id": "jlrsbp6", "parent": "t1_jlojc9l", "vote": 4}, {"content": "Do you use it to debug the actions locally before pushing them to the actual GitHub repo?", "id": "jlovcz3", "parent": "t1_jloma69", "vote": 5}, {"content": "It's... Okay... Only a runner from ubuntu 18.04 and it takes a while. It reminds me of compiling code locally again... Feels the same as waiting for logs from Vscode github actions extension, except you don't waste local resources with GHA runners..", "id": "jm1qkdy", "parent": "t1_jloma69", "vote": 2}, {"content": "Dagger looks great, it is definitely on my list to try out!\n\nI see from the docs that it runs the pipeline in a container. You would still need to add a sort of \"sleep\" in the pipeline itself to pause the container and SSH inside, right?", "id": "jlotxh7", "parent": "t1_jlolnei", "vote": 5}, {"content": "TIL Taskfile. It seems quite powerful. Thanks for the pointer!  \n\n\nIt should be easy to call the Breakpoint binary from a Taskfile.", "id": "jlovwjq", "parent": "t1_jloofie", "vote": 3}, {"content": "Use Jenkins and you\u2019ll have something you can hate even more.", "id": "jlpci6y", "parent": "t1_jloo2dw", "vote": 38}, {"content": "That's right, I've done similar things. Like creating a dummy pipeline that runs only the thing I am interested in. \n\nBut even then, it was very hard for me to be 100% confident that the real pipeline would work after I merged my changes.", "id": "jlou84r", "parent": "t1_jlojspw", "vote": 3}, {"content": "agree to this one.  \nI've started with having the whatever CI/CD system yaml to just be a thin wrapper over your makefile which is the real pipeline. Then you will also get instant feedback when debugging", "id": "jmg5p7b", "parent": "t1_jlp3al6", "vote": 2}, {"content": "I really liked doing this with CircleCI: [https://circleci.com/docs/how-to-use-the-circleci-local-cli/](https://circleci.com/docs/how-to-use-the-circleci-local-cli/) . Runs the same as in their cloud, but locally in docker.", "id": "jlrbx6p", "parent": "t1_jlpgd8w", "vote": 3}, {"content": "This post/comment has been edited for privacy reasons.", "id": "jls4lfj", "parent": "t1_jlpgd8w", "vote": 1}, {"content": "I could\u2019ve sworn GitLab had runners you could use locally to run some of your pipeline commands/scripts? The downside I can recall is that your local environment needs to mirror the environment where the runners live to get as close as possible, which is likely not gonna happen.", "id": "jlsmuye", "parent": "t1_jlpgd8w", "vote": 1}, {"content": "Sounds like a lot of effort over... just using better tooling.", "id": "jlqxtrx", "parent": "t1_jlpm7xo", "vote": 1}, {"content": "I'd recommend checking out these two tools for local Gitlab CI runs:\n- https://github.com/firecow/gitlab-ci-local\n- https://gitlab.com/AdrianDC/gitlabci-local", "id": "jltiuux", "parent": "t1_jlt1ura", "vote": 3}, {"content": "Interesting, similar concept! \n\nI find the way to continue the workflow a bit rough. Also, I don't seem to find a way to extend the SSH session in case I want one of the teammates to SSH in and help me debug.   \n\n\nIn Breakpoint, we wanted to leave the SSH server alive as long as either a timeout expires or the user calls \\`breakpoint resume\\`. Also, we use Slack, so we added a Slack hook to get notified when a Breakpoint is hit.", "id": "jlowt8f", "parent": "t1_jlot5wy", "vote": 2}, {"content": "Breakpoint CLI is just a binary. We targeted GitHub Actions for started, as they are the main CI we work with. But it should work out of the box for any CI/CD system.  \n\n\nIf you know Bitbucket Pipelines, feel free to try it out and give us your feedback at https://github.com/namespacelabs/breakpoint/issues/6!", "id": "jlv37w8", "parent": "t1_jlrosv8", "vote": 1}, {"content": "Hey! We really believe this tool can help the DevOps community, so we decided to release it open-source and free of charge.\n\nThe CI/CD world is incredibly large and wide, and we are genuinely curious to know how engineers found alternative solutions to these issues! In the end, we like to learn from the community and see if there are ways we can improve the current standards.", "id": "jlv2vg8", "parent": "t1_jlqi2q1", "vote": 2}, {"content": "\\+1 on this. We stopped using bitbucket-pipeline caches because they don't reliably update, we stopped using bitbucket-pipeline plugins because they don't have enough controls and we can't run them locally.\n\nThis allows us to deploy locally or through the pipeline.", "id": "jlpdq0w", "parent": "t1_jlonyf4", "vote": 4}, {"content": "+1 on that, this is why I believe the Breakpoint model should work in any CI/CD system. It's just a Go binary you can install anywhere you need.\n\n>  We have ours where you just set a few environment variables and you are good to go on testing\n\nDid you build an in-house tool?", "id": "jlot313", "parent": "t1_jlonyf4", "vote": 3}, {"content": "Yes, exactly. Sometimes you still need to push an action to get the full GHA environment, but act at least allows you to be much more confident.", "id": "jlqueui", "parent": "t1_jlovcz3", "vote": 5}, {"content": "i do.   whenever i\u2019m helping a dev, it\u2019s my first step, reproduce in act", "id": "jloyyhc", "parent": "t1_jlovcz3", "vote": 1}, {"content": "I mean, I guess it depends on what you're trying to do in your pipeline, but I personally found that using act allowed for pretty quick iteration.", "id": "jm1u6kw", "parent": "t1_jm1qkdy", "vote": 1}, {"content": ">You would still need to add a sort of \"sleep\" in the pipeline itself to pause the container and SSH inside, right?\n\nNo. You develop/test locally. No SSH needed, debug as you would any python/node/go script locally. When it works locally it'll work remotely (as long as you provide the environment variables etc). https://docs.dagger.io/145912/ci#gitlab-ci shows the very basic CI jobs that just run python/node/go code. You can run those same scripts anywhere.\n\nDagger is genuinely brilliant, it should be _at the top_ of your list.", "id": "jlqxooq", "parent": "t1_jlotxh7", "vote": 7}, {"content": "No, you can run it with a debug mode and it will give you all of the stdout output, and we use it with typescript, where most of the debugging I do is basic `console.log` level", "id": "jlowstu", "parent": "t1_jlotxh7", "vote": 1}, {"content": "Really don\u2019t understand this sentiment. Jenkins is a highly configurable tool that seems to work well for people who know what they\u2019re doing.", "id": "jlpga4q", "parent": "t1_jlpci6y", "vote": 1}, {"content": "circleci allows you to just ssh debug into their containers/machines if you have it cloud hosted.", "id": "kd2jzr8", "parent": "t1_jlrbx6p", "vote": 1}, {"content": "GitLab does have a local runner which works fairly well, but to mirror a prod config of complicated custom runner images, runtime environments, executors, running on AWS, with rules for this that and the other, it's just not doing any good. I end up just trying to get the script to work as good as I can locally and then debug it in on the kubernetes executor runner with a sleep statement", "id": "jlt30ya", "parent": "t1_jlsmuye", "vote": 2}, {"content": "Two tools I've used for local Gitlab CI runs:\n- https://github.com/firecow/gitlab-ci-local\n- https://gitlab.com/AdrianDC/gitlabci-local", "id": "jltimi2", "parent": "t1_jlsmuye", "vote": 2}, {"content": "Yeah but you asked a question all to promote your own solution to it. Sorry, but that just comes across poorly.", "id": "jlv5n32", "parent": "t1_jlv2vg8", "vote": 1}, {"content": "I won\u2019t pretend that I\u2019m an expert. We run hundreds of Jenkins instances and still, creating a system that automatically comes with the plugins we choose and correctly configured is, what I feel, a major pain. \n\nLet alone going thru the \u2026 fun \u2026 of upgrading the plugins or Jenkins itself. \n\nSure, it\u2019s highly configurable. Running Jenkins at scale still is a major pain.", "id": "jlpnxc1", "parent": "t1_jlpga4q", "vote": 8}, {"content": "It\u2019s still a fucking disaster to manage. Never seen it done well.", "id": "jlq7w64", "parent": "t1_jlpga4q", "vote": 3}, {"content": "Jenkins is the PHP of dev ops / CI tools. Most of the apologists seem to have little experience with a lot of other tools or forgive the platform\u2019s really glaring faults that tend to cause serious problems in practice when the tool hits reality", "id": "jlqgbhm", "parent": "t1_jlpnxc1", "vote": 8}, {"content": "hundreds is for sure a lot more than my one instance. we have quite a lot of jobs in there though, touching every aspect of our product and kube clusters.   \n\n\ni will have to see the light of another product in my spare time i guess....  \\*rambles about service based economy\\*", "id": "jlpqnba", "parent": "t1_jlpnxc1", "vote": 2}, {"content": "Well someone at yesterdays GutHub Galaxy said:\n> Wouldn\u2019t it be cool to just change code \ud83d\udc69\u200d\ud83d\udcbb in production? That would increase Developer productivity!\n\nI knew it!\n\nI always knew it!\n\nThis is the year of ~~the Linux desktop~~ PHP!", "id": "jlqhrft", "parent": "t1_jlqgbhm", "vote": 2}, {"content": "We\u2019re going for tekton, GitHub Actions, GitLab. \n\nThe model of having to first build the CI to have a good isolation level and then start building the actual CI is \u2026 expensive. \n\nJenkins was good, don\u2019t get me wrong. When Hudson (back then) arrived, people were fleeing in tribes from whatever they had at the time. Buildbot was one of the better systems and still no competition for it. \n\nThe world has moved on. Except for a few niche cases \u2014 where you _know_ that these are specific circumstances \u2014 I wouldn\u2019t recommend Jenkins any more. \n\nDon\u2019t even get me started about memory consumption (where I\u2019m not sure whether to put it in JVM classloader land or Groovy). When we fixed that bug total memory consumption went from double digit TB to a few hundred gigs (total). \n\nThink about the cost of this, we had to fiddle around for ~1 year.", "id": "jlpzjj2", "parent": "t1_jlpqnba", "vote": 5}], "link": "https://www.reddit.com/r/devops/comments/13s8jga/how_do_you_debug_cicd_pipelines_breakpoints/", "question": {"context": "I've mainly worked with Jenkins and GitHub Actions. But I always find myself adding debug messages and rerun the pipeline. In certain cases, the pipeline could take hours to reach the point I am interested in.\n\nRunning commands locally helps, but it is not always representative of the real CI/CD environment. For example, tools are not available for MacOS, or they have different behaviors.\n\nWhere I work, we deal with a lot of these issues, especially with GitHub Actions. So we decided to find a solution and we came up with [CI/CD Breakpoints](https://github.com/namespacelabs/breakpoint). It is 100% open-source. \n\nDo you have a different approach to debugging CI/CD pipelines?", "id": "13s8jga", "title": "How do you debug CI/CD pipelines? Breakpoints?"}, "resource": "Reddit"}, {"answers": [{"content": "That would be great. I find myself using the old-fashioned \"debug by logging\" technique too often for my comfort.", "id": "j41c759", "parent": "t3_109yf4d", "vote": 231}, {"content": "I am surprised to see no mention of [Headcrab](https://headcrab.rs/) - it sounded quite promising back in the days, although it appears to have lost steam along the way.", "id": "j41w6ms", "parent": "t3_109yf4d", "vote": 45}, {"content": "I am quite experienced with using the VS debugger for C++. C++ debugging isn't great either, though it is better than Rust in many cases because natvis works correctly for pretty much everything. Here are some things I really want a Rust debugger to have:\n\n* Memory snapshotting\n* Time travel (cross platform)\n* Fast conditional breakpoints (possible by patching an unconditional jump to a thunk, rather than an interrupt instruction)\n* Watchpoints for variable changes for complex types. Hardware watch registers are limited, so type creators should be able to specify which piece of a complex type to watch in order to best capture changes.\n* Ability to generate visualization for new user types quickly. Something like \"create visualization from template\" with templates for commonly used classes of datatype might work.\n* Better variable debugging in release mode, if possible.\n* Ability to evaluate arbitrary expressions in current context (available in gdb, but not VS debugger)", "id": "j41yzqp", "parent": "t3_109yf4d", "vote": 35}, {"content": "Yes please! Having something on the level of C# / C++ debugging would already be a massive help. Let alone if its given the 'rust' touch, I feel like we have so much compute sitting around that could be visualizing all kinds of useful program state! Real time interactions / visualizations of programs could help a lot to learn & understand. Eg:\n\n- Visualize variables as tables/matrices/images/graphs/...\n- Overview of active threads with names\n- RAM/CPU usage, per program, per thread\n- \\# of Mallocs/frees\n- Time spent in locks\n- Something like a lightweight sampling profiler showing current execution (useful in case you eg. accidentally have an infinite loop). Maybe show as a lightweight 'hot' function too\n- Tracking some viewed value over time\n- Perhaps some lightweight miri integrations (eg. do miri validation for some marked functions)\n- ...basically all of the sweet features in https://remedybg.itch.io/remedybg :)", "id": "j41e78y", "parent": "t3_109yf4d", "vote": 60}, {"content": "This is something I would love to see. It would do a lot for the developer experience!", "id": "j4129hm", "parent": "t3_109yf4d", "vote": 56}, {"content": "Very interesting, thank you. Good to know of the RFC as well.\n\nFocussing on how to show an \"object-tree\" is a little too narrow, though. The big reason for reaching for a debugger in Rust are logic bugs, and I've always found it helpful to have a history. That is, for finding the cause it's not so much important _where_ the program currently is but how it got there. There's time travel debugging but that's also quite intensive to step through.\n\nActually, I wonder, would it be helpful to let the program author(s) decide on some set of expressions that should be presented as relevant to a user while debugging a particular _scope_? All comparisons to printf-style-debugging purely incidental, the goal should be to have it integrated with the other tools of debuggers. But for root cause analysis it is most often useful to compute _more_ state (or present it different) than is present in the program state itself. \n\nAs a sufficiently advanced future development, the expressions could also guide hints such as hit-counts, graphs to link the domain knowledge of the code author with the visualization/state exploration of the debugger.", "id": "j41jlbl", "parent": "t3_109yf4d", "vote": 28}, {"content": "The thing I want most out of Rust debugging is the ability to debug the output of a macro.", "id": "j41rowc", "parent": "t3_109yf4d", "vote": 10}, {"content": "> Users of Rust are instead expected to use a third-party debugger such as gdb, lldb, or windbg\n\nWhy leave out the best Rust debugger out there, CLion?\n\nThe only difference with the IDEA/Java/Kotlin debugger experience is that you can't evaluate live expressions, but besides that, you get a full debugging experience in CLion.", "id": "j41wsqa", "parent": "t3_109yf4d", "vote": 23}, {"content": "[deleted]", "id": "j43viye", "parent": "t3_109yf4d", "vote": 6}, {"content": "I'm using lldb with VSCode to debug. One thing that I want is that the vscode can somehow display the structs through the Debug trait, rather than decomposing the fields. This itself will make debugging in vscode much easier!", "id": "j41h1jt", "parent": "t3_109yf4d", "vote": 12}, {"content": "Packaging a debugger is fine on Linux and probably Windows, but when I tried, it was an incredible pain on macOS due to the need to sign the debugger (or debug server).  Requiring XCode would work instead (it ships a signed one) but of course then one isn't really owning the toolchain.  There are also some dependency issues, like gdb uses Python (ideally) but it cannot use the Python stable ABI, so you need to make decisions about which Python exactly is supported.\n\nAnother big issue is that every large-ish change requires patching not just the Rust compiler (which would be easy) but also LLVM, which in addition to being harder generally, is also made even-harder since the compiler allows mix-and-match of LLVM versions.  This is essentially why traits don't work in gdb; in fact if something is really missing, I think this is usually the reason.  (It's even worse than that because normally you want to test things end-to-end so you implement it all; but then some reviewer along the way wants it redone, so you have to rewrite the other patches as well.)\n\nWell, that is true for gdb.  For lldb the issue is that lldb doesn't really understand Rust.  So for instance, this is why enums don't work -- the DWARF is fine (now) but since rust-like enums aren't in C++, lldb just ignores this debuginfo.  (I don't really follow lldb, so maybe it's better now?)  Anyway I wrote a Rust plugin for lldb but it had some setbacks -- like IIRC (unlikely) it was removed by an LLVM upgrade in Rust... working on lldb was personally kind of a bummer and then that was just super demoralizing.\n\nFor Linux, the Rust support in gdb is in all the distros by now, so shipping a gdb via rustup only looks important, from my perspective, if someone is actively working on debuginfo generation.  If someone does do this, I'm happy to write the gdb side; it's mostly invisible because Rust is pretty solid, but I already am testing each Rust release as it comes out to make sure gdb is still working.\n\nAlso, as a final note, DAP is not all that great.  I implemented the basic support for it in gdb recently.  It has some holes vis a vis a compiled language, and many things in it are simply undocumented.  It's better in some ways than gdb's other communication scheme, but notably worse in some others.", "id": "j44mpzt", "parent": "t3_109yf4d", "vote": 7}, {"content": "[deleted]", "id": "j41fey4", "parent": "t3_109yf4d", "vote": 3}, {"content": "I know it's often used to check for undefined behavior, but could something like MIRI be used as a debugger. Since it knows what things are from a Rust perspective it can take advantage of that such as `impl Debug` and slices, etc.", "id": "j43zc55", "parent": "t3_109yf4d", "vote": 3}, {"content": "The debugger should include half a compiler IMO. Coming from Java, where the debugger has the nice feature of you being able to evaluate arbitrary expressions (which call other functions), even if those functions are never called otherwise. And I want this in Rust. But since Rust strips and monomorphizes all the things, this almost always causes \"undefined symbol\" errors.", "id": "j4t6g9i", "parent": "t3_109yf4d", "vote": 3}, {"content": "I\u2019m probably too much of a graybeard developer to be the target audience for this, but I last fired up a debugger on purpose on 2009, and before that, maybe in 2000. I did use them a lot on Delphi stuff in the 90s.\n\nSo, while I agree, decent debuggers should exist for Rust, I think the main utility they have is for people new enough to the language, or coding in general, to develop their intuitive sense of control flow and ability to run code in their head. If I were writing a debugger, I think I\u2019d focus on making that excellent.\n\nA friend of mine was the primary author of Sun\u2019s C/C++ debugger for Solaris. It was a lovely product, but has features probably two developers on the planet ever used. So, staying out of the weeds is important.\n\nAs for \u201cold fashioned\u201d println debugging, that\u2019s a skill - and there is some science doing it effectively - that everyone can benefit from - sometimes you don\u2019t have a debugger; sometimes you\u2019re working in a language you don\u2019t use often, or don\u2019t have your usual tools available, but println works everywhere. It\u2019s pretty simple: binary-search. Add a println at the head and tail of the code where the problem could possibly be. Didn\u2019t find it? Add one in between those. Keep dividing and conquering and you will very quickly zero in on where the problem has to be. It\u2019s often *much* faster than stepping through reams of library code.\n\nThe one place it falls down is concurrency bugs where the overhead of the println changes the timing and makes the problem disappear. But the instrumentation overhead debuggers often add can also do that.", "id": "j440ioj", "parent": "t3_109yf4d", "vote": 4}, {"content": "I've been using [vscode-lldb](https://github.com/vadimcn/vscode-lldb) with VS Code on macos, and I've been very happy with the experience so far.\n\nIn fact, this VS Code extension is already packaging [a DAP debug adapter written in Rust](https://github.com/vadimcn/vscode-lldb/tree/master/adapter).\n\nIIRC, lldb support for msvc Windows has been getting better in recent years.\n\nSeems like that might be a good starting point.", "id": "j42s0yw", "parent": "t3_109yf4d", "vote": 1}, {"content": "Yes.", "id": "j45mqdf", "parent": "t3_109yf4d", "vote": 1}, {"content": "The debugging experience on Windows is terrible", "id": "j48n5qv", "parent": "t3_109yf4d", "vote": 1}, {"content": "Very interesting. I am trying lldb but with mixed results.", "id": "jtdxaok", "parent": "t3_109yf4d", "vote": 1}, {"content": "\"printf-style\" debugging in Rust isn't too bad. Especially if I didn't keep forgetting about that neat `dbg!` macro. In contrast to C where I may need a debugger just to have a way to print data structures. And to investigate segfaults, which are (usually) not a problem in Rust.\n\nBut debuggers are a good tool to have when needed, so any improvement there is good.\n\nActually, I'm not sure when I last tried to use `gdb` or `lldb` with Rust? At least for anything other than just getting a trace from a segfault for something involving ffi or other unsafely. I don't think support was good when I first tried to use `gdb` with a Rust project, but that would have been several years ago now.", "id": "j43b6cy", "parent": "t1_j41c759", "vote": 20}, {"content": "[deleted]", "id": "j41dwlk", "parent": "t1_j41c759", "vote": 18}, {"content": "Odd, I use the IntelliJ plugin for Rust and it just seems to \"work\" with a one-click launch.\n\nIt's not as say powerful as the one used for the JVM but it's better than debugging by logging.", "id": "j43hr1n", "parent": "t1_j41c759", "vote": 5}, {"content": "Rust's debugging experience isn't actually at all as bad as you might expect (especially from this article). If you install codelldb in VSCode then I've always found that it works perfectly first time - all you need to do is click to set breakpoints and then click `Debug Test` next to a test.\n\nA much *better* experience than most debuggers I've used (perhaps with the exception of something like Javascript). Python's debugging with Debugpy is pretty decent too but it comes with the enormous asterisk that setting it up is quite a pain because Python uses the utter tripe Pydb by default.\n\nThat said, I 100% agree with the article. We should make it work even better!", "id": "j423ie6", "parent": "t1_j41c759", "vote": 35}, {"content": "Same, plus adding a bunch of small tests till they fail. Not a super scalable when a function changes and you suddenly gotta rewrite 20 tests lol", "id": "j41wtu9", "parent": "t1_j41c759", "vote": 7}, {"content": "I must say I barely notice debugging issues with Rust because I almost never need to fire up a debugger.\n\nI like designing with types, and since Rust is so nicely strict with types I am seldom surprised by what the program does.", "id": "j43gjsx", "parent": "t1_j41c759", "vote": 2}, {"content": "Excellent name, too.", "id": "j43jpj9", "parent": "t1_j41w6ms", "vote": 10}, {"content": "Heck, while we are at it:\n\nSupport all of the above with a thin hypervisor debugger\n\nSupport Intel VTune \n\nSide by side views for different CPU isa extension targets (godbolt style)\n\nVisual code coverage / tracing like Ida pro lighthouse", "id": "j4560rv", "parent": "t1_j41yzqp", "vote": 3}, {"content": "You can do time-travel debugging right now on Windows, using WinDbg.  It's...  kinda awesome.", "id": "j5xxi1w", "parent": "t1_j41yzqp", "vote": 1}, {"content": "As a long-time user of Visual Studio for C++ (the *actual* Visual Studio, *not* VS Code), I really miss its debugging capabilities when writing Rust.\n\nI mean, Visual Studio debugger is just... **incredible**... imagine writing Rust there, with full support.", "id": "j41w467", "parent": "t1_j4129hm", "vote": 39}, {"content": "You're describing execution tracing, like in Erlang and bash. You capture a trace of the entire execution, and then you can inspect it at your leisure with the filters you care about. IMO that's the one true way to debug. Checkpoint-based debugging feels like a massive downgrade after using that.\n\nUnfortunately this is quite limited for native code - `rr` can be used as a backend, ~~but only on Intel CPUs (no AMD, no ARM, etc.),~~ and even its UI tries to be \"checkpoint but better\" instead of working with the entire trace at once.\n\nEdit: apparently some AMD and ARM CPUs are now supported! It's kind of a pain to get working due to Spectre mitigations messing with it, however.", "id": "j41z3lv", "parent": "t1_j41jlbl", "vote": 10}, {"content": "> it's not so much important where the program currently is but how it got there.\n\nDoes hopping around the call stack not give you what you need to know?", "id": "j41qsx1", "parent": "t1_j41jlbl", "vote": 2}, {"content": "My description of [Intel's Pin](https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html) is \"what if you took the core of an instrumenting profiler and made it a library\".\n\nI had some ideas around automatic tracing using Pin but ran into some issues and didn't have the motivation to continue.  If someone could get something like that to work, I bet that would be a big help.", "id": "j41rgrt", "parent": "t1_j41jlbl", "vote": 3}, {"content": "Maybe [this vscode extension](https://github.com/willcrichton/flowistry) could be useful to you?", "id": "j42hyn8", "parent": "t1_j41jlbl", "vote": 1}, {"content": "If you just want to view the results of a macro, you can do this in rust-analyzer. It's a command palette option (Shift+P, expand macro recursively).\n\nIf you'd like to step into a macro for debugging though, I'm right there wish you, wish that was possible.", "id": "j4216ck", "parent": "t1_j41rowc", "vote": 11}, {"content": "Not too familiar with macros but does [cargo-expand](https://github.com/dtolnay/cargo-expand) do what you want or did you mean something else?", "id": "j41uv1a", "parent": "t1_j41rowc", "vote": 7}, {"content": "Isn't CLion just using gdb under the scenes?", "id": "j42drpp", "parent": "t1_j41wsqa", "vote": 14}, {"content": "[deleted]", "id": "j43181i", "parent": "t1_j41wsqa", "vote": 4}, {"content": "Exactly what I thought, great debugging experience in CLion.", "id": "j42u36q", "parent": "t1_j41wsqa", "vote": 2}, {"content": "CLion doesn't have a separate debugger, only a debugger interface. It wraps the underlying native debuggers (gdb, lldb, idk about windbg).\n\n> Why leave out the best Rust debugger out there, CLion?\n\nBecause this is a Microsoft emploee arguing for more free work to support a Microsoft product.", "id": "j42wn6n", "parent": "t1_j41wsqa", "vote": 2}, {"content": "I'd love to be able to use `rr` nicely with Rust.", "id": "j45x46d", "parent": "t1_j43viye", "vote": 1}, {"content": "I've had a lot of trouble with code-lldb. Even newtyping a slice will make its contents invisible to the debugger and it isn't clear to me why.", "id": "j420zhw", "parent": "t1_j41h1jt", "vote": 7}, {"content": "I think we'd have to make a new trait outside of `Debug` at this point?\n\nFundamentally, the [`std::fmt::Debug` trait](https://doc.rust-lang.org/std/fmt/trait.Debug.html) is a \"please write some UTF-8 to this thingie\" with a convenience API on top. I think the [`std::fmt::Formatter`](https://doc.rust-lang.org/std/fmt/struct.Formatter.html) argument provided in `Debug::fmt` _could_ be useful for building a tree of visualization data, and `derive(Debug)` could be changed to implement printing of a more general underlying model. However, that would definitely have performance/optimization concerns, since `Formatter` is used in every other `std::fmt` trait. I suspect there would also be nontrivial roadblocks with accessing a specific subset of the tree performantly; the API is designed to run through the entire set of formatting logic before returning, and that could be prohibitive with, say, `Vec`s with an enormous number of elements.", "id": "j42xba7", "parent": "t1_j41h1jt", "vote": 2}, {"content": "Special macOS requirements just sounds like even more motivation for a central Rust solution.", "id": "j496nme", "parent": "t1_j44mpzt", "vote": 2}, {"content": "I've used both \"normal\" gdb and rust-analyzer's debugging integration. Both are _okay_ and good enough for my needs but if people are used to C#/Kotlin level integration then yeah it could be better", "id": "j41of1o", "parent": "t1_j41fey4", "vote": 7}, {"content": "I intentionally didn\u2019t want to make recommendations in the post, since this is something the Debugging WG should decide.\n\nFor example, the capabilities of `rr` are great when you have them, but aren\u2019t available on all platforms. gdb is probably the most used debugger, while lldb is part of the LLVM tooling we already rely on. There are even native Rust debuggers such as headcrab-rs. What the best choice is will depend on what you weigh the most, and it may even be the case that different options will work best for different platforms. And imo that\u2019s the Debugging WG\u2019s call to make.", "id": "j42994w", "parent": "t1_j41fey4", "vote": 7}, {"content": "While I'm mostly debug with `println!`, I believe that there are extremely good use cases for using an actual debugger.\n\nHere are a few:\n\n- concurrency \u2013 `println!` will often confuse things when there's lots of concurrency involved;\n- time-travel \u2013 see `rr` & co;\n- sometimes, you have a binary and a source code but you cannot afford to rebuild to add many `println!`, perhaps because rebuilding takes hours.", "id": "j45x2kc", "parent": "t1_j440ioj", "vote": 3}, {"content": ">IIRC, lldb support for msvc Windows has been getting better in recent years.\n\nI have like the opposite experience where in recent years the lldb and the microsoft c++ extension have increasingly been having a harder and harder time with Rust", "id": "j43nwg1", "parent": "t1_j42s0yw", "vote": 3}, {"content": "> Especially if I didn't keep forgetting about that neat dbg! macro.\n\nSilently cries in `#[no_std]` library. I'm copy&pasting a hand-rolled libc'ified `eprintln!` macro right now.", "id": "j43sabw", "parent": "t1_j43b6cy", "vote": 16}, {"content": "Thanks for the reminder, I always forget dbg!() too", "id": "j43qbl4", "parent": "t1_j43b6cy", "vote": 3}, {"content": "Try `dbg!()` :)\n\nhttps://doc.rust-lang.org/std/macro.dbg.html\n\n> You can also use `dbg!()` without a value to just print the file and line whenever it\u2019s reached.", "id": "j41fip2", "parent": "t1_j41dwlk", "vote": 77}, {"content": "[deleted]", "id": "j41fnbv", "parent": "t1_j41dwlk", "vote": 23}, {"content": "For small programs I use `dbg!` for larger applications I straight up setup `tracing` and instrument all my functions and code paths. It's a blessing when something needs debugging later down the line.", "id": "j41jmwq", "parent": "t1_j41dwlk", "vote": 18}, {"content": "[deleted]", "id": "j41l92h", "parent": "t1_j41dwlk", "vote": -4}, {"content": "I really don't mean to sound too negative but my opinion could hardly be any more different. I've been writing a lot of Go for the past few years and I thought the debugging story there is sub-par compared to Python-land from before. Both in their IntelliJ IDEs (Pycharm/Goland). Then, literally just today I tried using lldb for the first time with Rust (through CodeLLDB) and my god it's bad. Almost any data structure with a level of indirection seem to confuse it; something as simple as a `Box` in a `BTreeMap` was showing me bogus. Decoding enum variants wasn't working consistently either.", "id": "j42t5lk", "parent": "t1_j423ie6", "vote": 50}, {"content": "I completely disagree. I use IntelliJ but pythons debugging story there is a breeze. Literally just enable breakpoint and go, and you can even get dumped into an interactive session when you hit it. \n\nRust on the other hand, last I tried we still hadn't figured out how to show data structures anything more complex than Vec.", "id": "j42u1qq", "parent": "t1_j423ie6", "vote": 20}, {"content": "LLDB and GDB can be made to work. Breakpoints seem to work fine. The ability to view values in the debug session has improved recently: it's still not ideal. Setting values in the debug session is, as far as I know, not really viable for Rust at this point?\n\nThe big sticking point is the sometimes need to know the internal representation of a bunch of `std` to be able to debug. This is pretty grim.", "id": "j42lhuh", "parent": "t1_j423ie6", "vote": 13}, {"content": "In my experience, none of the breakpoints I put on lines work. I have to manually add the name of the function I want to debug to VSCode's breakpoint list to make it work. Even then, flow of code is very awkward in things like closures/iter chains.", "id": "j42upj8", "parent": "t1_j423ie6", "vote": 6}, {"content": "I just wish having a decent debugger wouldn't be editor-specific...", "id": "j42uhkd", "parent": "t1_j423ie6", "vote": 4}, {"content": "The issue is the VSCode uses some custom wrapper to give that experience. This is why other IDEs cannot keep up with it. For example, if you are a fan of neovim, then tough luck.", "id": "jiz33sn", "parent": "t1_j423ie6", "vote": 1}, {"content": "You have 20 tests per function? These functions sound too large.\n\nOr otherwise 20 tests depend on one function? This can be avoided by mocking.", "id": "j42g1mc", "parent": "t1_j41wtu9", "vote": 2}, {"content": "Sometimes it\u2019s code you didn\u2019t write, or some behavior you didn\u2019t expect. Debuggers are also useful when diving into a new code base, and understanding the flow of a program.", "id": "j43xq7n", "parent": "t1_j43gjsx", "vote": 7}, {"content": "CLion is the closest to VS, its debugging tools are way better than what you can do on VS Code", "id": "j44hied", "parent": "t1_j41w467", "vote": 6}, {"content": "This is my Rust pipe dream. First class support in Visual Studio for debugging (and tear-out tabs, sigh) would be incredible.", "id": "j420sbi", "parent": "t1_j41w467", "vote": 11}, {"content": "Big big same. That was like a golden age of programming for me, it was amazing how much it Just Worked", "id": "j42fjiu", "parent": "t1_j41w467", "vote": 3}, {"content": "I keep hearing little birdies telling me Microsoft is working on it.", "id": "j41z7tt", "parent": "t1_j41w467", "vote": 3}, {"content": "What you're describing is possible for Rust via Pernosco, which is built on top of rr by the rr maintainers: https://pernos.co/ . At least a few developers of the Rust project itself are Pernosco devotees.", "id": "j425e7f", "parent": "t1_j41z3lv", "vote": 15}, {"content": "[deleted]", "id": "j42d3hb", "parent": "t1_j41z3lv", "vote": 6}, {"content": "Well, maybe a bit beyond that. Some of the scopes contain (derived) expressions that are _only_ useful when debugging but present overhead during program execution. Display-formatted variables are just a very basic subset of such expressions.\n\nFor some buffer manager it may be extremely relevant to observe the sum of two classes of buffers at all times during a function execution. For a symbol encoder/decoder it could be relevant to observe a composite expressions such as (fictional syntax):\n\n    fn derive(&self, cur_bits: u16) {\n        dbg_watch!(self.code_table[cur_bits as usize]);\n    }\n\nThe 'generic' object-tree is often too unspecific here, while it would print `self.code_table` and `cur_bits` individually I can't spot 'cur_bits happens to be 216 and the 216th entry is' by eye. Meanwhile, it can not be computed outside the debugger since it might just be invalid (good debuggers could presumably recover from the segfault, though). Since, as the code author, I know this value to be relevant it would be incredibly helpful if I didn't have to do the dance of setting this watchpoint up manually each time or in each IDE session. And scripting interfaces introduce a very different kind of overhead, too, from another language etc.etc..\n\nI'd just like everyone working on the code to get the combined contributors insight into debugging, not a singular setup; with familiar syntax to add their own.", "id": "j435vzo", "parent": "t1_j41z3lv", "vote": 2}, {"content": "Debuggers help you see the tree, tracing let's you see the forest.  They help with different scales of problems.  \n\nWhen I'm using traces, I want to understand how the different interactions got me to that point.  In theory, you can do that with breakpoints but\n\n- You have to know where to insert the breakpoints.  When I've used traces for debugging, the traces helped me understand what those points I would care about\n\n- You have to manually build up the context from each snapshot the breakpoint gives you while traces build up the context automatically", "id": "j41rsq7", "parent": "t1_j41qsx1", "vote": 13}, {"content": "Not necessarily.\n\nImagine for example that you have code like:\n\n   let result = network_call().await;\n\n   log!(\"Network call took {elapsed} to complete\", elapsed = start.elapsed());\n\n   result.unwrap()\n\nAnd you break on the `rust_panic`.\n\nThat's cool, you know that `result.unwrap()` panicked. _Why_ is there an error there, though? You've got no idea. You don't even have a backtrace pointing you at the piece of code that created this error in the first place.\n\nYou either want traces, or a time-machine.", "id": "j42dkrj", "parent": "t1_j41qsx1", "vote": 6}, {"content": "90% of my errors occur long after the buggy function was executed that caused a wrong value to be returned or stored somewhere.", "id": "j424nza", "parent": "t1_j41qsx1", "vote": 2}, {"content": "I want to step through the output in a debugger, which afaik isn't possible right now", "id": "j4227en", "parent": "t1_j41uv1a", "vote": 7}, {"content": "Yes, but it sticks a sane interface over it.", "id": "j42tcna", "parent": "t1_j42drpp", "vote": 10}, {"content": "I would not describe the debugging (and build system at large) experience of any supported language (even via a plug-in, and there are so many supported officially that I won\u2019t bother listing them here) in the Jetbrains suite as an interface around {tool}\u201d.\n\nI guess you juste have to try it, even for a simple project. There is a free trial period. I used IntelliJ Ultimate ( for free and yes, legally) and Rider for some specific languages or ecosystems (Rider is very good for Unity projects, at least a few years ago it was). The same thing goes for Visual Studio (and Jetbrains started making money with a plug-in for it. It was almost \u201cmandatory\u201d at the time for large codebases, nowadays I don\u2019t think so much).\n\nAnd yes, I do use Visual Studio Code for basically everything since it launched. The Rust experience is incredible, for instance I noticed it now indicates how a tagged union (enums) is packed in memory, simply when hovering the type!  The Jetbrains alternative to rust-analyser is incredible, but I do not use it, simply since any Jetbrains tool fells too heavy (and no, it has nothing to do with them using Java, it\u2019s mostly architecture related and there is an effort to fix many issues with a next-gen platform called Jetbrains Fleet).\n\nIf you want to know, I started using Rust almost 10 years ago now, and I still do. Sorry for the rant :)", "id": "j45z7r1", "parent": "t1_j43181i", "vote": 1}, {"content": "[deleted]", "id": "j430ue3", "parent": "t1_j42wn6n", "vote": 1}, {"content": "why are those traits even needed for a debugger? the debug info emitted by the compiler should be enough, no?", "id": "j43rajh", "parent": "t1_j42xba7", "vote": 1}, {"content": "How so. They said that it's difficult because Apple *makes* it difficult to use a debugger other than the one they ship on the install discs for macOS.\n\nYour response feels like a milder version of \"We need to own the browser experience on iOS. Therefore, we need to design and ship a jailbreak so we can use our own rendering engine.\"\n\nDigging your heels in against \"The platform vendor makes it difficult to install and run an unauthorized build of the debugger\" doesn't seem like the smart way to make things easier for users. In fact, it reminds me of the time Google wasted before accepting that libSystem was the point of ABI stability for the OSX kernel in Go 1.12 and later.", "id": "j4bufgj", "parent": "t1_j496nme", "vote": 2}, {"content": "Good to know, thanks. I hadn't checked in on the msvc support since the LLVM team started working on it. Your comment compelled me to go check on it.\n\nhttps://lldb.llvm.org/status/status.html\n\nLooks like it has stalled out :/", "id": "j47nud2", "parent": "t1_j43nwg1", "vote": 1}, {"content": "You not able to pull in [`defmt`](https://lib.rs/crates/defmt) instead? Tends to be well used in the embedded envs already so if thats the space, might not even get noticed by consumers of it if you plan to open it up to the rest of the world.", "id": "j483xzb", "parent": "t1_j43sabw", "vote": 8}, {"content": "TIL", "id": "j41ibya", "parent": "t1_j41fip2", "vote": 25}, {"content": "`dbg!()` is great, you can write something like `let x = dbg!(broken_function());` to both print and assign on the same line", "id": "j421jrq", "parent": "t1_j41fip2", "vote": 28}, {"content": "I notice that it doesn't know how to evaluate Rust expressions, though.", "id": "j41v4ep", "parent": "t1_j41fnbv", "vote": 9}, {"content": "for me i sometimes i cant use vscode to run my projects because its only available as a flatpak to me (fedora) and that means it doesnt have access to system libraries so if im working on a gtk project it just says the linker failed to find the libraries", "id": "j425rhj", "parent": "t1_j41fnbv", "vote": 2}, {"content": "Agreed.\n\nLogging is useful as a post-incident investigation. Without logs, you've got no idea what happened. With good logging, you at least have a reasonable idea of the events prior to the issue, and may be able to formulate a hypothesis.", "id": "j42cvzc", "parent": "t1_j41jmwq", "vote": 11}, {"content": "Same. Coming from Go I thought there are still many improvements CodeLLDB or Rust can do to make the debugging experience even more painless, especially in the iterators area.", "id": "j43p5v7", "parent": "t1_j42t5lk", "vote": 4}, {"content": "if you are up to it, you can write gdb python extensions for the std lib. i have something similar to help with c++ stl.", "id": "j43ckl7", "parent": "t1_j42t5lk", "vote": 1}, {"content": "> it's still not ideal\n\nI agree, but that's the same for C and C++ too. Maybe I'm just too used to that!\n\n> Setting values in the debug session\n\nYeah again, basically impossible in C/C++ too. I guess it depends on whether you are used to debugging languages like Python and JavaScript or languages like C and C++.\n\nBut I still agree it would be great if it was better and I think making it better is very achievable.\n\nEdit: Why the downvotes? I don't think I've said anything untrue or controversial.", "id": "j42qzgb", "parent": "t1_j42lhuh", "vote": 0}, {"content": "It doesn't have to be! Read the bit in the article about DAP. It's LSP for debugging.", "id": "j43dhry", "parent": "t1_j42uhkd", "vote": 4}, {"content": "I'm pretty sure CLion has a similar debugging experience. I'm not really sure what you mean by a \"custom wrapper\". Do you mean the Debug Adapter Protocol? That's just their standard protocol for talking to debuggers, like LSP for debugging. Other IDEs can also use it if they want, or implement something else (like CLion).", "id": "jiz75pk", "parent": "t1_jiz33sn", "vote": 1}, {"content": "I guess that that would depend. It might be a more-complex-but-conceptually-simple API, like [something that parses a language and emits something else](https://docs.rs/rsass/latest/rsass/fn.compile_scss.html).", "id": "j431gv1", "parent": "t1_j42g1mc", "vote": 3}, {"content": "yeah my testing isn't particularly great, it's the latter and it's just my being lazy while writing the tests (it's just for debugging, it's just a quick check, whatever) but it builds up and basically becomes technical debt lol", "id": "j434dml", "parent": "t1_j42g1mc", "vote": 1}, {"content": "So far it looks more like having to deal with VSCode and a crappier experience than dealing with C++/WinRT.\n\nI guess we can dream.", "id": "j42aqqx", "parent": "t1_j41z7tt", "vote": 4}, {"content": "Does it just look like that at first glance or is that a hosted service where even the paid tiers (excluding the business one, talk to us about price) only have a small number of uploads per month?", "id": "j45r5ia", "parent": "t1_j425e7f", "vote": 3}, {"content": "Oh, that's great news! In that case I'll try it if I ever find myself reaching for a debugger.", "id": "j42dcso", "parent": "t1_j42d3hb", "vote": 1}, {"content": "Interesting, I've never used traces before. Is that a tool similar to a debugger?", "id": "j41s74i", "parent": "t1_j41rsq7", "vote": 2}, {"content": "You can use this: https://doc.rust-lang.org/beta/unstable-book/library-features/trace-macros.html\n\nWhich does require nightly, but should be fine as you only need to enable the feature when you're debugging your macro (I always use nightly so it's never a problem for me \ud83d\ude01)", "id": "j436440", "parent": "t1_j4227en", "vote": 1}, {"content": "I think it's the \"it also costs $99 a year\" part that's the more important detail.\n\nThe days when a language could be competitive when the \"recommended experience\" had a non-$0 price tag are long gone.", "id": "j4d7wsl", "parent": "t1_j45z7r1", "vote": 3}, {"content": "Yeah, let's all listen to the _most well-paid professionals ever_ bitch about paying the cost of 1.5 AAA games _per year_ for a tool which doubles their productivity.", "id": "j4337m1", "parent": "t1_j430ue3", "vote": 4}, {"content": "Not always.  For example the reason we pretty-printing to gdb is that a C++ container typically contains both your data, plus a lot of implementation stuff that you might not know anything about.  Worse, it's possible to implement things in very non-obvious ways, so that while the debuginfo is correct, you will not see your own data in there if you dump the data structure (this occurs in a couple of spots in libstdc++).  So, some kind of custom visualizer is useful -- both to reduce the noise, but also sometimes to even locate the thing you're really interested in.", "id": "j44n5xl", "parent": "t1_j43rajh", "vote": 3}, {"content": "Absolutely, and nope! For the same reason that we have custom `Debug` implementation logic, actually.\n\nTo elaborate on /u/tromey's sibling comment, many debuggers _do_ take advantage of structure layouts embedded in debug info to present them when no custom visualization is provided. Think of it like a derived `Debug` impl. However, the naive presentation might not be good enough, if not objectively bad. Let's return to the example of a `Vec` from GP. It's consists of a pointer, a length, and a capacity. Having this visualized from naive debug info a la `Debug` would give us:\n\n```\nVec { ptr: 0xDEADBEEF, capacity: 9001, length: 4 }\n```\n\n...which is generally not going to be nearly as useful as the current `Debug` implementation:\n\n```\n[1, 2, 3, 4]\n```", "id": "j49bcjt", "parent": "t1_j43rajh", "vote": 2}, {"content": "I have VSCode installed natively on fedora. You just need to [add their repo](https://code.visualstudio.com/docs/setup/linux#_rhel-fedora-and-centos-based-distributions). It works quite well.", "id": "j44p3tz", "parent": "t1_j425rhj", "vote": 2}, {"content": "Vscode has an rpm repo available fwiw", "id": "j42qelb", "parent": "t1_j425rhj", "vote": 1}, {"content": "Everything works fine in C? I use these features there extensively. C is the language these debuggers were built for. Can't speak to the C++ experience too much, but the other day I used `gdb` with some old C++ and it seemed to work fine\u2026", "id": "j42tijy", "parent": "t1_j42qzgb", "vote": 16}, {"content": "> I agree, but that's the same for C and C++ too. Maybe I'm just too used to that!\n\nI definitely expect better from Rust. Well, I mean I mostly just expect it to be a better experience than print debugging. I can easily use `Debug` impls when print debugging. If I can't do that with the debugger then I'm not going to bother unless I'm really desperate.\n\nI'd actually hope for an experience much better than print debugging. If I could derive some other trait and get a browsable tree representation of my type (like JS debuggers will do) then I'd use the debugger all the time.", "id": "j43tzdo", "parent": "t1_j42qzgb", "vote": 3}, {"content": "I know about DAP, but it can be a pain to get working, especially since Rust forks gdb and lldb for debuggers.", "id": "j43fdgv", "parent": "t1_j43dhry", "vote": 4}, {"content": "(Disclaimer: I'm involved in Pernosco.)\n\nAt $50 a month you get 50 uploads a month which is more than almost anyone would use. You typically don't need more than one upload per bug.\n\nIt would be great if we could give Pernosco away for free, but it costs money to operate, plus of course developers have to eat.", "id": "j4k0mou", "parent": "t1_j45r5ia", "vote": 2}, {"content": "Looks like that to me", "id": "j4a1vvr", "parent": "t1_j45r5ia", "vote": 1}, {"content": "I've not used `tracing` yet but used an internal tracing C++ library in a past job.  Its just a fancy form of printf debugging\n\n- Like `log`, it was always active in debug builds and is turned on/off at runtime\n- The function call start/end along with specific arguments/return types get captured.  In my case, function calls were indented for easier scanning", "id": "j41tkn3", "parent": "t1_j41s74i", "vote": 6}, {"content": "They mean at runtime, that's only helpful at compile time afaik", "id": "j45hcf2", "parent": "t1_j436440", "vote": 3}, {"content": "Can we please stop this thread and resume conversation on the actual topic?", "id": "j45x9ov", "parent": "t1_j4337m1", "vote": 1}, {"content": "It's not about what a Microsoft employee can pay. It's about marketing Rust to developers of other languages who are used to either getting everything for free or who might be used to something like XCode or Sublime Text and not want to pay for *another* tool to get the supposedly equivalent experience for a language they already use.\n\nLess \"I don't want to pay\" and more \"We don't want Rust to come off as 'Rust is great. All you have to do is pay $99 and learn Vim. You'll see!'.\n\nIt's a \"How is Netscape/Delphi/etc. supposed to convince people to switch from competition that's 'good enough' and giving away their offering for free?\" situation... except that this isn't VSCode vs. Sublime Text, it's Ada vs. C. It's not just a tool, but a skillset and ecosystem to learn and become dependent on.", "id": "j4d8qv3", "parent": "t1_j4337m1", "vote": 1}, {"content": "why wouldn't you see stuff in there I mean if your intentionally hiding it which I think is dumb always then unhide it until you finished debugging. I don't like opaque structures especially on what is supposed to be a system programming language. That's kind of your own fault then. stop hiding stuff and then everything just works I mean is it really worth it? I had to have a boatload of python scripts to interpret STL and other libraries because of that shit", "id": "j44nlyr", "parent": "t1_j44n5xl", "vote": 0}, {"content": "oh. You're just format it well enough the information is there it's just doesn't display it in a useful form.\n\nyeah that's of course GDB sucks at showing anything useful for a game how much data can we put on the screen and not give you any useful information to bug. I thought you were saying that it just lacked the information entirely. I mean that sounds more like a job for GDB python extensions. I haven't really seen anybody pushed the bounds of those hard. other couple years ago a GDP over a browser and I use those to do some very  immoral things along with GOTTY.\n\nthat's what SVG fraphics was made for right bugger information. could have sport was in the white paper.\n\nway back in the day there used to be a box and pointer diagram maker for GDP to get your nice like trees and linked lists with  boxes in pointers popped up  and even occasional value printed properly forgot what it was called though great for learning.", "id": "j49qjl1", "parent": "t1_j49bcjt", "vote": 1}, {"content": "You can get a browsable tree representation. That works already. I presume you mean a *custom* one which I agree would be sweet.", "id": "j44072b", "parent": "t1_j43tzdo", "vote": 1}, {"content": "A SaaS model just feels very strange for a debugger. You couldn't use it for anything working with data or code you can't share for some reason.", "id": "j4k0u00", "parent": "t1_j4k0mou", "vote": 5}, {"content": "I've not used `tracing`, but I have used both  Percepio Tracealyzer and Segger JTrace with Segger Ozone. Tracing is potentially a lot more than function calls. Interrupt handlers, cpu load, memory pressure, thread interactions, dma transfers, etc, all tracked and possible to graph/visualize. Percepio's [demo video](https://percepio.com/tracealyzer-4-demo/) is good.\n\nAt least with STM32 chips, there's even some hardware tracing built in. The ITM can trace watchpoints, interrupts, periodically sample the program counter, etc. The ETM can trace every single CPU instruction executed, indirect branch target addresses, etc.\n\nSo for embedded systems, tracing is more like a full stack trace and register view that updates in real time than it is like printf debugging.", "id": "j42xjq8", "parent": "t1_j41tkn3", "vote": 2}, {"content": "Macros do not exist at run time.", "id": "j45rbzl", "parent": "t1_j45hcf2", "vote": 1}, {"content": "\nwhen are the times when did a bugger can't figure it out? is it only when people hide it? I can't really imagine another case unless the like dwarf info is specifically hobbled", "id": "j44nt38", "parent": "t1_j44nlyr", "vote": 0}, {"content": "You can? Which tool can do that?", "id": "j4423dn", "parent": "t1_j44072b", "vote": 1}, {"content": "There's some truth to that especially at our small scale. But if say Amazon offered SaaS debugging as part of AWS ... you're already trusting AWS with your code and data.\n\nAnd FWIW Pernosco is architected so that we don't see your source code.\n\nWe do offer a self-hosting option for businesses that can't use SaaS, and we have some customers for that.", "id": "j4pfnpt", "parent": "t1_j4k0u00", "vote": 1}, {"content": "The code they generate (their \"expansion\") does, that's what they want to step through. If you install and run cargo-expand on a hello world project you'll see what they mean.", "id": "j461v7t", "parent": "t1_j45rbzl", "vote": 4}, {"content": "The point is the hiding is done by a library whose source you don't control.  So while the debuginfo correctly describes the code, it still is insufficient to show you your data -- which is what you were asking about.", "id": "j4c1ibu", "parent": "t1_j44nt38", "vote": 1}, {"content": "VSCode + codelldb IIRC.", "id": "j45j7dg", "parent": "t1_j4423dn", "vote": 1}, {"content": "I meant more of a question of does tithing through like the syntactic means like pub and stuff I guess then some of these stuff coming out does it change the debug info? and is hiding just like casting to void to see and then casting back inside the library which of course kind of hides it a little bit but I don't know if the rust syntactic stuff did", "id": "j4dcv2u", "parent": "t1_j4c1ibu", "vote": 1}], "link": "https://www.reddit.com/r/rust/comments/109yf4d/blog_rust_should_own_its_debugger_experience/", "question": {"context": "", "id": "109yf4d", "title": "[blog] Rust should own its debugger experience"}, "resource": "Reddit"}, {"answers": [{"content": "> And the reason so many APIs are bad isn't because someone designed a bad API -- it's that they didn't even realize they were designing an API to begin with. \n\nThe Money Quote if you ask me. \n\n(related via *the programmers think they can just look at examples of the output and figure out an API from that.*)", "id": "dov8lqc", "parent": "t3_78n07u", "vote": 539}, {"content": "The most reliable  gdb-based debugger that I have seen was Insight\n\n\nProbably because afair they did not parse the output, but linked against gdb and called internal functions\n", "id": "dov5wsk", "parent": "t3_78n07u", "vote": 77}, {"content": "This is a great post that has one flaw: it misses the forest for the trees. In the course of griping about wrapping a command-line utility being the wrong answer, the author misses a key reason why wrapping command-line tools doesn't work in the cases where it doesn't work: the GUI developer discards error information. \n\nNot all users need detailed error info, but for those who do, it is the difference between spending hours frustrated at something that is impossible to diagnose and fixing a problem in two minutes. This lack of transparency is what makes these wrappers so miserable - the underlying command-line tool can fail in a number of specific, well-defined ways, but without knowing which error occurred, it becomes nigh-impossible to trace the origin of a failure.\n\nThe moral of the story is: build tools that can be diagnosed and repaired. Don't discard error data. And don't obfuscate things from your users.", "id": "dov57r7", "parent": "t3_78n07u", "vote": 117}, {"content": ">That's the only debugger\n\nThere's LLDB as well. Doesn't really solve any of these complaints though.\n\nC++ debugging kinda sucks in general, compared to pretty much any higher-level language.", "id": "dov44j2", "parent": "t3_78n07u", "vote": 71}, {"content": "This is a very well written post with excellent images and quotes supporting the point made :)", "id": "dov2ixz", "parent": "t3_78n07u", "vote": 108}, {"content": "> You see, on UNIX there's GDB. That's the debugger. That's the only debugger.\n\nFunny... I've been using LLDB exclusively on BSD, Linux, and macOS for years now.\n\nAnd it's entire code base, much like LLVM, is written to be re-usable and modular.  It's code base 'is' the API (and there's even python wrappers for it to boot).\n\nThe only thing I'd say LLDB lacks is a higher level API wrapping it up into a simpler debug session protocol using language semantics, s.t. it was unambiguous 'how' to do something w/ the API (as opposed to being thrown it's entire code base and saying \"here, you can debug now!\").", "id": "dow17er", "parent": "t3_78n07u", "vote": 9}, {"content": "I'm not a pessimistic person, so I'm pretty impressed by the fact that Internet works at all, and I do think that people do produce good code, occasionally. That said, I also enjoy articles like this. eg. [Tout est Terrible](https://ferd.ca/tout-est-terrible.html) and others I can't find write now.\n\nHowever, this is my [all time favourite](https://www.stilldrinking.org/programming-sucks).", "id": "dovdmwg", "parent": "t3_78n07u", "vote": 14}, {"content": "I'm not sure I agree. What the author describes as weaknesses I believe are strengths.\n\nTake this ...\n\n>So much user-facing network software is built on top of other programs, like ssh or rsync, and when those things fail they just don't know what to do.\n\nYou are right they do not, but I do. The separation of concerns here makes the debugging exercise easier. When using MacPorts over `rync` and I see `rsync` failures I don't have to trouble myself with the arcane voodoo of MacPorts. I just start debugging the `rsync` problem. Every good debugging exercise starts with compartmentalization.\n\nCustom software that is \"bolted\" together may run more \"consistently\", but its opinionated nature makes diagnosis tricky. You have to understand how all the things are glued together and you can't rely on cultural/historical understanding of the various layers to give you clues. You have to start from scratch. \n\nFurthermore you can't escape the layers and composition. Surely the author is not proposing writing sockets, interrupt handlers, kernels, and device drivers from scratch for every application. You will always be subject to embedding someone else's software in your own.\n\nFinally the old Doug Gwyn maxim ...\n\n*UNIX was not designed to stop its users from doing stupid things, as that would also stop them from doing clever things*\n\nThe piping, stacking, and modularization of Unix has always been one of its strengths. This is in part because you can dream up all sorts of novel approaches to problems. Have you ever reclaimed a disassociated file by calling `cat` on a `dev` file and piping to `grep` to isolate the file's contents independent of the `inode`? The composability of commands is one of the best things Unix has going. Do you think the author of `cat` was thinking I'd be using it to recover some fat finger? No they said \"its useful to stream the contents of a file to standard out\" they left it up to my imagination to come up with the application.", "id": "dov8lsc", "parent": "t3_78n07u", "vote": 41}, {"content": "This covers some of my frustrations today very, almost eerily, well. ", "id": "dov5dub", "parent": "t3_78n07u", "vote": 13}, {"content": "[deleted]", "id": "dovbv6a", "parent": "t3_78n07u", "vote": 33}, {"content": "https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/\n\n> All non-trivial abstractions, to some degree, are leaky.", "id": "dov9bxf", "parent": "t3_78n07u", "vote": 14}, {"content": "I think part of the issue is a lot of the other CLI tools he mentioned, are all one-shot utilities. You give it some information, you get a response, or it downloads something, or it installs a package, or whatever. It is time-bounded. \n\nA tool like GDB is more of a daemon, in that it requires state and that state can't really be passed around so that you can break it up. What do you want? A program that reads the state of the processor? You can already do that. A program that halts the process? You can't run that and be time-bounded. And the list goes on. GDB is basically atomic in that it does a function that can't be represented by time-bounded programs executing in a chain. \n\nAnd that's kind of the problem with his assertion. Making a CLI like GDB is not the problem. If the person integrating it has made an error in judgement, then that's on the person doing the integration. Solution; make the calls you send to GDB server available to the user so they can sanity check. As long as you aren't obfuscating the connection you should be OK.", "id": "dovj81j", "parent": "t3_78n07u", "vote": 8}, {"content": "This is a rather poorly thought-out rant, methinks.\n\ngdb has an API. It might be shit, but it does have it.\n\nAny cmdline utility should have it, too. Some do, there's curl and libcurl, there's zlib and its shell support etc. When that is te case, shame on the app developer who used system().\n\nAs for error information, yes, programs lose it. That's  because they are poorly written. Providing good error information is hard, people cut corners or are inexperienced and don't know how to collect it and/or present it. But that is not rotten to the core, that's unfinished.", "id": "dovds4a", "parent": "t3_78n07u", "vote": 16}, {"content": "> Like Homer's pecking bird in the Simpsons\n\nThat shows that Homer was a practical genius.", "id": "doveeey", "parent": "t3_78n07u", "vote": 8}, {"content": "I feel the pain. KDevelop refuses to work with gdb if you install additional scripts(e.g. pwndbg). The refusal starts at the very beginning if these scripts print anything with \n something like \"You have gdb version of 'Added 112 commands', make sure you have gdb version 6.0 at least\" and I was told it doesn't get better anyway as kdevelop expects vanilla output.\n\nSo apparently there's either no way of getting it while leaving the user with scripts, or it's too hard and kdevelop is too lazy. Either way, no `dq` for me from inside of IDE as I'm can't be bothered to remove all prints or copy-paste implementation of this command to the new file.", "id": "dov2q29", "parent": "t3_78n07u", "vote": 5}, {"content": "Wait a minute. The author uses Microsoft's Visual Studio through QT Creator on Windows but he bitches about... gdb?\n\nhttps://wiki.qt.io/Qt_Creator_Windows_Debugging", "id": "dovrloc", "parent": "t3_78n07u", "vote": 6}, {"content": ">Jeff Goldblum said it best in that famous scene from Jurassic Park:\n\n>>The problem with the scientific power you've used is it didn't require any discipline to attain it. You read what others had done and you took the next step. You didn't earn the knowledge yourselves, so you don't take the responsibility for it. You stood on the shoulders of geniuses to accomplish something as fast as you could, and before you knew what you had, you patented it, packages it, slapped in on a plastic lunch box, and now you want to sell it.\n\nI prefer: \"your scientists were so preoccupied with the question of whether or not the could, they never stopped to consider whether or not they *should*\"\n", "id": "dowtkro", "parent": "t3_78n07u", "vote": 2}, {"content": "\"Libraries\" that wrap command line utilities are one of the worst kinds you can encounter. I try to avoid them as much as possible but still everything seems to be built on them. openssl based libraries use the commandline tool instead of the library, ssh libraries use subprocess stuff instead of libssh. the same with gpg. Not only will these abstractions never be perfect, they are also pretty slow.", "id": "dow1vjg", "parent": "t3_78n07u", "vote": 3}, {"content": "*You see, on UNIX there's GDB. That's the debugger. That's the only debugger.*\n\nNo.  It's not the only debugger (that's like saying ksh is the only shell because that's all you've encountered to date).  GDB is not even the best debugger depending on what you're trying to do.  But it is flexible, free and widely available on a lot of platforms.\n", "id": "dovrykx", "parent": "t3_78n07u", "vote": 3}, {"content": "> You've all seen those cheap Chinese toys that look like a PlayStation, but inside its just a 6502 and 50 NES games. \n\nUnderrated comparison, although it won't resonate with most born after 1995.", "id": "dovgett", "parent": "t3_78n07u", "vote": 1}, {"content": "The blog post reads like a complaint against the status quo. The modern world is made out of layers. The comment from character Ian Malcolm in Jurassic Park pretty much encapsulates this: \n\n> The problem with the scientific power you've used is it didn't require any discipline to attain it. You read what others had done and you took the next step. You didn't earn the knowledge yourselves, so you don't take the responsibility for it. You stood on the shoulders of geniuses to accomplish something as fast as you could, and before you knew what you had, you patented it, packages it, slapped in on a plastic lunch box, and now you want to sell it.\n\nThat's how the modern world works. We all do exactly what Ian Malcolm complains about when we drive a car or use a GPS system or make an internet blog post, or comment on one.  Everything is layered on everything else and we don't have to understand how it all works to make use of it.   It exactly this point that Mr. Mitton in his post seems to have missed about gdb.  Gdb is an API.  It is an API in the same sense that HTTP or FTP or SMTP are.    And just as REST sits on HTTP so to do higher level debuggers like ddd and Emacs debug mode sits on gdb.  Missing this point is pretty much missing reason for layered architectures all together.\n\n", "id": "dovdzzn", "parent": "t3_78n07u", "vote": 4}, {"content": "Powershell is superior to bash.", "id": "dovjrde", "parent": "t3_78n07u", "vote": 4}, {"content": "This points to things I've complained about here for years that few seem to understand so it's interesting this hasn't been downvoted. \n\nThere are flaws in his logic and assumptions, his comments about the use of gdb for one, but that shouldn't cloak the overall point and definitely not the Unix philosophy of doing one thing and doing it well. ", "id": "dov5xnl", "parent": "t3_78n07u", "vote": 3}, {"content": "Hmm, gdb is easy to throw mud at....... until you really understand what it is doing.\n\nIt has a vast vast vast bundle of functionality, facing away from you.\n\nWe feel belittled, \"Hey gdb, pay attention to ME, I'm THE USER, I'm KING\".\n\nExcept gdb is frantically paddling underneath coping with multiple os's, multiple cpu's, multiple languages, optimizers buggering things up totally for the debugger,   a vast array of historical proprietary legacy kruft, crappy embedded systems with half arsed debug monitors in them, half-arsed support from the various RTOS's it works with, multiple threads doing strange stuff......\n\nBut all we see and whinge about is the tui.\n\nps: Use emacs. It's a good gui on gdb.\n\nThere is a library API onto gdb.\n\nhttps://sourceware.org/gdb/current/onlinedocs/gdb/Guile-API.html#Guile-API\n\nIt's sort of irritating.\n\nThe level is weird...\n\nYou want the tui... but better.\n\nThe guile api is at the level of something you might write the tui in.\n\n", "id": "dovtjzu", "parent": "t3_78n07u", "vote": 1}, {"content": "I feel like a lot of people in this thread are missing the point", "id": "dowp4jd", "parent": "t3_78n07u", "vote": 1}, {"content": "Fantastic read. I didn't expect it to be relevant to me, but the Jurrasic Park part was great. ", "id": "dp4jq6g", "parent": "t3_78n07u", "vote": 1}, {"content": "The problem is not directly related to using library vs program. You can design interface to application so that reports about errors. You can design interface to library so that it does not.\n\nUsing the human interface directly is naturally not the best choice, there should be some more formal one", "id": "dov41zu", "parent": "t3_78n07u", "vote": 1}, {"content": "You've quite aptly explained the problem. What do you think the solution is?", "id": "dovcfqv", "parent": "t3_78n07u", "vote": 1}, {"content": "Leadership: We'll have our golden children make all the APIs in a silo.\n\nMe: But whose going to make sure the clients can actually work?\n\nLeadership: Were okay with chatty apis. I'm sure if you just keep calling around, you'll eventually get everything. The user's browser is fast nowadays.\n\nMe: Will, I'm not one of your desperately unfortunate users, so I guess I don't care.", "id": "dovgohk", "parent": "t3_78n07u", "vote": 1}, {"content": "This article have great examples for my hatred with \"classic terminals\" like unix's bash and the cmd, those archaic tools were good for when you had some weak mainframe and even weaker terminals, the only legit way to pass data around modules (i.e programs) was strings, this  was fine back than, but for now, this method doesn't cut it, and that is why I stand by powershell (yes the syntax is horrible...) that has a \"real\" dynamic type system and modules are real modules", "id": "dovjv2e", "parent": "t3_78n07u", "vote": -1}, {"content": "> Nothing had changed, at least so I thought. So why the failure? It turned out, after some experimentation, to be because Microsoft's symbol servers were down. That's right, a remote failure on someone else's part meant I couldn't debug locally.\n\nSo you\u2019re mad about Microsoft\u2019s servers, yet implicating the entire Unix architecture? Yeah ok. This entire fluff piece with gratuitious quotes could be summed up in 4 words (maybe 7): *handle your fucking errors[, god damn it]!*", "id": "dow0d5r", "parent": "t3_78n07u", "vote": -1}, {"content": "Spends the first half of the blog post complaining about gdb. Complains about debugging in Qt using msvc. Sooooo..... so dumb.", "id": "dovk7sj", "parent": "t3_78n07u", "vote": 0}, {"content": "Oh... so cute, the author decries the software layers! We should all be using KA9Q for the OS. Emphatically NO. Windows sort of tried to do this and failed miserably (good riddance). Layers and separation of concerns. Build new by standing on the shoulders of giants. A project that tries to reinvent everything is most likely doomed to fail. A few sticks and duct tape for a prototype is a sign of a successful project.", "id": "dovpsy2", "parent": "t3_78n07u", "vote": 0}, {"content": ">...a separate piece of software that would show a nice user interface, but internally would call GDB to do the work.\n\n>We're not talking about calling out to a library here. We're talking about actually launching an instance of GDB, passing it commands, and parsing the results it prints out. And this is where we get led down a dangerous path.\n\nI don't get why this is worse than \n\n> piping the output from grep into sed and then into sort\n\nnor do I get what the alternative is.", "id": "dovfqdn", "parent": "t3_78n07u", "vote": 0}, {"content": "also rotten to the core.", "id": "dov3r0w", "parent": "t3_78n07u", "vote": -3}, {"content": "The UNIX Philosophy works, it cannot be challenged.", "id": "dow69b5", "parent": "t3_78n07u", "vote": -3}, {"content": "Run GDB in Emacs, mo{r}+on.", "id": "dow84no", "parent": "t3_78n07u", "vote": -1}, {"content": "Bitch, please. There have been GUIs for gdb since 20 years ago. No-one uses them because of scriptability, which is very important.", "id": "dow5p9c", "parent": "t3_78n07u", "vote": -2}, {"content": "Unintentional design is almost always bad design. ", "id": "dovclbs", "parent": "t1_dov8lqc", "vote": 141}, {"content": "A few weeks ago we had a bug report from a user that had done some automation through a mouse movement/click recorder. We broke it by maximizing our \"API\" on startup.", "id": "dovx793", "parent": "t1_dov8lqc", "vote": 45}, {"content": "Anybody does blind test of APIs ? submit different ones to random devs, asks them to come up with a solution using it in 10mins, see which one helps", "id": "dovx3cq", "parent": "t1_dov8lqc", "vote": 9}, {"content": "Thats the secret: just treat all code as API.", "id": "dovsfp7", "parent": "t1_dov8lqc", "vote": 16}, {"content": "What do you think about GraphQL as a scalable solution to evolving APIs?", "id": "doviqa6", "parent": "t1_dov8lqc", "vote": -16}, {"content": "When I was tinkering with debugging earlier in the year I ultimately gave up on GUI wrappers altogether.  Much better were text based UIs like [voltron](https://github.com/snare/voltron) which work alongside gdb's CLI", "id": "dovgecs", "parent": "t1_dov5wsk", "vote": 27}, {"content": "Insight and tkgdb were the two best GUI frontends for GDB.  The latter was a frontend wrapper but it did a fine job.  Haven't seen it since the 1990s but it was a lifesaver in college.\n", "id": "dovsbp6", "parent": "t1_dov5wsk", "vote": 5}, {"content": ">afair\n\nas far as I remember? Afaik 'IIRC' is better.", "id": "dovfdzf", "parent": "t1_dov5wsk", "vote": -4}, {"content": "*Transparent* wrappers are indeed fantastic. They're also harder to get right than they seem + many people try to abstract things they shouldn't, which is what leads to the situation the writer is complaining about.\n\nI work on backend development automation, and nearly everything I do is some form of wrapper", "id": "dovb2bp", "parent": "t1_dov57r7", "vote": 35}, {"content": "The only way to do this is to return the error at every level. If the failure chain is\n\n* get monthly totals failed\n* because monthly-spreadsheet.odt failed\n* because account-groups failed\n* because data request failed\n* because entry 17 failed\n* because unicode error\n\nthen telling the user \"unicode error\" doesn't help, and \"monthly totals failed\" doesn't either. (S)he needs to be able to drill down through the entire failure stack, ergo, you need a list-like failure object.", "id": "dovkp3d", "parent": "t1_dov57r7", "vote": 34}, {"content": "> Don't parse.\n> I have discovered that there are two types of command interfaces in the world of computing: good interfaces and user interfaces.\n> \n> The essence of user interfaces is parsing: converting an unstructured sequence of commands, in a format usually determined more by psychology than by solid engineering, into structured data.\n> \n> When another programmer wants to talk to a user interface, he has to quote: convert his structured data into an unstructured sequence of commands that the parser will, he hopes, convert back into the original structured data.\n> \n> This situation is a recipe for disaster. The parser often has bugs: it fails to handle some inputs according to the documented interface. The quoter often has bugs: it produces outputs that do not have the right meaning. Only on rare joyous occasions does it happen that the parser and the quoter both misinterpret the interface in the same way.\n> \n> When the original data is controlled by a malicious user, many of these bugs translate into security holes. Some examples: the Linux login -froot security hole; the classic find | xargs rm security hole; the Majordomo injection security hole. Even a simple parser like getopt is complicated enough for people to screw up the quoting.\n> \n> In qmail, all the internal file structures are incredibly simple: text0 lines beginning with single-character commands. (text0 format means that lines are separated by a 0 byte instead of line feed.) The program-level interfaces don't take options.\n> \n\n(from http://cr.yp.to/qmail/guarantee.html )\n\n", "id": "dovs5p7", "parent": "t1_dov57r7", "vote": 13}, {"content": "I agree. Wrappers are not,  in and of itself, what makes this \"rotten\".\n\nI work at an ISP that provides email services for its customers. An email client is practically simply a wrapper around the text-based IMAP- and SMTP-protocols, and the server is adequately verbose when there is an error. Problems occur when the email client either decides to obfuscate the error output, or simply chooses to ignore it and keeps attempting to do whatever it was trying to do.\n\nMost of the major email clients are notorious for discarding error information, making troubleshooting practically impossible without consulting server logs. Outlook for Windows likes to throw \"An unknown error has occured\" or obscure error codes such as 0x80040600.\n\nIn reality, a perfectly descriptive error messages has been sent from the server to the client.\n\nIf the email client would simply display the error message verbatim instead of trying (and failing) to parse it, I'm confident most of our users would easily be able to solve the issue on their own without requiring us to dive into server logs to determine that the actual error message returned was simply \"Authentication failed\".", "id": "dovfxge", "parent": "t1_dov57r7", "vote": 23}, {"content": "C++ debugging with Visual Studio is a pretty great experience, IMHO. It's obviously not as easy as high-level languages can be because the language itself is tricky and because you often work with optimized code, but at least some people have an idea of how to design a debugger interface. ", "id": "dov6cyo", "parent": "t1_dov44j2", "vote": 128}, {"content": "The Visual Studio debugger is pretty good, I think. Higher level languages have the advantage of much richer information to work with too.", "id": "dov6viv", "parent": "t1_dov44j2", "vote": 15}, {"content": "Visual Studio and XCode have some really nice C++ debugging features.", "id": "dovlkod", "parent": "t1_dov44j2", "vote": 5}, {"content": "Visual Studio is decent and I particularly like dragging the instruction pointer from one line of code to another. \n\nOn linux C++ debugging is painful. gdb is really just a disassembler.", "id": "dowd5rc", "parent": "t1_dov44j2", "vote": 2}, {"content": "But there's no \"better\" way than what the article laments as the rotten core!\n\nI would imagine the reason why the symbol server was used was because there isn't any other way to achieve said debugging functionality. Parsing GDB output and converting that into a GUI is the only way to debug an app without completely writing your own debugging protocol (which, no-one else is going to use even if you wrote your own!). \n\nStandarization is the solution, but sometimes, just bodging it and getting it working with the least amount of resources is the 'business' answer, and therefore, this phenomenon continues. You see the modern day incarnation in Electron apps - carrying an entire browser rendering runtime just to show a small tray popup!", "id": "dov3kj5", "parent": "t1_dov2ixz", "vote": 68}, {"content": "Huh. Been debugging on Unix/Linux for 30 years and never heard of it. Looks nice. ", "id": "doxa7wb", "parent": "t1_dow17er", "vote": 1}, {"content": "Now after reading [that](https://www.stilldrinking.org/programming-sucks), I want to shoot my self in the head. Somebody help!", "id": "dovw857", "parent": "t1_dovdmwg", "vote": 4}, {"content": "I'll never get sick of reading that rant... That shit is my whole life when I'm hopped up on four coffees every day", "id": "doybcd9", "parent": "t1_dovdmwg", "vote": 2}, {"content": "This is the best and the worst thing I've read in a long time. I hate my profession but I am too old to a fresh start in another field.\n\nThere is no hope.\n\nI am doomed.", "id": "dowgh0a", "parent": "t1_dovdmwg", "vote": 1}, {"content": "> Furthermore you can't escape the layers and composition. Surely the author is not proposing writing sockets, interrupt handlers, kernels, and device drivers from scratch for every application. You will always be subject to embedding someone else's software in your own.\n\nIndeed he isn't, he's advocating for sensible APIs. The examples you gave all have very good APIs, `cat` and such as well. `gdb` and all backends of UNIX software that suffers from the issues in the article don't. \n\nWhat question answers `gdb`? It's not \"it's useful to debug\", but that's how it's used. ", "id": "dovixj8", "parent": "t1_dov8lsc", "vote": 25}, {"content": "In Firefox you can hit escape to stop the animation.", "id": "dovwrw4", "parent": "t1_dovbv6a", "vote": 9}, {"content": "I usually use Inspect + delete. There are also gif stopper extensions, but they don't always work.", "id": "dowrhrk", "parent": "t1_dovbv6a", "vote": 2}, {"content": "I was hoping to find someone who made this point, this should be the top comment, in my opinion.\n\nGDB was designed to be driven by the command line, not interactively. The GDB command language is more of a protocol, like HTTP, and GDB is intended to serve information like a server in response to requests given in this protocol. This protocol is in fact used for remote debugging as well, when the program you are debugging is running on a different computer (which is something I have to do for my day job, on occasion). But of course it can be used just as well on locally run software.\n\nIt was invited in a time before the World Wide Web, so the original wrapper interface to GDB is Emacs, which I like to think of as a proto-web browser.\n\nEmacs GDB integration is near perfect: it interprets C language statements, sets breakpoints, steps execution, and jump to source code in response to breakpoints and execution steps.\n\nWhen I read this article, I immediately thought, \"this person doesn't use Emacs, and doesn't get how to use GDB.\"", "id": "dow8kj4", "parent": "t1_dovj81j", "vote": 4}, {"content": "> gdb has an API. It might be shit, but it does have it.\n\nHe never said it didn't. He so much as said it does, in fact:\n\n> And the reason so many APIs are bad isn't because someone designed a bad API -- it's that they didn't even realize they were designing an API to begin with.", "id": "dppv7ae", "parent": "t1_dovds4a", "vote": 1}, {"content": "[deleted]", "id": "dovhyxa", "parent": "t1_dovds4a", "vote": -1}, {"content": "also the reason for `/bin/yes`", "id": "dovfi3y", "parent": "t1_doveeey", "vote": 17}, {"content": "doesn't kdevelop use GDB:MI?  The point of the machine interface is to paper over these cracks.  It must surely do so.  So its kinda surprising that something like pwndbg breaks MI.", "id": "dov30wn", "parent": "t1_dov2q29", "vote": 5}, {"content": "[deleted]", "id": "dovtfxs", "parent": "t1_dovrloc", "vote": 4}, {"content": "Yes! That is so true in the world of programming.", "id": "doxkie8", "parent": "t1_dowtkro", "vote": 1}, {"content": "This. I hate paramiko and these other ssh abstractions with a passion. Always something goes wrong... ", "id": "dox2b8i", "parent": "t1_dow1vjg", "vote": 1}, {"content": "There are still fake consoles being sold in stores today. Maybe they're not as common, but I wasn't around before 1995 so I wouldn't know.", "id": "dovp5j4", "parent": "t1_dovgett", "vote": 3}, {"content": "I'd argue that you're the one missing the point of the article.\n\n>Gdb is an API. It is an API in the same sense that HTTP or FTP or SMTP are.\n\nThe whole point of the article is that GDB is an API that wasn't designed as an API, and as a result it has a bad interface. The article isn't saying \"Layers are bad\", it is saying \"We have all these layers that don't work well together and are fragile because of this.\"\n\n", "id": "dovi9o2", "parent": "t1_dovdzzn", "vote": 16}, {"content": "From what I understand, the paradigm is better but the execution is so-so", "id": "dovotq3", "parent": "t1_dovjrde", "vote": 3}, {"content": "bash is documented.\n\nDoes PowerShell have actual documentation now? I know it didn't have any for years.\n\nAnd by \"documentation\" I mean something that describes the command language; a set of rules that lets you decide whether any given string is a valid PowerShell command, and if so, what it does.\n\nFor example:\n\n     foo <bar\\ baz \\<quux\n\nI know that bash parses this as an invocation of `foo` with a single argument `<quux`, with standard input redirected from a file named `bar baz` (and `foo` can be an alias, shell function, or external command (looked up in `$PATH`)). It's all documented at https://www.gnu.org/software/bash/manual/bash.html.\n\nIs there anything like that (even just a bunch of BNF rules) for PowerShell? (Please tell me the answer is yes!)", "id": "dowog3s", "parent": "t1_dovjrde", "vote": 3}, {"content": "Whew. I'm waiting to see what kind of responses you get... You're more or less right, but I bet it's going to be a controversial statement.", "id": "dovksuh", "parent": "t1_dovjrde", "vote": 4}, {"content": "[deleted]", "id": "dovtvjf", "parent": "t1_dovjrde", "vote": 2}, {"content": "Said a person who probably spent most of the life working with the Microsoft's software, used \"bash\" twice last year, and is completely not aware of the other unix shells in this world. And it was actually \"dash\", because you are not even aware what is the default shell on your Ubuntu.\n\nThere's really a few things created by Microsoft, which **might be** consider better than the solutions used in unixes and derivatives, but this is on the kernel level, so you would not get a thing.\n\nThis year guys at Microsoft switched to the git. Some time ago, they implemented working Linux subsystem within your Windows 10. They also released some software for Linux. You won't even notice, when your Windows 15 will be actually fully working Linux LTS with some shitty GUI made by your favorite, directed by the sellers, company.", "id": "dovsjv9", "parent": "t1_dovjrde", "vote": -2}, {"content": "> ps: Use emacs. It's a good gui on gdb  \n\nHoly shit that's a good idea. Because emacs has a thing for everything, it can always be a gui on top of {literally anything that doesn't have a gui but you really wish you had one for}  \nAm I right in this? Maybe I should switch from vim.", "id": "dow9htk", "parent": "t1_dovtjzu", "vote": 1}, {"content": "It's in the post. The sensible solution is to implement these programs as libraries, and link the command line program with the library.", "id": "dovhd2s", "parent": "t1_dovcfqv", "vote": 8}, {"content": "There's no solution. Just don't make it worse. ", "id": "dovgspu", "parent": "t1_dovcfqv", "vote": 1}, {"content": "[deleted]", "id": "dovtmip", "parent": "t1_dovcfqv", "vote": -1}, {"content": "Unix process interface is a really terrible and clunky interface. First, you need to start the program. You look up how to wire up 3 pipe() calls to get STDIN, STDOUT and STDERR into something you can control on the process you're about to fork. Then you fork(), dup the pipe endpoints in the child, and then exec the program.\n\nOn the parent side, you're stuck in some kind of select() based loop where you deal with these 3 pipes concurrently. You do things like write a command character and then mark a flag on your system that you just wrote a command and are now expecting some amount of output from the program. Perhaps the program writes back one line, or more than one line. How can you tell? Hopefully, you have some heuristic or marker to determine when the response is complete. This is, in general, unsolved problem in the Unix process interface. Then, of course, you still have to parse the bits of the response you actually care about, and return them in some kind of datastructure. This concludes one interaction.\n\nIf an error happens, you typically get some opaque text written to STDERR, and maybe no or partial STDOUT output. In the general case, you can do nothing about except mark the call as having failed somehow and maybe show the message to user which he can acknowledge in the hope that the user is smarter than your program and can fix the problem somehow. Your dialog will end up saying something like \"Stuff went wrong, here's some output that hopefully describes the reason for failure, press OK and I'll try to continue anyway\". If you try to be smarter than user, then you try to parse the error messages. Unfortunately, you need the error strings to never change, and you have to control localization, too. User may be running your program in French, but your forked process must still speak English back because the hardcoded strings you're looking for are written in English, and then you get nice error messages that are half in French and half in English.\n\nContrast this to a library call. You can forget all about the select, pipe, fork and exec bizarre nonsense that I just wrote above. You just do foo(). When foo returns, it returns with the data. There's no question about if the data is complete, because on return from foo(), all the data is right there. Anecdotally, this is the justification for Perl's existence \u2014 rather than try to use Unix shell to write programs and pipe stuff between sed, awk and grep, Larry Wall built a programming language where functions achieved with sed, awk and grep are basically primitives of this language. Then, he proceeded to write much simpler and more reliable programs than were possible with the previous system.", "id": "dovmsmk", "parent": "t1_dovfqdn", "vote": 16}, {"content": "I can't think of any programs that are particularly well suited to uses that the developers didn't intend or anticipate.", "id": "dovk5uy", "parent": "t1_dovclbs", "vote": 43}, {"content": "Most of the stuff is shit. Therefore if you try to make some stuff without a good idea how to avoid it being shit, it'd most likely be shit.", "id": "dovnlm9", "parent": "t1_dovclbs", "vote": 22}, {"content": "Relevant XKCD:  https://xkcd.com/1172/", "id": "dovyw65", "parent": "t1_dovx793", "vote": 47}, {"content": "[deleted]", "id": "dow4me0", "parent": "t1_dovx793", "vote": -22}, {"content": "Hallway usability testing for APIs? Charming idea!\n\nNo snark - but I see two problems: \n\n - The cost of creating a (structurally different) API. That's basically a different implementation on top of the same data. If it's just a wrapper over another API, the old ugly \"performance is observable behavior\" rears its head (also applies to other aspects)\n\n - Caters to one-use mashup projects *\"I need a code to scrape images off a web site, a code to add calendar dates to an image, and a code to send images to a printer\"* is the people you make happy with that. Not the \"I have to process 1000 images per minute on an ARM architecture, and 40% of my clients want the hindi calendar\"\n\nThe disparity between the time frames seems most burning: spending a week to churn out an alternate implementation, only to be rejected within minutes because that  foreign twat down the hall doesn't know what a ladle is. ", "id": "dowp3nt", "parent": "t1_dovx3cq", "vote": 3}, {"content": "[deleted]", "id": "dovtedz", "parent": "t1_dovsfp7", "vote": 19}, {"content": "That's an accidental benefit of \"write tests first\" that clicks with me: it puts you in the shoes of the caller before you flesh out the interface. ", "id": "dowq89m", "parent": "t1_dovsfp7", "vote": 2}, {"content": "I've thought long about it (and yeah, the question is a bit... tangential)\n\nHere's my take: \n\nI see it primarily as an *API Transport*, i.e. it allows remote calls for certain kinds of API's.  \n\nIn that sense it's also an API framework: it caters to (and is limited  to) a particular REST-like API structure. \n\nThe actual API (i.e.  \"the hard stuff\") hides in the design of the entities and their attributes. \n\nThe \"scalability\" - i.e. extensibility - comes at a price: no static typing. That's an advantage as often as a disadvantage. (at a cursory glance, it seems that GraphQL allows to handle that in a standard way through interfaces). \n\nThe architecture itself is certainly a tribute to modern ... \"achievements\": ever-changing APIs, a lot of processing power, and remote decoupling. \n\nHaving said all that: I'm a fan of a data-driven architecture, both in detail and in the large. (Which also means: I've seen the limits and the problems) This is certainly an improvement over functionally similar technologies, given the constraints and liberties mentioned above. \n\nHowever, it is - and that makes a great **tl;dr:** not a panacea. ", "id": "dowoxo7", "parent": "t1_doviqa6", "vote": 2}, {"content": "-14 just because you used some buzzwords in a legitimate question? I guess proggit is a little mean today. ", "id": "dowcx77", "parent": "t1_doviqa6", "vote": 2}, {"content": "For a while I kept trying to get various GDB wrappers working, but then I just embraced having the debugger in one terminal and the source in another. It would be nice if the source would automatically follow my current position, but it's easier to not have to worry that I've misconfigured emacs or whatever.", "id": "dovjp9b", "parent": "t1_dovgecs", "vote": 21}, {"content": "Is there something necessarily wrong with having a list-like failure object? You can hide it behind a \"more details\" button if you're reluctant to surface it to the user.", "id": "dovuonh", "parent": "t1_dovkp3d", "vote": 6}, {"content": "If you've ever done Windows programming and wondered what the difference is between an HRESULT and an SCODE, well a quarter century ago there was an intent to make an HRESULT a handle to an error object that would give you contextual information, like you describe.  Never happened, though.", "id": "downq21", "parent": "t1_dovkp3d", "vote": 2}, {"content": "Thinking on this a bit further, I'm not sure any of those items, even in a list, are what the user needs to see.\n\nWhat the user needs to know is, what's going to fix my problem? Why is there a unicode error when looking at entry 17 of the returned data for accounts?\n\nMaybe you put someone's name in a number field, and you should fix that.\nMaybe you thought you were loading the accounts file, but you actually loaded the email containing the accounts file.\nMaybe the database holding the accounts data is corrupted, and you need to ask someone to restore from backup.\nMaybe the program you're using is out of date, and doesn't understand a recent new extension to unicode.\n\nI don't expect any error message system to be able to distinguish all these cases - even a technical user, with all information accessible, could have trouble resolving it.\n\nBut, by carefully considering how things might go wrong, and what a certain kind of error in a certain place in the program *means*, it's possible to carefully choose the information you show the user, so they have the best shot at resolving the issue.\n\nIf the two extremes of the spectrum are \"show the user 'unexpected error'\" or \"show the user a full stack trace, with local variables at each frame, checksums of files in memory, temperature of the cpu, etc.\", maybe the golden middle path is \"figure out no more than 5 things to show the user, and make sure those are the most important things\"\n\nThis is hard. Interesting to think about. I wonder if there's a general-purpose solution...", "id": "dowhstt", "parent": "t1_dovkp3d", "vote": 1}, {"content": "That was a great read, even beyond the part you quoted. Interestingly, his issues specifically with parsing seem to be grounded in the text based Unix world that the OP article is talking about. In Windows, programs generally interact via APIs (or statically typed IPC messaging). Even configuration data is traditionally stored as structured data in a database (the registry). The points he makes are still salient regardless, but it\u2019s interesting to see how he has the basic assumption that most input will generally start off as unstructured text.", "id": "dovzh6u", "parent": "t1_dovs5p7", "vote": 12}, {"content": "I get your point about there being bad wrappers for these protocols, but it should be a lot easier to write a wrapper for them than your typical command line application. These are machine-readable formats with well-defined behaviour if something goes wrong. Many (perhaps most) command line applications are not like this. You often have to try to pick out the data you're interested in from the cruft of headline banners and other stuff you don't care about. Reliably extracting error information can be almost impossible, so it's no surprise that the usual behaviour is to just dump the entire output to a log file and present a generic error message to the user.", "id": "dovmow5", "parent": "t1_dovfxge", "vote": 9}, {"content": "[deleted]", "id": "dowot07", "parent": "t1_dovfxge", "vote": 2}, {"content": "The visual studio debugger is probably the best thing MS has ever done. It works in 95% of cases really well, and we have some pretty bizzare technology stacks  where I work.", "id": "dov72zx", "parent": "t1_dov6cyo", "vote": 106}, {"content": "And in addition to Visual Studio, WinDbg and kd are pretty good when you need to do lower level debugging.\n\nThere's also a new version of WinDbg out that modernizes the user interface. The core technology across the debuggers has been continually evolving as well. \n\nhttps://blogs.msdn.microsoft.com/windbg/2017/08/28/new-windbg-available-in-preview/", "id": "dovcavl", "parent": "t1_dov6cyo", "vote": 25}, {"content": "I've worked with that and OllyDbg, and honestly was horrified the one time I tried using gdb. It's like going from a brand new Mercedes to a Soviet era Moskvitch.", "id": "dov82i1", "parent": "t1_dov6cyo", "vote": 39}, {"content": "I do like the project-level `.natvis` files with live-edit support. \n\nHowever, it still seems to be impossible to evaluate a simple thing such as \"is this key in this `std::map`\" at run-time (or add a watch for it, using `map.count`).\n\nConditional breakpoints based on the value of a `std::string` were also not possible if I remember correctly.", "id": "dov7yp3", "parent": "t1_dov6cyo", "vote": 8}, {"content": "Ditto for CLion", "id": "doverjl", "parent": "t1_dov6cyo", "vote": 4}, {"content": "But UNIX philosophy is Zeus word bro.", "id": "dovsk7k", "parent": "t1_dov6cyo", "vote": 1}, {"content": "When I once had to debug some unix process spawn race conditions .... I looked for a good debugger UI and ended up buying a Mac Mini using XCode to debug it.", "id": "dowgjbf", "parent": "t1_dovlkod", "vote": 1}, {"content": "Xcode has a gorgeous C++ debugger. I love being able to dive into the currently-running memory.", "id": "doxaazc", "parent": "t1_dovlkod", "vote": 1}, {"content": "I may be biased because I love low level debugging. But GDB + Windbg both have source modes that show the code. In fact I would confidently say that windbg is much more powerful and versatile than the VS debugger, but the VS debugger is more user friendly, both in UI and that it simplifies many steps", "id": "dowta0h", "parent": "t1_dowd5rc", "vote": 1}, {"content": "[deleted]", "id": "dov68km", "parent": "t1_dov3kj5", "vote": 136}, {"content": "> But there's no \"better\" way than what the article laments as the rotten core!\n\nYou can use the Firefox devtools to remotely debug a webapp running in Chrome.\n\n> Parsing GDB output and converting that into a GUI is the only way to debug an app without completely writing your own debugging protocol\n\nThe rotten core is that GDB does not implement such a protocol, all of the knowledge poured into GDB? Locked in there and only accessible through a shitty command-line.", "id": "dovdhyi", "parent": "t1_dov3kj5", "vote": 34}, {"content": "There is a better way...\n\nUse lldb.\n\nHis assertion that there's \"only one debugger\" is incorrect.", "id": "dov7bq1", "parent": "t1_dov3kj5", "vote": 17}, {"content": ">  getting it working with the least amount of resources is the 'business' answer, \n\nCorrect, that all businesses I have worked for prioritize speed over everything else, to such a great degree that speed of developing new features takes 99% priority and other priorities are condensed to 1%.\n\nAnd that is why the news is chock-full of hacks, i.e., successfully exploiting (innumerable) bugs in the code.", "id": "dovgdo9", "parent": "t1_dov3kj5", "vote": 7}, {"content": "> But there's no \"better\" way than what the article laments as the rotten core!\n\nn...no,I disagree. Proper dedication and understanding and using the errors and such provided by the underlying application is **intrsumental** to avoiding the rot that takes place. This article alone should help create an awareness for this problem. The solution is not some radical change in the way things are done; it is having a good understanding in both the  'wrapper' and the 'wrappee' what the interface, or API is, and what the possible outputs are.\n\n\n\n", "id": "dov50a4", "parent": "t1_dov3kj5", "vote": 18}, {"content": "The business wants to limit cost.  Quality costs, especially in software as it is a craft.  Why would the business spend more to build an application that isn't trash?\n\nThe obvious answer is because the customer won't buy it.  But unfortunately much of what makes software a craft is actually hidden from the customer.  They will buy the $5 product, even if it uses 10x the memory and CPU because that's something most of them never even see or think about.\n\nThey're certainly not going to link their unstable and crashing system to some random piece of software they saved $5 on.  Thus the business has no reason to spend the money, it's pointless and simply drives up the cost.  Security is in much the same boat.\n\nUntil the average consumer can actually *punish* the companies producing trash software by purchasing from better competitors or avoiding it altogether there's not going to be a lot of business motivation.", "id": "dovjppf", "parent": "t1_dov3kj5", "vote": 4}, {"content": "Lisp machines were a better way. Unfortunately, they were far too expensive to become mainstream at the time. Unix took over commodity hardware, and here we are.", "id": "dov7jgs", "parent": "t1_dov3kj5", "vote": 0}, {"content": "> The human brain isn\u2019t particularly good at basic logic and now there\u2019s a whole career in doing nothing but really, really complex logic. Vast chains of abstract conditions and requirements have to be picked through to discover things like missing commas. Doing this all day leaves you in a state of mild aphasia as you look at people\u2019s faces while they\u2019re speaking and you don\u2019t know they\u2019ve finished because there\u2019s no semicolon.\n\nThat last part really sums it up.", "id": "dow2j7i", "parent": "t1_dovw857", "vote": 4}, {"content": ">Indeed he isn't, he's advocating for sensible APIs.\n\nI think he is advocating for more than this. The name of the article alludes to a systemic issue.\n\nRight before his remarks on APIs he says this...\n\n>We're not talking about calling out to a library here. We're talking about actually launching an instance of GDB, passing it commands, and parsing the results it prints out. And this is where we get led down a dangerous path.\n\nHe believes that the pipe, `stdin`, `stdout` model is broken. \n\nfurthermore he says this ...\n\n>programs that don't actually do the thing themselves, but 'outsource' their work to other programs. It's a stack of layers, and it's not a nice clean stack.\n\nPart of those layers are those that interface with the OS and ultimately the metal itself.\n\nI think the author suffers from more than a little [IKEA Effect](https://en.wikipedia.org/wiki/IKEA_effect). I'm sure whatever alternative he would come up with would seem grand at first then show its serious design flaws when applied to any practical pursuit. If there is one thing UNIX did right it was keeping things simple.", "id": "dovl9o4", "parent": "t1_dovixj8", "vote": 5}, {"content": "This doesn't work for me, weird", "id": "dowd820", "parent": "t1_dovwrw4", "vote": 2}, {"content": "https://www.gnu.org/software/gdb/papers/libgdb/libgdb.html", "id": "dovi71y", "parent": "t1_dovhyxa", "vote": 2}, {"content": "> It's still wrapping an external debugger via a text-parsing interface, it has all the same problems.\n\nBut that's not the problem. The GUI program is accessing the symbol server directly.", "id": "dovtlud", "parent": "t1_dovtfxs", "vote": 0}, {"content": "I disagree with that formulation too.    ", "id": "dovitpz", "parent": "t1_dovi9o2", "vote": 2}, {"content": "Like this? - https://www.microsoft.com/en-us/download/details.aspx?id=36389\n", "id": "dowsljt", "parent": "t1_dowog3s", "vote": 3}, {"content": "No actually it is not :) It is in the spirit of the article. The author states that passing strings around is not a good idea. Powershell does not pass strings, it passes objects. Powershell is superior at building APIs. It also has exceptions which prevent the false returning functions described in the article.", "id": "dovv4g1", "parent": "t1_dovtvjf", "vote": 4}, {"content": "Coming from a guy of 10 years of Linux as primary OS (9 of them Gentoo!), I feel the idea of Powershell is so much better than the traditional means.\n\nThere comes times when plumbing textual output between a sink and a source just doesn't cut it, where objects fit better.\n\nI wish there was more of a way to gel the two together, given the choice of powershell or zsh I would opt for zsh because it's a lot more sane, you can tell there's been years of love and work put into it. If there was that much raw work put into powershell it would be far better than the current crippled and off putting manifestation.  It has so much potential.\n\nIf \"ifs\" and \"buts\" were candy and nuts, we'd all have a merry Christmas though. ", "id": "dow3mqz", "parent": "t1_dovsjv9", "vote": 6}, {"content": ">  You won't even notice, when your Windows 15 will be actually fully working Linux LTS\n\nIf I don't notice then they have done a fine job. Because I always notice your Ubuntu's, Debians and so on", "id": "dovt992", "parent": "t1_dovsjv9", "vote": 2}, {"content": "Yup, in addition to being a nifty editor, it's known to decrease sarcasm to tolerable levels.", "id": "dowee8r", "parent": "t1_dow9htk", "vote": 2}, {"content": "His point is that you should stop doing that.\n\nScroll up and you'll find real humans arguing that building software \"on top of an interface that wasn't designed to be extended\" is not such a bad idea. ", "id": "dowefa7", "parent": "t1_dovtmip", "vote": 3}, {"content": "[deleted]", "id": "doycevn", "parent": "t1_dovmsmk", "vote": 1}, {"content": "This tells me concerns about piping, but it doesn't tell my why those concerns are acceptable for grep/sed/sort but 'rotten' for gdb.", "id": "dovp189", "parent": "t1_dovmsmk", "vote": 0}, {"content": "And yet it's what the web is built on.\n\nHTML was intended for simple hyperlinked documents.\n\nJavaScript was intended for short scripts.\n\nEtc.", "id": "dovxpyr", "parent": "t1_dovk5uy", "vote": 79}, {"content": "I don't know, the internet seems to work pretty well.", "id": "dow3c9c", "parent": "t1_dovk5uy", "vote": 5}, {"content": "Anything on a command line?", "id": "dovy763", "parent": "t1_dovk5uy", "vote": 3}, {"content": "cat", "id": "dox72r4", "parent": "t1_dovk5uy", "vote": 1}, {"content": "[deleted]", "id": "dovwsw0", "parent": "t1_dovnlm9", "vote": 11}, {"content": "\"oh, the setup works for you, I can close the bug report then\".", "id": "dow4vut", "parent": "t1_dovyw65", "vote": 7}, {"content": "It's stretched vertically by quite a bit. Had to zoom out to 25% to see what it was.", "id": "dowa6ib", "parent": "t1_dow4me0", "vote": 7}, {"content": "Maybe it could be paper APIs, not actual code. Just to get a feel of people understanding of that new one.", "id": "dowqfub", "parent": "t1_dowp3nt", "vote": 2}, {"content": "For code that will be maintained, it pays dividends over the years. And almost all code ends up being maintained. Even that throwaway database migration script will end up having to be tweaked and rerun several times over, IME.", "id": "dows1ko", "parent": "t1_dovtedz", "vote": 3}, {"content": "Well I guess it was a pretty shitty question in the context of the article.  I was curious if anyone felt like some wrappers actually provide a solution for a poorly designed API.  Too many bad buzzwords though, you\u2019re right", "id": "dowkhul", "parent": "t1_dowcx77", "vote": 2}, {"content": ">  It would be nice if the source would automatically follow my current position\n\nLemme blow your mind: type `tui enable` in gdb. It also has a [single key mode](https://sourceware.org/gdb/onlinedocs/gdb/TUI-Single-Key-Mode.html#TUI-Single-Key-Mode).", "id": "dovnvib", "parent": "t1_dovjp9b", "vote": 35}, {"content": "I guess it's because it tends to get much more technical than in this simple example. You can easily follow a bug down to its source with a Python traceback, but that's not something you want to present to the user.\n\nWe try to abstract away the underlying complexities because the user usually doesn't even know they exist, let alone what it means when the piece of code down at level 23 thinks the gazoobler has too much flimflam in the gnorks.", "id": "dovworw", "parent": "t1_dovuonh", "vote": 15}, {"content": "No; my point is that a list of some sort is a necessity. And yes, I see a \"More details\" button as better than a wall of cryptic words.", "id": "dow5cy4", "parent": "t1_dovuonh", "vote": 10}, {"content": "I think you're describing a stack trace.", "id": "dowdpmk", "parent": "t1_dovuonh", "vote": 5}, {"content": "I've written about this somewhere before, but I once worked on a 'detailed' error handling system that worked *quite* well like this. Essentially we had a process P, that needed to do operations A,B,C, and D in order to complete a task. Some of this was internal stuff, some interacted with other systems. We took a combination of a progress tracking variable (e.g. OperationStage.StageB) and profiling of the errors that can occur. operation A and C could give the same error, but that error *really* means completely different things when it comes from stage C compared to stage A. Knowing 'error 0x005' doesn't help you, knowing error '0x005' happened during C helps more. Taking that info we could then build up an error message starting with a general description unique to that stage and error code (or something generic if it was unknown), then for the common stuff you could often check some things to provide extra info e.g. this error normally relates to some database operation, do a quick sanity check of connecting to the database and querying something. The errors also lived in a linked list so we would could get more detail like \"error 5 in C happened after error 10 caused in B, but we tried to recover and carry on\".\n\nPositives: Our users loved it, we got great error messages with recovery steps listed (that were usually right) when we knew about the problem. If something went wrong it often provided context missing from things like the stack trace.\n\nNegatives: Wasn't massively robust, if something changed too much our heuristics were wrong, and they needed updating.\n\nI can't see why a similar, less fiddly, method wouldn't be possible as an *aid* to the user, especially in some systems where things like circular buffers are available in memory to record the past X operations.", "id": "dowt2d1", "parent": "t1_dowhstt", "vote": 4}, {"content": "Yeah, I wonder how much better off we would be today if OSes provided real databases for persistence (instead of \"file systems\").\n\nSo many ad-hoc storage formats, hand-rolled protocols, quoting and parsing...", "id": "dow5rfb", "parent": "t1_dovzh6u", "vote": 5}, {"content": "> In Windows, programs generally interact via APIs (or statically typed IPC messaging)  \n\nAlso there's Powershell that nicks this problem at its root by being OO.", "id": "dow79xe", "parent": "t1_dovzh6u", "vote": 3}, {"content": "No, but neither is \"An unknown error occured\" :-)", "id": "doxb7pm", "parent": "t1_dowot07", "vote": 2}, {"content": "That new version of WinDbg actually has time travel debugging too. I had to use WinDbg before to track down some super rare stack corruption bug and it was painful as hell. I would have killed for that new version of WinDbg!", "id": "dovfa0a", "parent": "t1_dovcavl", "vote": 14}, {"content": "Oh fuck yes, WinDbg with a visual studio UI.", "id": "dovfe30", "parent": "t1_dovcavl", "vote": 10}, {"content": "I'm the dev lead for that. It's been fun to finally have the chance to add some more modern ui features.", "id": "dowcnyz", "parent": "t1_dovcavl", "vote": 6}, {"content": "The WinDbg syntax is about as arcane as gdb's though. For what they do, I think both have a learning curve that's way too steep.", "id": "dovxz9u", "parent": "t1_dovcavl", "vote": 2}, {"content": "Huh? What specifically are your gripes with gdb? I have been using it daily for over a year and have become quite enamored with it.", "id": "dowcwq5", "parent": "t1_dov82i1", "vote": 3}, {"content": "Apparently a lot of the GCC stuff was *intentionally* made inflexible and not modular or as a library. RMS feared that commercial interests might try to leverage sections of it and produce proprietary plugins and interfaces if the necessary APIs and modularity was available. [He still opposes Clang/LLVM for the same reason.](https://lwn.net/Articles/582241/)\n\n[An interesting bit of commentary by David Kastrup on the matter as part of the same discussion linked above.](https://lists.gnu.org/archive/html/emacs-devel/2015-02/msg00516.html)", "id": "dovkpu0", "parent": "t1_dov68km", "vote": 92}, {"content": "Or use LLDB", "id": "dovh5kr", "parent": "t1_dov68km", "vote": 14}, {"content": "Yup, and there is a GPGME (\"made easy\" lol) wrapper library that makes you feel that you're actually using a library for about five whole minutes until something goes wrong. And it's not just some rare edge cases, the fact that it's an independently, and not very well, designed API results in fun stuff like that you must choose what you want to do, decrypt a file and/or check signatures, before you know if the file is encrypted or has signatures, and get an error if you guessed wrong.", "id": "dov87ef", "parent": "t1_dov68km", "vote": 32}, {"content": "I like what you say, but there is an unintended side-effect: how do you debug applications or components that weren't linked to the debug library?  Everyone has to agree to use the library, and more importantly use the **same** library.\n\nAlso, I really appreciate your gpg example as I just recently struggled with trying to call it from with an app that I'm writing.  Total pita, it desperately needs a linkable library.", "id": "dov828m", "parent": "t1_dov68km", "vote": -8}, {"content": "When you invoke from any program you don't really have to worry about this - unless you prefer \"system\" to \"exec\" for any reason. Thing is, \"system\" will invoke your command via shell - and shell is the one that needs fancy escaping. Placing a dependency on a maybe available library makes your tool either force installation of this library or creates need to write a lot of boiler plate code. Most people don't need gdb on their system, and most developers are too smart to make their code overcomplicated or unreadable.\n\nInterfacing gdb is simple for the very reason article posts first. You just create two pipes and call exec, the rest is sending text commands and parsing text output from gdb.\n\nFinally, I treat it as a penalty. If you have to use gdb to debug your code you clearly don't understand it. That makes you learn something: it's better to spend 10 hours to write code carefully than to spend 50 to debug low quality code. I would really feel bad walking up one day to see that every developer needs debugger to understand what they wrote...", "id": "dov8cqv", "parent": "t1_dov68km", "vote": -29}, {"content": "For the longest time, this was a deliberate feature, wasn't it? GCC was as monolithic as possible, to avoid integration into non-OSS work?", "id": "dove2o6", "parent": "t1_dovdhyi", "vote": 35}, {"content": "> he rotten core is that GDB does not implement such a protocol, \n\nGDB supports remote debugging and the \u201cGDB/MI Interface\u201d which is a\n\u201cmachine oriented interface to GDB\u201d.  You can consider the Emacs\ninterface as a de-facto reference implementation for a client.\n", "id": "dovjsgj", "parent": "t1_dovdhyi", "vote": 19}, {"content": "I think that requires you to use an LLVM pipeline though, doesn\u2019t it? I\u2019ve worked on many targets where GCC is the only sensible option", "id": "dovacu2", "parent": "t1_dov7bq1", "vote": 9}, {"content": "> He believes that the pipe, stdin, stdout model is broken.\n\nIt is broken when the information to be transferred is sufficiently complex. Unless you think it's actually reasonable to expect every tool builder to write a custom parser for text output that likely was never designed to be machine readable in the first place.\n\nHint: that's what people have to do now, and it's a *shittastically monumental* task, which is why so many edge cases get ignored.\n\n> I think the author suffers from more than a little IKEA Effect.\n\nHuh? He didn't propose or build anything. All he did is say that this sucks and it should be better.\n\n> I'm sure whatever alternative he would come up with would seem grand at first then show its serious design flaws when applied to any practical pursuit.\n\nYep. That's why PowerShell died a horrible death, right?\n", "id": "dovtc56", "parent": "t1_dovl9o4", "vote": 8}, {"content": "I'm still using ESR (52.4). Maybe the removed it.", "id": "dowtu2d", "parent": "t1_dowd820", "vote": 1}, {"content": "At first I didn't think it could be true, but yes the API is indeed a GDB REPL duct taped to a C function.\n\nI'm with you though, this is ultimately a loss of information problem, not a poorly-defined API problem.", "id": "dowe4et", "parent": "t1_dovi71y", "vote": 1}, {"content": "[deleted]", "id": "dovyl7b", "parent": "t1_dovtlud", "vote": 3}, {"content": "I love you! This is perfect.\n\n(Except for the part where it's a .docx file instead of HTML, PDF, or just plain text. But the contents look great.)", "id": "dox3w69", "parent": "t1_dowsljt", "vote": 1}, {"content": "[deleted]", "id": "dow3gzk", "parent": "t1_dovv4g1", "vote": 1}, {"content": "> Because I always notice your Ubuntu's, Debians and so on\n\nYeah, sure. Now go to /r/unixporn and tell the guys there that Windows' tiles are superior to i3wm.", "id": "dovu7qb", "parent": "t1_dovt992", "vote": -3}, {"content": "it's always the side-benefits we end up valuing the most", "id": "dowjpux", "parent": "t1_dowee8r", "vote": 1}, {"content": "I am just saying that forking a process sucks as an interface. It has a lot of failure modes. Did you know that if a process in a pipe chain exits with a return code other than 0, the entire pipe might still appear to succeed, e.g. $? is 0? You have to explicitly set pipefail to notice stuff like that.\n\nI'm not really talking about C. I have used things like Perl and Java to interface with processes, and it's inevitably tricky garbage that's hard to get right. The idea of doing stuff in the same process image and having linked-in libraries is the superior model that I'm advocating for. Text exchange between programs is really one of the worse interfaces that exists, despite all that Unix philosophy supposedly claims.\n\nIf there is one thing I would like to dispel, it is the idea that bash is a \"great glue language\". It does work for some stuff, but shell was first advanced as serious programming language like 40 years ago, and I'm pretty sure that in the intervening years, we have found better ways to program than the shell. In particular, the unix process interface is awful in to use in practice.", "id": "doz9jqw", "parent": "t1_doycevn", "vote": 2}, {"content": "They kinda suck for them too, but the difference is a grep call does only one thing and then terminates, or issues an error then terminates. So you can read the pipe until it closes. gdb, on the other hand, will not close the pipe on either success or error, so you aren't sure when to stop reading - are those next characters the prompt or more output? Is it a success or error message?\n\nVery flimsy code doing stuff like timeouts and if string ends with \\ngdb> and exact match of known messages at the boundaries.", "id": "dovtcoy", "parent": "t1_dovp189", "vote": 6}, {"content": "And the web is a total mess as a result", "id": "dow18wm", "parent": "t1_dovxpyr", "vote": 64}, {"content": "The issue with those is that someone decided to bring the two together. ", "id": "dovzwz5", "parent": "t1_dovxpyr", "vote": 3}, {"content": "We're up to version 5 of html and version 3 of css. Those technologies are very different from their original spec. JavaScript is Turing Complete, so we can abstract our way towards reasonable.", "id": "dowhf3o", "parent": "t1_dovxpyr", "vote": -4}, {"content": "most sites actually don't work well ", "id": "dow7vjh", "parent": "t1_dow3c9c", "vote": 14}, {"content": "For some definition of \"well\" :P ", "id": "dowcn10", "parent": "t1_dow3c9c", "vote": 10}, {"content": "Half of the websites I use don't work well on a 2560x1440 screen. At this DPI I do have to scale websites or they will look like websites for ants. When I set a scaling factor, a lot of websites just bleed off the screen. You click on a menu, but the menu scrolls past my screen. No way to click on the bottom part. In fact, I might not know there are more menu items.", "id": "dowhanc", "parent": "t1_dow3c9c", "vote": 5}, {"content": "Small, loosely coupled elements... Works a treat.", "id": "dow5430", "parent": "t1_dow3c9c", "vote": 3}, {"content": "Yup, sums up every day for me as a debugger.\n\nMy job is literally all about fixing bugs when new mobile devices come out and browsers update.. every device, every browser... :')", "id": "dovy1we", "parent": "t1_dovwsw0", "vote": 8}, {"content": "Yep, I had to Ctrl+- a few times. I guess this is why ascii art died. ", "id": "dowctsy", "parent": "t1_dowa6ib", "vote": 1}, {"content": "Well, we do it in a way that we present alternatives for concepts how a new feature will be explained to the user (which includes creating terms, definitions and abstractions) - and then model the \"top layer\" API according to these abstractions. ", "id": "doyl2yu", "parent": "t1_dowqfub", "vote": 1}, {"content": "[Boom](http://www.reactiongifs.com/r/2013/10/tim-and-eric-mind-blown.gif)", "id": "dow6dl0", "parent": "t1_dovnvib", "vote": 2}, {"content": "Except it's kinda buggy. Or it was when I tried using it maybe two years ago. YMMV", "id": "dowwuif", "parent": "t1_dovnvib", "vote": 2}, {"content": "That was one of the first gdb commands that I learned, but it just kept breaking. Buggy tools are not worth the effort.", "id": "doze7e9", "parent": "t1_dovnvib", "vote": 1}, {"content": "Sure, but it's easy to hide that messy traceback behind an \"error details\" button so that the users who don't want to know the details don't need to know it, but the information is *still accessible* for people who do need to access it.", "id": "doxa4xl", "parent": "t1_dovworw", "vote": 7}, {"content": "Gotcha! I misinterpreted the tone of that comment as considering error lists a bad thing.  ", "id": "dow6xwl", "parent": "t1_dow5cy4", "vote": 3}, {"content": "Well, not quite, because that\u2019d be produced by a debugger from an executable that has symbols (i.e. in debug mode, not a released product) from what I understand. Similar, though. ", "id": "doweqa4", "parent": "t1_dowdpmk", "vote": 4}, {"content": "So, like a shared \"registry\" database that programs could read and write typed values to?  Yeah, too bad no OS managed to make something like that back in the day.  Everyone would have loved it.", "id": "dowa00a", "parent": "t1_dow5rfb", "vote": 5}, {"content": "If you look at sqlite's website it practically reads like a plea to developers to stop using the filesystem directly for storing application state. ACID transactions are something that almost every significant piece of software will need eventually, and if you try to implement your own you'll probably do it badly. \n\nOne thing that I've always felt needed more attention is doing away with the awkwardness of programmatically interacting with databases. Interacting with a DB via ODBC/JDBC style clients just sucks. \n\nI really want a modern programming language that treats db interaction as core concept, allowing SQL to be written inline (not inside a string), with autocomplete support when writing SQL and seamless statically typed query results.\nMicrosoft's LinqToSQL is the closest thing, but I'd prefer to be able to write real SQL. DB stored Procedure languages (PL/SQL, T-SQL) offer this but they're all kinda crappy languages rooted in language design from the 80s.", "id": "dow86dv", "parent": "t1_dow5rfb", "vote": 7}, {"content": "Yeah, it's a good example of how the windows development environment was very purposefully designed steer people away from using unstructured text as a means of transmitting data. It's not that the Windows is great and unix sucks, but that the people that treat the UNIX STDIN/STDOUT/STDERR philosophy as holy scripture often fail to acknowledge that there are entire systems that utterly reject that particular approach and don't seem to suffer for it. Powershell is just the perfect example of how this is possible even in the context of command line software. \n\nAnd it's not just Windows. Android, built on top of the linux kernel, completely replaced the typical linux userspace with one that similarly rejects text as a means of transmitting data.", "id": "dow9j1e", "parent": "t1_dow79xe", "vote": 15}, {"content": "At first we kind of poked fun at it for using a ribbon, but overall it's a welcome change.", "id": "downnv7", "parent": "t1_dowcnyz", "vote": 2}, {"content": "My favorite ugly windbg syntax are the various ways to execute scripts.   \n\n    $<Filename \n    $><Filename \n    $$<Filename \n    $$><Filename \n    $$>a<Filename  \n  \nI wonder who thought \"yes, dollar signs, greater than signs, and less than signs are a great way to signify I want to execute a script.\" ", "id": "dow7h3m", "parent": "t1_dovxz9u", "vote": 5}, {"content": "I couldn't figure anything out on how to use it, even with a tutorial.\nI settled for using a GUI wrapper, but even that was ugly.", "id": "dowmv57", "parent": "t1_dowcwq5", "vote": 1}, {"content": "As much as I like the guy, he certainly does have his faults. ", "id": "dovvnme", "parent": "t1_dovkpu0", "vote": 27}, {"content": "As much as I wish the man were more pragmatic when it comes to this, I guess he really wouldn't be who he is if he had an ounce of pragmatism in his bones.", "id": "dow231q", "parent": "t1_dovkpu0", "vote": 8}, {"content": "> that makes you feel that you're actually using a library for about five whole minutes until something goes wrong. \n\nwhat makes you think it would be any different if it was a real library ? libraries go wrong all the time", "id": "dovh663", "parent": "t1_dov87ef", "vote": 2}, {"content": "The point is to put GDB's functionality into a reusable library. The debugger (gdb-console or gdb-flying-toaster-gui) would be linked against that, the debugee doesn't need to. ", "id": "dov8ph5", "parent": "t1_dov828m", "vote": 27}, {"content": "The target application doesn\u2019t link with the debugger. The actual debugging works in the same way, but instead of scraping output from the TTY output, GDB would be a dynamic library that you\u2019d, as a debugging interface, link to", "id": "dovaa4l", "parent": "t1_dov828m", "vote": 18}, {"content": "> Also, I really appreciate your gpg example as I just recently struggled with trying to call it from with an app that I'm writing. Total pita, it desperately needs a linkable library.\n\n[Go has a decent library](https://godoc.org/golang.org/x/crypto/openpgp). (Despite the description saying it does \"high level\" operations, it has all the types & support to do a lot of things with keys, too.) It may be easier (and safer) to learn Go, implement what you need in the library, and then shell out to that instead.\n\nThis is not praise of Go or this library; it is an indictment on gpg's accessibility.", "id": "dovdbbb", "parent": "t1_dov828m", "vote": 6}, {"content": "> Finally, I treat it as a penalty. If you have to use gdb to debug your code you clearly don't understand it. That makes you learn something: it's better to spend 10 hours to write code carefully than to spend 50 to debug low quality code. I would really feel bad walking up one day to see that every developer needs debugger to understand what they wrote...\n\nAbsolutely. *So much* development and QA time could be saved if programmers would just write everything bug-free the first time. If only the [Vigil](https://github.com/munificent/vigil) language was more popular...", "id": "dov9xi6", "parent": "t1_dov8cqv", "vote": 31}, {"content": "I think this is literally the first time I've ever seen someone claim that only amateurs use debuggers", "id": "dow6wiw", "parent": "t1_dov8cqv", "vote": 5}, {"content": "Yes but LLVM ass-kicked GCC and GCC showed it's age.\n\nSo the other parts of the monolithic debuggers sucking as well, does not come as a surprise.", "id": "dovefw8", "parent": "t1_dove2o6", "vote": 28}, {"content": "LLVM pipeline in what sense? Where you can use GDB you can use LLDB. ", "id": "dovh7nm", "parent": "t1_dovacu2", "vote": 9}, {"content": "> Yep. That's why PowerShell died a horrible death, right?\n\nI'm still so psyched it is ported to linux shell. I love OO so much.", "id": "dovvt7u", "parent": "t1_dovtc56", "vote": 2}, {"content": "> It is broken when the information to be transferred is sufficiently complex. \n\nAre you just trying to be argumentative? The innate, systemic deficiency of this model is the entire thesis of the article. Its title is \"Something is Rotten In The Core\". The implication is that the entire approach is flawed. My only point is that I disagree and I don't think its rot; I think its clever and is perhaps primary reason the operating system has been so successful. I will take a little grind between the layers if the alternative is a heaving, unwieldy monolith.", "id": "dovw9a3", "parent": "t1_dovtc56", "vote": -3}, {"content": "> No it doesn't. cdb/dbgeng does the work internally.\n\nFrom the article you didn't read:\n\n> When launching debugging for the first time, you are prompted to set up a Symbol server , which adds a special entry to the symbol path of the debugger. The Symbol Server provides debugging information for operating system and compiler runtime libraries. The initial download can be time-consuming.", "id": "dow6k9c", "parent": "t1_dovyl7b", "vote": 0}, {"content": "My Google Fu is powerful. Typed \"Powershell specification\" in Google :)\n\nNote that this spec is for 3.0 and the current version is 5.something. MS have a tendency to skip publishing specifications on some releases but I'd expect Powershell to be relatively stable by now and unless you are building your own implementation the old spec will probably do.", "id": "doxgj7t", "parent": "t1_dox3w69", "vote": 1}, {"content": "I'm not much into scripting but as far as I know the problem with Powershell on Windows is that not every Windows software provides command line or cmdlet interface while on *nix everything expects this.", "id": "dow3od0", "parent": "t1_dow3gzk", "vote": 3}, {"content": "I don't care if they are superior. I only care that I don't have to spend time learning an OS. I have enough things to learn about, your kernels, desktop environments and so on are not interesting. If MS switches Windows to the Linux kernel and I don't find out then this is something they have done infinitely better than any Linux distro.", "id": "dovuwhv", "parent": "t1_dovu7qb", "vote": 4}, {"content": "Only from the web mechanics point of view. ", "id": "dow3eig", "parent": "t1_dow18wm", "vote": 4}, {"content": "JavaScript was created specifically for Netscape Navigator.", "id": "dow0k2a", "parent": "t1_dovzwz5", "vote": 11}, {"content": "Turing completeness is easy to reach and does not say anything about how easy to use or abstract something is. Did you ever wrote a program to the formal Turing machine specification? HTML+CSS or Conway\u2019s game of life are Turing complete, but I certainly wouldn\u2019t like to program in them. You can write compilers, but you have to keep a lot of underlying idiosyncrasies, if you don\u2019t want to have terrible performance.", "id": "dowjses", "parent": "t1_dowhf3o", "vote": 14}, {"content": "What method are you using? I can only afford 1920x1080 at the moment, but I still have to scale websites. However, it works fine when I do. I use ctrl+ in Chrome and Firefox, and the equivalent default setting. Are you using a different method?", "id": "dox64yg", "parent": "t1_dowhanc", "vote": 1}, {"content": "That's not normal. MacBook Pros have had higher resolution than that for 5 years, and most sites look fine on them nowadays. Sounds like something specific to your setup / OS / browser.", "id": "doxm49r", "parent": "t1_dowhanc", "vote": 1}, {"content": "What, are you using Internet Explorer 6?", "id": "doy2aw4", "parent": "t1_dowhanc", "vote": 1}, {"content": "My condolences.", "id": "dovz4ld", "parent": "t1_dovy1we", "vote": 5}, {"content": "I guess on the positive side of things, you'll likely always have work, as new stuff keeps coming out.", "id": "dow1so9", "parent": "t1_dovy1we", "vote": 4}, {"content": ".........why? \ud83d\ude27", "id": "dow5c3v", "parent": "t1_dovy1we", "vote": 3}, {"content": "idk, I've been using it longer than that and never saw any bugs, except I think for one thing, the step-into/over doesn't work properly in assembly view in single key mode, it still steps over lines or something iirc.\n\nAre you sure that was not the usual effects of -O2 or bad symbols or whatever that you just don't feel so acutely when poking at it through the command line like a blind kitten?", "id": "doxo2rd", "parent": "t1_dowwuif", "vote": 1}, {"content": "[deleted]", "id": "doyc2mz", "parent": "t1_doweqa4", "vote": 1}, {"content": "No, they means a database as an actual **replacement** for the filesystem - maying databases *available* (especially simple hierarchical key/value databases like the registry, or stuff like BerkelyDB etc) is pretty unremarkable.  MS did dabble with this idea at one point (winfs), but in the end abandoned it.  IIRC, BeOS did it to some degree, though never it myself, so can't say to what degree, and in the end BeOS didn't catch on.", "id": "doxgn47", "parent": "t1_dowa00a", "vote": 2}, {"content": "Have you seen the database approach taken by the J and K languages?  These are array-oriented languages and both sell columnar/in-memory database products.  There is no need for something like an object-relational mapping, because databases are (high dimensional) arrays.\n\nNot sure about creature comforts like autocomplete though.  Array programmers don't seem to want IDEs as much as OOP programmers do.  Even syntax highlighting is a rarity.", "id": "dowc45u", "parent": "t1_dow86dv", "vote": 3}, {"content": "I mostly work in python and sqlalchemy is a joy to use.\n\nToo bad it and the rest of python is slooooooooow.", "id": "doxdzg5", "parent": "t1_dow86dv", "vote": 3}, {"content": "> but that the people that treat the UNIX STDIN/STDOUT/STDERR philosophy as holy scripture often fail to acknowledge that there are entire systems that utterly reject that particular approach and don't seem to suffer for it.\n\nstringly typed data bites us all ", "id": "dowpdkd", "parent": "t1_dow9j1e", "vote": 3}, {"content": "> the windows development environment was very purposefully designed steer people away from using unstructured text as a means of transmitting data\n\nAre you talking about Windows registry?\n\n\n\n> Android, built on top of the linux kernel, completely replaced the typical linux userspace with one that similarly rejects text as a means of transmitting data\n\nI am sorry, could you point me what Android has done for this?", "id": "dowds26", "parent": "t1_dow9j1e", "vote": 1}, {"content": "[deleted]", "id": "doyc4sv", "parent": "t1_dow9j1e", "vote": 0}, {"content": "We tried a lot of things before ending up with a ribbon. It's gotten a lot of flak from ribbon haters, but we have plans for stuff that will make a lot of sense with the ribbon. And for folks that don't like it, you just collapse it and you have more screen real estate than the old ui.", "id": "dowob98", "parent": "t1_downnv7", "vote": 4}, {"content": "And the scripts themselves are even more arcane. We are replacing it with JavaScript and a structured data model for querying data about the target. It's still a work in progress but we have docs up on msdn.", "id": "dowcrkd", "parent": "t1_dow7h3m", "vote": 8}, {"content": "Now try x64dbg... it's so much better than Olly. (but IDA is still king)", "id": "dozq7oz", "parent": "t1_dowmv57", "vote": 1}, {"content": "Like being unopposed to kiddy diddling. ", "id": "dow3fcp", "parent": "t1_dovvnme", "vote": 4}, {"content": "1. As I said, using the original API would be much better, because it's guaranteed to satisfy most usual use cases. An alternative made based on reverse engineering and pure imagination is practically guaranteed to be worse.\n\n2. The most common and also most frustrating GPGME error is \"Invalid engine\" which is a code for \"gpg said something I don't understand\". This whole class of errors would be eliminated in case of an actual libgpg, of course.\n\nYeah, libraries go wrong all the time, but libraries-wrapping-executables go wrong much harder and deeper.", "id": "dovmjeo", "parent": "t1_dovh663", "vote": 22}, {"content": "You probably wouldn't need to shell out, provided your language of choice can call into C; it's fairly easy in Go to build a library accessible from C - easy enough that the entire source of a library exporting, say, a function `SayHello(char* s)` that did the equivalent of `printf(\"Hello, %s!\\n\", s)` is:\n\n    package main\n    \n    import \"C\"\n    import (\n    \t\"fmt\"\n    )\n\n    //export SayHello\n    func SayHello(s *C.char) {\n    \tstr := C.GoString(s)\n    \tfmt.Printf(\"Hello, %s!\\n\", str)\n    }\n\n    func main() {}\n\nand its use from C is as simple as:\n\n    #include \"libhello.h\"\n\n    int main(void) {\n    \tSayHello(\"World\");\n    \treturn 0;\n    }\n\nPlacing the first into `libhello.go` and the second into `hello.c`, you can then do:\n\n    $ go build -buildmode=c-shared -o libhello.so libhello.go\n    $ gcc -o hello hello.c -L. -lhello\n    $ ./hello\n    Hello, World!\n\n`go build -buildmode=c-shared ...` writes `libhello.so` and `libhello.h`, the latter of which is pulled in by `gcc`.", "id": "dovn6rl", "parent": "t1_dovdbbb", "vote": 2}, {"content": "That's not exactly what I'm saying and we both know that's not fully possible.\n\nMy point is that more often than not you end up debugging a spaghetti code that in worst case has been created by someone you never met.\n\nLots of companies have a really decent coding guidelines that help you avoid most pitfalls and make your code readable enough that before you learn gdb you will actually find that bug.", "id": "dova78n", "parent": "t1_dov9xi6", "vote": -14}, {"content": "Okay I think my message is not clear enough. Did you see \"amateurs\" out there anywhere? (note to self: only amateurish thing here is me replying to this)\n\nI'm saying i'm too lazy to learn gdb. **I treat it's complicated usage as an incentive for me to write simple code**: a code that I won't have to use gdb for, because i can understand it. I got this concept from . My ideas of simple code follow pretty much concepts of 'brain rules' book - eg. you can't keep track of more than 4 (up to 7, assuming you're a genius) different things for a longer time. not without writing it down somewhere anyway.\n\nA side note however: no, is not an unpopular concept.\n\n[Torvalds on debuggers](https://www.linuxtoday.com/infrastructure/2000090700221OSCYKN): not having a kernel debugger forces people to\nthink about their problem on a different level than with a debugger. I\nthink that without a debugger, you don't get into that mindset where you\nknow how it behaves, and then you fix it from there. Without a debugger,\nyou tend to think about problems another way. You want to understand\nthings on a different _level_.\n\nPlauger and Kerninghan promote the rule of writing simple code too: Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.\n\nnow don't get me wrong here: learning to press \"step over\" or \"step into\" by clicking on UI - this anyone can do. understanding what happens with the code - that is not as much a simple task. Debugger will tell you \"what\" but not \"why\". **My goal is to know the \"what\" without launching debugger** because i want to focus on the \"why\" instead.\n\nI hope that's clearer, but i know i'm just feeding trolls. Long as you ignore we're discussing opinions and that you consider the sole fact a tool has a CLI interface and is not a shared object or kernel feature is nothing but a severe disadvantage - we will probably not understand each other. Long as you think the only way to work with software is via debugger we won't understand each other. So why bother.", "id": "dow75tm", "parent": "t1_dow6wiw", "vote": 1}, {"content": "I could completely be talking out of my arse, I\u2019ve never used it, but I thought it was only compatible with the debug symbols emitted by the LLVM code generator, unlike GDB which supports at least STAB and DWARF", "id": "dovhpx5", "parent": "t1_dovh7nm", "vote": 2}, {"content": "[deleted]", "id": "dow727r", "parent": "t1_dow6k9c", "vote": 3}, {"content": "You are just ignorant with a limited mind and common sense :)\nHappy life!", "id": "dovxg7s", "parent": "t1_dovuwhv", "vote": -2}, {"content": "From any sane developers point of view. The web like the C programming language is a perfect example of  \"worse is better\". ", "id": "dow6ekn", "parent": "t1_dow3eig", "vote": 35}, {"content": "Most single-program embedded scripting languages are bad; http://yosefk.com/blog/i-cant-believe-im-praising-tcl.html sums up some of the issues nicely (the part entitled \"Ad-hoc scripting languages \u2013 the sub-Turing tar pit\"). Javascript is an embedded language for a single program that got really big; fundamentally it's Netscape Navigator's equivalent of VBA or GDB scripting or ...\n\n", "id": "dowrplr", "parent": "t1_dow0k2a", "vote": 4}, {"content": "Fair enough. I'm not knowledgeable about the history of JavaScript other than knowing it's unusable (for anything other than short scripts, it's original intended purpose according to the post I replied to) without using dozens of frameworks and libraries. Not that serverside languages are any different in that respect.\n\nI also just re-learned that JS is on it's uh... 6th or higher significant version, so that means a lot of added features since original spec.", "id": "dowkr4q", "parent": "t1_dowjses", "vote": -2}, {"content": "Yes, I'm using pixel scaling", "id": "dox6u1r", "parent": "t1_dox64yg", "vote": 2}, {"content": "Firefox", "id": "doy3u3e", "parent": "t1_doy2aw4", "vote": 1}, {"content": "True, the job very secure", "id": "dowjewq", "parent": "t1_dow1so9", "vote": 3}, {"content": "Somebody has gotta do it", "id": "dowm2c4", "parent": "t1_dow5c3v", "vote": 3}, {"content": "Cool. \n\nThe problem was with the TUI mode itself. I can't recall exactly, but something with the way the \"windows\" worked or whatever was bugged, sometimes I couldn't switch anymore I think, or something in that fashion. Not debugger functionality, the UI itself.", "id": "doxqesg", "parent": "t1_doxo2rd", "vote": 1}, {"content": "Really? So then why does a lot of released software have symbols stripped? Is it just an anti-reverse engineering method?", "id": "doymd3o", "parent": "t1_doyc2mz", "vote": 1}, {"content": "\"The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.\" -Alan Kay", "id": "dox77rh", "parent": "t1_dowpdkd", "vote": 2}, {"content": "> Are you talking about Windows registry?\n\nPrimarily I was talking about how IPC is generally done by exchanging structured data via facilities like COM or, even more idiomatically, by just exposing the functionality via libraries. Except for ports from the Unix world, Windows executables almost never interact with other executables via STDIN/STDOUT.\n\nAnother example is how Unix uses device files like /dev/random to expose kernel functionality via an essentially unstructured data stream. That approach, outside of UNIX compatibility layers, would be utterly out of place in Windows where the OS typically exposes such functionality only via system libraries with well-defined APIs (which is also how the Linux kernel also tends to expose new functionality nowadays). So if you\u2019re in bash on Linux it\u2019s trivially easy to get random numbers from the kernel because the interface (a file) is essentially non-programmatic. In Windows there\u2019s no way to do it outside of a programming language that can link to system libraries. \n\n> I am sorry, could you point me what Android has done for this?\n\nAFAIK, almost all IPC in Android goes though is done via facilities that use well defined interfaces and structured data. At the OS level, Android isolates a lot of low level functionality, like hardware device drivers, into separate processes. But those processes generally interact with each other via remote procedure calls using binder. The entire concept of STDIN/STDOUT is almost entirely foreign to the Android ecosystem.", "id": "dowh6xq", "parent": "t1_dowds26", "vote": 11}, {"content": "> Scripting a Linux system is so fucking simple and easy\n\nlol no", "id": "dozq3ko", "parent": "t1_doyc4sv", "vote": 1}, {"content": "lolwut, you got a source there bud?", "id": "dow6dci", "parent": "t1_dow3fcp", "vote": 4}, {"content": "Normally building a Go library for non-Go use makes me nervous because I don't understand how the runtimes interact, but this is one case where it really is just straight-up a library; a quick grep & eyeball scan says there are zero `go` uses in the gpg library.", "id": "dovqoc7", "parent": "t1_dovn6rl", "vote": 2}, {"content": "Sure, but if you were using a debugger that was really to interface with than gdb, you could find the bug even faster and you wouldn't have to spend all that time learning to use it. Coding guidelines don't magically make all bugs easy to find by scanning the code. ", "id": "dovbbld", "parent": "t1_dova78n", "vote": 10}, {"content": "I _think_ you might have some good points in here, intermingled with some schizophrenic ranting about how everyone else is trolling and you're wasting your time talking to us", "id": "dowhd0n", "parent": "t1_dow75tm", "vote": 2}, {"content": "Maybe at one time, but llvm/lldb has support for dwarf though I dont know if its complete and version 5. Its supported stabs for some time. I know DWARF was implemented at least a few years ago so its not some bleeding edge feature in LLVM.\n\n", "id": "doviqp5", "parent": "t1_dovhpx5", "vote": 17}, {"content": "I stand corrected: https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/using-a-symbol-server", "id": "dow7kfz", "parent": "t1_dow727r", "vote": 2}, {"content": "Ah! That confirms what not to use, then. Try the other method and see if that works better for you?", "id": "doxf1im", "parent": "t1_dox6u1r", "vote": 1}, {"content": "Yes, but stripping symbols also heavily reduces binary size (on non trivial programs).\n\nThat said, reversing with symbols is SO much easier.", "id": "dozpum3", "parent": "t1_doymd3o", "vote": 3}, {"content": "Thank you for educating me on these subjects.", "id": "dowiiov", "parent": "t1_dowh6xq", "vote": 5}, {"content": "From [the horse's own mouth](https://www.stallman.org/archives/2006-may-aug.html#05%20June%202006%20%28Dutch%20paedophiles%20form%20political%20party%29)", "id": "dow7oco", "parent": "t1_dow6dci", "vote": 5}, {"content": "https://en.m.wikiquote.org/wiki/Richard_Stallman\n\n> The nominee is quoted as saying that if the choice of a sexual partner were protected by the Constitution, \"prostitution, adultery, necrophilia, bestiality, possession of child pornography, and even incest and pedophilia\" also would be. He is probably mistaken, legally \u2014 but that is unfortunate. All of these acts should be legal as long as no one is coerced. They are illegal only because of prejudice and narrowmindedness.", "id": "dow6war", "parent": "t1_dow6dci", "vote": 5}, {"content": "Of course not. Coding guidelines are there to make it easier to understand the code. That's my point.\n\nEverybody makes bugs. But if your code is clean and readable it's much easier to find it. It's not a big deal to find out which line is causing trouble*, but figuring out why that bug is there is a whole other story.\n\n*Does not apply to drunk coding. Been there too ;-)", "id": "dovcben", "parent": "t1_dovbbld", "vote": -9}, {"content": "And at the same time I see you put your misinterpretation in my mouth some comments above and now you're calling me schizophrenic. It's difficult not to see that as unwelcome.\n\nIt's easier to shout out \"hey, I think this guy says we're all dumb\" rather than \"dude, I don't think I understand what you mean\". I'm not sure if that is the level of conversations on Reddit, but I begin to believe it might be the case.\n\nPoint to take here is that not everyone who sees certain benefits in inconveniences is instantly calling everyone else an idiot. For me this case only inspires me to work on code quality. On my end.\n\nYes, gdb frontend is not the most fortunate one. Most if not all tools could have different, perhaps better frontends. Question is what we all do with what we have. We can rant about it, like the article, or find something good in it. Which apparently made me disgrace lots of devs out there.", "id": "dowixmi", "parent": "t1_dowhd0n", "vote": 1}, {"content": "Makes sense that on a large program the symbols would reduce final binary size. I'm studying CS right now so binary sizes aren't exactly the biggest concern for me yet.", "id": "dozr224", "parent": "t1_dozpum3", "vote": 1}, {"content": "> > as long as no one is coerced\n\nVery important clause here, though. ", "id": "dowbo3u", "parent": "t1_dow6war", "vote": 5}, {"content": "I suppose it's important if you believe that children and animals can give consent to have sex with adults.  I'd say that's a controversial opinion.", "id": "dowc632", "parent": "t1_dowbo3u", "vote": 12}, {"content": "No, no it isn't.  The concept of coercion does not apply to children.", "id": "dox6wdl", "parent": "t1_dowbo3u", "vote": 0}, {"content": "That's a different debate altogether, which wasn't being discussed here as children are one of several subjects of the original statement. ", "id": "dox7k8y", "parent": "t1_dox6wdl", "vote": 0}, {"content": "No. The quote was in response to the subject of sexual relations with children. ", "id": "dox8r30", "parent": "t1_dox7k8y", "vote": 0}], "link": "https://www.reddit.com/r/programming/comments/78n07u/something_rotten_in_the_core/", "question": {"context": "", "id": "78n07u", "title": "Something Rotten In The Core"}, "resource": "Reddit"}, {"answers": [{"content": "PyCharm's debugger can show you all of those things. Any competent debugger can, really. I don't know if it's hobbled in the free version.", "id": "inw2jyy", "parent": "t3_xaw7t6", "vote": 37}, {"content": "My \"Python skill level\" is I was a longtime Django committer (until I literally rewrote Django's governance document to abolish the \"committer\" role) and release manager, and have been elected a lifetime Fellow of the Python Software Foundation for my contributions to and efforts on behalf of the Python web ecosystem. At my current job, my level/title is Principal.\n\nAnd: the best IDE/editor is the one that you feel comfortable with and that makes you most productive.\n\nFor me that's Emacs, because I learned it a very long time ago and have it configured the way I want, with decades of muscle memory. For a lot of my co-workers it's PyCharm or VS Code. For you, who knows? Try a few things and see what you like. Don't listen to people who tell you there's only one you should use, or who will look down on you for using something they don't like.", "id": "inwxefi", "parent": "t3_xaw7t6", "vote": 28}, {"content": "Vs code all day. I use the pandas library a lot and VS code has a Jupiter notebooks extension.", "id": "inw2h26", "parent": "t3_xaw7t6", "vote": 57}, {"content": "I was using python to ease my work since 2008, now doing python programming for living for 4 years. For smaller things I use vim, for bigger I use pycharm, as its total powerhouse. \n\nYou can go line by line in pycharm using F7 during debugging.", "id": "inwc3gl", "parent": "t3_xaw7t6", "vote": 19}, {"content": "Senior level Python dev, I use neovim as a text editor and then run testing/debugging/git straight from the terminal.", "id": "inwcx2a", "parent": "t3_xaw7t6", "vote": 36}, {"content": "Spyder. I'm a physicist who does lots of numerical stuff. The enhanced IPython console is very nice. The interface is modeled after Matlab. \n\nMain downside I've found is using pymc (Bayesian MCMC package) it doesn't like to launch multiple processes. Multicore pymc code works running from vanilla IPython, but not through Spyder. Other my multiprocessing stuff does work in Spyder, so not sure what the issue is.", "id": "inwy3ue", "parent": "t3_xaw7t6", "vote": 17}, {"content": "I'm not sure I've ever seen a Microsoft product embraced as quickly and near-universally by programmers, engineers, coders, etc as Visual Studio Code.\n\nIts really good. Much better than the Atom it replaced. Is it technically an IDE? Eh, I suppose not.", "id": "inwav72", "parent": "t3_xaw7t6", "vote": 17}, {"content": "At the start of my journey I was using VS Code. It was nice and had every feature I needed. I also tried Pycharm but it didn't click with me (I don't know why, I just preferred VS Code).\n\nNow I am using Emacs as my editor with Evil editing style (same as in Vim). I love it! It is hard to express, how smooth and efficient is editing code with it. Also Emacs has so many features beyond simple editing of text files.", "id": "invy3gk", "parent": "t3_xaw7t6", "vote": 9}, {"content": "Dev lead, 20 years python, I use Vim.\n\nPycharm and VSCode seem the most popular options these days, both are good. I find them a bit laggy and have returned to vim every time I've tried a new editor. Probably because it was the first I learnt.", "id": "inwqpq2", "parent": "t3_xaw7t6", "vote": 5}, {"content": "Jupiter notebook", "id": "inwm0fb", "parent": "t3_xaw7t6", "vote": 3}, {"content": "Vscode and vim\nEdit: I'm a python developer whose main tasks are to develop microservices and make some basic classification models.", "id": "iny7j3f", "parent": "t3_xaw7t6", "vote": 3}, {"content": "VSCode - 15 years of Python", "id": "inyvrcn", "parent": "t3_xaw7t6", "vote": 3}, {"content": "4 year of python. For me it's neovim with astroneovim for little project (like quick cli script or proof of concept things) otherwise it's pycharm", "id": "inyxvam", "parent": "t3_xaw7t6", "vote": 3}, {"content": "Jupyter notebook : beginner", "id": "inwi5uq", "parent": "t3_xaw7t6", "vote": 5}, {"content": "Don\u2019t worry too much about your editor.\n\nYou can run a REPL in Pycharm in the terminal, just type python3 and hit enter.\n\nAlternately (this might take some googling), check out iPython. I\u2019m usually running it in a pop up terminal next to whatever IDE I\u2019m using (I switch between vim, PyCharm, and inteliJ depending on the project needs). \n\niPython is a great line by line REPL that has TONS of extra features making it nice to use. I could rant pages on it, but it\u2019s fantastic for learning.", "id": "invyl4a", "parent": "t3_xaw7t6", "vote": 4}, {"content": "I like pyzo. \n\nIt has less possibilities then pycharm, vscode and spyder BUT it has the best tree outline and it is the fastest of them all. \n\nI sometimes have to edit 20K plus lines of code modules but it does not show any latency like Pycharm, vscode and Spyder.\n\npyzo is written in Qt/PyQt and is open source.", "id": "inw4pgj", "parent": "t3_xaw7t6", "vote": 2}, {"content": "I always used PyCharm\n\nI did consider myself half decent once, but other than quite a cool launch control script for sim racing, I\u2019ve not written any Python for a couple of years.", "id": "inw67od", "parent": "t3_xaw7t6", "vote": 2}, {"content": "12+ years of coding experience, VSCode + Vim shortcuts plugin + custom shortcuts for project tree navigation.", "id": "inxmvl6", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Pycharm.\n\nSeveral years of python and I do back end and data analytics day to day professionally.\n\n\nThe tooling for managing and switching environments especially pipenv, poetry makes my life a lot easier. \n\nPycharm can make life a lot easier in TDD with the refactoring shortcuts. \n\nOn the data thing using the database integration from datagrip that\u2019s in pycharm is a huge time saver. I can dump queries out straight to excel, csv, html which pastes into word, excel and outlook perfectly and even more formats like pretty or markdown.\n\nI make use of tools like pylint, black, pre-commit, pytest git and mypy in my projects.", "id": "iny34tf", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Based on this comment section I feel as if I should be giving Pycharm a shot. I have mostly been using JNB and JL, I am trying nudge my way into data analysis, eventually data science.", "id": "iny69pd", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Full stack python development PyCharm professional or Inteliji ultimate edition. Best is Inteliji ultimate. If you are running automated test, generating coverage reports, memory profiling, static analysis of your code to identify the bottle necks. This is the best", "id": "inye5k4", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Vim. Nothing more is required.", "id": "inyj7px", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Senior swe, not python specific, but python also.\nvim.\nTried adopting vs code + vim plugin - it worth effort for golang for me, but the moment I became more familiar with the language and ecosystem - small changes became easier to do in vim. Muscle memory + minimalist interface wins the day - for me.\nPeople around me use vs code a lot - it seems to be a good environment of choice these days, especially due to plugin ecosystem. Set of advised plugins and their prferred initial settings are better maintained at team level - this simplifies onboarding a lot.", "id": "inyreog", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Pycharm is the best. It real helps in debugging things quickly either by yourself or gives automatic fixes. I am an intermediate level python programmer. Have made a couple of projects using python and database. My final year project file was taken by my local invigilator from the central board of education to check out cuz they found it to be good. Python is one of the easier languages out there. The standard IDLE that ships with python is also good enough for practicing things but doesn't provide much in terms of functions. A pro tip:- always always get your basics in check. They are the foundation of programming.", "id": "inyt9o0", "parent": "t3_xaw7t6", "vote": 2}, {"content": "I learned python + vim ~7 years ago , still using vim for all my work.\nFor exploratory I use Jupiter Lab.", "id": "inz101q", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Visual Studio Code easily. It's very customizable, has great python support, and is very lightweight. I have tried pycharm but just couldn't vibe with it after using vscode.", "id": "inwp025", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Senior Python developer, and use Pycharm.  Well worth the $$$.   The debugger is fantastic and can do what you describe.\n\nI\u2019ve tried VSCode and wasn\u2019t impressed at all.  \n\nThe subscription cost of Pycharm pays for the productivity gains - it pays for itself.", "id": "inxdxwq", "parent": "t3_xaw7t6", "vote": 2}, {"content": "Vs code. Nothing beats it.", "id": "inx66nm", "parent": "t3_xaw7t6", "vote": 0}, {"content": "Notepad", "id": "iny4i4r", "parent": "t3_xaw7t6", "vote": 0}, {"content": "I've been using Python for 10 years. I started with IDLE, then sublime, then PyCharm. I gave vscode a try but I uninstalled it about 10 minutes after.", "id": "inw36lq", "parent": "t3_xaw7t6", "vote": -1}, {"content": "Thonny is what you want, if you want the processes broken down step by step.  I've been learning for a couple months now, and VS Code just seems to work.  For now, it will do.", "id": "inw161i", "parent": "t3_xaw7t6", "vote": 0}, {"content": "I usually use vscode and I am 8/10 in python language", "id": "inwogz8", "parent": "t3_xaw7t6", "vote": -1}, {"content": "When I was starting out I was exclusively using jupyer notebooks but have since switched to PyCharm. \n\nThe datagrip integration with PyCharm professional is just unbeatable in my opinion. Plus it just had a lot of intuitive features built in (obviously bias there though). Can\u2019t speak to my skill level but I code in python everyday for work pretty much.", "id": "inwcwgl", "parent": "t3_xaw7t6", "vote": 1}, {"content": "I am an experienced programmer, but two weeks in Python... so a noob. I need to decide which IDE to use. The tutorials put me on Jupiter Notebook, but I saw Spyder IDE and thought that looked more practical.\n\nI am retired, so this is for a hobby use only. I could use vi for all I care, and use Jupyter for testing segments of code. I am developing on a Digital Ocean server... not local. Just writing some trade bots... exchange API, SQLite for storage, TA-Lib, panda.... open to suggestions for an IDE.", "id": "inwozla", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Vs code i can is best for me and I'm beginner in python and i like that \ud83d\udc0d", "id": "inwwgbz", "parent": "t3_xaw7t6", "vote": 1}, {"content": "VS Code all day long. Data Engineer at a startup.", "id": "inxjwpa", "parent": "t3_xaw7t6", "vote": 1}, {"content": "I use Spyder and IDLE; and I work with a small corporate library and make programs used by students and colleagues.", "id": "inxlwpx", "parent": "t3_xaw7t6", "vote": 1}, {"content": "10yrs senior/lead; Sublime Text. I don't use plugins. It's too much configuration. Once, I used PyCharm for some ugly codebases. The \"hyper-click\" feature came in handy.\n\nNormally, I'll just use find in project or just the directory tree for smaller projects.", "id": "inxq9tt", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Why not to use a code editor instead of a IDE? I have intermediate python knowledge, you can add some plugins, read their documentation and have fun, debugging, auto import and self complete are easy to find", "id": "inxr4zb", "parent": "t3_xaw7t6", "vote": 1}, {"content": " VS code I would say that I'm a high intermittent skill level.  Not sure if I can be considered a developer but I work on my own SAS projects for companies that I'm trying to start and I code API integrations for customers at work.", "id": "inxv5sh", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Spyder for anything focused on pure python. VS code for everything else. Spyder is great for starting a new project when I need to interact with and view variables to figure out what I'm doing. Vs code is perfect for making updates, debugging, managing git, etc. Engineering consultant, been using python for about 3 years so I'd say intermediate.", "id": "inxyumb", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Vs code.  I dont think the Jupyter extension is up to par of actual JNB for data science stuff, but it\u2019s close enough now that it can do whatever I need it to.  \n  \nWhen I say \u201cnot up to par\u201d I\u2019m admitting that it feels foreign and unnatural compared to jupyter and that it may as well be just as good at this point.", "id": "inxzyam", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Jupyter lab and doom emacs, but I wouldn\u2019t recommend emacs unless you\u2019re prepared for a steep learning curve", "id": "iny0l3x", "parent": "t3_xaw7t6", "vote": 1}, {"content": "DevOps engineer who has also done data analytics and software engineering. I primarily use Emacs for all of my Python development because:\n\n* I can customize it exactly how I want (interpreter, linters, etc.)\n* On-the-fly error checking with Flycheck and debugging support via PDB\n* Code completion and mini-buffer documentation via Company Mode and Jedi \n* Automatic PEP8 formatting every time I save a file\n* Jupyter and IPython integration\n* Exceptional git support via *magit*\n* The ability to edit remote files using TRAMP and retain all of my IDE functionality\n* The ability to document everything (and incorporate literate programming in code blocks) with Org Mode and export it to HTML, PDF, etc. for other developers\n\nAn added bonus is that I don\u2019t need to download a separate IDE for C++, SQL, Bash, etc. I can have split buffers with Python on one side and PlantUML on the other, and can work with both files simultaneously and have IDE support for both.  It also acts as a terminal, document renderer, SQL client, organizer, and several other features. \n\n[Here is a nice write-up](https://realpython.com/emacs-the-best-python-editor) on using Emacs as a Python developer environment.", "id": "iny3bi9", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Beginner. I jump between Sublime, VS Code, Mu, or PyCharm. When a program requires input, I practice linux commands in Ubuntu WSL or Git Bash and run the program within the shell. Obviously the easiest way is to use PyCharm for this. For graphics I use Py Processing. For git commit, VS Code.", "id": "inya4lx", "parent": "t3_xaw7t6", "vote": 1}, {"content": "I have Pycharm on my Linux virtual machine but I'm thinking trying VS Code soon. For some ungodly reason I don't want to install Python on my windows, my brain wants to keep it separated plus I enjoy Linux's Terminal much more than PowerShell (for when I want to run my python files in Terminal). I use [replit.com](https://replit.com) when I'm too lazy to fire up my virtual machine, its easily accessed and I like the user interface, its handy for small projects. I have been practicing python for a few months now, so I'm not advanced yet.", "id": "inyalxc", "parent": "t3_xaw7t6", "vote": 1}, {"content": "pycharm's pretty good yeah. It's what I use. 6 years of Python here.", "id": "inycos3", "parent": "t3_xaw7t6", "vote": 1}, {"content": "I would say vs code you can run and read almost anything due to its vast extension ecosystem, not to mention GitHub copilot. I consider myself as a intermediate developer.", "id": "inyefye", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Advanced user.. sublime text", "id": "inymqen", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Vs code and and Jupyter \n\u0130t's been 40days i have started", "id": "inyqbe9", "parent": "t3_xaw7t6", "vote": 1}, {"content": "I\u2019m new and was using Visual Studio Code but then, I think there was alert about an update or something, I started using Visual Studio 2022. What is the difference between them? I\u2019m probably going to switch to Pycharm, but I\u2019m curious. \n\nThe guy I follow and have started learning from who uses Python for Revit uses Pycharm.", "id": "inyqd7n", "parent": "t3_xaw7t6", "vote": 1}, {"content": "I have tried a few when I was at Uni. For data stuff I found Spyder that comes with Anaconda to be better for Data Analysis type stuff, and if data is your thing I don't think there is 1 that comes close to it. Atom is pretty good but isn't as appealing on the eye, but you can do more than just python on it and you can get it to work with GitHub pretty easy. Visual Studio I liked as it had auto-complete, but it wasn't as straight forward to use, but don't let that put you away from it because I think it was me not wanting to try.\n\nIMHO sometimes I find with people that it's just down to what they find more appealing on the eye, as you will need to sit and stare it for a bit.", "id": "inytje6", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Notepad on Windows and gedit on Ubuntu", "id": "inyviqd", "parent": "t3_xaw7t6", "vote": 1}, {"content": "4 years using python professionally.\nWeb developer Django, flask, fast api, odoo etc.\n Pycharm for work and vscode for \"dirty\" script's.", "id": "inz1phv", "parent": "t3_xaw7t6", "vote": 1}, {"content": "VIM - god level", "id": "inz1wrg", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Pycharm, Very versatile interface. And its debugging feature is very good. And this is coming from a person Who has recently got introduced into Python 3 weeks ago", "id": "inz2cci", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Though I started my programming journey with Java but I really wanted to try python as most of my friends were learning it and it has many advantages over java. I basically used every idle to learn it like python's idle , pycharm,visual studio,atom , jupyter notebook etc. And after trying all of them Pycharm and and idle are my top preferences.", "id": "inzk7mb", "parent": "t3_xaw7t6", "vote": 1}, {"content": "PyCharm and VSCode for bigger projects.\n\nSublime for small offhand projects.", "id": "inzxlf3", "parent": "t3_xaw7t6", "vote": 1}, {"content": "PyCharm is the best IDE for me :)", "id": "io02j2v", "parent": "t3_xaw7t6", "vote": 1}, {"content": "I'm a level 20 python wielder with data science and SOLID perks and I use a pycharm build.", "id": "io09n1z", "parent": "t3_xaw7t6", "vote": 1}, {"content": "IDE i usually use pycharm or vs (visual studio)\nI use vs for when i am writing flask, djang or ursina code but anything else i just use pycharm however i have also tried sublime text, Mu(i still use it sometime but on rare occasions) as for my level i have been learning for like 3 year so i would say i am pretty comfortable with python", "id": "io0e5lt", "parent": "t3_xaw7t6", "vote": 1}, {"content": "Editor = Emacs; Level = Advanced (8 years)", "id": "io3xxjj", "parent": "t3_xaw7t6", "vote": 1}, {"content": "PyCharm and TDD has pretty much saved me from spending twice the amount of time on projects.  I think the conservative estimate is it\u2019s saved me from spending 100% more time on fixing defects.  I think if I didn\u2019t do TDD and PyCharm debugging, I would be spending not just 100% but 200% more time on fixing deep rooted issues in my code.  TDD is the guard rail but for tracing through code that doesn\u2019t necessarily lend itself to unit tests (where I haven\u2019t written automated integration and functional tests) the debugger and stepping thru code and seeing the current run stack is indispensable.  It\u2019ll free you up to spend time with your family or whatever you do on your free time.", "id": "inyda88", "parent": "t1_inw2jyy", "vote": 8}, {"content": "I tried to use the debugger to have line by line process in pycharm but it requires break points and doesn't process/return values one by one live on demand...i wish that could be added in pycharm like replit does", "id": "inw673m", "parent": "t1_inw2jyy", "vote": -18}, {"content": ">For me that's Emacs, because I learned it a very long time ago and have it configured the way I want, with decades of muscle memory. For a lot of my co-workers it's PyCharm or VS Code. For you, who knows? Try a few things and see what you like. Don't listen to people who tell you there's only one you should use, or who will look down on you for using something they don't like.\n\nThat's really good advice thanks !", "id": "iny9pfn", "parent": "t1_inwxefi", "vote": 1}, {"content": "I'm sure you got downvoted for this.  I have used Jove for decades an always get downvoted when I tell people this.  Muscle memory is very powerful.  And change in workflow tools  can really impact productivity.  In 2018 I broke my wrist had was forced to use vi(m) since I had one hand.  I did so much more damage while editing that I thought was possible.\n\nWhen I watch any youtube videos where people code using an IDE, the constant popups with suggestions as you type seem very distracting rather than helpful.  For users who are new to a language, some of this functionality may be useful.", "id": "inyzltb", "parent": "t1_inwxefi", "vote": 1}, {"content": "Would you mind sharing your init.el? Or just the snippets relevant for python? I'm looking for ideas how to optimize my config...", "id": "io0ajpn", "parent": "t1_inwxefi", "vote": 1}, {"content": "I tried the jupyter extension in vs code but it runs slow as hell, i don't know if they fixed that issue.", "id": "iny0vle", "parent": "t1_inw2h26", "vote": 5}, {"content": "VS code is best", "id": "iny5c4h", "parent": "t1_inw2h26", "vote": 1}, {"content": "[deleted]", "id": "inykxuc", "parent": "t1_inw2h26", "vote": 1}, {"content": "Thats awesome information! Thanks!", "id": "inx2kpr", "parent": "t1_inwc3gl", "vote": 4}, {"content": "I'm more at the beginner level, but I also prefer a text editor + terminal over an IDE, with gedit as my editor of choice", "id": "inwqyr7", "parent": "t1_inwcx2a", "vote": 9}, {"content": "And i thought I was a savage using vs code conteinerized with shared workspace between linux host os (using thony on it) and windows (smb+sublime/vscode)\n\nEdit: In a good way obviously. \n\nAdd: I'm studying with a new course and the teatcher is using anaconda, pycharm and kivy, so Im going to replicate his setup in VM/Docker so I can have the same results as him. (You guys have any thoughts on kivy? )", "id": "inx1q6e", "parent": "t1_inwcx2a", "vote": 5}, {"content": "What is the difference in vi, vim, and neovim? What do you think about nano?", "id": "inyid41", "parent": "t1_inwcx2a", "vote": 2}, {"content": "+1\n\nI use Vim instead of NeoVim and drop into shell for everything other than coding.", "id": "inyk2es", "parent": "t1_inwcx2a", "vote": 1}, {"content": "Same! I started with Spyder and liked how easy it was to run through the variable explorer. Now I\u2019m a bigger fan of vscode, but it\u2019s so robust with options and configurations that I don\u2019t think I would have liked it early on.\n\nIn retrospect though, I think Jupyter notebooks would have really helped me learn and improve sections of my code faster.", "id": "io0nh8h", "parent": "t1_inwy3ue", "vote": 2}, {"content": "These multiprocess issues made me switch to VSCode. Tried some Pycharm also, but I like some more lightweight IDE. The amount of (great) features of pycharm feels a bit overwhelming to me. I think one benefit of the switch is some better structured code, as I think Ipython and Jupyter can lead to some bad habits.", "id": "inyivq1", "parent": "t1_inwy3ue", "vote": 1}, {"content": "An engineer here: I like spyder and pycharm for its matrix/data frame introspective abilities - unfortunately VSCode is not on that level wrt to this. On other levels I am happy with VSCode and it's many plug-ins", "id": "iojp1hd", "parent": "t1_inwy3ue", "vote": 1}, {"content": "I was looking for someone to say Jupyter notebook (and lab), which is what have used for most of my projects. I have used used Sublime a few times. BTW, I have been working on my Python skills for about a year and a half, but I am not sure if I would consider myself to be a upper beginner or lower intermediate. Because I haven\u2019t used Python in a professional / work environment, yet.", "id": "iny3gjy", "parent": "t1_inwi5uq", "vote": 2}, {"content": "Never thought of using multiple IDEs...is it efficient and what are the benefits? Since im in a learning process, my projects are small (less than 100 lines of codes) packed in 2~3 python files and usually have no librairy...i have 2 \"big\" projects in mind which are the reasons im learning python...i just want to have the best basics (especially IDE) to help me through that journey", "id": "inw7f5u", "parent": "t1_invyl4a", "vote": 1}, {"content": "Out of curiosity, what shortcuts you need/use in an IDE? And you use both VScode and Vim silmutaneously? What are the benefits using 2 IDE? Really trying to understand vets/pros way of coding to try multiple approaches", "id": "inxr20j", "parent": "t1_inxmvl6", "vote": 2}, {"content": "What I like about VSC that I don't think PyCharm has, is I can use it for almost all of my dev work. Everything from Python to Rust to HTML works seamlessly with it.\n\nMaybe JetBrains Fleet will offer competition on that front, but I hate having to dedicate an entire environment to working with one language (doubly so for a language like Python, that you often have to interface with other languages like C or Rust.)", "id": "inxatlp", "parent": "t1_inwp025", "vote": 3}, {"content": "yeah man i feel the same way", "id": "iny5pit", "parent": "t1_inwp025", "vote": 0}, {"content": "Well..... my experience is that vscode is ridiculous slow when coding and way too complex for doing just coding. Too many options on too many places with too many vague discriptions.\n\nThe tree outliner is slow as well with a lot of latency when there are many methods inside a module. CPU usage is high on an 8 core i7 with 16GB of RAM on Linux Mint.\n\nIf I compare that to Pyzo then Pyzo is so much a relief compared to the other big ones as well  (PyCharm and Spyder).\n\nIn terms of functionality PyCharm and Spyder are so much more better too then vscode but they remain complex and slow compared to Pyzo.", "id": "inyr9j9", "parent": "t1_inx66nm", "vote": 1}, {"content": "Not even notepad++ ?", "id": "inycfyv", "parent": "t1_iny4i4r", "vote": 2}, {"content": "So pycharm is what you use now as a professionnal?", "id": "inw6at2", "parent": "t1_inw36lq", "vote": 2}, {"content": "That's the kind of answer i very like, explaining the pros of the tool you use...thanks for the precious infos and your time for replying", "id": "inycckj", "parent": "t1_iny3bi9", "vote": 2}, {"content": "VSCode: \n\n* multiplatform (Linux,MS, i believe Mac as well)\n\n* no prefered language\n\n* open source\n\n* module/plugin based\n\nVisual Studio:\n\n* windowd only \n\n* designed for C#/MS Projects, lots of other stuff to optimize and analyse\n\nMant IDEs support additional languages and featues, but they often feel very secondary.\n\nWith the right plugins you can develop on most of the effectively.", "id": "inzyadl", "parent": "t1_inyqd7n", "vote": 2}, {"content": "If you use debugger you get all variables previously defined and you can create new one in the debugger. I also didn't like it or Pycharm overall but once you learn the features it's a really good IDE in my opinion", "id": "inw91eh", "parent": "t1_inw673m", "vote": 12}, {"content": "You put 1 breakpoint to tell it where to stop, then you can go further line by line, evaluate functions, calculate variables, do whatever you want.\n\nNgl, I find your tone quite arrogant, especially for a beginner...", "id": "inwplwr", "parent": "t1_inw673m", "vote": 10}, {"content": "when you add a breakpoint. Right next to the word Debugger is the word console...\n\nClick it\n\nWelcome to the REPL.", "id": "inw9hp2", "parent": "t1_inw673m", "vote": 1}, {"content": "Isn\u2019t there an option on context menu to execute selected code. Maybe your requirements are different but I was able run line by line", "id": "inxih7y", "parent": "t1_inw673m", "vote": 1}, {"content": "they did", "id": "inz2yvg", "parent": "t1_iny0vle", "vote": 1}, {"content": "For some applications, such as data analysis, you don't need to run a script, you need to run some code, get some output and then base your next steps on that output. For that something like a jupyter notebook is very useful.", "id": "inyqmun", "parent": "t1_inykxuc", "vote": 6}, {"content": "I've never used Kivy, but from a quick bit of research, it looks like a good tool, though I prefer doing everything myself, hence not using an IDE, I did use Pycharm for a while, and I think it's a very good IDE", "id": "inxda6h", "parent": "t1_inx1q6e", "vote": 4}, {"content": "I also try getting different ide as my instructor changes lol", "id": "iny5l4w", "parent": "t1_inx1q6e", "vote": 2}, {"content": "Kivy is fine. IDK though at the point where I need a GUI for a python app, im just refactoring it as a web server and writing the front end in JavaScript.", "id": "iny6k3v", "parent": "t1_inx1q6e", "vote": 2}, {"content": "vi was an older editor, but is now a minimal implementation of vim\n\nvim is a vi-like editor with more features and plugins\n\nneovim is a fork of vim with a few different features and plugins, many of which still work with vim", "id": "io0crl4", "parent": "t1_inyid41", "vote": 1}, {"content": "For now, pick what you enjoy working in and don\u2019t even question or listen to other people telling you to change. \n\nWhatever most quickly and comfortably gets you using and interacting with python is the right one for now.\n\nI don\u2019t really do multiple ones consciously, but I tend to prefer vim simply because I\u2019ve been using it for almost 20 years and am very comfortable in it, but I started using PyCharm at work as it\u2019s very powerful and I really like some of the lookup features, especially when parsing multiple work projects, which are huge and messy.\n\nIntelliJ is Java and honestly I think anyone doing Java without an IDE is a masochist. It\u2019s made by the same people as PyCharm though, and I like the feature parity/parallels between them.\n\nBut above any other piece of advice, I\u2019d honestly say do NOT worry too much about what\u2019s \u201cright.\u201d\n\nWhat\u2019s right is writing and reading more code for now. Whatever gets you there is the right one for you.", "id": "inw9ela", "parent": "t1_inw7f5u", "vote": 6}, {"content": "Hi, glad that you ask and sure, let me explain the comment more in detail! the IDE is VSCode with a plugin that enables the same modes and shortcuts as VIM, that let's me search inside a file using the \"/\" key, navigating with h,j,k,l instead of arrow keys, split the code window with CTRL + W + s or + v, change tabs with gt or gT, etc.  \n\n\nThis is beneficial for my workflow and to avoid pain in my hands as i don\u00b4t need to use the mouse for anything. Other shortcuts that i've configured are related to display/hide the project folders using CTRL + shift + T, split the console in two, resize the console with ctrl + \\` + h|j|k|l.  \n\n\nAnd something cool! i'm using a Chrome plugin called Vimium that let's me navigate web pages using the same shortcuts :D.  \n\n\nHope this helps and feel free to ask any additional questions!", "id": "inxxkr6", "parent": "t1_inxr20j", "vote": 3}, {"content": "PyCharm has html, css, js, rust(with extension) support, and personally writing html in pycharm is much easier since it suggests stuff", "id": "inypx4d", "parent": "t1_inxatlp", "vote": 2}, {"content": "Tbh I've never had a problem like that on my macbook pro. I'm thinking it could be a hardware issue depending on what year the i7 is from. Not all i7s are made equal. For me vs code is just perfect, gets all the work done and is a good experience to just use.", "id": "io0xl2p", "parent": "t1_inyr9j9", "vote": 1}, {"content": "nah, the code and I go toe-to-toe with the kiddy gloves off", "id": "inyg38t", "parent": "t1_inycfyv", "vote": 1}, {"content": "Yes. I've used the community edition the most so even though I have the pro version through work now, I'm still not using all of its features out of habit. The basic stuff is on autopilot now so a new IDE would have to be a lot better to make me switch.", "id": "inwa2iv", "parent": "t1_inw6at2", "vote": 2}, {"content": "[deleted]", "id": "inyrbzn", "parent": "t1_inyqmun", "vote": 1}, {"content": "I might do that as well, but learning a gui might come in hand some day, plus this course is the third im taking on python and the teacher is going through every step, like everything, and it was his course that thaught me about venvs and their need.", "id": "inze8fj", "parent": "t1_iny6k3v", "vote": 1}, {"content": "I'll keep that in mind for when i reach a decent level of python...thanks for sharing", "id": "inyysuk", "parent": "t1_inxxkr6", "vote": 2}, {"content": "Interesting! Does this go for almost all languages (where they have some extension that supports them, like in VSC) or only a few?\n\nAnd are the extensions as good as they are on VSC?", "id": "inzl4ls", "parent": "t1_inypx4d", "vote": 0}, {"content": "Notebooks are much more convinient for exploring raw data. Things like image processing, geospatial data analysis or interactive plots come to mind.\n\nAlso they a good way to present and document a workflow for people without extensive programming experience, that is the main reason they are a thing.", "id": "inywr4c", "parent": "t1_inyrbzn", "vote": 7}, {"content": "you need to use the special IDEs like IntelliJfor java, bur pycharm does syntax highlight it, just doesn't have all the tools for example java", "id": "io0v1e8", "parent": "t1_inzl4ls", "vote": 2}, {"content": "Scientist who has used python for data analysis - can confirm. A lot of the time we are working with new experimental types of datasets so we don\u2019t have appropriate analysis scripts hashed out. Notebooks allow us to do the analysis in real time, including visualization with packages like plotly.\n\nAnd then for all our other software we write our own python packages/scripts, and use the VSCode debugger to work those out in development", "id": "inyzo1u", "parent": "t1_inywr4c", "vote": 2}], "link": "https://www.reddit.com/r/Python/comments/xaw7t6/which_ide_you_trieduse_and_what_is_your_level_in/", "question": {"context": "I've been learning python for a few weeks, working my way through different online courses. The first course I took was using pycharm, which is the only IDE I've used so far. I love how it auto completes the coding and adds imports automatically, but I want to know if it's the best IDE to use. I saw Angela Yu using replit at the beggining of her course and it had that awesome feature that let you run your code line by line, returning the results in a separate frame (like variables and arguments), which is a huge lack in pycharm in my opinion. I checked other IDE for python on google, but the opinions tend to lean toward pycharm as the best overall IDE. \n\n&#x200B;\n\nTL;DR: what's your python skill level and what IDE you use and why?", "id": "xaw7t6", "title": "Which IDE you tried/use and what is your level in python?"}, "resource": "Reddit"}, {"answers": [{"content": "Imagine randomly checking reddit and seeing an article about me on the front page! Anyhow, here I am, AMA.", "id": "gc55zcu", "parent": "t3_jtehnm", "vote": 383}, {"content": "I'll add that printf-debugging works well if the edit-compile-run loop is fast. If it takes an hour to do the loop, it becomes desperate.", "id": "gc58gf2", "parent": "t3_jtehnm", "vote": 118}, {"content": "I used to debug a lot using print statements before, but I've been favoring debuggers heavily the last year or so. It really just kind of saves time when I can stop at a breakpoint, read whatever I would have gotten from a print-debug, and then be able to make follow-up reads based on the new information I've gotten, without having to restart the program/add new print statements.\n\nI think having moved to tools that have very good support for debuggers has helped a lot, too. Back when I wrote a lot of JavaScript I used print-debugging more, as the debugger integration with the tools I used was never quite good enough.", "id": "gc55hkm", "parent": "t3_jtehnm", "vote": 30}, {"content": "I love the idea of debuggers, but most of the time when I've used them in the past they've been better in theory than in practice; it often seemed that it would take longer to get the debugger to do what I wanted than to add a `print` statement. I agree with both of itsnn's comments, where I prefer logs anyway (because it's what I'll be depending on to debug production), but I also do find the JS debugger in Chrome to be very useful.\n\nOne other area where I do find debuggers useful though, is when they're part of an IDE specifically made for the language I'm using and I'm using the IDE to get familiar with a new codebase. I do tend to find that I often outgrow them once I become more familiar with the codebase, and the weight of using an IDE eclipses the benefit I get from it, but I like having it as a tool for that initial exploration.", "id": "gc562v7", "parent": "t3_jtehnm", "vote": 22}, {"content": "I feel like this is IDE / Language's environment dependent\n\nI don't feel why would I want to add those 1-time-use logs (in majority of the cases) when Visual Studio / C# offers me conditional breakpoints, expression evaluation at fly, an ability to change values at fly and add to that: an ability to change the code at fly, so when I hit the breakpoint then I can edit next lines. Probably also an ability pick thread that you want to debug.\n\nOf course it's not like I don't use those logs at all, sometimes they're very handy when stuff is going on on various threads and you don't like jumping.", "id": "gc55mvl", "parent": "t3_jtehnm", "vote": 17}, {"content": "I never do debugging with a debugger. I favor logs, because logs remain. That being said, I have however a notable exception from the rule above - javascript", "id": "gc54ys5", "parent": "t3_jtehnm", "vote": 27}, {"content": "It's an attitude common in the c++ world, and rare in the c#/java world, the difference is that debuggers are really good on the managed languages side.", "id": "gc5fsxm", "parent": "t3_jtehnm", "vote": 9}, {"content": "As people said in the thread, this seems less of a debugger in general problem and more a debugger for language X sucks. \n\nIf your debugger can't give you clean information, it's a bad debugger.\n\nObjectively, if the debugger doesn't suck, it's superior to any type of print statement since it can do anything a print statement does and then some.", "id": "gc5avaz", "parent": "t3_jtehnm", "vote": 21}, {"content": "Dunno how to link this, but damn...\n\n> \tWalterBright on Dec 31, 2018 [\u2013]\n\n> I used to build/program embedded systems (around a 6800 uP). I'd debug using an oscilloscope, sometimes an LED attached to a pin, sometimes connecting the pin to a speaker (!). There wasn't enough EPROM space for a printf. And besides, the turnaround time for erasing/blowing an EPROM was just too long.\nEssentially you just get good at staring at the code and running gedanken experiments till you figure it out.", "id": "gc6qfen", "parent": "t3_jtehnm", "vote": 7}, {"content": "I strongly disagree. To me the ability to set a conditional break point, look at the values of variables and memory, set a different break point, change the value of a variable and then try again, without having to change applications or recompile is invaluable. It is also useful in the case of new code and you just want to follow the execution to see what it does. Adding printf statements and recompiling seems like a unnecessary step, that still does not give you the abilities a debugger does.", "id": "gc5a4f0", "parent": "t3_jtehnm", "vote": 10}, {"content": "Who cares? Use whatever you need to figure out the problem.", "id": "gc57hgv", "parent": "t3_jtehnm", "vote": 11}, {"content": "I also rarely use the debugger. I joke that I need a version called gdbbt because backtrace is all I ever use.\n\nI feel that many developers overuse the debugger rather than reading their code and trying to find the logic error.", "id": "gc60nao", "parent": "t3_jtehnm", "vote": 4}, {"content": "With a debugger you can see and search the entire state of the program, try out and examine code on-the-fly and insert conditional breakpoints. Printf does not even come close to this in terms of productivity. Debuggers are a tool that people need to learn how to use efficiently, but once you have the knowledge it's much, much faster than trying to figure out issues by printing stuff out, especially if your compile cycle is slow.", "id": "gc5nso2", "parent": "t3_jtehnm", "vote": 6}, {"content": "Great thread full of arbitrary opinions! Here's my slice of cheese on the thing:\n\n**printfs/logging**\n\n- write what already happened, great for surveying execution history, shove all the data in elasticsearch and analyse trends\n\n- write only what you specified before the execution started\n\n- can get screwed up if operating time is very small: you may have print 2 before print 1 due to compiler optimizations and thread synchronization bugs, cpu timing etc.\n\n**debuggers**\n\n- allow inspecting what is going on before and after each instruction, execution is still ongoing\n\n- can look-up any piece of data in memory, can execute custom functions at any state you've stopped\n\n- can reach almost any desired state due to breakpoint conditions and custom breakpoint calls\n\n- may be slow to load, may mistakenly run with release builds, is useless at debugging release builds which have problems debug builds don't\n\nPOR QUE NO LOS DOS?\n\n>If your loop takes billions of iterations on gigabytes of data before returning the wrong answer, how do you debug? Breakpoints are useless because which iteration introduced the fault? The critical paths are long. Watchpoint start after you pauzed. Reverse debugging is to slow for millions of instructions.\n \n>My conclusion: A debugger is good for finding bug in data that moves, not for data that changes.\n\n\nHow are printfs useful in scenarios with billions of cycles with an unknown culprit ? Printing tons of data in a log is not pretty and you'd have to target the code loop either way to find the spot with the error and isolate it in a separate run.\n\nA good debugger also shows you what's being executed and can replay a particular instruction or a custom call causing the data to change again. You can also edit the data and then call the function again and again. You can effectively test strange code directly and interactively.\n\nI believe the debugger and log prints are complementary with profiling being the hardcore option.", "id": "gc5glvv", "parent": "t3_jtehnm", "vote": 3}, {"content": "I've always wondered if devs that use printf don't know that debuggers can do that same thing without having to go as far as recompile, or if somehow Microsoft of all people just have a better debugger than average.\n\nThough I abuse the hell out of my debugger, being able to drag the execution of the code around to skip or re-order code to see how something behaves is a life safer rather than multiple recompile runs. I tend to abuse it to skip over code I'm not interested in too, and I've on more than one occasion used conditional-breakpoints to set variables to values I want them to be to reproduce some weird behavior.", "id": "gc5nxa1", "parent": "t3_jtehnm", "vote": 5}, {"content": "Me too.\n\nDebuggers are more fun to write than to use.", "id": "gc53q2y", "parent": "t3_jtehnm", "vote": 6}, {"content": "Low-level code tends to favour debugging, as it can be tricky to follow the logic by hand, instead of a real sample. This type of code typically doesn't log much and may have strict performance and resource utilization requirements. Debugging is the tool when you know the codepath and data with some sort of flaw.\n\nComplex high-level code favours using logs and log-levels, to be able to analyze what happened after the fact. There's less invisible magic, but there might be off by one errors that have gone unnoticed, or other flaws in higher level logic. Debugging may be too narrow a scope, especially for interdependent services and codepaths. High-level code tend to be more readable, so debugger may not bring much more clarity than just browsing the code and following definitions.\n\nThere's room for both. Though, for business rules logs should absolutely describe what the automation did, why and when.", "id": "gc57ncq", "parent": "t3_jtehnm", "vote": 2}, {"content": "one unsung genius programmer.", "id": "gc5lcgt", "parent": "t3_jtehnm", "vote": 2}, {"content": "::nervously looks at feet because his program only works in debug mode::", "id": "gc5tc7t", "parent": "t3_jtehnm", "vote": 2}, {"content": "Everybody uses logging for proper information filtering. Problem is when using printf makes the bug go away. I worked in embedded , where you out rarely can afford to do remote debugging. You are lucky to catch something with ringbuffer logging, esp with real-time.\n\nNow printf forces stack alignment. In one major case adding a printf fixed a sigbus for us. Or -DDEBUG fixed it also. Not Intel obviously. Involved calling out to a fortran blas library. Fortran demands 16byte stack alignment, but forcing 16byte as alignment on all calls would have been far beyond our memory budget. Do we kept the printf in. Apple does similar stuff because of SSE, double optimizations.\n\nThere are also many cases where everything works under gdb, but crashes without.", "id": "gc5x6h7", "parent": "t3_jtehnm", "vote": 2}, {"content": "I use print statements when debugging either race conditions, something that happens intermittently, or when I already know how things are going to be and I don't want to step through nonsense.", "id": "gc76at1", "parent": "t3_jtehnm", "vote": 2}, {"content": "It amazes me how few people in the industry seem to know tracepoints exist. You can get the prints while running the debugger without changing the code. It's the best of both worlds in a lot of situations (not every situation obviously, and not as a replacement for proper logging and/or event tracing). IDEs can easily save and manage the tracepoints. When you're done with it forever, you delete the tracepoint. You can easily make it a conditional tracepoint the same way you'd make a conditional breakpoint. For a lot of normal debugging tasks, they're a great tool for the job, but so few people know they exist.", "id": "gc79dga", "parent": "t3_jtehnm", "vote": 2}, {"content": "3 hours ago I was an hour deep into a strange bug. I had break points going. The debugger was flying. Watch points and expressions.  This bug had evaded me so much I even broke out the disassembly. Still no solution.\n\nFuck it.\n\nI pepperred printf everywhere. Printing values, memory address, function pointers, everything I could think of.\n\nAnd then I saw it. Printing out the\n\n    sizeof()\n\nA bunch of stuff revealed that the calling application had allocated more bytes for a boolean datatype than the interface library had. So the library only ever read the higher order byte which was always zero for a boolean type.", "id": "gc7dgzu", "parent": "t3_jtehnm", "vote": 2}, {"content": "> I mostly use printf. A debugger is only good for telling you where it seg faulted and the stack trace.\n\nlol\n\nWe have a system with potentially 1m concurrent users. We store a small history of each user state in memory. That way, if we get a crash, we can just open the core file in gdb, check not only the backtrace (where we crashed), but also how we got there over time. And you also have the full user state, not only the state you thought you needed.\n\nLog outputs, at the same time, is mostly useless, you have a million user's logs mixed, most of it us aggregated, and some of it is lost.\n\nEven for non-crashing problems in system test (e.g. a log indicating a problem), is most often solved by replacing the log with a crash, and rerunning the test.", "id": "gc5iagx", "parent": "t3_jtehnm", "vote": 1}, {"content": "I've come across this attitude way too often in my carreer. IMHO there are two types of people who look down on developers using debuggers:\n\nThose who are limited to working on the command line and/or cannot use a graphical debugger due to poor tooling/IDE support (Bazel, looking at you) and just don't know about the wealth of information it can give you. Raw gdb _is_ hard to use after all.\n\nAnd then there are those who think of debuggers as a last resort tool that is only used by mediocre developers who don't know what their code is doing. Unfortunately this elitist view can spread from rockstars to normal developers. Please don't be one of those.", "id": "gc5f08w", "parent": "t3_jtehnm", "vote": 3}, {"content": "I use TDD, where you basically validate the printf's. No need to debug the code if it does EXACTLY what you want and expect. \n\nIf you also make sure you can log real life scenario's, you are golden... which can be nearly impossible due to timing issues. So, determinism for the WIN! \n\nBlep.", "id": "gc59yu9", "parent": "t3_jtehnm", "vote": 1}, {"content": "I mostly use printf for debugging.\n\nIt scales better than a debugger:\n\nPrints allow you to add verbosity, rerun, add verbosity, rerun, and so on until you get a rich log. Each successive run produces outputs incorporating all previous prints. (I guess you can mimic this by driving a debugger with a script, but why bother?)\n\nYou can read the resulting log forward or backwards. Most debuggers don't let you go backwards, but of course we need to debug from effect back to cause.", "id": "gc81o3m", "parent": "t3_jtehnm", "vote": 1}, {"content": "For me this really depends on the language. For something like C# the debugger is just good enough that it isn't worth dropping down to console output. For native languages debuggers are usually bad enough that I'd do anything to avoid them.", "id": "gc5rgya", "parent": "t3_jtehnm", "vote": 0}, {"content": "Usually when debug builds are too slow it's that inlining is missing. Just manually annotate the critical functions as always inline and wala, fast again.", "id": "gc5qc1b", "parent": "t3_jtehnm", "vote": 1}, {"content": "I can't imagine using printf for debugging. I would feel crippled and my debugging would slow to a crawl\n\nBut, I like the author's statement that he doesn't want to force anyone to do it his way or have a tool war, he just uses the tool that works for him", "id": "gc63lwu", "parent": "t3_jtehnm", "vote": 1}, {"content": "Who?", "id": "gc72rq5", "parent": "t3_jtehnm", "vote": 1}, {"content": "I mostly use 'print', not 'printf', for debugging, but then I don't code in C.\n\nA C-style 'printf' is just incredibly fiddly to type, especially as debugging prints are added and removed constantly. C:\n\n    printf(\"p = %p, tag=%lld, value=%lld\\n\", p, p->tag, p->value);\n\nThat has 9 shifted characters. My print with 0 shifted characters:\n\n    println =p, =p.tag, =p.value\n\nAlso, not being case-sensitive, I often write such temporary statements in capitals, to make them easy to see, comment out or remove.\n\nAs for debuggers: never used them. They would anyway be of limited use in the private languages I code in, and in the language-related projects I tend to work on, the issue could be in one of several layers of source code:\n\nIt could be a bug in my script program, in the interpreter for that program, or in the compiler I used to build it, or in the compiler for that compiler...\n\nThe speed of the turnaround time has been mentioned (for edit-compile-run). Edit takes as long as it takes, but on my projects (up to 50Kloc), a full rebuild might take 0.2 seconds. (So you can afford to keep rebuilding just to tweak the layout of a print, since it's more or less instant.)", "id": "gcbj58b", "parent": "t3_jtehnm", "vote": 1}, {"content": "Oh, I enjoy so much your sharing of experience and your always interesting explanations! A Big Thank you!", "id": "gc577dd", "parent": "t1_gc55zcu", "vote": 47}, {"content": "What editor do you use? I work with some very talented developers who all use SlickEdit although lately theyve been switching to Code. I need all the eye candy i can get...", "id": "gc56oq9", "parent": "t1_gc55zcu", "vote": 21}, {"content": "Hi Walter, what is your opinion on how C++ turned out?", "id": "gc5cy1b", "parent": "t1_gc55zcu", "vote": 14}, {"content": "You work on compilers and similar tools. Do you think that would still be the case if you worked on an enterprise monstrosity?", "id": "gc56tp8", "parent": "t1_gc55zcu", "vote": 14}, {"content": "What was your relationship with funding like in the first 10-ish years of designing & developing D-lang?", "id": "gc59jyn", "parent": "t1_gc55zcu", "vote": 7}, {"content": "Do you follow the Rust programming language as well?\nIf yes, I was wondering what you thought about the governance model it follows for feature development (RFCs, Working groups, etc)", "id": "gc59ee7", "parent": "t1_gc55zcu", "vote": 8}, {"content": "What is the hardest part of creating a new language (+ecosystem) so that it becomes sufficiently popular?", "id": "gc5hz3b", "parent": "t1_gc55zcu", "vote": 3}, {"content": "3-4 years ago you answered to a question of mine (I one day want to sell my own static analysis tool) and you encouraged me to go for it, I made a screenshot and still have to find it somewhere. You absolutely made my day!\n\nNowadays I work in a demanding job where I learn much about the full tech stack - that will be handy later on. I still think about my MVP now and then. I have one smallish thing and one middle-sizish-project in my pipeline and then I will beginn work on the MVP in my free time, maybe while reducing work. Let's see where this goes! I still think there is some low-hanging fruit and unexplored nieches, even though I am aware that tool-building is a huge endaveor... ;)\n\nAll the best to you and thank you for your kind words back then!", "id": "gc8qq0f", "parent": "t1_gc55zcu", "vote": 3}, {"content": "have you ever decided to start businesses of your own?", "id": "gc5m9wl", "parent": "t1_gc55zcu", "vote": 2}, {"content": "What did you eat for lunch today?", "id": "gc64ozy", "parent": "t1_gc55zcu", "vote": 2}, {"content": "I have one question about software development in general: \n\nWhat do you think are today, in general terms, the best solutions for library development, packaging, distribution, and dependency management?  \n\nHow can build products with complex and \"cloudy\" dependency chains (say, something like tensorflow or OpenCV ) be delivered in a stable and reproducible way? \n\nWhat do you think are key features that modern build and packaging systems beyond compilers need to cover? \n\nAnd which approaches, are, in your opinion, less than optimal, for perhaps non-obvious reasons?", "id": "gc5oztx", "parent": "t1_gc55zcu", "vote": 2}, {"content": "I'm currently learning C and this printf debugging is a real life changer.\n\nI now only need a rubber duck and then I'm basically settled :')\n\nNo questions here, just a thank you!", "id": "gc758id", "parent": "t1_gc55zcu", "vote": 2}, {"content": "There is an interesting question from /u/syoliver : https://old.reddit.com/r/programming/comments/jtehnm/walter_bright_explains_i_mostly_use_printf_for/gc586mu/\n\nThe question is, what do you do if you do not know the code base (or do not know it well)? By your experience, what is the best strategy for debugging then?", "id": "gc61qem", "parent": "t1_gc55zcu", "vote": 1}, {"content": "Do you think that it is possible to implement a D \"[REPL environment](https://en.wikipedia.org/wiki/REPL)\" similar to Scala or CL, where one can enter code and test interactively? I remember that once, many years ago, I tried out a tool which was called \"C interpreter\", and it confused the heck out of me, because it actually interpreted C.", "id": "gc8uozj", "parent": "t1_gc55zcu", "vote": 1}, {"content": "Do you so any pen and paper debugging? Sometimes I want to tear my hair out when the compiler insists on doing nothing for minutes end for simple changes, and resort to notepad!", "id": "gc8m194", "parent": "t1_gc55zcu", "vote": 1}, {"content": "I've found printf to be very effective in two instances:\n\n* Debugging Monocypher. It's small (<2K lines), and in pure C, so even with optimisations, the thing takes less than 2 seconds to compile and run.\n\n* Debugging a bytecode interpreter I wrote for a custom scripting language (to test programmable logic controllers). The garbage collector more specifically:\u00a0I scanned the heap for objects, and printed them all. If I see something weird, I probably corrupted my heap somewhere, and the trace gave me a good hint. It felt like a custom version of Valgrind, really. (Valgrind proper couldn't help me, because I\u00a0put everything in a giant array of bytes.)\n\nFor GUI applications however (I'm thinking Qt specifically), the debugger starts to be more enticing. Though I\u00a0mostly use it to get the stack trace upon crash, and walk the code step by step only infrequently.", "id": "gc5guth", "parent": "t1_gc58gf2", "vote": 28}, {"content": "Love this, I've started working in a server side, containerised environment, reloading micro services using file system watchers: for the most part I hit save and see the service reload, If things are going screwy I feel the logs.\n\nTldr fast reload is the bomb", "id": "gc5vvjp", "parent": "t1_gc58gf2", "vote": 8}, {"content": "What are some good not-so-well-known tricks to make that loop fast?", "id": "gc5w3em", "parent": "t1_gc58gf2", "vote": 3}, {"content": "It's also sometimes the only option that works when debugging UI interactions :'(", "id": "gc98iei", "parent": "t1_gc58gf2", "vote": 2}, {"content": "In a way, it seems like using printf makes me think harder, and better, about what I need to know - what I think the program should be doing, what I *believe* it is doing, and what I really observe from what it actually does. It seems to help a lot to separate these aspects. At the end, I have a mental model about the program which is wrong, otherwise it would be doing what I expect. The primary task is to dig out that mismatch.\n\nFor me, it does not seem to be the tool support which makes the difference; for example both Visual Studio or Emacs with gud-mode do have excellent GUI debugging capabilities for C/C++. It is just that using these does not seem to save me time to understand what happens. One thing I observe is that a debugger seems to tend to resolve information to *below* the level of abstraction I am working.", "id": "gc57fhj", "parent": "t1_gc55hkm", "vote": 23}, {"content": "Which debuggers did you use before? Which features / capabilities did make the difference for you?\n\nI am wondering because the ability to set breakpoints and inspect variables alone is nothing new....", "id": "gc5j8mu", "parent": "t1_gc55hkm", "vote": 1}, {"content": "One thing is also: Setting a breakpoint somewhere and looking at a value once might be faster than inserting a printf and recompile. Perhaps, looking at the breakpoint takes half a second or one second. But if the breakpoint happens to be in a loop which is iterated 200 times,  a printf there gives you a nice table of values which you can muster at a glance, while a preakpoint costs 200 inspections and \"continue\" instructions. And to step through that that is definitively slower for me. And for me, it has turned out that a lot, if not most of the code I write (digital signal processing) does much of the work in loops.", "id": "gceqzz5", "parent": "t1_gc55hkm", "vote": 1}, {"content": "I totally agree. I almost always use a debugger. Logging can be good to determine some performance aspects, but for the most, even then, the debugger helps me just fine too.", "id": "gc6wtx4", "parent": "t1_gc55hkm", "vote": 1}, {"content": "> It really just kind of saves time when I can stop at a breakpoint, read whatever I would have gotten from a print-debug, and then be able to make follow-up reads based on the new information I've gotten, without having to restart the program/add new print statements.\n\ni think this is exactly what makes a REPL that loads into the running program work so well for LISP like languages (clojure etc). it's a more powerful breakpoint and eval-expression mechanism!", "id": "gc8dhzm", "parent": "t1_gc55hkm", "vote": 1}, {"content": "They aren't always 1 time use logs. I often will leave them in, just disabled, as they come in handy again. After a while I develop a sense of which ones should stay, and which are ephemeral. If it was in the debugger, I'd have to reinvent them. And since they stay in the code, they're worth some extra time in making them nice.", "id": "gc56q67", "parent": "t1_gc55mvl", "vote": 13}, {"content": "Logs are the UI for ops. Give your logs some love!", "id": "gc5f29y", "parent": "t1_gc54ys5", "vote": 15}, {"content": ">  I have however a notable exception from the rule above - javascript\n\n> `console.log( ... )`, `console.log( ... )`, `console.log( ... )`, `console.log( ... )`, `console.log( ... )`, `console.log( ... )`, `console.log( ... )`, `console.log( ... )`, ...\n\nI like that the log let's me drill down into the object, but in any other language I would just have serialized the whole thing when I wanted to see it anyways", "id": "gc60zeq", "parent": "t1_gc54ys5", "vote": 7}, {"content": "What makes the difference?", "id": "gc62nvx", "parent": "t1_gc54ys5", "vote": 1}, {"content": "My impression is that debuggers are actually more important in the C++ world. I have programmed Java a few times and Clojure a bit more, and I have to confess that it didn't ever *occur* to me to use a debugger on Java. Profiling tools? Yes, of course. Debuggers? Why?", "id": "gc5iqoy", "parent": "t1_gc5fsxm", "vote": 3}, {"content": "It depends on the context. Debuggers do have side-effects which become apparent when you're trying to understand a race condition or step through a UI event.", "id": "gc5dzmj", "parent": "t1_gc5avaz", "vote": 3}, {"content": "> As people said in the thread, this seems less of a debugger in general problem and more a debugger for language X sucks. \n\nBut I don't think they suck.\n\nPerhaps time-traveling debuggers (which can go backwards in time) could change the equation, but this has to be seen.\n\n> Objectively, if the debugger doesn't suck, it's superior to any type of print statement since it can do anything a print statement does and then some.\n\nWhat it **can't** figure out is where to put the print statement effectively. Because this where is related to the (wrong/broken/incomplete) mental model you have, and this depends on your mind, which the debugger has no access to.", "id": "gc5b3am", "parent": "t1_gc5avaz", "vote": 3}, {"content": "I hope not to disappoint you, but the discussion linked in the OP is about debuggers in general.", "id": "gc66yar", "parent": "t1_gc5avaz", "vote": 1}, {"content": "As someone who has recently debugged an FPGA by flashing LEDs on the board, it's quite funny to read this whole debate. Printf would be such a luxury!", "id": "gc8fiab", "parent": "t1_gc6qfen", "vote": 3}, {"content": "> It is also useful in the case of new code and you just want to follow the execution to see what it does.\n\nThis might be the thing. When I want to know that, I try to read the code.\n\nAnd the thing is, reading code is often harder than writing code, it is something that I learned much later than the first, and reading and understanding a program often takes considerable time, but there seems no alternative for that.", "id": "gc5ap3i", "parent": "t1_gc5a4f0", "vote": 6}, {"content": "Of course, but first one needs to be aware of various techniques in order to pick the most appropriate method. I often see people going around the horn (myself included) being unaware there's a canal.", "id": "gc57uu9", "parent": "t1_gc57hgv", "vote": 27}, {"content": "Well, as said, I am programming since more than 30 years, and as people say that using debuggers is an important and helpful tool for them, I am sometimes wondering what I am missing. The thing is that I *did* try them, of course! Just could not see the advantage. Or I might just always have been working in domains where debuggers just don't help - but then I wonder, in which domains are they really helpful for most people, aside from preferences?", "id": "gc58cng", "parent": "t1_gc57hgv", "vote": 9}, {"content": "One gripe I have is that good programs are structured in layers with clear interfaces between them. And in the same way, every function has a well-defined interface which can be described in one sentence, or three.\n\nBut what debuggers do is, they  present a kind of \"vertical view\" on the program that cuts through these interfaces. It makes it more difficult to see the interfaces and its invariants as a whole. And if you find an error and fix it only in that place, chances are that you are missing some of the picture.\n\nAnd do that over a longer time with many such innocent but hasty changes, and your codebase doesn't has any more any layering and interfaces at all. It just became a kind of spaghetti. Happens more easily with bad OOP code, too.", "id": "gc62hyi", "parent": "t1_gc60nao", "vote": 5}, {"content": "This is like my grandfather arguing that pen and paper is better than a computer. Sure pen and paper is better at some things but saying it is just better just shows you have no clue how to use a computer.\n\nAlso a debugger doesn't smear all over your code with stupid log.debug(\"im here\"); lines. Even if most ppl clean after themselves (they don't), in 10 years time you will end up with your codebase being 20% BS logging lines as topping on a million line spaguetti mess.", "id": "gc7c3k0", "parent": "t1_gc5nso2", "vote": 4}, {"content": "So you think that people which often prefer printf-debugging just don't know how to use them? What if they know how to use them, and they come to the conclusion it is often not the best approach?\n\n(I'd be careful not to fall into absolute statements what is good and what not, it always depends. In programming, there are really *very* few things which are true 100% of the time.)", "id": "gc8w7dy", "parent": "t1_gc5nso2", "vote": 1}, {"content": "> How are printfs useful in scenarios with billions of cycles with an unknown culprit ?\n\nMy experience is that printf and tests are extremely effective precisely in areas like digital signal processing where your data are millions of numbers.", "id": "gc5i99z", "parent": "t1_gc5glvv", "vote": 2}, {"content": ">Printing tons of data in a log is not pretty\n\nIf you don't know how to find the data you need in a text file regardless of how \"pretty\" it is, you have no business debugging anything.", "id": "gc6c2m9", "parent": "t1_gc5glvv", "vote": -4}, {"content": "I'm pretty they know well how those things works, another famous that don't use debugger at all (unlike Walter) is Linus torvards.", "id": "gc6azaz", "parent": "t1_gc5nxa1", "vote": 2}, {"content": "There are (apart from the cases mentioned in the OP)  two cases, in my so far 25+ years of programming, when I found debuggers really useful:\n\nOne was when I was working out a statistical algorithm in python which processed lots of speech audio data, which would run over days. In some cases, it errored out after running more than a day. In this case, using the post-mortem facility of PDB was really saving time.\n\nThe other time it was when I needed to write some efficient implementations for  the special functions (like sin(), tan(), log() and so on) which needed to run purely on SSE instructions, as the platform my company was using could not use fpu87 any more. I was not that experienced in assembly and the debugger could give me some help showing what was happening there. The other very valuable tool was maxima, which has a mode that allows arbitrary-precision floating point computations, which made it possible to verify that the new math code was at least better than fpu87 (in fact the precision of fpu87 is rather crappy at some points, so the new code was better).\n\n**(Edit)** There is also the case which Walter Bright mentioned, where  you have a crash, perhaps a crash dump, and you can fire up a debugger and it can show you the program state at the time where the crash happened. This can indeed be a very quick way to identify a problem. But, perhaps I am lucky, I am not dealing often any more with such crashes, probably also as a result of becoming more and more careful and deliberate over the years.\n\nAll the other times, \"looking at the code\" combined with printf() has worked quite well.", "id": "gc54rmh", "parent": "t1_gc53q2y", "vote": 7}, {"content": "I have heard this a number of times, but I am not sure about that one.\n\nFor example, I've written code for lock-less concurrent data structures, which is very low-level, and surprisingly, I found printf very helpful.\n\nThe Linux kernel does not have a kernel debugger, and Linus Torvalds does not use debugggers, and this is probably as low-level as you can get. In the end, what a PCI driver does is that it pokes registers at some addresses and gets bytes from there.\n\nOn the other hand, I Richard Stallmann initially wrote the GDB debugger, and AFAIK he also uses a debugger for Emacs Lisp, which is much more high-level in comparison. But I might be wrong on that second one.", "id": "gc59wps", "parent": "t1_gc57ncq", "vote": 3}, {"content": "> Problem is when using printf makes the bug go away.\n\nOn the other hand, such behavior is a clue to what to look for - memory corruption, uninitialized data, threading problems, stack corruption, compiler bugs (cough cough).", "id": "gc79tue", "parent": "t1_gc5x6h7", "vote": 1}, {"content": "[Correctly formatted](https://reddit.com/r/backtickbot/comments/jtrg05/httpsredditcomrprogrammingcommentsjtehnmwalter/)\n\nHello, PlayboySkeleton. Just a quick heads up!\n\nIt seems that you have attempted to use triple backticks (\\`\\`\\`) for\nyour codeblock/monospace text block.\n\n**This isn't universally supported on reddit**, for some users your comment\nwill look not as intended.\n\nYou can avoid this by **indenting every line with 4 spaces instead**.\n\nThere are also other methods that offer a bit better compatability like\n[the \"codeblock\" format feature on new Reddit](https://stalas.alm.lt/files/new-reddit-codeblock.png).\n\nTip: in new reddit, changing to \"fancy-pants\" editor and changing back to \"markdown\" will reformat correctly!\nHowever, that may be unnaceptable to you.\n\nHave a good day, PlayboySkeleton.\n\n^(You can opt out by replying with \"backtickopt6\" to this comment. Configure to send allerts\nto PMs instead by replying with \"backtickbbotdm5\". Exit PMMode by sending \"dmmode_end\".)", "id": "gc7dhv6", "parent": "t1_gc7dgzu", "vote": 1}, {"content": "> lol \n\nWell, Walter Bright is the main developer of the [D programming language](https://en.wikipedia.org/wiki/D_(programming_language\\)) and compiler and of some of the best early C++ compilers. You can search Wikipedia for him.\n\nAnd, while there exist other opinions, he isn't alone with this one among a lot of proficient programmers. You'll see this when you follow the linked original post.\n\n> We have a system with potentially 1m concurrent users. We store a small history of each user state in memory. That way, if we get a crash, we can just open the core file in gdb, check not only the backtrace (where we crashed), but also how we got there over time.\n\nI'd call that a, perhaps clever, hybrid method of logging and debugging.", "id": "gc5k2ur", "parent": "t1_gc5iagx", "vote": 4}, {"content": ">  (Bazel, looking at you) \n\nI don't understand.. Bazel is a build system ?\n\nFor the other thing is, I am sure that people who use the command line all the time are able to use gdb in it, and are also able to use an IDE on top of a debugger. \n\nAlso my experience does not match your last paragraph. I was using printf more or less from the beginning when I started programming and  I am still using it after many years of experience - even after having used GUI debuggers. Normally, and with some rare exceptions, I do not find them that effective. I do not think that makes me a rockstar.", "id": "gc5ilbo", "parent": "t1_gc5f08w", "vote": 5}, {"content": "As a rockstar ninja, I absolutely recommend everyone to use a debugger whenever they can. But I almost never do.", "id": "gc5z6bx", "parent": "t1_gc5f08w", "vote": 2}, {"content": "I don't think anyone is necessarily looking down at developers using debuggers but I certainly wince anytime it's recommended to me.\n\nThese things go both ways, you appear to be judging people you perceive to be judging your way of doing things.\n\nThere are times I would like to be able to drill down into a particular area of code with a debugger, but is it worth it to learn a debugger for these few times?\n\nThe answer is obviously that it depends on the person, the technology and the debuggers in play, if I was a C or embedded systems dev I'd make sure to research it.\n\nThere has never been a point in my short programming career where I haven't been able to reason and figure out a bug with printfs, and the idea of using a debugger to do so is seriously unappealing to me. People in this thread are talking about flicking around through code to 'understand' or to see some other values further down the line. The key word the author is using correctly is 'distraction'. I feel like flicking around bits of code looking at values won't get you very far, you need to be looking at the code and following your intuitions, carefully(if you got slow compiles!) littering a few printfs to get you to the bottom of the issue.\n\nBut I'm not judging those who use debuggers and I don't think anyone here is either, it's preference and people find ways to be productive with both tools, who's more productive isn't really something any one can empirically state.", "id": "gc97v7r", "parent": "t1_gc5f08w", "vote": 1}, {"content": "I agree it interacts very well with testing.\n\nWhich, interestingly, is the second important product of a debug session. One wants to understand the issue, one wants to have a test case, and one wants to have a fix - ideally in that order.", "id": "gc5ayx2", "parent": "t1_gc59yu9", "vote": 2}, {"content": "No, this is not the thing! I do not really find them *bad*. I find that they, in a more fundamental way, do not deliver what I *need*. \n\nAnd it has nothing to do with the GUI or kind of language. For Emacs/C++, gud-mode (based on gdb) is a good debugger. There are also debuggers for Python around. But I saw almost never the need to use the latter, as I can check and develop code on the command line. And much the same is true for the Lisp family like Clojure, Common Lisp, and Racket.", "id": "gc5s24f", "parent": "t1_gc5rgya", "vote": 2}, {"content": "depending on the code base, it works. I've used this extensively with C, C++ and D. Doesn't mean we don't use a debugger at all. We can even mix them. It totally depends on the case.", "id": "gc6ncoq", "parent": "t1_gc63lwu", "vote": 2}, {"content": "My pleasure!", "id": "gc57oh1", "parent": "t1_gc577dd", "vote": 25}, {"content": "I use [microEmacs in D](https://github.com/DigitalMars/med) and am surely the only user of it :-)", "id": "gc56yi8", "parent": "t1_gc56oq9", "vote": 59}, {"content": "They should copy more of D's ideas!", "id": "gc70snz", "parent": "t1_gc5cy1b", "vote": 23}, {"content": "Since I've never worked on an enterprise monstrosity, I cannot give an intelligent answer on it. Might as well ask me about making a souffle!", "id": "gc571ax", "parent": "t1_gc56tp8", "vote": 50}, {"content": "I work on enterprise monstrosities. Can confirm that a lot of printf is used. Debuggers are fine but I generally don\u2019t want to see every step in the process, I want to see the path my code took (e.g. what important points in the logic did it hit or not).\n\nI could do this with a debugger, but it would break at every point and I really just want to see everything in one go. So I look at my log statements.", "id": "gc5ckoh", "parent": "t1_gc56tp8", "vote": 28}, {"content": "log debug FTW", "id": "gc6k3d7", "parent": "t1_gc56tp8", "vote": 2}, {"content": "I think good programming languages are rarely the result of corporate efforts but are created by people which have an idea and an incredible drive to make that reality. It is probably very hard to get initial third-party funding for that. Rich Hickey, for example, took a kind of sabbattical and blew his pension fund on creating Clojure. \n\nWith that, D has the distinct quality that everything around it is incredibly long-term and steady.", "id": "gc5adt9", "parent": "t1_gc59jyn", "vote": 10}, {"content": "There was no funding. Myself and volunteers just did it.", "id": "gc71hfx", "parent": "t1_gc59jyn", "vote": 9}, {"content": "I don't closely follow it, Rust has a different organization more suited to its different size and community. D is, however,  implementing an ownership/borrowing system that I'll be talking about at [DConf2020](https://dconf.org/2020/online/index.html).", "id": "gc75yb5", "parent": "t1_gc59ee7", "vote": 4}, {"content": "A bit off-topic, but in an ideal world for me, Rust would take over a lot of what is done so far in C and \"low-level C++\", and D would take over what remains of C++, Go, and perhaps Java. In terms of the language, I think it is a much better language, among other things because its designers do have an ideal of quality and an idea of where to stop before it becomes a huge bloated mess.", "id": "gc5jh9r", "parent": "t1_gc59ee7", "vote": 15}, {"content": "I don't know what sort of model D uses, but hopefully it avoids the biggest problem with the C model: a lack of any consensus understanding about what the Standard's jurisdiction is supposed to be.\n\nThere is no reason why a quality language implementation suitable for low-level programming shouldn't be able to accommodate a concept like \"take an address which is known to be four-byte aligned, fetch four bytes from there without regard for what they represent, and interpret them as a little-endian 32-bit integer\".  If C had a standard syntax for that, it would be trivial for compilers to support it.\n\nUnfortunately, C is caught in a Catch-22 because implementations designed and configured to be maximally suitable for low-level programming on platforms where such a construct would be a good fit have always supported it consistent syntax.  Since such a construct would mainly be useful in non-portable programs, people who regard the Standard's jurisdiction as applying only to portable constructs thus see no need to introduce a new syntax for a non-portable construct, especially when implementations that want to support such semantics from doing so with existing syntax.  On the flip side, some people interpret the Standard's failure to mandate support for a non-portable construct as a prohibition on the use use of the construct even in non-portable programs.\n\nIf the Committee were to reach a consensus that it is supposed to specify everything that would be needed to accommodate some particular kinds of tasks, and that it isn't intended to specify everything necessary to accommodate some other particular kinds of tasks, that would make clear the need to have the Standard recognize optional constructs which are useful for the supported tasks, even if they wouldn't be supportable on all implementations, while at the same time making clear that the Standard's failure to mandate support for constructs which are useful for tasks outside its jurisdiction does not imply any judgment about whether an implementation should be regarded as suitable for such tasks without supporting such constructs.", "id": "gc6b0jr", "parent": "t1_gc59ee7", "vote": 2}, {"content": "Rust is talked a lot about but D is surprisingly mature.", "id": "gc6fr2k", "parent": "t1_gc59ee7", "vote": 1}, {"content": "Saying no to the endless lists of feature requests. (It's utterly impossible to implement them all, and nobody would use the language if it had them all.)", "id": "gc71wxy", "parent": "t1_gc5hz3b", "vote": 9}, {"content": "You're quite welcome!", "id": "gcawwe3", "parent": "t1_gc8qq0f", "vote": 2}, {"content": "Several! The first was Northwest C, then Zortech, now Digital Mars.", "id": "gc76acb", "parent": "t1_gc5m9wl", "vote": 2}, {"content": "I haven't had lunch yet, but I'm eyeing a chocolate bar that's sitting on the  counter.", "id": "gc772gg", "parent": "t1_gc64ozy", "vote": 7}, {"content": "I'm not an expert in packaging systems, I haven't used them very much, and don't think my opinion on them would be very valuable.", "id": "gc76fkt", "parent": "t1_gc5oztx", "vote": 4}, {"content": "welcs!", "id": "gc8kzzk", "parent": "t1_gc758id", "vote": 1}, {"content": "I've been programming a long time, and like most experienced programmers, developed a nose for where a problem is likely to be in an unfamiliar code base. Unfortunately, that isn't exactly useful advice! The strategy depends on what kind of bug it is. If it's a heisenbug, for example, look for uninitialized data, or the parts of the program that are multithreaded. If it's consistent, start adding printf's.", "id": "gc76xew", "parent": "t1_gc61qem", "vote": 3}, {"content": "It's possible, but nobody has set about to do it.", "id": "gcaxh09", "parent": "t1_gc8uozj", "vote": 1}, {"content": "I have a spiral paper notebook next to my keyboard where I take notes, sometimes when trying to isolate a problem.", "id": "gcax2dr", "parent": "t1_gc8m194", "vote": 2}, {"content": "I wrote a gc for fun and kept getting corrupted data after an update.\n\n`madvice( ...  DONT_NEED )` will 0 memory on linux and let the kernel reclaim the memory. it takes a `size_t length` bytes to apply the advice to.\n\nthe man page, at least the 2015 copy I've got, doesn't mention that while it accepts a byte-length madvising applies only to page increments, and it rounds up, not down.\n\nrip data just after the end of the memory I wanted to free.\n\na lot of printfing and staring at gc object dumps to puzzle that one out", "id": "gc60dma", "parent": "t1_gc5guth", "vote": 10}, {"content": "I haven't found a use case for Valgrind yet.\n\nBy the time my program is big enough that something strange is happening, it's too complicated and spaghetti (I'll pass the buck to my coworkers for that) to work with valgrind or rr.\n\nAt least Tracy Profiler can work in release mode on spaghetti programs. You have to mark everything up, but then turning off the 'printf' equivalents is just compiling with Tracy disabled", "id": "gc7doox", "parent": "t1_gc5guth", "vote": 1}, {"content": "No trick, really, just have a fast editor, compiler, and linker. MicroEmacs, that I mentioned earlier, is as fast as hitting the [Enter] key. (One reason for its speed is it does not load a configuration file.)", "id": "gc793sw", "parent": "t1_gc5w3em", "vote": 7}, {"content": "This may be true when you work on a codebase you already know well. Then logs are sufficient in most case, but on uge, badly written codebase, debugger helps a lot to understand what the flow actually is (and what it should be). Sadly I more often work on old codebase than I write new...", "id": "gc586mu", "parent": "t1_gc57fhj", "vote": 12}, {"content": "That may work for you and that's fair enough, however for me, I will be thinking \"harder\" regardless of my tools. Ultimately my goal is to solve an issue and the tools are just a means to an end. For web based applications with long startup times, having things like a debugger and features like evaluate expression (and more) allow me to very quickly explore and iterate through a problem. And though features like this are nothing new/special, IDE's like Intellij make this process extremely easy and most importantly fast. Couple that with hot swapping, and I find myself very rarely stopping my application when debugging. This is specific to my experience with web based Java, but I imagine there are similar alternatives in other tech stacks / contexts.\n\n\nCould also be that some people work better with visuals, similar to how people learn differently and an IDE+Debugger combo provides that.", "id": "gc73dhi", "parent": "t1_gc57fhj", "vote": 3}, {"content": "The feature that really made the difference for me was 'integration tightness'. I've developed in many different languages/platforms. Currently I develop more or less only for Android, where debugging is very well integrated into the IDE, while when I've developed for example for web, the experience had not been so well integrated into for example VSCode, or when I developed some backend in Python.\n\nInterestingly, I did once develop backend in C#, and there I did use the debugging capabilities as well.", "id": "gc5smai", "parent": "t1_gc5j8mu", "vote": 2}, {"content": "Breakpoint with conditions, there's no replacement for it. You don't have to go digging through obtuse logs. All the information is in the program, you don't have to change your printf's when you need more information. Callstack as well. There's just an infinite amount of more information you get from being able to use a debugger. Also have tools like [rr](https://rr-project.org/) that record the execution of the program and you can go back, forth, return the program all doing so deterministically.\n\nI've had the displeasure of working on one of Walter's code bases. It's littered with commented out print statements everywhere. It really is awful, a lot of the time they don't work cause 99% of the time they are commented out and the code around them changes. So they don't have to actually compile.\n\nD's tooling is rather poor, so I don't blame him for sticking with print statements. But sadly as a result the situation (no functioning debugger that actually displays what it is suppose to) won't get better (and hasn't for a long long time).", "id": "gc7gcng", "parent": "t1_gc5j8mu", "vote": 1}, {"content": "I like being able to run it in the debugger and when I spot a mistake, I change the code and rerun it without having to start the process over from scratch.\n\nYes, being able to inspect variables and set breakpoints is nothing new. I think a anyone who use printf debugging has just fallen victim to busywork honestly.", "id": "gc8rz8y", "parent": "t1_gc5j8mu", "vote": 1}, {"content": "The right tool for the right job. I still occasionally use print-style debugging, in particular if pausing execution is inappropriate.\n\nOne trick that can sometimes be utilized with debugging in loops is conditional breakpoints - i.e. only pause execution when a certain condition is met on this particular line of code. Pretty nifty!", "id": "gcfo2gp", "parent": "t1_gceqzz5", "vote": 1}, {"content": ">But if the breakpoint happens to be in a loop which is iterated 200 times,  a printf there gives you a nice table of values which you can muster at a glance, while a preakpoint costs 200 inspections and \"continue\" instructions\n\nThis is what breakpoint actions are for. You don't have to suspend when a breakpoint is hit; you can evaluate an expression which prints to the console and reference variables that are in scope. Basically, you can add printf without compiling and restarting. Add a loop to your failing test case, and you'll be even happier.", "id": "kqfun1v", "parent": "t1_gceqzz5", "vote": 1}, {"content": "For me, logs are primarily for post-mortem debugging of issues in the field. I have an extensive logging system with a centralized log server and remote log viewing and monitoring and whatnot. Or for pointing me where to apply the debugger when in development mode.\n\nBut, for debugging actual problems, I avoid ad hoc logging because I've been bitten too many times by making some change to support logging something and failing to remove it again. I at least know that the debugger isn't going to change my code. Nothing like forgetting that you left an ad hoc log msg in something that gets invoked many times a second on an ongoing basis. Then some problem occurs and you realize that there's nothing useful in the logs, just that one msg that's pushed everything else out.\n\nSince a lot of my work involves communications protocols, I do use ad hoc logging sometimes out of necessity since you generally can't get very far if you stop one side of a conversation. The other side just gives up. But, even there, sometimes I find it more effectively to work through one chunk at a time to see if I'm seeing the right things. The other side dies, so I start it again and move to the next section. Since the data can be complicated sometimes, logging something coherent can be more work than the debugger.", "id": "gc6smph", "parent": "t1_gc56q67", "vote": 3}, {"content": "Yeah, but logging is an art. Bad logs are awful to sift through, even after you've written dozens of regular expressions to highlight syntax and structure. On the other hand, good logs will tell you what the problem is without having to open a debugger.", "id": "gc60jj2", "parent": "t1_gc5f29y", "vote": 3}, {"content": "> let's\n\nOh come on...", "id": "gc6sct9", "parent": "t1_gc60zeq", "vote": 0}, {"content": "Yeah, - for me - sometimes it is not enough.", "id": "gc61amg", "parent": "t1_gc60zeq", "vote": 1}, {"content": "One does not dump countless output on the console.\n\nI know there are tricks/libs to enable/disable the output, but I only tend to leave only informative and errors in the console log. plus, there are stupid things in that language. Last time I debugged, an === was false because we used 2 lib components, one was treating the val as a number, other as a string. It was working in 98% of the cases, but not quite. Fun time.", "id": "gc65ytd", "parent": "t1_gc62nvx", "vote": 1}, {"content": "Sure exceptions help loads too", "id": "gc6fwyk", "parent": "t1_gc5iqoy", "vote": 1}, {"content": "Idk about Java, but in Visual Studio with C# the debugger is phenomenally helpful.  You can set a breakpoint, hit it, inspect the locals, step backwards in the execution, modify variable values and run through hypothetical scenarios without changing any code.  Not to mention the immediate window, where you can interact with objects in scope and call methods on them.  It saves a huge amount of time.", "id": "gcbd8sn", "parent": "t1_gc5iqoy", "vote": 1}, {"content": "I'm not sure I understand your point. Yes, you have to know where you want to debug. That's true for breakpoints and print statements.", "id": "gc5bqfg", "parent": "t1_gc5b3am", "vote": 9}, {"content": "> Perhaps time-traveling debuggers (which can go backwards in time) could change the equation, but this has to be seen.\n\nYeah, I am a printf-driven programmer as well, but this really was a game changer for me. Going backwards from where the program crashed makes much more sense to me than the usual debugger/printf workflow.", "id": "gc5fjeb", "parent": "t1_gc5b3am", "vote": 3}, {"content": "Personally, the biggest advantage I get from using debuggers instead of print statements is the ability to examine variable contents, then add additional breakpoints depend on their actual content further into the flow, and even step through the lines, all without recompiling and restarting the app. I use both, but I tend to lean towards the debugger approach as it gets me a lot more info without the trial and error of recompiling and restarting the app once you discover some unknown aspect of the code while debugging.", "id": "gc5gre8", "parent": "t1_gc5b3am", "vote": 3}, {"content": "I'm not sure what you're trying to say.", "id": "gc672tt", "parent": "t1_gc66yar", "vote": 2}, {"content": "I want to be clear, I don't disagree with what you just said either. I do read new code, and reading new code is always harder than writing code. I just find a debugger helps with the process. It is an aid, but of course doesn't substitute reading and thinking.", "id": "gc5b4aq", "parent": "t1_gc5ap3i", "vote": 1}, {"content": "> Well, as said, I am programming since more than 30 years, and as people say that using debuggers is an important and helpful tool for them, I am sometimes wondering what I am missing.\n\nA debugger doesn\u2019t have to be used this way (there\u2019s a lot of other things you get out of it such as the stacktrace, monitoring/interacting with all your threads easily, inspecting any memory at a glance, inspecting inside libraries you don\u2019t have the source to, can break on memory writes/reads, scriptability, etc.), but you can do printf style debugging with it (both lldb and gdb\u2019s print is actually more flexible than the standard printf). The benefit if that type of debugging is your preference is that you don\u2019t need to repeat the whole edit/compile/run loop, for instance in a debugger you don\u2019t need to cycle through that process. The only time when printf is advantageous over the debugger is if that process is quicker than launching the debugger and setting it up (which sometimes it is). But other than that there\u2019s no other advantage you\u2019re getting with printf over the debugger, as the debugger can do all of the same (and much more). \n\n> Or I might just always have been working in domains where debuggers just don't help - but then I wonder, in which domains are they really helpful for most people, aside from preferences?\n\nA domain where a debugger is probably one if not the most valuable tool isn\u2019t even in programming but rather reverse engineering.", "id": "gc5atej", "parent": "t1_gc58cng", "vote": 6}, {"content": "> but then I wonder, in which domains are they really helpful\n\nI mostly use printf, but there are some cases when you need to fire up gdb.\n\n1: When you have narrowed the problem down to a small part of the code that has a big state. You don't know what to print second until after you have looked at the first thing. Printing everything with printf or restarting is just more work than getting one thing at a time in the debugger.\n\n2: Looking at things that are in some other context. I.e. *this function destroys something outside of this function*. Step - look outside - step - look outside - ...\n\n3: printf changes the timing, so the bug is not there anymore. Usually the debugger also sucks in this scenario, but slightly less\n\n4: \"*hmm, foo should never be equal to bar. I wonder what the call stack looks like for that to happen*\"\n\nThe worst bugs usually require both printf and the debugger before they are solved...", "id": "gc5mk4l", "parent": "t1_gc58cng", "vote": 5}, {"content": "Printf isn't useful in a lot of bare metal c situations on a microcontroller. Printf is nontrivial in terms of memory use and execution time. Not only could it substantially change execution, but it may simply not work at all depending on where you are. \n\nPlus, I find it extremely necessary to monitor the registers, or to catch wierd interrupt behavior.", "id": "gc6cfqv", "parent": "t1_gc58cng", "vote": 2}, {"content": "Have you used it in well integrated environment like IDE with direct GDB support?.\n\nIt makes whole process so much faster where you can just hit the line and instantly (well, when your program gets to it) see the state of your program (or alternatively get answer to the \"where my program is stuck\" by just pausing)\n\nI use debugger most often actually in hobby, in embedded microcontrollers, but that's mostly because getting the printf is a bit of PITA and might even not fit in flash memory (think tens of kilobytes of flash at the disposal)", "id": "gc6im1l", "parent": "t1_gc58cng", "vote": 1}, {"content": "I never met a person that was proficient in using debuggers yet preferred using printf(). People also seem to be unable to provide any compelling arguments other than debugging data races (which I agree with) for why you would use printf over debuggers. I guess it also doesn\u2019t help that gdb and lldb are just awful and borderline unusable from a user experience standpoint compared to using something like Visual Studio, or IntelliJ debuggers. So many unix and C (Rust, etc.) folks have no decent debuggers available to them, maybe that\u2019s why they prefer printing?", "id": "gc9dpvr", "parent": "t1_gc8w7dy", "vote": 2}, {"content": ">find the data you need\n\nIt's easy to find something you know how to describe. Bit more difficult when something's wrong and you don't exactly know what it is.", "id": "gc6ym3x", "parent": "t1_gc6c2m9", "vote": 2}, {"content": "This kind of reminds me of a co-worker. They had a physical calculator and to find the sum of hundreds of values they were manually re-typing them into that calculator. All I was doing was copying and pasting them into excel and I got the sum. \n\nYou can get the same information from a printf and a debugger. To me, personally, based on what you are saying it just sounds like you don't know how to effectively use the features of a debugger to get what your getting with printf. If printf works fine for you, then continue to use it, there's nothing wrong with it. Even if I think it's just incredibly inefficient and I can be much more productive with a debugger.", "id": "gc7jc4w", "parent": "t1_gc54rmh", "vote": 3}, {"content": "True. Thanksfully never compiler bugs there, only with gcc. But there way too many recently.", "id": "gc8o83l", "parent": "t1_gc79tue", "vote": 1}, {"content": "I am well aware of who Walter Bright is. That doesn't mean that he is automatically right. :)\n\nWhat he should have said is, printf debugging works better than a debugger for *me*, for *my* problem domain.\n\nWe use a lot of \"printf\" debugging as well, in our design tests, where you have a very controlled environment. But gdb and coredumps are a godsend when trying to debug a problem in system test, where you can have thousands of \"users\", and the problem happens maybe once per hour.", "id": "gc6beg4", "parent": "t1_gc5k2ur", "vote": 2}, {"content": "This is just my experience in a few companies working with different developers.\n\nI mentioned Bazel as an example where IDE support during development is almost nonexistent, so people tend to use (advanced) text editors that have no graphical debugging support.", "id": "gc5llm0", "parent": "t1_gc5ilbo", "vote": 1}, {"content": "TBH I'm not convinced of this. Walter mentions in the linked article printing an AST but you can absolutely get stuff like this out of a proper debugger easily. In VS any tree structure I have I might need to debug at some point I'll add a property to serialise as JSON and then you can just look at that property live in the debugger.", "id": "gc5u7yu", "parent": "t1_gc5s24f", "vote": 2}, {"content": "Have you ever used a Smalltalk image?  The way its debugging works is that you can rewrite code at runtime and proceed once you've hopefully fixed the error.  You can also evaluate everything, restart execution, etc.\n\nIt's really awesome.  It also make it possible to do interactive implementation, where you just call something that doesn't exist, or throw exceptions in place of implementation.  Once it gets to that point, you write the code that you need, maybe making more placeholders along the way.  Eventually you get down to something that hopefully works.\n\nThe only caveat I will say with this interactive programming is that it can get really convoluted quickly if you're not careful, because you're just fixing the problem of the thrown exception in an ad-hoc way every time.  Plus it's hard to couple effectively (though not impossible) with test-driven development for problems that are really effective with it.", "id": "gc5wmw2", "parent": "t1_gc5s24f", "vote": 1}, {"content": "Not any more I think. Though the jury is out on next week :)", "id": "gc5cnc7", "parent": "t1_gc56yi8", "vote": 16}, {"content": "Cool :) As a die-hard GNU Emacs user, why microEmacs?", "id": "gc6mnt7", "parent": "t1_gc56yi8", "vote": 7}, {"content": "Does it have practical differences to mg? What I love about mg is that it is extremely light-weight, and still has many functions of the \"big\" GNU emacs. The only thing I miss once in a while is Unicode support ....", "id": "gc5mdjd", "parent": "t1_gc56yi8", "vote": 3}, {"content": "I am actually more curious about Rust vs D.  \nI know that D have a language subset  that is safe \"SafeD\" that use Garbage Collection.  \nHow do you think \"Rust\" compare to \"SafeD\"?", "id": "gc7e8l8", "parent": "t1_gc70snz", "vote": 7}, {"content": "Hi Walter,\n\nI've made savoury souffl\u00e9s for quite some time, but have begun to make quite a few more sweet ones as well. I've seen sweet souffl\u00e9s made a variety of ways; some use a b\u00e9chamel as the base, others a cr\u00e8me patissiere, and occasionally a fruit pur\u00e9e. I've only used a b\u00e9chamel up to this point (quite a bit quicker than making a creme pat from scratch), but I was curious if there were any particular rules of thumb for the issue.\n\nMy second question is on using french meringue versus egg whites to fold in; so far in my testing, I've concluded that that the french meringue would be a little more stable, but that the egg whites solo would be a bit fluffier, but I'm curious if there's anything else that might contribute to the decision as far as which is more effective.\n\nThanks!", "id": "gc5bjec", "parent": "t1_gc571ax", "vote": 121}, {"content": "I haven't really worked on stuff like that, apart from a rather tidy 4+ million LOC codebase. But my guess is that a debugger does not only amplify the level of information, but also very much the level of noise, and therefore makes it harder to *find* things like bugs.", "id": "gc5kw2r", "parent": "t1_gc5ckoh", "vote": 14}, {"content": "Logging breakpoints exist. Take the same time to add as printfs, do not require recompiling or restarting your program.", "id": "gc5q46u", "parent": "t1_gc5ckoh", "vote": 15}, {"content": "> I work on enterprise monstrosities. Can confirm that a lot of printf is used. \n\nI, also, build monsters, mostly out of java and confusion. A lot of my colleagues swear by the debugger and don't seem to be hurting (much) from that, but I personally favours ad-hoc log statements. I just find that, for me, the debugger gets in the way of thinking about the code.\n\nI think debuggers carries with them an inherent bias towards narrowing your focus further and further down into the code, and you can end up staring at some length at a particular needle on a particular pine in a particular copse in a particular section of the forest. Since most bugs[1] do not boil down to a single-line mistake, but are rather emergent behaviour from the interwork of different parts of the code, such a narrow focus is often counter-productive.\n\n[1] Well, at least most bugs that are not simple to find and fix regardless of what debugging technique or methodology you apply.", "id": "gc8s0kx", "parent": "t1_gc5ckoh", "vote": 3}, {"content": "> Debuggers are fine but I generally don\u2019t want to see every step in the process, I want to see the path my code took (e.g. what important points in the logic did it hit or not).\n\nWell, that's what breakpoints and stack traces are for, right?", "id": "gc7b3mn", "parent": "t1_gc5ckoh", "vote": 4}, {"content": "I think even C and low-level, D could be a good replacement instead of Rust.", "id": "gc5qond", "parent": "t1_gc5jh9r", "vote": 3}, {"content": "[deleted]", "id": "gc7e2qo", "parent": "t1_gc5jh9r", "vote": 2}, {"content": "Bad dreams this is.\n\nD is gone the moment they they had GC.\nRust went South the moment they forgot who their audience is and made a language aesthetically worse than C++.\n\nNerds should no longer be the sole designers. C++ is becoming untouchable with each release. Thanks to our nerds who designed for themselves instead of the rest of us.", "id": "gc6l19d", "parent": "t1_gc5jh9r", "vote": -3}, {"content": "Low-level code should be written in ats or f\\*, not rust.", "id": "gc73p27", "parent": "t1_gc5jh9r", "vote": 1}, {"content": "    #include <string.h> \n\n    uint_32_t get_u32_as_le(void *p)\n    {\n        uint32_t i;\n        char bytes[4];\n        memcpy(bytes, p, sizeof(bytes));\n        i = (bytes[0]<<0) | (bytes[1]<<8) | (bytes[2]<<16) | (bytes[3]<<24);\n        \n       return i;\n    }\n\n\nWhat is the problem?\n\nBut see also: https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html", "id": "gc6d3zv", "parent": "t1_gc6b0jr", "vote": 3}, {"content": "> It's utterly impossible to implement them all, and nobody would use the language if it had them all.\n\nThat doesn't seem to be stopping C++.  Not satisfied with the kitchen sink, they seem to be trying to squeeze in the rest of the kitchen as well.", "id": "gc7o8xr", "parent": "t1_gc71wxy", "vote": 4}, {"content": ":D", "id": "gcmle2e", "parent": "t1_gcawwe3", "vote": 1}, {"content": "Valgrind saved my day more than once, typically on big programs I\u00a0didn't wrote. I\u00a0have an error, I try out Valgrind, and the first invalid read or write (that often happens well before the segfault that triggered this investigation), gives me a stack trace. 80% of the time, the bug was somewhere in that stack trace.", "id": "gc7fcc6", "parent": "t1_gc7doox", "vote": 4}, {"content": "The address sanitizer and undefined behavior sanitizer (ubsan) options of the various compilers are helpful, too. They make it possible to catch a lot of undefined behavior and this is highly desirable because it can make your program behaving erratically and not deterministic at all. So, it is desirable to fix that first. And then one can, for example, insert tests.", "id": "gceqk20", "parent": "t1_gc7doox", "vote": 1}, {"content": "I wish conditional breaks were fast. In a lot of languages (C# comes to mind most recently) it takes a very big performance hit. I wind up just hardcoding in the conditional break in those cases.", "id": "gc7yu5c", "parent": "t1_gc7gcng", "vote": 2}, {"content": "> making some change to support logging something and failing to remove it again.\n\nI've done that a lot, too. The test suite almost always catches it, though, before it gets into the field.", "id": "gc79ed1", "parent": "t1_gc6smph", "vote": 1}, {"content": "Logs can be really helpful when debugging multithreading issues.", "id": "gc7tgsq", "parent": "t1_gc6smph", "vote": 1}, {"content": "Agreed. I need to sit down and write my thoughts on it. Building a good log is a process not an afterthought, and it really is a user interface.", "id": "gc653ai", "parent": "t1_gc60jj2", "vote": 1}, {"content": "You have to be one of the only people in the world who is mad because js didn't perform implicit type coercion.", "id": "gc8f70w", "parent": "t1_gc65ytd", "vote": 1}, {"content": "Yes. Your argument was that the debugger does something for me. The most important step in debugging is know where, and why, to put the print statement (or the breakpoint). The debugger does not help me with the \"where\". Instead, I often find it rather distracting.\n\nPutting it in different words, I hugely prefer **one** sparse but highly relevant bit of information, than a huge amount of irrelevant information and a bit of possibly relevant information buried in that heap.", "id": "gc5ixsd", "parent": "t1_gc5bqfg", "vote": 3}, {"content": "That's really interesting. What are currently the limits of this? The historical data needs to be somewhere stored, so what is the capacity limit to do that?", "id": "gc67566", "parent": "t1_gc5fjeb", "vote": 2}, {"content": "Ah!\n\nI initially linked to a discussion, this one: https://news.ycombinator.com/item?id=18795583\n\nAs you can see, the discussion was about using debuggers in general. There were different points of view but Walther Brights opinion had wide support.", "id": "gc67hwo", "parent": "t1_gc672tt", "vote": 1}, {"content": "> The benefit if that type of debugging is your preference is that you don\u2019t need to repeat the whole edit/compile/run loop, for instance in a debugger you don\u2019t need to cycle through that process.\n\nIf you use any unit testing at all, your code is already structured so that such a cycle goes very quickly. The argument would become that a debugger relieves you from the need to do such testing, which I think is not really true.", "id": "gc5begf", "parent": "t1_gc5atej", "vote": -1}, {"content": "Thanks, good points!", "id": "gc5mul7", "parent": "t1_gc5mk4l", "vote": 2}, {"content": "It must be my lack of experience, but I have used it with great success on an Arduino.\n\nI guess you have a smaller device in mind? In that case, I agree - you will need other means. But I think it is not a really common use case.", "id": "gc6dtkk", "parent": "t1_gc6cfqv", "vote": 1}, {"content": "> Printf isn't useful in a lot of bare metal c situations on a microcontroller.\n\nOTOH, in my experience those are the occasions when the debugger is the least useful since pausing the execution often inherently affects the result.", "id": "gc6wttc", "parent": "t1_gc6cfqv", "vote": 1}, {"content": "This is really interesting. \n\nThere seem to be people which prefer debuggers which think printf debugging is highly inefficient. And I am not sure if they have tried it for some time. \n\nAnd on the other hand there are programmers, including very experienced ones, which say that they have tried debuggers and did not find them most of the time helpful compared to using printf (without saying that printf is *always* the best way).\n\nIs this difference down to experience? Does it take more time to learn one or both of these methodologies than it seems? Debuggers with a GUI seem to be able to be learned rather quickly - setting a breakpoint, adding a watch, or inspecting CPU registers is not difficult. Why do many experienced programmers say that it does not help them?", "id": "gc8vt8a", "parent": "t1_gc7jc4w", "vote": 1}, {"content": "> That doesn't mean that he is automatically right.\n\nTrue, but I am automatically bright.", "id": "gc79z1u", "parent": "t1_gc6beg4", "vote": 2}, {"content": "Isn't that a bit similar to Linux kernel development?", "id": "gc6c19p", "parent": "t1_gc6beg4", "vote": 1}, {"content": "You can do that also in gdb, using Python. But few people use it.", "id": "gc5uqy9", "parent": "t1_gc5u7yu", "vote": 1}, {"content": "I don't know Smalltalk but Clojure, for example, also has such an environment. Also Common Lisp, and these capabilities are widely used.\n\nBut they also make it very easy to type in code snippets as tests and insert them into the program.", "id": "gc8wf0r", "parent": "t1_gc5wmw2", "vote": 1}, {"content": "It initially appeared for free over Usenet in the 80's. I was using Emacs on a Unix machine. MicroEmacs was small, Emacs-like and expertly written, ideal for DOS. I and some friends customized it and I've been using it ever since. It's been easy to port to every platform I've used. It's still very small and loads instantly. One nice thing about it, as opposed to IDEs, is it works in a remote tty window.", "id": "gc71a0j", "parent": "t1_gc6mnt7", "vote": 16}, {"content": "It has some Unicode support, I just haven't got around to fleshing that out. Being the only user means I sometimes neglect things that aren't immediately important.", "id": "gc71ecz", "parent": "t1_gc5mdjd", "vote": 7}, {"content": "D has a prototype feature now that adds an ownership/borrowing system. This will put it on par with Rust conceptually, but it is opt-in on a per-function basis and the syntax remains the familiar D syntax. I'll be talking about it at [DConf2020](https://dconf.org/2020/online/index.html).", "id": "gc7lnu0", "parent": "t1_gc7e8l8", "vote": 21}, {"content": "This better be a copy pasta", "id": "gc6cuxi", "parent": "t1_gc5bjec", "vote": 10}, {"content": "When you've got a lot of moving parts, sometimes timestamped logging/printf can be more useful to see what's going on, because stepping through with the debugger can cause other components to behave differently, timeouts etc.", "id": "gc85mjp", "parent": "t1_gc5kw2r", "vote": 2}, {"content": "If one goes back in the thread of execution, in order to test a new hypothesis / check a new place whether it shows expected behavior, one often needs to re-start the program anyway, at least with a normal (not time-traveling debugger).", "id": "gc8uhi5", "parent": "t1_gc5q46u", "vote": 1}, {"content": "Don\u2019t think I\u2019ve ever heard of that. They keep a point in time snapshot of every breakpoint?", "id": "gcdyr3v", "parent": "t1_gc5q46u", "vote": 1}, {"content": "A fantastic explanation!\n\nWhich begs the question, are debuggers perhaps better suited as a learning tool?", "id": "gc8uws0", "parent": "t1_gc8s0kx", "vote": 1}, {"content": "and conditional breakpoints", "id": "gc7v2du", "parent": "t1_gc7b3mn", "vote": 4}, {"content": "Stack trace gives you only where you are *now* not where you have been.\n\nE.g. if function a and b get called sequentially, you won\u2019t see a in the stack trace for b.", "id": "gcdym5c", "parent": "t1_gc7b3mn", "vote": 1}, {"content": "It surely can. What Rust has and D, so far, does not, is the ownership concept which makes it memory-safe, and prevents data race conditions. But this comes at a cognitive cost, Rust is a tad harder to learn.\n\nAnd also, while Rust uses some familiar curly-brace syntax from the Algol family, its origins are from a different tradition, of lambda calculus and ML. \n\nBut I think that both languages, Rust and D, are more than good enough to have a place in the future. Using the C ABI, then can also play well together. \n\nWhile C++ is becoming more and more unmanageable, at increasing speed, and Go's main advantage over Java is its simplicity, which does not seem enough to me.", "id": "gc5rms4", "parent": "t1_gc5qond", "vote": 6}, {"content": "> D gave up on having a standard logger 5+ years ago, and no one is going to try again now.\n\n[ahem](https://dlang.org/phobos/std_experimental_logger.html)", "id": "gcbqdda", "parent": "t1_gc7e2qo", "vote": 1}, {"content": ">Rust went South the moment they forgot who their audience is and made a language aesthetically worse than C++.\n\n\nAesthetics are inherently personal, to me rust is far better in that category than c++ by a huge margin.", "id": "gc718bc", "parent": "t1_gc6l19d", "vote": 2}, {"content": "Can you explain why you think that? What properties do these two have?", "id": "gc8v0f6", "parent": "t1_gc73p27", "vote": 1}, {"content": "It's more clunky than `*(uint32_t*)p`, and will perform very badly if one is using a platform that doesn't support unaligned loads, or one is unable to safely use a sufficient optimization level to have the compiler make the appropriate substitution.  Note that gcc can sometimes be coaxed into generating halfway decent code with \\`-O0\\`, and that its optimizer makes unsound assumptions even at \\`-O1\\`.  Outside of contrived situations, the only reason having a compiler process that construct as described would impose any meaningful performance cost would be that some compiler writers interpret the Standard's failure to mandate that they do so as an excuse to demand that programmers jump through hoops to accomplish what should be easy.\n\nNote that 6.5p7 was intended to say when compilers must allow for the possibility of pointers and lvalues aliasing *even when there is no evidence that they might do so*.  The authors of the Standard didn't think compiler writers had to be ordered to accommodate situations that would be readily visible to any compiler that wasn't willfully blind.", "id": "gc6gq3g", "parent": "t1_gc6d3zv", "vote": 1}, {"content": ">What is the problem?\n\nThe C Standard describes Undefined Behavior as resulting from \"non-portable or erroneous\" constructs.  It fails, however, to offer any guidance as to when implementations should regard such constructs as erroneous, versus presuming that while they are non-portable, they are correctly designed to meet application requirements when processed \"in a documented fashion characteristic of the environment\", and should thus be processed in that fashion.\n\nThis is especially a problem in cases where some parts of the Standard, platform's documentation, and observable traits such as reported `sizeof` values would together describe the behavior of some action, but another part of the Standard characterizes an overlapping category of actions as invoking Undefined Behavior.\n\nIf the Standard were to either make a real effort to exhaustively identify all of the cases where programmers should expect the defined behavior to have priority, or else explicitly state that makes no effort to do so, either state of affairs would be superior to the current one where the Standard makes no effort to exhaustively list such cases, but compiler writers treat the Standard's specifications as exhaustive anyway.", "id": "gc71nv3", "parent": "t1_gc6d3zv", "vote": 1}, {"content": "Yeh, that's the other most common scenario. Though I will say that modern debuggers like Visual Studio (which I only use as a debugger not an IDE) are a better with multithreaded debugging that used to be the case back the day.", "id": "gcbffan", "parent": "t1_gc7tgsq", "vote": 1}, {"content": "You for sure misunderstand me. That example was just to show why console.log is not enough in js.", "id": "gc8naev", "parent": "t1_gc8f70w", "vote": 1}, {"content": "The debugger certainly can help you figure out \"where\" you need to actually debug. Certainly, at minimum, just as much a print statement. \n\nLike I said, my problem with your point is that a debugger can literally just print whatever information you want, therefore being, at minimum, equivalent to print statement.", "id": "gc5zm9h", "parent": "t1_gc5ixsd", "vote": 5}, {"content": "They use lots tricks like hardlinking files and compressing event data like results of system calls to minimize storage needs. Depending on how much input an application consumes, the trace needs around 0.1-20MB per second of execution.\n\nI'm just a user though, so it may be better to have a look at their [technical overview](https://arxiv.org/pdf/1705.05937.pdf). All I can say for sure is that it works astonishingly well :)", "id": "gc6drzg", "parent": "t1_gc67566", "vote": 1}, {"content": "Yes, I did read the discussion, what I meant was that I couldn't understand what exactly you're saying with that specific comment.", "id": "gc6zwj9", "parent": "t1_gc67hwo", "vote": 2}, {"content": "> If you use any unit testing at all, your code is already structured so that such a cycle goes very quickly. \n\nSure, if you\u2019re assuming the problem lies in some repeatable test setup, some bugs might only reveal themselves in other environments though (this also goes the other way too, some bugs might only cause problems in your unit tests but not in your program). For instance if you have an out of bounds write, you could end up with a scenario in which this never causes a problem in your unit tests but it does cause a problem in your program (even worse if it\u2019s not resulting in a crash but changes some behaviour of something completely unrelated in your program). \n\nBut even when you do have something you want to debug that fits nicely within that test case. The window of time for where using printf is advantageous to the debugger is pretty small. If you find when finding/understanding the bug you\u2019ve had to recompile (assuming fast compile times) a number of times chances are you would\u2019ve been quicker doing it with the debugger. And I don\u2019t even mean because you could utilise additional features the debugger provides, but simply because you\u2019re able to continue and inspect other things without having to go through that entire loop as you would with a printf (if you hadn\u2019t had the thought to log all of those other things beforehand). \n\n> The argument would become that a debugger relieves you from the need to do such testing, which I think is not really true.\n\nI\u2019ve not heard that argument before but a debugger is definitely not a replacement for tests.", "id": "gc5e7m7", "parent": "t1_gc5begf", "vote": 7}, {"content": "The difference is that Arduino pretty much abstracts away all the situations where that would be an issue. Mbed is also printf only.\n\nThe problem is that those abstractions also severely limit what you can do with the hardware, especially if you want to any hard real time stuff like signal processing or control systems where low latency and timing or power consumption are very important.\n\nSometimes the debugger isn't helpful either, especially if you are trying to figure out an issue with how the system behaves at full speed. I will sometimes add code to toggle an output pin that I can watch on an oscilloscope, since that's way, way faster than doing a printf.\n\nSometimes I'll also use printf to give me data that I've set up the program to collect and then it will shoot that over when it won't mess anything else up.", "id": "gc6eozu", "parent": "t1_gc6dtkk", "vote": 1}, {"content": "Yeah, that can definitely be a problem as well. You have to go at it from many angles.", "id": "gc6wxvu", "parent": "t1_gc6wttc", "vote": 1}, {"content": "> There seem to be people which prefer debuggers which think printf debugging is highly inefficient. And I am not sure if they have tried it for some time.\n\nI'm not sure what you mean by \"haven't tried it for some time\". Printf debugging is as simple as it gets, it hasn't changed. I'm not sure what you mean by \"inefficient\", if you mean computationally inefficient, that's not what I meant. I meant how efficiently the tool can be used to achieve the goal. You have a lot more flexibility and fine tuning with debuggers. That makes them much more complicated to use effectively. So I'm not surprised there are individuals that favor a simpler method. You don't have to spend time to learn something new that's more complicated and become efficient at it.\n\n> Debuggers with a GUI seem to be able to be learned rather quickly - setting a breakpoint, adding a watch, or inspecting CPU registers is not difficult.\n\nUsing the tool and using it effectively are two different things. You can set a breakpoint but that doesn't mean that breakpoint will hit the code in the state that you need it to debug. Compare that to log of printf statements. You can just scroll down the list and find the state that you need to look at. It's much more difficult to use a debugger effectively. Printf is much simpler to use. \n\n> which say that they have tried debuggers and did not find them most of the time helpful compared to using printf (without saying that printf is always the best way).\n\nAgain not surprising, it takes time. If they tried it and it wasn't immediately better than what they are already experienced with using. They aren't going to take the time to learn it to become better at it. This might be why you see those more experienced individuals sticking with printf statements, as they do tend to be older. Compared to younger individuals that grow up with the software and learnt it as they were gaining experience. So they didn't have another method they were already more efficient at using to fall back on.\n\nIt is a human curse. I don't know how many people I've shown short-cuts like ctrl+c and ctrl+v that weren't using it and they just continued to use right-click and select copy/paste from the context menu. If you've become efficient at something and then you try something new, you aren't just going to be as good at it as you would be with a method you've been using for 30 years. So of course you aren't going to spend the time to learn to use it effectively.", "id": "gc9674h", "parent": "t1_gc8vt8a", "vote": 1}, {"content": "Bright in name only. ;)", "id": "gc8jhlc", "parent": "t1_gc79z1u", "vote": 2}, {"content": "I suppose it depends on difficulty. In C# it takes adding this to an object. I typically have a base class which has this already for anything I'm likely to inspect.\n\n    public string JsonValue\n    {\n        {\n             return JsonSerializer.Serialize(this);\n        }\n    }", "id": "gc5v63o", "parent": "t1_gc5uqy9", "vote": 2}, {"content": "Looking forward to it", "id": "gc87nlg", "parent": "t1_gc7lnu0", "vote": 3}, {"content": "That's really exciting to hear! A good thing that languages borrow good ideas from each other, and develop them further!\n\nHow would you compare the \"safety philosophy\" of Rust vs. D? Rust has the principle that there should no unsafe behavior be allowed, even for things like signed integer overflow or divide by zero. How important do you think is this in practice? Is some of this perhaps more important to beginners or less experience programmers than to very experienced ones?\n\nAbout performance... in many programs, there is only a very small fraction of code which has a big influence on program speed. But there are also aspects which are cross-cutting (some people will remember how slow early-day Java programs felt). What do you think should be the consequences that language designers and implementors draw from this? What guidance in respect to performance would you give to programmers of D which want snappy programs with modest effort?", "id": "gc8ue4e", "parent": "t1_gc7lnu0", "vote": 2}, {"content": "Copy pasta is the only cooking technique I know.", "id": "gc71pca", "parent": "t1_gc6cuxi", "vote": 46}, {"content": "No, they just print things to console when you reach the breakpoint", "id": "gcelwfs", "parent": "t1_gcdyr3v", "vote": 2}, {"content": "Hey now, let's not get too fancy.", "id": "gc849mv", "parent": "t1_gc7v2du", "vote": 1}, {"content": "Well said.  \"Rust and D, are more than good enough to have a place in the future \" that's a really interesting statement. What do you think we are missing to D and Rust be largely used, picked as C++, Java replacement more often? tooling? Do you think C# will be replace by some Rust/D in the future? I think there are some areas that apply", "id": "gc5srkv", "parent": "t1_gc5rms4", "vote": 2}, {"content": "The ability to prove more properties of code, and more interesting ones.\n\nFor example, both have dependent types; and recursion must be proven to be bounded.\n\nIn ats, the unsafe \u2018escape hatch\u2019 is much less prominent, because you can prove the correctness of code that would have to be marked `unsafe` in rust (which [has been a vector for bugs](https://groups.google.com/g/rustlang-security-announcements/c/CmSuTm-SaU0)).", "id": "gcadcy7", "parent": "t1_gc8v0f6", "vote": 1}, {"content": "I agree that it is better to get away from Undefined Behavior. But this will probably be impossible for C and C++. And this is one of the best arguments for Rust and D.", "id": "gc8v2rh", "parent": "t1_gc71nv3", "vote": 1}, {"content": "But for looking at a value at some point, you need to set a breakpoint. In order to not run over the breakpoint, you need to set it *before* you start the program. \n\nThe thing is you have a hypothesis what happens and you can confirm or discard the hypothesis by looking at that value - otherwise, you are just wasting time. Especially, \"looking around\" for me always feels like wasting time. So, you need to think at which value of which variable to look at. And you need to do that *before* running your program, because if not, it will either run into a crash or just pass the place with the error and do something weird.\n\nAnd when you have set it and do have your value, typically, **you need to go up the stack and *also* back in time**, in order to check whether the condition which caused the value was present there already. And this very often means you need to run the whole program again.", "id": "gc60xm5", "parent": "t1_gc5zm9h", "vote": 2}, {"content": "> especially if you want to any hard real time stuff like signal processing or control systems where low latency and timing or power consumption are very important.\n\nI've worked both a lot (around ten years) in signal processing and industrial control systems with cycle times down to 100ns, and have used printf a lot (as well as an oscilloscope). A debugger is not helpful in most situations, because it would stop the program. It can help when your system crashes, and you need a stack trace. Which is exactly what the comment linked in the OP talks about. Some systems will have, just like the Arduino, a buffered serial port which can be used for that.\n\nAgreed, situations can always be different, and there is no rule or tool that matches 100% of cases.  But printf is surprisingly versatile (and embedded toolchains can be surprisingly buggy otherwise ).", "id": "gc6fj4g", "parent": "t1_gc6eozu", "vote": 1}, {"content": "I always specify a free uart pin in my embedded projects that I can then connect to a simple high speed USB uart for debug prints. Even quite short buffers can be enough to allow the prints to happen in the background with almost no effect on program execution speed.", "id": "gc6xc4q", "parent": "t1_gc6wxvu", "vote": 1}, {"content": "How is that easier than in Rust:\n\n    println!(\"{:?}\", vec![\"a\", \"b\", \"c\"]);\n    // Output: [\"a\", \"b\", \"c\"]\n\n\nhttps://riptutorial.com/rust/example/1248/advanced-usage-of-println-", "id": "gc5vwka", "parent": "t1_gc5v63o", "vote": 1}, {"content": "I'm no expert on Rust. D's approach to safety is incremental, the same as its approach to functional programming. You can choose which parts of the program get strict safety checking, and which do not. It's amenable to adding safety in to existing, working code with minimal disruption.\n\nD also uses a familiar, well known syntax.\n\nD allows for direct mapping to machine code and control over things like memory layout, so performance is entirely up to how the user likes to code.", "id": "gcaw7be", "parent": "t1_gc8ue4e", "vote": 3}, {"content": "Instructions unclear, penne stuck in copier.", "id": "gc8mvib", "parent": "t1_gc71pca", "vote": 6}, {"content": "Exactly what Rust is currently doing feels like the best place for its growth. We're seeing the largest tech companies growing their Rust teams, now, to be used on some critical infra. AWS, Cloudflare (long time user), Facebook, and Microsoft notably have opened roles specifically for Rust dev.\n\nIt will take time, but as those companies feed ideas back into the ecosystem, I believe we'll continue to see the growth and gaining confidence.\n\nFor as hard as the concepts are to grasp in Rust, I feel the Rust compiler is extremely helpful and descriptive when you fail to meet a constraint.\n\nIt just takes time, and patience for devs and tech managers to start trusting it.", "id": "gc5zfd4", "parent": "t1_gc5srkv", "vote": 5}, {"content": "> What do you think we are missing to D and Rust be largely used, picked as C++, Java replacement more often?\n\nThey both need to overcome a huge amount of inertia in infrastructure and companies. At the moment, there is a kind of \"no body has ever been fired for using IBM\" situation. This will change when companies see that the more modern languages give an competitive edge. But it is a different world from the world where Python, Clojure, React, Angular and Javascript are used. The web economy moves much much faster.\n\nInfrastructure, that are things like electrical grids, industrial automation systems for steel processing plants and trains systems, embedded software components for cars, medical devices. Operating systems. This stuff needs to run decades on. Stuff like the Python2/3 transition simply cannot be allowed to happen in that realm. They'd rather run COBOL. It is an incredibly conservative environment. But, \"modern C++\" does not seems to be a good match to that.\n\nRust has a great deal of mindshare, a very competnt and engaged development community, and a nascent but lively library ecosystem. \n\nD seems, in a way, more boring. It is possible that its next stage of adoption will mainly be driven by hobbyists, as was the case with [Turbo Pascal](https://en.wikipedia.org/wiki/Turbo_Pascal). It still needs more library support. But I think it is a good language, perhaps well suited for parts of the open source landscape. Maybe we need some GNOME and Qt bindings for D.\n\nI think C# is similar to Java, but it is much tighter bound to one OS, Windows. I do not see it used for server backends. It might simply become less relevant. In a way, it does not have an own life without a company pushing for it. If, or rather when, Windows dies, it will pull C# into its grave.\n\n**Edit:** typo", "id": "gc5tqis", "parent": "t1_gc5srkv", "vote": 3}, {"content": "What made C very useful as a low-level language in the 1990s was the fact that the Standard allowed implementations to process many actions \"in a documented manner characteristic of the environment\" without the Standard having to know or care about particular situations where such treatment would be useful.  Unfortunately, someone came up with the \"clever\" (horrible) notion that since the C Standard doesn't impose any requirements on how implementations process actions it characterizes as \"Undefined Behavior\", compilers should feel free to assume that programs will never receive any inputs that would cause such actions to be performed.\n\nOne really wouldn't have to add much to the C Standard to accommodate most of the tasks for which C is used.  Start by defining a \"nominal\" execution model in which all actions behave as though decomposed into either a sequence of operations that are defined by the underlying platform or standard sequences of steps for operations which are not thus defined by the platform (e.g. a if a platform doesn't specify a means of performing a 64-bit load, but does specify a means of performing a 32-bit load, an implementation would implement a 64-bit load as two 32-bit loads).\n\nSuch a specification would leave some aspects of behavior unspecified (e.g. if a platform has two natural ways of multiplying signed numbers, but their behavior on overflow would differ, an implementation might choose between them in Unspecified fashion), but very few actions would invoke jump-the-rails Undefined Behavior at the language level.  The one critical form of UB would be overwriting storage which the implementation has received from the environment, but which is not legitimately owned by the C program.\n\nAlthough such a specification would preclude many useful forms of optimization, the way to fix that shouldn't be to characterize as UB all situations where a useful optimization might affect program behavior, but rather to specify situations in which implementations may transform the program in various ways *without regard for whether doing so might affect behavior*.  For example, many useful integer-math optimizations could be facilitated by saying that an implementation may, at its leisure, behave as though it uses types with a larger range than required when performing integer computations, and division by zero may yield any value.  Under such rules, if an implementation that is evaluating `x*y/z` knows that \\`y\\` has previously been set to \\`z\\*5\\`, it could replace the expression with `x*5` even though that might change program behavior in cases where `x*y` would have overflowed.  If an application would meet requirements equally well regardless of whether that expression yields `x*5` or `(int)(1u*x*y)/z`, letting the implementation make such a substitution despite the fact that it would affect program results would be far more useful than treating as Undefined Behavior all situations where the effects of such substitution would be observable.", "id": "gc9t73k", "parent": "t1_gc8v2rh", "vote": 1}, {"content": "You're not wrong, but a print statement isn't any better. With a print statement you'll have to \"look around\" all the same.", "id": "gc678ds", "parent": "t1_gc60xm5", "vote": 8}, {"content": "> And when you have set it and do have your value, typically, \n> you need to go up the stack and \n> also\n>  back in time\n> , in order to check whether the condition which caused the value was present there already. And this very often means you need to run the whole program again.\n\nIt's cheaper to rerun a program than it is to recompile it. In my case even in real time applications, you can save the state of the program either as a separate program https://rr-project.org/ so you can easily re-run the same program. Or build it into your program.", "id": "gc7i39o", "parent": "t1_gc60xm5", "vote": 2}, {"content": "> In order to not run over the breakpoint, you need to set it before you start the program. \n\nbefore the line of code is executed*, at least in my language\n\nI can set breakpoints on when the code is executing without any problem\n\n>And when you have set it and do have your value, typically, you need to go up the stack and also back in time, in order to check whether the condition which caused the value was present there already. And this very often means you need to run the whole program again.\n\nI do agree", "id": "gc7dyyp", "parent": "t1_gc60xm5", "vote": 1}, {"content": "That's fairly hardware and implementation specific. Are you implementing the timing functionality itself in hardware, or are you just calling libraries written in assembly to do it for you? Even then, if the program structure allows you do everything serially instead of juggling a bunch of different peripherals and DMA calls, you may find you can get away with interrupting execution to run printf. However, the fact of the matter is printf takes a pretty large amount of time to execute, and if you are in the middle of some loop that can't afford that time, you are SOL. \n\nNow, sometimes I'll have a printf statement elsewhere that collects all the info I need and pushes it back to me after the program has run for a defined amount of time or something. It really just depends on the problem. \n\nI do find the debugger most useful for reverse engineering badly documented behavior of some crappy vendor HAL, especially if I'm getting unexpected interrupts thrown.", "id": "gc6hper", "parent": "t1_gc6fj4g", "vote": 1}, {"content": "What do you mean by \"speed\"? Often the issue isn't so much how fast something executes, but rather that it needs to do a thing at a very exact time.", "id": "gc6xw4e", "parent": "t1_gc6xc4q", "vote": 1}, {"content": "You need to implement show for Rust to print IIRC. The C# json stuff can serialise anything that isn't cyclical.", "id": "gc6398q", "parent": "t1_gc5vwka", "vote": 1}, {"content": "It's perhaps one of these damn Barilla packages, they have nasty DRM.", "id": "gc8uu0a", "parent": "t1_gc8mvib", "vote": 2}, {"content": "Yeah, I agree, the Rust compiler has excellent and helpful error messages! It is *much* more beginner-friendly than C++ with templates for that.", "id": "gc6167y", "parent": "t1_gc5zfd4", "vote": 2}, {"content": "Your opinion of C# is extremely outdated. C# the language isn't limited to any platform. Unity is using it to ship games on pretty much every gaming platform. Donet framework is the old version of dotnet that was windows only, but mono has existed for a long time to run it on things that aren't windows and since 2016 Microsoft has released donet core which is a complete rewrite of dotnet framework and it's also completely multiplatform. It's also used a lot in backend web services, so I don't know how you came to the conclusion that it wasn't.\n\nSo, sure it's still heavily tied to Microsoft, but even if Windows dies, it's not tied in any way to it. Now, if Microsoft dies that's another story, but if that happens it probably means there was some very major events in the world at that point.", "id": "gc73i1q", "parent": "t1_gc5tqis", "vote": 9}, {"content": "C++ very, very, very rarely breaks backwards compatibility, and when they do the change is almost always fairly easily mitigated (such as `auto_ptr` being deprecated and then removed), unlike wholesale language changes in Perl and Python.", "id": "gc6po87", "parent": "t1_gc5tqis", "vote": 3}, {"content": "It's much worse if you have to recompile your program when you have to modify your print statements and then that takes half an hour.", "id": "gc7hstb", "parent": "t1_gc678ds", "vote": 2}, {"content": "I agree, on some hardware, this is not possible. But also, not every hardware allows for a debugger.", "id": "gc8vht8", "parent": "t1_gc6hper", "vote": 1}, {"content": "Pretty much that. As long as you aren\u2019t outright printing in a tight ISR, a judiciously constructed print statement that simply appends data to a debug uart buffer will usually have very little effect on the timing on modern MCUs. A debugger on the other hand halts the entire mcu making it difficult to use in even very soft realtime systems (such as in Bluetooth host where you usually have hundreds of milliseconds to multiple seconds to send a reply to a packet).", "id": "gc6z0qg", "parent": "t1_gc6xw4e", "vote": 1}, {"content": "Implementation is usually `#[derive(Debug)]`, though.", "id": "gc6gij3", "parent": "t1_gc6398q", "vote": 1}, {"content": "But what brings it there what is really different from Java?", "id": "gc8uyuz", "parent": "t1_gc73i1q", "vote": 2}, {"content": "Ah. I find it rather important to structure my programs so that they can be tested quickly in smaller parts with little inter-dependencies. So far, I have seen that is even possible with multi-million code bases. I believe this is also better for general architecture of software.\n\nBut there might be cases where this approach is not possible, can you explain more?", "id": "gc8vfs4", "parent": "t1_gc7hstb", "vote": 1}, {"content": "A lot of syntax sugar to reduce the verbosity, lambdas almost 10 years before java, LINQ almost 10 years before the stream api and the stream api is a lot more limited and more verbose than linq, auto properties, type inference with var almost 10 years before, a lot of tools for performance optimizations like struct and Span<T>, value types. More recently, nullables, and focus on pattern matching and switch expression. I'm sure I'm missing a bunch too, but I hope you get the point.", "id": "gcaeqzf", "parent": "t1_gc8uyuz", "vote": 2}, {"content": "Line count doesn't really tell how long something will take to compile. As an obvious example you don't have to compile python. So your statement is rather vague that you can quickly test smaller parts. Being quickly tested doesn't mean those test are effective. I can only take your word on it if that whatever it is you worked on and implemented is actually effective.\n\nThere's plenty of cases where that approach is inefficient. Physics simulations come to mind, you can still have those small unit tests that make sure each individual component is working correctly independently. But it's something completely different when you have 1000s of components interacting with each other in real time. Someone could say those smaller tests are sufficient, I would disagree. Now add on system on top of that physics simulation and it becomes much more complicated and just exacerbates the problem more.", "id": "gc97sf9", "parent": "t1_gc8vfs4", "vote": 2}], "link": "https://www.reddit.com/r/programming/comments/jtehnm/walter_bright_explains_i_mostly_use_printf_for/", "question": {"context": "", "id": "jtehnm", "title": "Walter Bright explains: \"I mostly use printf [for debugging] ..\""}, "resource": "Reddit"}]}